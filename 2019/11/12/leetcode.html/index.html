<!DOCTYPE html>
<html>
<head>

  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="https://lourisxu.github.io">
  <title>LeetCode | Louris&#39; Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="题目 难度 算法    1. 两数之和 Easy Hash   2. 两数相加 Meidum 数学   3. 无重复字符的最长子串 Medium 滑动窗口   4. 寻找两个正序数组的中位数 Hard 分治   5. 最长回文子串 Medium 动态规划   7. 整数反转 Easy 限制判断   8. 字符串转换整数 (atoi) Medium 数学   9. 回文数 Easy 字符串，T">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode">
<meta property="og:url" content="https://lourisxu.github.io/2019/11/12/leetcode.html/index.html">
<meta property="og:site_name" content="Louris&#39; Blog">
<meta property="og:description" content="题目 难度 算法    1. 两数之和 Easy Hash   2. 两数相加 Meidum 数学   3. 无重复字符的最长子串 Medium 滑动窗口   4. 寻找两个正序数组的中位数 Hard 分治   5. 最长回文子串 Medium 动态规划   7. 整数反转 Easy 限制判断   8. 字符串转换整数 (atoi) Medium 数学   9. 回文数 Easy 字符串，T">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/Insertion-sort-example-300px.gif">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/q2-e1.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/q2-e5-.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/1482_example_1_2.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/sample_2_1784.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/points3.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/question_11.jpg">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/1f51a.png?v8">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/1f51a.png?v8">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/1f51a.png?v8">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/1190_example_01.gif">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/116_sample.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/117_sample.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/113_sample.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/fivetrees.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/bst_cameras_01.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/bst_cameras_02.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/tree1.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/tree2.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/tree3.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/tree4.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/1236_example_1.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/1236_example_2.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/tree_1104.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/378_example_01.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/218_example_01.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/218_example_02.gif">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/bstdlloriginalbst.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/bstdllreturndll.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/rectangle_area.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/237_example.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/multilevellinkedlist.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/multilevellinkedlistflattened.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/160_statement.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/37_example_01.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/37_example_01.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/39_example_01.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/40_example_01.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/8-queens.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/8-queens.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/60_example_01.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/60_example_02.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/60_example_03.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/60_example_04.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/77_example_01.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/90_example_01.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/131_example_01.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/PascalTriangleAnimated2.gif">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/PascalTriangleAnimated2.gif">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/circularlinkedlist.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/circularlinkedlist_test2.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/circularlinkedlist_test3.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/160_statement.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/160_example_1.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/160_example_2.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/160_example_3.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/Binary_clock_samui_moon.jpg">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/959_1.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/959_2.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/959_3.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/959_4.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/959_5.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/sample_1_1677.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/sample_2_1677.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/995.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/minesweeper_example_1.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/minesweeper_example_2.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/931_example_1.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/narytreeexample.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/narytreeexample.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/sketch0.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/snakes.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/q1248-01.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/q1248-02.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/q1248-03.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/square_sum.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/leetcode_friends_1.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/leetcode_friends_2.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/1053_example.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/621_example_1.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/621_example_2.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/621_example_3.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/621_example_4.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/621_example_5.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/134_example_1.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/1111_example_1.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/1353_example_1.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/cinema_seats_1.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/cinema_seats_2.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/402_example_01.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/910_example_01.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/944_1.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/944_2.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/interview_20.jpg">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/598_example_01.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/1390_example_01.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/1390_example_02.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/838_example_01.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/ball.jpg">
<meta property="article:published_time" content="2019-11-12T13:19:42.000Z">
<meta property="article:modified_time" content="2024-01-19T02:20:51.956Z">
<meta property="article:author" content="Louris">
<meta property="article:tag" content="Algorithm">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lourisxu.github.io/assets/img/algorithm/Insertion-sort-example-300px.gif">
  
    <link rel="alternative" href="/atom.xml" title="Louris&#39; Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/assets/img/blog/favicon.png">
  
  <link rel="stylesheet" type="text/css" href="/./main.e8862b.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

<meta name="generator" content="Hexo 4.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #00BFFF"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/assets/img/blog/userpic.jpg" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">Louris</a></h1>
		</hgroup>
		
		<p class="header-subtitle">Do what I can</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">Home</a></li>
	        
				<li><a href="/categories/DS/">DS</a></li>
	        
				<li><a href="/tags/ML/">ML&amp;DL</a></li>
	        
				<li><a href="/tags/Tech/">Tech</a></li>
	        
				<li><a href="/tags/Algorithm/">Algorithm</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">All articles</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">Friends</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">About me</a>
    			
            
		</nav>
		<nav>
		 <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=230 height=86 src="//music.163.com/outchain/player?type=2&id=2080322&auto=1&height=66"></iframe>
		 <!--<div id="aplayer_home" class="aplayer" style="margin-bottom: 20px;width:100%;"></div>
		 <script type="text/javascript" src="\assets\js\APlayer.min.js"> </script>
 			<script>
   			new APlayer({
     		element: document.getElementById("aplayer_home"),
     		narrow: false,
     		autoplay: false,
     		showlrc: 0,
     		music: {
       		title: "What Are Words",
       		author: "Chris Media",
       		url: "https://coding.net/u/LourisXu/p/LourisXu/attachment/4532287/preview/4533847",
       		pic: "http://ov4otygyd.bkt.clouddn.com/What_Are_Words.jpg",
   			}
 			});
			</script>-->
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/LourisXu" title="github"><i class="icon-github"></i></a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/5634881238/profile?rightmod=1&wvr=6&mod=personinfo" title="weibo"><i class="icon-weibo"></i></a>
		        
					<a class="mail" target="_blank" href="mailto:louris@csu.edu.cn" title="mail"><i class="icon-mail"></i></a>
		        
			</div>
		</nav>
	</header>
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #00BFFF"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/assets/img/blog/userpic.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">Louris</h1>
			</hgroup>
			
			<p class="header-subtitle"><i class="icon icon-quo-left"></i>Do what I can<i class="icon icon-quo-right"></i></p>
			
			
			
				
			
				
			
				
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/LourisXu" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/5634881238/profile?rightmod=1&wvr=6&mod=personinfo" title="weibo"><i class="icon-weibo"></i></a>
			        
						<a class="mail" target="_blank" href="mailto:louris@csu.edu.cn" title="mail"><i class="icon-mail"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 70%">
				
				
					<li style="width: 20%"><a href="/">Home</a></li>
		        
					<li style="width: 20%"><a href="/categories/DS/">DS</a></li>
		        
					<li style="width: 20%"><a href="/tags/ML/">ML&amp;DL</a></li>
		        
					<li style="width: 20%"><a href="/tags/Tech/">Tech</a></li>
		        
					<li style="width: 20%"><a href="/tags/Algorithm/">Algorithm</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            <article id="post-Algorithm/leetcode/LeetCode" class="article article-type-post " itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      LeetCode
    </h1>
  


        
        <a href="/2019/11/12/leetcode.html/" class="archive-article-date">
  	<time datetime="2019-11-12T13:19:42.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-11-12</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><table>
<thead>
<tr>
<th align="left">题目</th>
<th align="center">难度</th>
<th align="center">算法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1. 两数之和</td>
<td align="center">Easy</td>
<td align="center">Hash</td>
</tr>
<tr>
<td align="left">2. 两数相加</td>
<td align="center">Meidum</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">3. 无重复字符的最长子串</td>
<td align="center">Medium</td>
<td align="center">滑动窗口</td>
</tr>
<tr>
<td align="left">4. 寻找两个正序数组的中位数</td>
<td align="center">Hard</td>
<td align="center">分治</td>
</tr>
<tr>
<td align="left">5. 最长回文子串</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">7. 整数反转</td>
<td align="center">Easy</td>
<td align="center">限制判断</td>
</tr>
<tr>
<td align="left">8. 字符串转换整数 (atoi)</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">9. 回文数</td>
<td align="center">Easy</td>
<td align="center">字符串，Two points</td>
</tr>
<tr>
<td align="left">10. 正则表达式匹配</td>
<td align="center">Hard</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">11. 盛最多水的容器</td>
<td align="center">Medium</td>
<td align="center">双指针</td>
</tr>
<tr>
<td align="left">12. 整数转罗马数字</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">13. 罗马数字转整数</td>
<td align="center">Easy</td>
<td align="center">字符串，技巧</td>
</tr>
<tr>
<td align="left">14. 最长公共前缀</td>
<td align="center">Easy</td>
<td align="center">字符串比较</td>
</tr>
<tr>
<td align="left">17. 电话号码的字母组合</td>
<td align="center">Medium</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">20. 有效的括号</td>
<td align="center">Easy</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="left">21. 合并两个有序链表</td>
<td align="center">Easy</td>
<td align="center">单链表</td>
</tr>
<tr>
<td align="left">22. 括号生成</td>
<td align="center">Medium</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">23. 合并K个排序链表</td>
<td align="center">Hard</td>
<td align="center">分治/非递归归并</td>
</tr>
<tr>
<td align="left">24. 两两交换链表中的节点</td>
<td align="center">Medium</td>
<td align="center">链表</td>
</tr>
<tr>
<td align="left">26. 删除排序数组中的重复项</td>
<td align="center">Easy</td>
<td align="center">数组去重</td>
</tr>
<tr>
<td align="left">27. 移除元素</td>
<td align="center">Easy</td>
<td align="center">数组去重</td>
</tr>
<tr>
<td align="left">28. 实现strStr</td>
<td align="center">Easy</td>
<td align="center">KMP算法</td>
</tr>
<tr>
<td align="left">29. 两数相除</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">31. 下一个排列</td>
<td align="center">Medium</td>
<td align="center">双指针</td>
</tr>
<tr>
<td align="left">32. 最长有效括号</td>
<td align="center">Hard</td>
<td align="center">字符串/动态规划</td>
</tr>
<tr>
<td align="left">33. 搜索旋转排序数组</td>
<td align="center">Medium</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">35. 搜索插入位置</td>
<td align="center">Easy</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">37. 解数独</td>
<td align="center">Hard</td>
<td align="center">解数独</td>
</tr>
<tr>
<td align="left">38. 报数</td>
<td align="center">Easy</td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="left">39. 组合总和</td>
<td align="center">Medium</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">40. 组合总和 II</td>
<td align="center">Medium</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">43. 字符串相乘</td>
<td align="center">Medium</td>
<td align="center">模拟</td>
</tr>
<tr>
<td align="left">44. 通配符匹配</td>
<td align="center">Hard</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">46. 全排列</td>
<td align="center">Medium</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">47. 全排列 II</td>
<td align="center">Medium</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">48. 旋转图像</td>
<td align="center">Medium</td>
<td align="center">数组</td>
</tr>
<tr>
<td align="left">50. Pow(x, n)</td>
<td align="center">Medium</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">51. N 皇后</td>
<td align="center">Hard</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">52. N皇后 II</td>
<td align="center">Hard</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">53. 最大子序和</td>
<td align="center">Easy</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">54. 螺旋矩阵</td>
<td align="center">Medium</td>
<td align="center">数组</td>
</tr>
<tr>
<td align="left">55. 跳跃游戏</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">56. 合并区间</td>
<td align="center">Medium</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">57. 插入区间</td>
<td align="center">Hard</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">58. 最后一个单词的长度</td>
<td align="center">Easy</td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="left">60. 第k个排列</td>
<td align="center">Medium</td>
<td align="center">回溯+剪枝</td>
</tr>
<tr>
<td align="left">61. 旋转链表</td>
<td align="center">Medium</td>
<td align="center">链表</td>
</tr>
<tr>
<td align="left">62. 不同路径</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">63. 不同路径 II</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">64. 最小路径和</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">65. 有效数字</td>
<td align="center">Hard</td>
<td align="center">确定有限状态自动机</td>
</tr>
<tr>
<td align="left">66. 加一</td>
<td align="center">Easy</td>
<td align="center">加法进位</td>
</tr>
<tr>
<td align="left">67. 二进制求和</td>
<td align="center">Easy</td>
<td align="center">加法进位</td>
</tr>
<tr>
<td align="left">69. x 的平方根</td>
<td align="center">Easy</td>
<td align="center">二分法</td>
</tr>
<tr>
<td align="left">70. 爬楼梯</td>
<td align="center">Easy</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">71. 简化路径</td>
<td align="center">Medium</td>
<td align="center">栈/字符串</td>
</tr>
<tr>
<td align="left">74. 搜索二维矩阵</td>
<td align="center">Medium</td>
<td align="center">二分</td>
</tr>
<tr>
<td align="left">75. 颜色分类</td>
<td align="center">Medium</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">77. 组合</td>
<td align="center">Medium</td>
<td align="center">回溯+剪枝</td>
</tr>
<tr>
<td align="left">78. 子集</td>
<td align="center">Medium</td>
<td align="center">位运算</td>
</tr>
<tr>
<td align="left">79. 单词搜索</td>
<td align="center">Medium</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">81. 搜索旋转排序数组 II</td>
<td align="center">Medium</td>
<td align="center">二分</td>
</tr>
<tr>
<td align="left">82. 删除排序链表中的重复元素 II</td>
<td align="center">Medium</td>
<td align="center">链表</td>
</tr>
<tr>
<td align="left">83. 删除排序链表中的重复元素</td>
<td align="center">Easy</td>
<td align="center">单链表</td>
</tr>
<tr>
<td align="left">86. 分隔链表</td>
<td align="center">Medium</td>
<td align="center">链表</td>
</tr>
<tr>
<td align="left">88. 合并两个有序数组</td>
<td align="center">Easy</td>
<td align="center">数组合并</td>
</tr>
<tr>
<td align="left">89. 格雷编码</td>
<td align="center">Medium</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">90. 子集 II</td>
<td align="center">Medium</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">91. 解码方法</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">92. 反转链表 II</td>
<td align="center">Medium</td>
<td align="center">链表</td>
</tr>
<tr>
<td align="left">93. 复原IP地址</td>
<td align="center">Medium</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">94. 二叉树的中序遍历</td>
<td align="center">Medium</td>
<td align="center">栈/树</td>
</tr>
<tr>
<td align="left">95. 不同的二叉搜索树 II</td>
<td align="center">Medium</td>
<td align="center">递归</td>
</tr>
<tr>
<td align="left">96. 不同的二叉搜索树</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">97. 交错字符串</td>
<td align="center">Hard</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">98. 验证二叉搜索树</td>
<td align="center">Medium</td>
<td align="center">二叉搜索树</td>
</tr>
<tr>
<td align="left">99. 恢复二叉搜索树</td>
<td align="center">Hard</td>
<td align="center">树</td>
</tr>
<tr>
<td align="left">100. 相同的树</td>
<td align="center">Easy</td>
<td align="center">二叉树</td>
</tr>
<tr>
<td align="left">101. 对称二叉树</td>
<td align="center">Easy</td>
<td align="center">二叉树</td>
</tr>
<tr>
<td align="left">102. 二叉树的层次遍历</td>
<td align="center">Medium</td>
<td align="center">广搜</td>
</tr>
<tr>
<td align="left">103. 二叉树的锯齿形层次遍历</td>
<td align="center">Medium</td>
<td align="center">广搜</td>
</tr>
<tr>
<td align="left">104. 二叉树的最大深度</td>
<td align="center">Easy</td>
<td align="center">二叉树</td>
</tr>
<tr>
<td align="left">105. 从前序与中序遍历序列构造二叉树</td>
<td align="center">Medium</td>
<td align="center">二叉树</td>
</tr>
<tr>
<td align="left">106. 从中序与后序遍历序列构造二叉树</td>
<td align="center">Medium</td>
<td align="center">二叉树</td>
</tr>
<tr>
<td align="left">107. 二叉树的层次遍历 II</td>
<td align="center">Easy</td>
<td align="center">二叉树</td>
</tr>
<tr>
<td align="left">108. 将有序数组转换为二叉搜索</td>
<td align="center">Easy</td>
<td align="center">二叉树</td>
</tr>
<tr>
<td align="left">109. 有序链表转换二叉搜索树</td>
<td align="center">Medium</td>
<td align="center">平衡二叉树</td>
</tr>
<tr>
<td align="left">110. 平衡二叉树</td>
<td align="center">Easy</td>
<td align="center">二叉树</td>
</tr>
<tr>
<td align="left">111. 二叉树的最小深度</td>
<td align="center">Easy</td>
<td align="center">二叉树</td>
</tr>
<tr>
<td align="left">112. 路径总和</td>
<td align="center">Easy</td>
<td align="center">二叉树</td>
</tr>
<tr>
<td align="left">113. 路径总和 II</td>
<td align="center">Medium</td>
<td align="center">二叉树</td>
</tr>
<tr>
<td align="left">114. 二叉树展开为链表</td>
<td align="center">Medium</td>
<td align="center">二叉树遍历</td>
</tr>
<tr>
<td align="left">116. 填充每个节点的下一个右侧节点指针</td>
<td align="center">Medium</td>
<td align="center">层次遍历</td>
</tr>
<tr>
<td align="left">117. 填充每个节点的下一个右侧节点指针 II</td>
<td align="center">Medium</td>
<td align="center">层次遍历</td>
</tr>
<tr>
<td align="left">118. 杨辉三角</td>
<td align="center">Easy</td>
<td align="center">简单模拟</td>
</tr>
<tr>
<td align="left">119. 杨辉三角 II</td>
<td align="center">Easy</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">120. 三角形最小路径和</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">121. 买卖股票的最佳时机</td>
<td align="center">Easy</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">122. 买卖股票的最佳时机 II</td>
<td align="center">Easy</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">123. 买卖股票的最佳时机 III</td>
<td align="center">Hard</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">125. 验证回文串</td>
<td align="center">Easy</td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="left">126. 单词接龙 II</td>
<td align="center">Hard</td>
<td align="center">双向广搜</td>
</tr>
<tr>
<td align="left">127. 单词接龙</td>
<td align="center">Medium</td>
<td align="center">双向广搜</td>
</tr>
<tr>
<td align="left">129. 求根到叶子节点数字之和</td>
<td align="center">Medium</td>
<td align="center">二叉树遍历</td>
</tr>
<tr>
<td align="left">130. 被围绕的区域</td>
<td align="center">Medium</td>
<td align="center">并查集</td>
</tr>
<tr>
<td align="left">131. 分割回文串</td>
<td align="center">Medium</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">132. 分割回文串 II</td>
<td align="center">Hard</td>
<td align="center">动规</td>
</tr>
<tr>
<td align="left">133. 克隆图</td>
<td align="center">Medium</td>
<td align="center">BFS+Map</td>
</tr>
<tr>
<td align="left">134. 加油站</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">135. 分发糖果</td>
<td align="center">Hard</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">136. 只出现一次的数字</td>
<td align="center">Easy</td>
<td align="center">逻辑</td>
</tr>
<tr>
<td align="left">139. 单词拆分</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">140. 单词拆分 II</td>
<td align="center">Hard</td>
<td align="center">DP+回溯</td>
</tr>
<tr>
<td align="left">141. 环形链表</td>
<td align="center">Easy</td>
<td align="center">单链表，快慢指针</td>
</tr>
<tr>
<td align="left">142. 环形链表 II</td>
<td align="center">Medium</td>
<td align="center">链表</td>
</tr>
<tr>
<td align="left">143. 重排链表</td>
<td align="center">Medium</td>
<td align="center">链表</td>
</tr>
<tr>
<td align="left">145. 二叉树的后序遍历</td>
<td align="center">Hard</td>
<td align="center">树/栈</td>
</tr>
<tr>
<td align="left">146. LRU缓存机制</td>
<td align="center">Medium</td>
<td align="center">设计</td>
</tr>
<tr>
<td align="left">147. 对链表进行插入排序</td>
<td align="center">Medium</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">148. 排序链表</td>
<td align="center">Medium</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">150. 逆波兰表达式求值</td>
<td align="center">Medium</td>
<td align="center">栈/字符串</td>
</tr>
<tr>
<td align="left">152. 乘积最大子序列</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">153. 寻找旋转排序数组中的最小值</td>
<td align="center">Medium</td>
<td align="center">二分</td>
</tr>
<tr>
<td align="left">155. 最小栈</td>
<td align="center">Easy</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="left">160. 相交链表</td>
<td align="center">Easy</td>
<td align="center">双指针</td>
</tr>
<tr>
<td align="left">162. 寻找峰值</td>
<td align="center">Medium</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">166. 分数到小数</td>
<td align="center">Medium</td>
<td align="center">数学/模拟</td>
</tr>
<tr>
<td align="left">167. 两数之和 II - 输入有序数组</td>
<td align="center">Easy</td>
<td align="center">Hash</td>
</tr>
<tr>
<td align="left">168. Excel表列名称</td>
<td align="center">Easy</td>
<td align="center">字符串hash</td>
</tr>
<tr>
<td align="left">169. 多数元素</td>
<td align="center">Easy</td>
<td align="center">逻辑</td>
</tr>
<tr>
<td align="left">170. 两数之和 III - 数据结构设计</td>
<td align="center">Easy</td>
<td align="center">设计</td>
</tr>
<tr>
<td align="left">171. Excel表列序号</td>
<td align="center">Easy</td>
<td align="center">字符串hash</td>
</tr>
<tr>
<td align="left">173. 二叉搜索树迭代器</td>
<td align="center">Medium</td>
<td align="center">设计</td>
</tr>
<tr>
<td align="left">174. 地下城游戏</td>
<td align="center">Hard</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">179. 最大数</td>
<td align="center">Medium</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">187. 重复的DNA序列</td>
<td align="center">Medium</td>
<td align="center">位运算</td>
</tr>
<tr>
<td align="left">188. 买卖股票的最佳时机 IV</td>
<td align="center">Hard</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">189. 旋转数组</td>
<td align="center">Easy</td>
<td align="center">数组移动</td>
</tr>
<tr>
<td align="left">190. 颠倒二进制位</td>
<td align="center">Easy</td>
<td align="center">二进制</td>
</tr>
<tr>
<td align="left">191. 位1的个数</td>
<td align="center">Easy</td>
<td align="center">二进制</td>
</tr>
<tr>
<td align="left">198. 打家劫舍</td>
<td align="center">Easy</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">199. 二叉树的右视图</td>
<td align="center">Medium</td>
<td align="center">DFS</td>
</tr>
<tr>
<td align="left">200. 岛屿数量</td>
<td align="center">Medium</td>
<td align="center">并查集</td>
</tr>
<tr>
<td align="left">201. 数字范围按位与</td>
<td align="center">Medium</td>
<td align="center">位运算</td>
</tr>
<tr>
<td align="left">202. 快乐数</td>
<td align="center">Easy</td>
<td align="center">快慢指针</td>
</tr>
<tr>
<td align="left">203. 移除链表元素</td>
<td align="center">Easy</td>
<td align="center">单链表</td>
</tr>
<tr>
<td align="left">204. 计数质数</td>
<td align="center">Easy</td>
<td align="center">素数Euler</td>
</tr>
<tr>
<td align="left">205. 同构字符串</td>
<td align="center">Easy</td>
<td align="center">Hash</td>
</tr>
<tr>
<td align="left">206. 反转链表</td>
<td align="center">Easy</td>
<td align="center">单链表</td>
</tr>
<tr>
<td align="left">207. 课程表</td>
<td align="center">Medium</td>
<td align="center">拓扑排序</td>
</tr>
<tr>
<td align="left">208. 实现 Trie (前缀树)</td>
<td align="center">Medium</td>
<td align="center">设计</td>
</tr>
<tr>
<td align="left">209. 长度最小的子数组</td>
<td align="center">Medium</td>
<td align="center">滑动窗口</td>
</tr>
<tr>
<td align="left">210. 课程表 II</td>
<td align="center">Medium</td>
<td align="center">拓扑排序</td>
</tr>
<tr>
<td align="left">211. 添加与搜索单词 - 数据结构设计</td>
<td align="center">Medium</td>
<td align="center">设计</td>
</tr>
<tr>
<td align="left">213. 打家劫舍 II</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">214. 最短回文串</td>
<td align="center">Hard</td>
<td align="center">字符串/KMP</td>
</tr>
<tr>
<td align="left">215. 数组中的第K个最大元素</td>
<td align="center">Medium</td>
<td align="center">分治</td>
</tr>
<tr>
<td align="left">216. 组合总和 III</td>
<td align="center">Medium</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">217. 存在重复元素</td>
<td align="center">Easy</td>
<td align="center">Hash</td>
</tr>
<tr>
<td align="left">218. 天际线问题</td>
<td align="center">Hard</td>
<td align="center">分治</td>
</tr>
<tr>
<td align="left">219. 存在重复元素 II</td>
<td align="center">Easy</td>
<td align="center">Hash</td>
</tr>
<tr>
<td align="left">220. 存在重复元素 III</td>
<td align="center">Medium</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">221. 最大正方形</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">222. 完全二叉树的节点个数</td>
<td align="center">Medium</td>
<td align="center">树</td>
</tr>
<tr>
<td align="left">223. 矩形面积</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">225. 用队列实现栈</td>
<td align="center">Easy</td>
<td align="center">队列</td>
</tr>
<tr>
<td align="left">226. 翻转二叉树</td>
<td align="center">Easy</td>
<td align="center">二叉树</td>
</tr>
<tr>
<td align="left">230. 二叉搜索树中第K小的元素</td>
<td align="center">Medium</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">231. 2的幂</td>
<td align="center">Easy</td>
<td align="center">快速幂</td>
</tr>
<tr>
<td align="left">232. 用栈实现队列</td>
<td align="center">Easy</td>
<td align="center">设计</td>
</tr>
<tr>
<td align="left">234. 回文链表</td>
<td align="center">Easy</td>
<td align="center">链表</td>
</tr>
<tr>
<td align="left">235. 二叉搜索树的最近公共祖先</td>
<td align="center">Easy</td>
<td align="center">树</td>
</tr>
<tr>
<td align="left">236. 二叉树的最近公共祖先</td>
<td align="center">Medium</td>
<td align="center">树</td>
</tr>
<tr>
<td align="left">237. 删除链表中的节点</td>
<td align="center">Easy</td>
<td align="center">链表</td>
</tr>
<tr>
<td align="left">239. 滑动窗口最大值</td>
<td align="center">Hard</td>
<td align="center">滑动窗口</td>
</tr>
<tr>
<td align="left">240. 搜索二维矩阵 II</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">241. 为运算表达式设计优先级</td>
<td align="center">Medium</td>
<td align="center">分治</td>
</tr>
<tr>
<td align="left">242. 有效的字母异位词</td>
<td align="center">Easy</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">256. 粉刷房子</td>
<td align="center">Easy</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">257. 二叉树的所有路径</td>
<td align="center">Easy</td>
<td align="center">深搜</td>
</tr>
<tr>
<td align="left">258. 各位相加</td>
<td align="center">Easy</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">260. 只出现一次的数字 III</td>
<td align="center">Medium</td>
<td align="center">位运算</td>
</tr>
<tr>
<td align="left">264. 丑数 II</td>
<td align="center">Medium</td>
<td align="center">动态规划+三指针</td>
</tr>
<tr>
<td align="left">268. 缺失数字</td>
<td align="center">Medium</td>
<td align="center">位运算</td>
</tr>
<tr>
<td align="left">270. 最接近的二叉搜索树值</td>
<td align="center">Easy</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">274. H 指数</td>
<td align="center">Medium</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">275. H指数 II</td>
<td align="center">Medium</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">276. 栅栏涂色</td>
<td align="center">Easy</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">278. 第一个错误的版本</td>
<td align="center">Easy</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">279. 完全平方数</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">284. 顶端迭代器</td>
<td align="center">Medium</td>
<td align="center">设计</td>
</tr>
<tr>
<td align="left">287. 寻找重复数</td>
<td align="center">Medium</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">292. Nim 游戏</td>
<td align="center">Easy</td>
<td align="center">极大极小化</td>
</tr>
<tr>
<td align="left">303. 区域和检索 - 数组不可变</td>
<td align="center">Easy</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">304. 二维区域和检索 - 矩阵不可变</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">306. 累加数</td>
<td align="center">Medium</td>
<td align="center">DFS</td>
</tr>
<tr>
<td align="left">307. 区域和检索 - 数组可修改</td>
<td align="center">Medium</td>
<td align="center">树状数组</td>
</tr>
<tr>
<td align="left">309. 最佳买卖股票时机含冷冻期</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">310. 最小高度树</td>
<td align="center">Medium</td>
<td align="center">拓扑排序变体</td>
</tr>
<tr>
<td align="left">312. 戳气球</td>
<td align="center">Hard</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">313. 超级丑数</td>
<td align="center">Medium</td>
<td align="center">数组、DP</td>
</tr>
<tr>
<td align="left">315. 计算右侧小于当前元素的个数</td>
<td align="center">Hard</td>
<td align="center">树状数组</td>
</tr>
<tr>
<td align="left">316. 去除重复字母</td>
<td align="center">Medium</td>
<td align="center">单调栈</td>
</tr>
<tr>
<td align="left">318. 最大单词长度乘积</td>
<td align="center">Medium</td>
<td align="center">位运算</td>
</tr>
<tr>
<td align="left">321. 拼接最大数</td>
<td align="center">Hard</td>
<td align="center">单调栈</td>
</tr>
<tr>
<td align="left">322. 零钱兑换</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">324. 摆动排序 II</td>
<td align="center">Medium</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">327. 区间和的个数</td>
<td align="center">Hard</td>
<td align="center">树状数组</td>
</tr>
<tr>
<td align="left">328. 奇偶链表</td>
<td align="center">Medium</td>
<td align="center">链表</td>
</tr>
<tr>
<td align="left">329. 矩阵中的最长递增路径</td>
<td align="center">Hard</td>
<td align="center">深搜/拓扑排序</td>
</tr>
<tr>
<td align="left">331. 验证二叉树的前序序列化</td>
<td align="center">Medium</td>
<td align="center">栈/字符串</td>
</tr>
<tr>
<td align="left">332. 重新安排行程</td>
<td align="center">Medium</td>
<td align="center">欧拉回路、深搜</td>
</tr>
<tr>
<td align="left">337. 打家劫舍 III</td>
<td align="center">Medium</td>
<td align="center">树形DP</td>
</tr>
<tr>
<td align="left">338. 比特位计数</td>
<td align="center">Medium</td>
<td align="center">位运算+动态规划</td>
</tr>
<tr>
<td align="left">341. 扁平化嵌套列表迭代器</td>
<td align="center">Medium</td>
<td align="center">设计</td>
</tr>
<tr>
<td align="left">342. 4的幂</td>
<td align="center">Easy</td>
<td align="center">位运算</td>
</tr>
<tr>
<td align="left">343. 整数拆分</td>
<td align="center">Medium</td>
<td align="center">动态规划/数学</td>
</tr>
<tr>
<td align="left">344. 反转字符串</td>
<td align="center">Easy</td>
<td align="center">双指针</td>
</tr>
<tr>
<td align="left">347. 前 K 个高频元素</td>
<td align="center">Medium</td>
<td align="center">堆</td>
</tr>
<tr>
<td align="left">349. 两个数组的交集</td>
<td align="center">Easy</td>
<td align="center">集合</td>
</tr>
<tr>
<td align="left">350. 两个数组的交集 II</td>
<td align="center">Easy</td>
<td align="center">排序/哈希表</td>
</tr>
<tr>
<td align="left">354. 俄罗斯套娃信封问题</td>
<td align="center">Hard</td>
<td align="center">动规</td>
</tr>
<tr>
<td align="left">355. 设计推特</td>
<td align="center">Medium</td>
<td align="center">设计</td>
</tr>
<tr>
<td align="left">357. 计算各个位数不同的数字个数</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">367. 有效的完全平方数</td>
<td align="center">Easy</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">368. 最大整除子集</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">371. 两整数之和</td>
<td align="center">Easy</td>
<td align="center">位运算</td>
</tr>
<tr>
<td align="left">372. 超级次方</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">374. 猜数字大小</td>
<td align="center">Easy</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">375. 猜数字大小 II</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">376. 摆动序列</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">377. 组合总和 Ⅳ</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">378. 有序矩阵中第K小的元素</td>
<td align="center">Medium</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">385. 迷你语法分析器</td>
<td align="center">Medium</td>
<td align="center">栈/字符串</td>
</tr>
<tr>
<td align="left">389. 找不同</td>
<td align="center">Easy</td>
<td align="center">位运算</td>
</tr>
<tr>
<td align="left">392. 判断子序列</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">393. UTF-8 编码验证</td>
<td align="center">Medium</td>
<td align="center">位运算</td>
</tr>
<tr>
<td align="left">394. 字符串解码</td>
<td align="center">Medium</td>
<td align="center">栈/字符串</td>
</tr>
<tr>
<td align="left">397. 整数替换</td>
<td align="center">Medium</td>
<td align="center">位运算、动态规划</td>
</tr>
<tr>
<td align="left">399. 除法求值</td>
<td align="center">Medium</td>
<td align="center">并查集</td>
</tr>
<tr>
<td align="left">400. 第N个数字</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">401. 二进制手表</td>
<td align="center">Easy</td>
<td align="center">位运算</td>
</tr>
<tr>
<td align="left">402. 移掉K位数字</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">403. 青蛙过河</td>
<td align="center">Hard</td>
<td align="center">记忆化搜索/动规</td>
</tr>
<tr>
<td align="left">404. 左叶子之和</td>
<td align="center">Easy</td>
<td align="center">树</td>
</tr>
<tr>
<td align="left">405. 数字转换为十六进制数</td>
<td align="center">Easy</td>
<td align="center">位运算</td>
</tr>
<tr>
<td align="left">406. 根据身高重建队列</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">410. 分割数组的最大值</td>
<td align="center">Hard</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">415. 字符串相加</td>
<td align="center">Easy</td>
<td align="center">字符串/模拟</td>
</tr>
<tr>
<td align="left">416. 分割等和子集</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">417. 太平洋大西洋水流问题</td>
<td align="center">Medium</td>
<td align="center">广搜</td>
</tr>
<tr>
<td align="left">421. 数组中两个数的最大异或值</td>
<td align="center">Medium</td>
<td align="center">位运算/字典树</td>
</tr>
<tr>
<td align="left">424. 替换后的最长重复字符</td>
<td align="center">Medium</td>
<td align="center">滑动窗口</td>
</tr>
<tr>
<td align="left">429. N叉树的层序遍历</td>
<td align="center">Medium</td>
<td align="center">广搜</td>
</tr>
<tr>
<td align="left">430. 扁平化多级双向链表</td>
<td align="center">Medium</td>
<td align="center">链表</td>
</tr>
<tr>
<td align="left">435. 无重叠区间</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">436. 寻找右区间</td>
<td align="center">Medium</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">437. 路径总和 III</td>
<td align="center">Medium</td>
<td align="center">树</td>
</tr>
<tr>
<td align="left">441. 排列硬币</td>
<td align="center">Easy</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">445. 两数相加 II</td>
<td align="center">Medium</td>
<td align="center">链表</td>
</tr>
<tr>
<td align="left">446. 等差数列划分 II - 子序列</td>
<td align="center">Hard</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">452. 用最少数量的箭引爆气球</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">454. 四数相加 II</td>
<td align="center">Medium</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">455. 分发饼干</td>
<td align="center">Easy</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">456. 132模式</td>
<td align="center">Medium</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="left">459. 重复的子字符串</td>
<td align="center">Easy</td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="left">461. 汉明距离</td>
<td align="center">Easy</td>
<td align="center">位运算</td>
</tr>
<tr>
<td align="left">464. 我能赢吗</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">467. 环绕字符串中唯一的子字符串</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">474. 一和零</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">475. 供暖器</td>
<td align="center">Easy</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">476. 数字的补数</td>
<td align="center">Easy</td>
<td align="center">位运算</td>
</tr>
<tr>
<td align="left">477. 汉明距离总和</td>
<td align="center">Medium</td>
<td align="center">位运算</td>
</tr>
<tr>
<td align="left">478. 在圆内随机生成点</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">486. 预测赢家</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">491. 递增子序列</td>
<td align="center">Medium</td>
<td align="center">回溯+剪枝</td>
</tr>
<tr>
<td align="left">493. 翻转对</td>
<td align="center">Hard</td>
<td align="center">分治+二分查找+树状数组</td>
</tr>
<tr>
<td align="left">496. 下一个更大元素 I</td>
<td align="center">Easy</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="left">497. 非重叠矩形中的随机点</td>
<td align="center">Medium</td>
<td align="center">二分查找/设计</td>
</tr>
<tr>
<td align="left">501. 二叉搜索树中的众数</td>
<td align="center">Easy</td>
<td align="center">树/Morris中序遍历</td>
</tr>
<tr>
<td align="left">503. 下一个更大元素 II</td>
<td align="center">Medium</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="left">508. 出现次数最多的子树元素和</td>
<td align="center">Medium</td>
<td align="center">树</td>
</tr>
<tr>
<td align="left">513. 找树左下角的值</td>
<td align="center">Medium</td>
<td align="center">广搜</td>
</tr>
<tr>
<td align="left">514. 自由之路</td>
<td align="center">Hard</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">515. 在每个树行中找最大值</td>
<td align="center">Medium</td>
<td align="center">广搜</td>
</tr>
<tr>
<td align="left">516. 最长回文子序列</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">523. 连续的子数组和</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">524. 通过删除字母匹配到字典里最长单词</td>
<td align="center">Medium</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">526. 优美的排列</td>
<td align="center">Medium</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">528. 按权重随机选择</td>
<td align="center">Medium</td>
<td align="center">二分查找/随机数</td>
</tr>
<tr>
<td align="left">529. 扫雷游戏</td>
<td align="center">Medium</td>
<td align="center">广搜</td>
</tr>
<tr>
<td align="left">530. 二叉搜索树的最小绝对差</td>
<td align="center">Easy</td>
<td align="center">树</td>
</tr>
<tr>
<td align="left">535. TinyURL 的加密与解密</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">537. 复数乘法</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">538. 把二叉搜索树转换为累加树</td>
<td align="center">Easy</td>
<td align="center">树</td>
</tr>
<tr>
<td align="left">542. 01 矩阵</td>
<td align="center">Medium</td>
<td align="center">广搜</td>
</tr>
<tr>
<td align="left">543. 二叉树的直径</td>
<td align="center">Easy</td>
<td align="center">树</td>
</tr>
<tr>
<td align="left">546. 移除盒子</td>
<td align="center">Hard</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">547. 朋友圈</td>
<td align="center">Medium</td>
<td align="center">并查集</td>
</tr>
<tr>
<td align="left">553. 最优除法</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">557. 反转字符串中的单词 III</td>
<td align="center">Easy</td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="left">559. N叉树的最大深度</td>
<td align="center">Easy</td>
<td align="center">广搜</td>
</tr>
<tr>
<td align="left">563. 二叉树的坡度</td>
<td align="center">Easy</td>
<td align="center">树</td>
</tr>
<tr>
<td align="left">567. 字符串的排列</td>
<td align="center">Medium</td>
<td align="center">滑动窗口</td>
</tr>
<tr>
<td align="left">572. 另一个树的子树</td>
<td align="center">Easy</td>
<td align="center">树</td>
</tr>
<tr>
<td align="left">576. 出界的路径数</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">592. 分数加减运算</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">593. 有效的正方形</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">598. 范围求和 II</td>
<td align="center">Easy</td>
<td align="center">数学/短板效应</td>
</tr>
<tr>
<td align="left">617. 合并二叉树</td>
<td align="center">Easy</td>
<td align="center">树</td>
</tr>
<tr>
<td align="left">621. 任务调度器</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">622. 设计循环队列</td>
<td align="center">Medium</td>
<td align="center">设计</td>
</tr>
<tr>
<td align="left">632. 最小区间</td>
<td align="center">Hard</td>
<td align="center">堆</td>
</tr>
<tr>
<td align="left">636. 函数的独占时间</td>
<td align="center">Medium</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="left">637. 二叉树的层平均值</td>
<td align="center">Easy</td>
<td align="center">树</td>
</tr>
<tr>
<td align="left">638. 大礼包</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">640. 求解方程</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">641. 设计循环双端队列</td>
<td align="center">Medium</td>
<td align="center">设计</td>
</tr>
<tr>
<td align="left">645. 错误的集合</td>
<td align="center">Easy</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">646. 最长数对链</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">647. 回文子串</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">648. 单词替换</td>
<td align="center">Medium</td>
<td align="center">字典树</td>
</tr>
<tr>
<td align="left">649. Dota2 参议院</td>
<td align="center">Medium</td>
<td align="center">模拟+贪心</td>
</tr>
<tr>
<td align="left">650. 只有两个键的键盘</td>
<td align="center">Medium</td>
<td align="center">深搜+剪枝/数学</td>
</tr>
<tr>
<td align="left">652. 寻找重复的子树</td>
<td align="center">Medium</td>
<td align="center">序列化</td>
</tr>
<tr>
<td align="left">655. 输出二叉树</td>
<td align="center">Medium</td>
<td align="center">树</td>
</tr>
<tr>
<td align="left">657. 机器人能否返回原点</td>
<td align="center">Easy</td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="left">658. 找到 K 个最接近的元素</td>
<td align="center">Medium</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">659. 分割数组为连续子序列</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">662. 二叉树最大宽度</td>
<td align="center">Medium</td>
<td align="center">树</td>
</tr>
<tr>
<td align="left">673. 最长递增子序列的个数</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">676. 实现一个魔法字典</td>
<td align="center">Medium</td>
<td align="center">字典树</td>
</tr>
<tr>
<td align="left">679. 24 点游戏</td>
<td align="center">Hard</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">682. 棒球比赛</td>
<td align="center">Easy</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="left">684. 冗余连接</td>
<td align="center">Medium</td>
<td align="center">并查集</td>
</tr>
<tr>
<td align="left">685. 冗余连接 II</td>
<td align="center">Hard</td>
<td align="center">并查集</td>
</tr>
<tr>
<td align="left">688. “马”在棋盘上的概率</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">690. 员工的重要性</td>
<td align="center">Easy</td>
<td align="center">广搜</td>
</tr>
<tr>
<td align="left">691. 贴纸拼词</td>
<td align="center">Hard</td>
<td align="center">状压DP+BFS</td>
</tr>
<tr>
<td align="left">693. 交替位二进制数</td>
<td align="center">Easy</td>
<td align="center">位运算</td>
</tr>
<tr>
<td align="left">696. 计数二进制子串</td>
<td align="center">Easy</td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="left">698. 划分为k个相等的子集</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">703. 数据流中的第K大元素</td>
<td align="center">Easy</td>
<td align="center">设计</td>
</tr>
<tr>
<td align="left">704. 二分查找</td>
<td align="center">Easy</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">707. 设计链表</td>
<td align="center">Easy</td>
<td align="center">设计</td>
</tr>
<tr>
<td align="left">712. 两个字符串的最小ASCII删除和</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">714. 买卖股票的最佳时机含手续费</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">718. 最长重复子数组</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">720. 词典中最长的单词</td>
<td align="center">Easy</td>
<td align="center">字典树</td>
</tr>
<tr>
<td align="left">721. 账户合并</td>
<td align="center">Medium</td>
<td align="center">并查集+Hash</td>
</tr>
<tr>
<td align="left">725. 分隔链表</td>
<td align="center">Medium</td>
<td align="center">链表</td>
</tr>
<tr>
<td align="left">733. 图像渲染</td>
<td align="center">Easy</td>
<td align="center">深搜</td>
</tr>
<tr>
<td align="left">735. 行星碰撞</td>
<td align="center">Medium</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="left">738. 单调递增的数字</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">739. 每日温度</td>
<td align="center">Medium</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="left">740. 删除与获得点数</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">743. 网络延迟时间</td>
<td align="center">Medium</td>
<td align="center">最短路径</td>
</tr>
<tr>
<td align="left">744. 寻找比目标字母大的最小字母</td>
<td align="center">Easy</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">746. 使用最小花费爬楼梯</td>
<td align="center">Easy</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">752. 打开转盘锁</td>
<td align="center">Medium</td>
<td align="center">广搜</td>
</tr>
<tr>
<td align="left">756. 金字塔转换矩阵</td>
<td align="center">Medium</td>
<td align="center">位运算+深搜</td>
</tr>
<tr>
<td align="left">762. 二进制表示中质数个计算置位</td>
<td align="center">Easy</td>
<td align="center">位运算</td>
</tr>
<tr>
<td align="left">763. 划分字母区间</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">764. 最大加号标志</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">767. 重构字符串</td>
<td align="center">Medium</td>
<td align="center">贪心+桶排序</td>
</tr>
<tr>
<td align="left">775. 全局倒置与局部倒置</td>
<td align="center">Medium</td>
<td align="center">数学/树状数组</td>
</tr>
<tr>
<td align="left">784. 字母大小写全排列</td>
<td align="center">Easy</td>
<td align="center">位运算</td>
</tr>
<tr>
<td align="left">785. 判断二分图</td>
<td align="center">Medium</td>
<td align="center">广搜、并查集</td>
</tr>
<tr>
<td align="left">787. K 站中转内最便宜的航班</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">789. 逃脱阻碍者</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">790. 多米诺和托米诺平铺</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">797. 所有可能的路径</td>
<td align="center">Medium</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">799. 香槟塔</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">801. 使序列递增的最小交换次数</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">808. 分汤</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">813. 最大平均值和的分组</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">820. 单词的压缩编码</td>
<td align="center">Medium</td>
<td align="center">后缀+字典树</td>
</tr>
<tr>
<td align="left">826. 安排工作以达到最大收益</td>
<td align="center">Medium</td>
<td align="center">双指针/二分</td>
</tr>
<tr>
<td align="left">834. 树中距离之和</td>
<td align="center">Hard</td>
<td align="center">树形DP</td>
</tr>
<tr>
<td align="left">837. 新21点</td>
<td align="center">Medium</td>
<td align="center">概率DP</td>
</tr>
<tr>
<td align="left">838. 推多米诺</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">841. 钥匙和房间</td>
<td align="center">Medium</td>
<td align="center">深搜</td>
</tr>
<tr>
<td align="left">842. 将数组拆分成斐波那契序列</td>
<td align="center">Medium</td>
<td align="center">DFS</td>
</tr>
<tr>
<td align="left">843. 猜猜这个单词</td>
<td align="center">Hard</td>
<td align="center">极大极小化</td>
</tr>
<tr>
<td align="left">844. 比较含退格的字符串</td>
<td align="center">Easy</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="left">845. 数组中的最长山脉</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">851. 喧闹和富有</td>
<td align="center">Medium</td>
<td align="center">记忆化搜索/拓扑排序</td>
</tr>
<tr>
<td align="left">852. 山脉数组的峰顶索引</td>
<td align="center">Easy</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">853. 车队</td>
<td align="center">Medium</td>
<td align="center">排序+单调栈</td>
</tr>
<tr>
<td align="left">856. 括号的分数</td>
<td align="center">Medium</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="left">867. 转置矩阵</td>
<td align="center">Easy</td>
<td align="center">数组</td>
</tr>
<tr>
<td align="left">860. 柠檬水找零</td>
<td align="center">Easy</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">861. 翻转矩阵后的得分</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">863. 二叉树中所有距离为 K 的结点</td>
<td align="center">Medium</td>
<td align="center">坐标化</td>
</tr>
<tr>
<td align="left">868. 二进制间距</td>
<td align="center">Easy</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">869. 重新排序得到 2 的幂</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">870. 优势洗牌</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">873. 最长的斐波那契子序列的长度</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">874. 模拟行走机器人</td>
<td align="center">Easy</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">875. 爱吃香蕉的珂珂</td>
<td align="center">Medium</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">876. 链表的中间结点</td>
<td align="center">Easy</td>
<td align="center">链表</td>
</tr>
<tr>
<td align="left">877. 石子游戏</td>
<td align="center">Medium</td>
<td align="center">动态规划/记忆化搜索/前缀和</td>
</tr>
<tr>
<td align="left">880. 索引处的解码字符串</td>
<td align="center">Medium</td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="left">881. 救生艇</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">885. 螺旋矩阵 III</td>
<td align="center">Medium</td>
<td align="center">数学/数组</td>
</tr>
<tr>
<td align="left">887. 鸡蛋掉落</td>
<td align="center">Hard</td>
<td align="center">动规</td>
</tr>
<tr>
<td align="left">892. 三维形体的表面积</td>
<td align="center">Easy</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">894. 所有可能的满二叉树</td>
<td align="center">Medium</td>
<td align="center">树/递归</td>
</tr>
<tr>
<td align="left">898. 子数组按位或操作</td>
<td align="center">Medium</td>
<td align="center">位运算+unordered_set</td>
</tr>
<tr>
<td align="left">901. 股票价格跨度</td>
<td align="center">Medium</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="left">907. 子数组的最小值之和</td>
<td align="center">Medium</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="left">908. 最小差值 I</td>
<td align="center">Easy</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">909. 蛇梯棋</td>
<td align="center">Medium</td>
<td align="center">广搜</td>
</tr>
<tr>
<td align="left">910. 最小差值 II</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">911. 在线选举</td>
<td align="center">Medium</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">913. 猫和老鼠</td>
<td align="center">Hard</td>
<td align="center">极大极小化</td>
</tr>
<tr>
<td align="left">914. 卡牌分组</td>
<td align="center">Easy</td>
<td align="center">最大公约数</td>
</tr>
<tr>
<td align="left">919. 完全二叉树插入器</td>
<td align="center">Medium</td>
<td align="center">树</td>
</tr>
<tr>
<td align="left">921. 使括号有效的最少添加</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">922. 按奇偶排序数组 II</td>
<td align="center">Easy</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">930. 和相同的二元子数组</td>
<td align="center">Medium</td>
<td align="center">前缀和</td>
</tr>
<tr>
<td align="left">931. 下降路径最小和</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">932. 漂亮数组</td>
<td align="center">Medium</td>
<td align="center">分治</td>
</tr>
<tr>
<td align="left">933. 最近的请求次数</td>
<td align="center">Easy</td>
<td align="center">队列</td>
</tr>
<tr>
<td align="left">934. 最短的桥</td>
<td align="center">Medium</td>
<td align="center">广搜</td>
</tr>
<tr>
<td align="left">935. 骑士拨号器</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">944. 删列造序</td>
<td align="center">Easy</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">946. 验证栈序列</td>
<td align="center">Medium</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="left">947. 移除最多的同行或同列石头</td>
<td align="center">Medium</td>
<td align="center">并查集+Hash</td>
</tr>
<tr>
<td align="left">948. 令牌放置</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">955. 删列造序 II</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">956. 最高的广告牌</td>
<td align="center">Hard</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">959. 由斜杠划分区域</td>
<td align="center">Medium</td>
<td align="center">并查集</td>
</tr>
<tr>
<td align="left">967. 连续差相同的数字</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">968. 监控二叉树</td>
<td align="center">Hard</td>
<td align="center">树</td>
</tr>
<tr>
<td align="left">969. 煎饼排序</td>
<td align="center">Medium</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">970. 强整数</td>
<td align="center">Easy</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">973. 最接近原点的 K 个点</td>
<td align="center">Medium</td>
<td align="center">分治</td>
</tr>
<tr>
<td align="left">976. 三角形的最大周长</td>
<td align="center">Easy</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">978. 最长湍流子数组</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">979. 在二叉树中分配硬币</td>
<td align="center">Medium</td>
<td align="center">树</td>
</tr>
<tr>
<td align="left">980. 不同路径 III</td>
<td align="center">Hard</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">981. 基于时间的键值存储</td>
<td align="center">Medium</td>
<td align="center">设计/二分</td>
</tr>
<tr>
<td align="left">983. 最低票价</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">984. 不含 AAA 或 BBB 的字符串</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">987. 二叉树的垂序遍历</td>
<td align="center">Medium</td>
<td align="center">坐标+排序</td>
</tr>
<tr>
<td align="left">990. 等式方程的可满足性</td>
<td align="center">Medium</td>
<td align="center">并查集</td>
</tr>
<tr>
<td align="left">991. 坏了的计算器</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">992. K 个不同整数的子数组</td>
<td align="center">Hard</td>
<td align="center">滑窗</td>
</tr>
<tr>
<td align="left">993. 二叉树的堂兄弟节点</td>
<td align="center">Easy</td>
<td align="center">坐标化</td>
</tr>
<tr>
<td align="left">994. 腐烂的橘子</td>
<td align="center">Medium</td>
<td align="center">广搜</td>
</tr>
<tr>
<td align="left">996. 正方形数组的数目</td>
<td align="center">Hard</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">1002. 查找常用字符</td>
<td align="center">Easy</td>
<td align="center">字符串/数组</td>
</tr>
<tr>
<td align="left">1003. 检查替换后的词是否有效</td>
<td align="center">Medium</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="left">1004. 最大连续1的个数 III</td>
<td align="center">Medium</td>
<td align="center">滑动窗口</td>
</tr>
<tr>
<td align="left">1005. K 次取反后最大化的数组和</td>
<td align="center">Easy</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">1006. 笨阶乘</td>
<td align="center">Medium</td>
<td align="center">数学/模拟</td>
</tr>
<tr>
<td align="left">1008. 前序遍历构造二叉搜索树</td>
<td align="center">Medium</td>
<td align="center">树</td>
</tr>
<tr>
<td align="left">1009. 十进制整数的反码</td>
<td align="center">Easy</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">1011. 在 D 天内送达包裹的能力</td>
<td align="center">Medium</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">1015. 可被 K 整除的最小整数</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">1017. 负二进制转换</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">1019. 链表中的下一个更大节点</td>
<td align="center">Medium</td>
<td align="center">单调栈</td>
</tr>
<tr>
<td align="left">1021. 删除最外层的括号</td>
<td align="center">Easy</td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="left">1022. 从根到叶的二进制数之和</td>
<td align="center">Easy</td>
<td align="center">树</td>
</tr>
<tr>
<td align="left">1023. 驼峰式匹配</td>
<td align="center">Easy</td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="left">1024. 视频拼接</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1025. 除数博弈</td>
<td align="center">Easy</td>
<td align="center">数学/动态规划</td>
</tr>
<tr>
<td align="left">1027. 最长等差数列</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1029. 两地调度</td>
<td align="center">Easy</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">1030. 距离顺序排列矩阵单元格</td>
<td align="center">Easy</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">1033. 移动石子直到连续</td>
<td align="center">Easy</td>
<td align="center">脑筋急转弯</td>
</tr>
<tr>
<td align="left">1037. 有效的回旋镖</td>
<td align="center">Easy</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">1039. 多边形三角剖分的最低得分</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1040. 移动石子直到连续 II</td>
<td align="center">Medium</td>
<td align="center">滑动窗口</td>
</tr>
<tr>
<td align="left">1043. 分隔数组以得到最大和</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1046. 最后一块石头的重量</td>
<td align="center">Easy</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">1047. 删除字符串中的所有相邻重复项</td>
<td align="center">Easy</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="left">1048. 最长字符串链</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1049. 最后一块石头的重量 II</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1052. 爱生气的书店老板</td>
<td align="center">Medium</td>
<td align="center">滑动窗口</td>
</tr>
<tr>
<td align="left">1053. 交换一次的先前排列</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">1064. 不动点</td>
<td align="center">Easy</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">1079. 活字印刷</td>
<td align="center">Medium</td>
<td align="center">回溯+剪枝</td>
</tr>
<tr>
<td align="left">1081. 不同字符的最小子序列</td>
<td align="center">Medium</td>
<td align="center">单调栈</td>
</tr>
<tr>
<td align="left">1090. 受标签影响的最大值</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">1091. 二进制矩阵中的最短路径</td>
<td align="center">Medium</td>
<td align="center">广搜</td>
</tr>
<tr>
<td align="left">1093. 大样本统计</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">1094. 拼车</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">1104. 二叉树寻路</td>
<td align="center">Medium</td>
<td align="center">树</td>
</tr>
<tr>
<td align="left">1105. 填充书架</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1111. 有效括号的嵌套深度</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">1122. 数组的相对排序</td>
<td align="center">Easy</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">1124. 表现良好的最长时间段</td>
<td align="center">Medium</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="left">1129. 颜色交替的最短路径</td>
<td align="center">Medium</td>
<td align="center">广搜</td>
</tr>
<tr>
<td align="left">1130. 叶值的最小代价生成树</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1131. 绝对值表达式的最大值</td>
<td align="center">Medium</td>
<td align="center">位运算+数学</td>
</tr>
<tr>
<td align="left">1139. 最大的以 1 为边界的正方形</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1140. 石子游戏 II</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1143. 最长公共子序列</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1150. 检查一个数是否在数组中占绝大多数</td>
<td align="center">Easy</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">1154. 一年中的第几天</td>
<td align="center">Easy</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">1155. 掷骰子的N种方法</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1171. 从链表中删去总和值为零的连续节点</td>
<td align="center">Medium</td>
<td align="center">链表</td>
</tr>
<tr>
<td align="left">1175. 质数排列</td>
<td align="center">Easy</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">1186. 删除一次得到子数组最大和</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1190. 反转每对括号间的子串</td>
<td align="center">Medium</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="left">1191. K 次串联后最大子数组之和</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1201. 丑数 III</td>
<td align="center">Medium</td>
<td align="center">数学+容斥原理+二分查找</td>
</tr>
<tr>
<td align="left">1202. 交换字符串中的元素</td>
<td align="center">Medium</td>
<td align="center">并查集</td>
</tr>
<tr>
<td align="left">1208. 尽可能使字符串相等</td>
<td align="center">Medium</td>
<td align="center">滑动窗口</td>
</tr>
<tr>
<td align="left">1209. 删除字符串中的所有相邻重复项 II</td>
<td align="center">Medium</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="left">1217. 玩筹码</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">1218. 最长定差子序列</td>
<td align="center">Medium</td>
<td align="center">动态规划变体</td>
</tr>
<tr>
<td align="left">1219. 黄金矿工</td>
<td align="center">Medium</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">1221. 分割平衡字符串</td>
<td align="center">Easy</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">1223. 掷骰子模拟</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1227. 飞机座位分配概率</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1234. 替换子串得到平衡字符串</td>
<td align="center">Medium</td>
<td align="center">滑动窗口</td>
</tr>
<tr>
<td align="left">1237. 找出给定方程的正整数解</td>
<td align="center">Easy</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">1239. 串联字符串的最大长度</td>
<td align="center">Medium</td>
<td align="center">位运算+暴力</td>
</tr>
<tr>
<td align="left">1240. 铺瓷砖</td>
<td align="center">Hard</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1247. 交换字符使得字符串相同</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">1249. 移除无效的括号</td>
<td align="center">Medium</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="left">1253. 重构 2 行二进制矩阵</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">1261. 在受污染的二叉树中查找元素</td>
<td align="center">Medium</td>
<td align="center">树</td>
</tr>
<tr>
<td align="left">1262. 可被三整除的最大和</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1269. 停在原地的方案数</td>
<td align="center">Hard</td>
<td align="center">动规</td>
</tr>
<tr>
<td align="left">1276. 不浪费原料的汉堡制作方案</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">1277. 统计全为 1 的正方形子矩阵</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1282. 用户分组</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">1283. 使结果不超过阈值的最小除数</td>
<td align="center">Medium</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">1286. 字母组合迭代器</td>
<td align="center">Medium</td>
<td align="center">设计</td>
</tr>
<tr>
<td align="left">1290. 二进制链表转整数</td>
<td align="center">Easy</td>
<td align="center">位运算</td>
</tr>
<tr>
<td align="left">1291. 顺次数</td>
<td align="center">Medium</td>
<td align="center">枚举</td>
</tr>
<tr>
<td align="left">1292. 元素和小于等于阈值的正方形的最大边长</td>
<td align="center">Medium</td>
<td align="center">前缀和+二分</td>
</tr>
<tr>
<td align="left">1296. 划分数组为连续数字的集合</td>
<td align="center">Medium</td>
<td align="center">贪心+Hash+模拟</td>
</tr>
<tr>
<td align="left">1297. 子串的最大出现次数</td>
<td align="center">Medium</td>
<td align="center">位运算</td>
</tr>
<tr>
<td align="left">1300. 转变数组后最接近目标值的数组和</td>
<td align="center">Medium</td>
<td align="center">二分</td>
</tr>
<tr>
<td align="left">1305. 两棵二叉搜索树中的所有元素</td>
<td align="center">Medium</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">1306. 跳跃游戏 III</td>
<td align="center">Medium</td>
<td align="center">广搜</td>
</tr>
<tr>
<td align="left">1310. 子数组异或查询</td>
<td align="center">Medium</td>
<td align="center">位运算+前缀和</td>
</tr>
<tr>
<td align="left">1311. 获取你好友已观看的视频</td>
<td align="center">Medium</td>
<td align="center">广搜</td>
</tr>
<tr>
<td align="left">1314. 矩阵区域和</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1317. 将整数转换为两个无零整数的和</td>
<td align="center">Easy</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">1318. 或运算的最小翻转次数</td>
<td align="center">Medium</td>
<td align="center">位运算</td>
</tr>
<tr>
<td align="left">1319. 连通网络的操作次数</td>
<td align="center">Medium</td>
<td align="center">并查集</td>
</tr>
<tr>
<td align="left">1329. 将矩阵按对角线排序</td>
<td align="center">Medium</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">1337. 方阵中战斗力最弱的 K 行</td>
<td align="center">Easy</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">1338. 数组大小减半</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">1339. 分裂二叉树的最大乘积</td>
<td align="center">Medium</td>
<td align="center">动态规划/数学</td>
</tr>
<tr>
<td align="left">1351. 统计有序矩阵中的负数</td>
<td align="center">Easy</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">1353. 最多可以参加的会议数目</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">1356. 根据数字二进制下 1 的数目排序</td>
<td align="center">Easy</td>
<td align="center">位运算</td>
</tr>
<tr>
<td align="left">1362. 最接近的因数</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">1366. 通过投票对团队排名</td>
<td align="center">Medium</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">1367. 二叉树中的列表</td>
<td align="center">Medium</td>
<td align="center">动态规划/链表/二叉树</td>
</tr>
<tr>
<td align="left">1370. 上升下降字符串</td>
<td align="center">Easy</td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="left">1372. 二叉树中的最长交错路径</td>
<td align="center">Medium</td>
<td align="center">动态规划/二叉树/深搜</td>
</tr>
<tr>
<td align="left">1381. 设计一个支持增量操作的栈</td>
<td align="center">Medium</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="left">1386. 安排电影院座位</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">1387. 将整数按权重排序</td>
<td align="center">Medium</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">1390. 四因数</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">1391. 检查网格中是否存在有效路径</td>
<td align="center">Medium</td>
<td align="center">广搜</td>
</tr>
<tr>
<td align="left">1400. 构造 K 个回文字符串</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">1403. 非递增顺序的最小子序列</td>
<td align="center">Easy</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">1405. 最长快乐字符串</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">1410. HTML 实体解析器</td>
<td align="center">Medium</td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="left">1414. 和为 K 的最少斐波那契数字数目</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">1415. 长度为 n 的开心字符串中字典序第 k 小的字符串</td>
<td align="center">Medium</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">1423. 可获得的最大点数</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1424. 对角线遍历 II</td>
<td align="center">Medium</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">1433. 检查一个字符串是否可以打破另一个字符串</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">1438. 绝对差不超过限制的最长连续子数组</td>
<td align="center">Medium</td>
<td align="center">滑动窗口</td>
</tr>
<tr>
<td align="left">1441. 用栈操作构建数组</td>
<td align="center">Easy</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="left">1447. 最简分数</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">1452. 收藏清单</td>
<td align="center">Medium</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">1456. 定长子串中元音的最大数目</td>
<td align="center">Medium</td>
<td align="center">滑动窗口</td>
</tr>
<tr>
<td align="left">1471. 数组中的 k 个最强值</td>
<td align="center">Medium</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">1473. 粉刷房子 III</td>
<td align="center">Hard</td>
<td align="center">动规</td>
</tr>
<tr>
<td align="left">1477. 找两个和为目标值且不重叠的子数组</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1481. 不同整数的最少数目</td>
<td align="center">Medium</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">1482. 制作 m 束花所需的最少天数</td>
<td align="center">Medium</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">1491. 去掉最低工资和最高工资后的工资平均值</td>
<td align="center">Easy</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">1498. 满足条件的子序列数目</td>
<td align="center">Medium</td>
<td align="center">滑动窗口</td>
</tr>
<tr>
<td align="left">1502. 判断能否形成等差数列</td>
<td align="center">Easy</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">1504. 统计全 1 子矩形</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1508. 子数组和排序后的区间和</td>
<td align="center">Medium</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">1528. 重新排列字符串</td>
<td align="center">Easy</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">1530. 好叶子节点对的数量</td>
<td align="center">Medium</td>
<td align="center">树</td>
</tr>
<tr>
<td align="left">1544. 整理字符串</td>
<td align="center">Easy</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="left">1561. 你可以获得的最大硬币数目</td>
<td align="center">Medium</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">1621. 大小为 K 的不重叠线段的数目</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1626. 无矛盾的最佳球队</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1631. 最小体力消耗路径</td>
<td align="center">Medium</td>
<td align="center">优先队列+DP</td>
</tr>
<tr>
<td align="left">1636. 按照频率将数组升序排序</td>
<td align="center">Easy</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">1637. 两点之间不包含任何点的最宽垂直面积</td>
<td align="center">Medium</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="left">1641. 统计字典序元音字符串的数目</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">1658. 将 x 减到 0 的最小操作数</td>
<td align="center">Medium</td>
<td align="center">哈希表/滑动窗口</td>
</tr>
<tr>
<td align="left">1664. 生成平衡数组的方案数</td>
<td align="center">Medium</td>
<td align="center">动态规划/前缀和</td>
</tr>
<tr>
<td align="left">1674. 使数组互补的最少操作次数</td>
<td align="center">Medium</td>
<td align="center">差分数组</td>
</tr>
<tr>
<td align="left">1705. 吃苹果的最大数目</td>
<td align="center">Medium</td>
<td align="center">优先队列</td>
</tr>
<tr>
<td align="left">1706. 球会落何处</td>
<td align="center">Medium</td>
<td align="center">模拟</td>
</tr>
<tr>
<td align="left">1707. 与数组中元素的最大异或值</td>
<td align="center">Hard</td>
<td align="center">字典树</td>
</tr>
<tr>
<td align="left">1723. 完成所有工作的最短时间</td>
<td align="center">Hard</td>
<td align="center">动规</td>
</tr>
<tr>
<td align="left">5471. 和为目标值的最大数目不重叠非空子数组数目</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">5520. 拆分字符串使唯一子字符串的数目最大</td>
<td align="center">Medium</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">5631. 跳跃游戏 VI</td>
<td align="center">Medium</td>
<td align="center">动态规划/优先队列/单调队列</td>
</tr>
<tr>
<td align="left">5642. 大餐计数</td>
<td align="center">Medium</td>
<td align="center">贪心</td>
</tr>
<tr>
<td align="left">5643. 将数组分成三个子数组的方案数</td>
<td align="center">Medium</td>
<td align="center">前缀和+二分</td>
</tr>
<tr>
<td align="left">5644. 得到子序列的最少操作次数</td>
<td align="center">Hard</td>
<td align="center">哈希+二分/LCS</td>
</tr>
<tr>
<td align="left">面试题 01.05. 一次编辑</td>
<td align="center">Medium</td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="left">面试题 02.01. 移除重复节点</td>
<td align="center">Easy</td>
<td align="center">链表</td>
</tr>
<tr>
<td align="left">面试题 02.08. 环路检测</td>
<td align="center">Medium</td>
<td align="center">链表</td>
</tr>
<tr>
<td align="left">面试题 03.01. 三合一</td>
<td align="center">Easy</td>
<td align="center">设计</td>
</tr>
<tr>
<td align="left">面试题 03.02. 栈的最小值</td>
<td align="center">Easy</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">面试题 03.04. 化栈为队</td>
<td align="center">Easy</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="left">面试题 03.06. 动物收容所</td>
<td align="center">Easy</td>
<td align="center">设计</td>
</tr>
<tr>
<td align="left">面试题 04.03. 特定深度节点链表</td>
<td align="center">Medium</td>
<td align="center">广搜+链表</td>
</tr>
<tr>
<td align="left">面试题32 - I. 从上到下打印二叉树 II</td>
<td align="center">Medium</td>
<td align="center">广搜</td>
</tr>
<tr>
<td align="left">面试题32 - II. 从上到下打印二叉树 II</td>
<td align="center">Easy</td>
<td align="center">广搜</td>
</tr>
<tr>
<td align="left">面试题32 - III. 从上到下打印二叉树 III</td>
<td align="center">Medium</td>
<td align="center">广搜</td>
</tr>
<tr>
<td align="left">面试题14- I. 剪绳子</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">面试题14- II. 剪绳子 II</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">面试题 08.01. 三步问题</td>
<td align="center">Easy</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">面试题 08.02. 迷路的机器人</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">面试题 08.03. 魔术索引</td>
<td align="center">Easy</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">面试题 08.04. 幂集</td>
<td align="center">Medium</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">面试题 08.07. 无重复字符串的排列组合</td>
<td align="center">Medium</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">面试题 08.08. 有重复字符串的排列组合</td>
<td align="center">Medium</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">面试题 08.09. 括号</td>
<td align="center">Medium</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">面试题 08.11. 硬币</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">面试题 08.12. 八皇后</td>
<td align="center">Hard</td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="left">面试题 08.14. 布尔运算</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">面试题 10.03. 搜索旋转数组</td>
<td align="center">Medium</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">面试题 10.05. 稀疏数组搜索</td>
<td align="center">Easy</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">面试题 10.09. 排序矩阵查找</td>
<td align="center">Medium</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">面试题 16.05. 阶乘尾数</td>
<td align="center">Easy</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">面试题 16.06. 最小差</td>
<td align="center">Medium</td>
<td align="center">双指针</td>
</tr>
<tr>
<td align="left">面试题 16.07. 最大数值</td>
<td align="center">Easy</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">面试题 16.11. 跳水板</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">面试题 16.17. 连续数列</td>
<td align="center">Easy</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">面试题 16.19. 水域大小</td>
<td align="center">Medium</td>
<td align="center">广搜</td>
</tr>
<tr>
<td align="left">面试题 16.25. LRU缓存</td>
<td align="center">Medium</td>
<td align="center">设计</td>
</tr>
<tr>
<td align="left">面试题17. 打印从1到最大的n位数</td>
<td align="center">Easy</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">面试题 17.06. 2出现的次数</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">面试题 17.07. 婴儿名字</td>
<td align="center">Medium</td>
<td align="center">并查集</td>
</tr>
<tr>
<td align="left">面试题 17.08. 马戏团人塔</td>
<td align="center">Medium</td>
<td align="center">二分/动态规划</td>
</tr>
<tr>
<td align="left">面试题 17.09. 第 k 个数</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">面试题 17.10. 主要元素</td>
<td align="center">Easy</td>
<td align="center">分治/数组</td>
</tr>
<tr>
<td align="left">面试题 17.11. 单词距离</td>
<td align="center">Medium</td>
<td align="center">哈希+双指针</td>
</tr>
<tr>
<td align="left">面试题 17.13. 恢复空格</td>
<td align="center">Medium</td>
<td align="center">动态规划+Trie</td>
</tr>
<tr>
<td align="left">面试题 17.14. 最小K个数</td>
<td align="center">Medium</td>
<td align="center">分治</td>
</tr>
<tr>
<td align="left">面试题 17.16. 按摩师</td>
<td align="center">Easy</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">面试题 17.17. 多次搜索</td>
<td align="center">Medium</td>
<td align="center">KMP/AC自动机</td>
</tr>
<tr>
<td align="left">面试题 17.18. 最短超串</td>
<td align="center">Medium</td>
<td align="center">滑动窗口</td>
</tr>
<tr>
<td align="left">面试题 17.22. 单词转换</td>
<td align="center">Medium</td>
<td align="center">双向广搜</td>
</tr>
<tr>
<td align="left">面试题 17.23. 最大黑方阵</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">面试题20. 表示数值的字符串</td>
<td align="center">Medium</td>
<td align="center">数学/确定有限状态自动机</td>
</tr>
<tr>
<td align="left">面试题42. 连续子数组的最大和</td>
<td align="center">Easy</td>
<td align="center">动规</td>
</tr>
<tr>
<td align="left">面试题47. 礼物的最大价值</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">面试题49. 丑数</td>
<td align="center">Medium</td>
<td align="center">丑数</td>
</tr>
<tr>
<td align="left">面试题62. 圆圈中最后剩下的数字</td>
<td align="center">Easy</td>
<td align="center">数学+迭代</td>
</tr>
<tr>
<td align="left">面试题67. 把字符串转换成整数</td>
<td align="center">Medium</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">剑指 Offer 09. 用两个栈实现队列</td>
<td align="center">Easy</td>
<td align="center">设计/队列/栈</td>
</tr>
<tr>
<td align="left">剑指 Offer 11. 旋转数组的最小数字</td>
<td align="center">Easy</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">剑指 Offer 25. 合并两个排序的链表</td>
<td align="center">Easy</td>
<td align="center">分治</td>
</tr>
<tr>
<td align="left">剑指 Offer 30. 包含min函数的栈</td>
<td align="center">Easy</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="left">剑指 Offer 36. 二叉搜索树与双向链表</td>
<td align="center">Medium</td>
<td align="center">分治</td>
</tr>
<tr>
<td align="left">剑指 Offer 38. 字符串的排列</td>
<td align="center">Medium</td>
<td align="center">回溯+剪枝</td>
</tr>
<tr>
<td align="left">剑指 Offer 39. 数组中出现次数超过一半的数字</td>
<td align="center">Easy</td>
<td align="center">位运算/分治</td>
</tr>
<tr>
<td align="left">剑指 Offer 40. 最小的k个数</td>
<td align="center">Easy</td>
<td align="center">分治</td>
</tr>
<tr>
<td align="left">剑指 Offer 48. 最长不含重复字符的子字符串</td>
<td align="center">Medium</td>
<td align="center">滑动窗口</td>
</tr>
<tr>
<td align="left">剑指 Offer 52. 两个链表的第一个公共节点</td>
<td align="center">Easy</td>
<td align="center">链表</td>
</tr>
<tr>
<td align="left">剑指 Offer 53 - I. 在排序数组中查找数字 I</td>
<td align="center">Easy</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">剑指 Offer 53 - II. 0～n-1中缺失的数字</td>
<td align="center">Easy</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="left">剑指 Offer 59 - I. 滑动窗口的最大值</td>
<td align="center">Easy</td>
<td align="center">滑动窗口</td>
</tr>
<tr>
<td align="left">剑指 Offer 59 - II. 队列的最大值</td>
<td align="center">Medium</td>
<td align="center">滑动窗口</td>
</tr>
<tr>
<td align="left">剑指 Offer 63. 股票的最大利润</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">剑指 Offer 68 - II. 二叉树的最近公共祖先</td>
<td align="center">Easy</td>
<td align="center">树</td>
</tr>
<tr>
<td align="left">LCP 13. 寻宝</td>
<td align="center">Hard</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">LCP 17. 速算机器人</td>
<td align="center">Easy</td>
<td align="center">数学</td>
</tr>
<tr>
<td align="left">LCP 18. 早餐组合</td>
<td align="center">Easy</td>
<td align="center">二分</td>
</tr>
<tr>
<td align="left">LCP 19. 秋叶收藏集</td>
<td align="center">Medium</td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="left">LCP 22. 黑白方格画</td>
<td align="center">Easy</td>
<td align="center">暴力</td>
</tr>
</tbody></table>
<blockquote>
<h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1></blockquote>
<h3 id="992-K-个不同整数的子数组"><a href="#992-K-个不同整数的子数组" class="headerlink" title="992. K 个不同整数的子数组"></a>992. K 个不同整数的子数组</h3><p><strong>Description</strong><br>给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。<br>（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。）<br>返回 A 中好子数组的数目。<br><strong>Example</strong><br>示例 1：<br>输入：A = [1,2,1,2,3], K = 2<br>输出：7<br>解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].</p>
<p>示例 2：<br>输入：A = [1,2,1,3,4], K = 3<br>输出：3<br>解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].</p>
<p>提示：<br>1 &lt;= A.length &lt;= 20000<br>1 &lt;= A[i] &lt;= A.length<br>1 &lt;= K &lt;= A.length<br><strong>Program</strong><br><strong>滑窗</strong><br>错误代码<br>样例一就有问题[1,2,1,2]中的{2,1,2}无法识别orz。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; mst;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> end=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(mst.count(A[i<span class="number">-1</span>])==<span class="number">1</span>){</span><br><span class="line">                    st.erase(A[i<span class="number">-1</span>]);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">//mst.erase(A[i-1]); //这里删除所有A[i-1]值了！错误！</span></span><br><span class="line">                mst.erase(mst.find(A[i<span class="number">-1</span>])); <span class="comment">//这样才对</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(st.size()==K) ans++;</span><br><span class="line">            <span class="keyword">while</span>(end+<span class="number">1</span>&lt;n&amp;&amp;(st.size()&lt;K||mst.count(A[end+<span class="number">1</span>])&gt;=<span class="number">1</span>)){</span><br><span class="line">                mst.insert(A[end+<span class="number">1</span>]);</span><br><span class="line">                st.insert(A[end+<span class="number">1</span>]);</span><br><span class="line">                end++;</span><br><span class="line">                <span class="keyword">if</span>(st.size()==K) ans++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>详见官方题解<br>K个不同整数的子数组个数=最多包含K种不同整数的子数组个数-最多包含K-1种不同整数的子数组个数，妙啊！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> atMostKDistinct(A, K) - atMostKDistinct(A, K<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">atMostKDistinct</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(K==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; freq(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>; <span class="comment">//不同数的个数</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(freq[A[i<span class="number">-1</span>]]==<span class="number">1</span>) cnt--;</span><br><span class="line">                freq[A[i<span class="number">-1</span>]]--;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span>(end+<span class="number">1</span>&lt;n&amp;&amp;(cnt&lt;K||freq[A[end+<span class="number">1</span>]]&gt;<span class="number">0</span>)){ <span class="comment">//cnt==K时，后者还可以继续递增end</span></span><br><span class="line">                end++;</span><br><span class="line">                <span class="keyword">if</span>(freq[A[end]]==<span class="number">0</span>) cnt++;</span><br><span class="line">                freq[A[end]]++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//精髓，[i, end]区间, 例如[1,2,1,2],有[1],[1,2],[1,2,1,],[1,2,1,2]四个区间，</span></span><br><span class="line">            <span class="comment">//那么[2,1,2]咋办，这个会在下一次以2为起点的时候进行计算！</span></span><br><span class="line">            <span class="comment">//类似这种计算技巧遇到好几次了，orz，记录一波，下次遇到好整理，好菜啊</span></span><br><span class="line">            ans+=end-i+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="LCP"><a href="#LCP" class="headerlink" title="LCP"></a>LCP</h1></blockquote>
<h2 id="LCP-17-速算机器人"><a href="#LCP-17-速算机器人" class="headerlink" title="LCP 17. 速算机器人"></a>LCP 17. 速算机器人</h2><p><strong>Description</strong><br>小扣在秋日市集发现了一款速算机器人。店家对机器人说出两个数字（记作 x 和 y），请小扣说出计算指令：<br>“A” 运算：使 x = 2 * x + y；<br>“B” 运算：使 y = 2 * y + x。<br>在本次游戏中，店家说出的数字为 x = 1 和 y = 0，小扣说出的计算指令记作仅由大写字母 A、B 组成的字符串 s，字符串中字符的顺序表示计算顺序，请返回最终 x 与 y 的和为多少。<br><strong>Example</strong><br>示例 1：<br>输入：s = “AB”<br>输出：4<br>解释：<br>经过一次 A 运算后，x = 2, y = 0。<br>再经过一次 B 运算，x = 2, y = 2。<br>最终 x 与 y 之和为 4。</p>
<p>提示：<br>0 &lt;= s.length &lt;= 10<br>s 由 ‘A’ 和 ‘B’ 组成<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">1</span>, y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++){</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'A'</span>){</span><br><span class="line">                x=<span class="number">2</span>*x+y;</span><br><span class="line">            }<span class="keyword">else</span> y=<span class="number">2</span>*y+x;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="LCP-18-早餐组合"><a href="#LCP-18-早餐组合" class="headerlink" title="LCP 18. 早餐组合"></a>LCP 18. 早餐组合</h2><p><strong>Description</strong><br>小扣在秋日市集选择了一家早餐摊位，一维整型数组 staple 中记录了每种主食的价格，一维整型数组 drinks 中记录了每种饮料的价格。小扣的计划选择一份主食和一款饮料，且花费不超过 x 元。请返回小扣共有多少种购买方案。<br>注意：答案需要以 1e9 + 7 (1000000007) 为底取模，如：计算初始结果为：1000000008，请返回 1<br><strong>Example</strong><br>示例 1：<br>输入：staple = [10,20,5], drinks = [5,5,2], x = 15<br>输出：6<br>解释：小扣有 6 种购买方案，所选主食与所选饮料在数组中对应的下标分别是：<br>第 1 种方案：staple[0] + drinks[0] = 10 + 5 = 15；<br>第 2 种方案：staple[0] + drinks[1] = 10 + 5 = 15；<br>第 3 种方案：staple[0] + drinks[2] = 10 + 2 = 12；<br>第 4 种方案：staple[2] + drinks[0] = 5 + 5 = 10；<br>第 5 种方案：staple[2] + drinks[1] = 5 + 5 = 10；<br>第 6 种方案：staple[2] + drinks[2] = 5 + 2 = 7。</p>
<p>示例 2：<br>输入：staple = [2,1,1], drinks = [8,9,5,1], x = 9<br>输出：8<br>解释：小扣有 8 种购买方案，所选主食与所选饮料在数组中对应的下标分别是：<br>第 1 种方案：staple[0] + drinks[2] = 2 + 5 = 7；<br>第 2 种方案：staple[0] + drinks[3] = 2 + 1 = 3；<br>第 3 种方案：staple[1] + drinks[0] = 1 + 8 = 9；<br>第 4 种方案：staple[1] + drinks[2] = 1 + 5 = 6；<br>第 5 种方案：staple[1] + drinks[3] = 1 + 1 = 2；<br>第 6 种方案：staple[2] + drinks[0] = 1 + 8 = 9；<br>第 7 种方案：staple[2] + drinks[2] = 1 + 5 = 6；<br>第 8 种方案：staple[2] + drinks[3] = 1 + 1 = 2；</p>
<p>提示：<br>1 &lt;= staple.length &lt;= 10^5<br>1 &lt;= drinks.length &lt;= 10^5<br>1 &lt;= staple[i],drinks[i] &lt;= 10^5<br>1 &lt;= x &lt;= 2<em>10^5<br>*</em>Program**<br><strong>二分</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">breakfastNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; staple, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; drinks, <span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m=staple.size(), n=drinks.size();</span><br><span class="line">        sort(staple.begin(), staple.end());</span><br><span class="line">        sort(drinks.begin(), drinks.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">if</span>(staple[i]&gt;=x) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">                <span class="keyword">int</span> mid=left+(right-left+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(staple[i]+drinks[mid]&lt;=x) left=mid;</span><br><span class="line">                <span class="keyword">else</span> right=mid<span class="number">-1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(staple[i]+drinks[left]&gt;x) left--;</span><br><span class="line">            res=(res+left+<span class="number">1</span>)%MOD;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="LCP-19-秋叶收藏集"><a href="#LCP-19-秋叶收藏集" class="headerlink" title="LCP 19. 秋叶收藏集"></a>LCP 19. 秋叶收藏集</h2><p><strong>Description</strong><br>小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 leaves， 字符串 leaves 仅包含小写字符 r 和 y， 其中字符 r 表示一片红叶，字符 y 表示一片黄叶。<br>出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。<br><strong>Example</strong><br>示例 1：<br>输入：leaves = “rrryyyrryyyrr”<br>输出：2<br>解释：调整两次，将中间的两片红叶替换成黄叶，得到 “rrryyyyyyyyrr”</p>
<p>示例 2：<br>输入：leaves = “ryr”<br>输出：0<br>解释：已符合要求，不需要额外操作</p>
<p>提示：<br>3 &lt;= leaves.length &lt;= 10^5<br>leaves 中只包含字符 ‘r’ 和字符 ‘y’<br><strong>Program</strong><br><strong>动态规划</strong><br>（1）DP[0][i]表示从头到尾全变红的最少次数；<br>（2）DP[1][i]表示从头变红，当前变黄（红黄）的最少次数；<br>（3）DP[2][i]表示之前是红黄，现在变成红黄红的最少次数；<br>时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumOperations</span><span class="params">(<span class="built_in">string</span> leaves)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=leaves.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; DP(<span class="number">3</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            DP[<span class="number">0</span>][i]=(i&gt;=<span class="number">1</span>?DP[<span class="number">0</span>][i<span class="number">-1</span>]:<span class="number">0</span>)+(leaves[i]!=<span class="string">'r'</span>);  <span class="comment">//从头开始全变红</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">1</span>) DP[<span class="number">1</span>][i]=DP[<span class="number">0</span>][i]; <span class="comment">//头部要以红开头</span></span><br><span class="line">            <span class="keyword">else</span> DP[<span class="number">1</span>][i]=min(DP[<span class="number">0</span>][i<span class="number">-1</span>]+(leaves[i]!=<span class="string">'y'</span>),</span><br><span class="line">                              DP[<span class="number">1</span>][i<span class="number">-1</span>]+(leaves[i]!=<span class="string">'y'</span>)); <span class="comment">//从头开始全是红，当前是黄</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">2</span>) DP[<span class="number">2</span>][i]=DP[<span class="number">1</span>][i]; <span class="comment">//前两个必须是红黄</span></span><br><span class="line">            <span class="keyword">else</span> DP[<span class="number">2</span>][i]=min(DP[<span class="number">1</span>][i<span class="number">-1</span>]+(leaves[i]!=<span class="string">'r'</span>), DP[<span class="number">2</span>][i<span class="number">-1</span>]+(leaves[i]!=<span class="string">'r'</span>)); <span class="comment">//前面是红黄，现在是红</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[<span class="number">2</span>][n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="LCP-22-黑白方格画"><a href="#LCP-22-黑白方格画" class="headerlink" title="LCP 22. 黑白方格画"></a>LCP 22. 黑白方格画</h2><p><strong>Description</strong><br>小扣注意到秋日市集上有一个创作黑白方格画的摊位。摊主给每个顾客提供一个固定在墙上的白色画板，画板不能转动。画板上有 n * n 的网格。绘画规则为，小扣可以选择任意多行以及任意多列的格子涂成黑色，所选行数、列数均可为 0。<br>小扣希望最终的成品上需要有 k 个黑色格子，请返回小扣共有多少种涂色方案。<br>注意：两个方案中任意一个相同位置的格子颜色不同，就视为不同的方案。<br><strong>Example</strong><br>示例 1：<br>输入：n = 2, k = 2<br>输出：4<br>解释：一共有四种不同的方案：<br>第一种方案：涂第一列；<br>第二种方案：涂第二列；<br>第三种方案：涂第一行；<br>第四种方案：涂第二行。</p>
<p>示例 2：<br>输入：n = 2, k = 1<br>输出：0<br>解释：不可行，因为第一次涂色至少会涂两个黑格。</p>
<p>示例 3：<br>输入：n = 2, k = 4<br>输出：1<br>解释：共有 2*2=4 个格子，仅有一种涂色方案。</p>
<p>限制：<br>1 &lt;= n &lt;= 6<br>0 &lt;= k &lt;= n * n<br><strong>Program</strong><br><strong>暴力</strong><br>取i行j列，所得黑格数为$i * n + j *(n - i)$，注意i,j从0开始，且$k=n * n$时答案为1！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calCn</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        a=b=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=n-k+<span class="number">1</span>;i--) a*=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&gt;=<span class="number">1</span>;i--) b*=i;</span><br><span class="line">        <span class="keyword">return</span> a/b;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">paintingPlan</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(k==n*n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++){</span><br><span class="line">                <span class="keyword">int</span> s=i*n+j*(n-i);</span><br><span class="line">                <span class="keyword">if</span>(s==k){</span><br><span class="line">                    ans+=calCn(n, i) * calCn(n, j);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1></blockquote>
<h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h2><p><strong>Description</strong><br>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回滑动窗口中的最大值。<br>进阶：<br>你能在线性时间复杂度内解决此题吗？<br><strong>Example</strong><br>示例:<br>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></tbody></table></figure>

<p>提示：<br>1 &lt;= nums.length &lt;= 10^5<br>-10^4 &lt;= nums[i] &lt;= 10^4<br>1 &lt;= k &lt;= nums.length<br><strong>Program</strong><br><strong>滑动窗口</strong><br>一个很自然的思路就是维护一个保有索引的优先队列，然而时间复杂度为$O(n\log{k})$<br>线性复杂度的做法：<br>维护一个双端队列window：<br>（1）变量的最前端（也就是 window.front()）是此次遍历的最大值的下标<br>（2）当我们遇到新的数时，将新的数和双项队列的末尾（也就是window.back()）比较，如果末尾比新数小，则把末尾扔掉，直到该队列的末尾比新数大或者队列为空的时候才停止。<br>（3）双项队列中的所有值都要在窗口范围内<br><strong>特点1：队列头尾当前最大元素下标</strong><br>特点2：队列降序排列，最大值、次大值…下标<br>例如</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,3,1,2,0,5]</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure>
<p>[[1,3,1],2,0,5]，队列3,1<br>[1,[3,1,2],0,5]，队列3,2<br>[1,3,[1,2,0],5]，剔除3，新进0，队列2,0<br>[1,3,1,[2,0,5]]，队列5</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++){</span><br><span class="line">            <span class="keyword">while</span>(!dq.empty()&amp;&amp;nums[dq.back()]&lt;nums[i]){</span><br><span class="line">                dq.pop_back();</span><br><span class="line">            }</span><br><span class="line">            dq.push_back(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        res.push_back(nums[dq[<span class="number">0</span>]]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(dq[<span class="number">0</span>]&lt;=i-k) dq.pop_front();</span><br><span class="line">            <span class="keyword">while</span>(!dq.empty()&amp;&amp;nums[dq.back()]&lt;nums[i]){</span><br><span class="line">                dq.pop_back();</span><br><span class="line">            }</span><br><span class="line">            dq.push_back(i);</span><br><span class="line">            res.push_back(nums[dq[<span class="number">0</span>]]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>传统思路</strong><br>超时</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> idx;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> i, <span class="keyword">int</span> n):idx(i),num(n){}</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; node)<span class="keyword">const</span>{</span><br><span class="line">            <span class="keyword">return</span> num&lt;node.num;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) {</span><br><span class="line">        priority_queue&lt;Node&gt; pq;</span><br><span class="line">        <span class="built_in">deque</span>&lt;Node&gt; dq;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++){</span><br><span class="line">            dq.push_back(Node(i, nums[i]));</span><br><span class="line">            pq.push(Node(i, nums[i]));</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        res.push_back(pq.top().num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;n;i++){</span><br><span class="line">            dq.pop_front();</span><br><span class="line">            dq.push_back(Node(i, nums[i]));</span><br><span class="line">            priority_queue&lt;Node&gt; pq(dq.begin(), dq.end());</span><br><span class="line">            res.push_back(pq.top().num);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1438-绝对差不超过限制的最长连续子数组"><a href="#1438-绝对差不超过限制的最长连续子数组" class="headerlink" title="1438. 绝对差不超过限制的最长连续子数组"></a>1438. 绝对差不超过限制的最长连续子数组</h2><p><strong>Description</strong><br>给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。<br>如果不存在满足条件的子数组，则返回 0 。<br><strong>Example</strong><br>示例 1：<br>输入：nums = [8,2,4,7], limit = 4<br>输出：2<br>解释：所有子数组如下：<br>[8] 最大绝对差 |8-8| = 0 &lt;= 4.<br>[8,2] 最大绝对差 |8-2| = 6 &gt; 4.<br>[8,2,4] 最大绝对差 |8-2| = 6 &gt; 4.<br>[8,2,4,7] 最大绝对差 |8-2| = 6 &gt; 4.<br>[2] 最大绝对差 |2-2| = 0 &lt;= 4.<br>[2,4] 最大绝对差 |2-4| = 2 &lt;= 4.<br>[2,4,7] 最大绝对差 |2-7| = 5 &gt; 4.<br>[4] 最大绝对差 |4-4| = 0 &lt;= 4.<br>[4,7] 最大绝对差 |4-7| = 3 &lt;= 4.<br>[7] 最大绝对差 |7-7| = 0 &lt;= 4.<br>因此，满足题意的最长子数组的长度为 2 。</p>
<p>示例 2：<br>输入：nums = [10,1,2,4,7,2], limit = 5<br>输出：4<br>解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| = 5 &lt;= 5 。</p>
<p>示例 3：<br>输入：nums = [4,2,2,2,4,4,2,2], limit = 0<br>输出：3</p>
<p>提示：<br>1 &lt;= nums.length &lt;= 10^5<br>1 &lt;= nums[i] &lt;= 10^9<br>0 &lt;= limit &lt;= 10^9<br><strong>Program</strong><br>滑动窗口最大值变型题，所不同的是需要维护两个双端队列，分别保存窗口最大值和最小值（其实是窗口最值排序）</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; miDq, mxDq; <span class="comment">//记录窗口最小最大值</span></span><br><span class="line">        <span class="keyword">int</span> e=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(!mxDq.empty()&amp;&amp;mxDq[<span class="number">0</span>]==i<span class="number">-1</span>) mxDq.pop_front();</span><br><span class="line">                <span class="keyword">if</span>(!miDq.empty()&amp;&amp;miDq[<span class="number">0</span>]==i<span class="number">-1</span>) miDq.pop_front();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//miDq非空，则mxDq必非空</span></span><br><span class="line">            <span class="keyword">while</span>(e+<span class="number">1</span>&lt;n&amp;&amp;(miDq.empty()||(!miDq.empty()&amp;&amp;<span class="built_in">abs</span>(nums[miDq[<span class="number">0</span>]]-nums[e+<span class="number">1</span>])&lt;=limit&amp;&amp;<span class="built_in">abs</span>(nums[mxDq[<span class="number">0</span>]]-nums[e+<span class="number">1</span>])&lt;=limit))){</span><br><span class="line">                <span class="keyword">while</span>(!miDq.empty()&amp;&amp;nums[miDq.back()]&gt;nums[e+<span class="number">1</span>]){</span><br><span class="line">                    miDq.pop_back();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">while</span>(!mxDq.empty()&amp;&amp;nums[mxDq.back()]&lt;nums[e+<span class="number">1</span>]){</span><br><span class="line">                    mxDq.pop_back();</span><br><span class="line">                }</span><br><span class="line">                miDq.push_back(e+<span class="number">1</span>);</span><br><span class="line">                mxDq.push_back(e+<span class="number">1</span>);</span><br><span class="line">                e++;</span><br><span class="line">            }</span><br><span class="line">            ans=max(ans, e-i+<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="5631-跳跃游戏-VI"><a href="#5631-跳跃游戏-VI" class="headerlink" title="5631. 跳跃游戏 VI"></a>5631. 跳跃游戏 VI</h2><p><strong>Description</strong><br>给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。<br>一开始你在下标 0 处。每一步，你最多可以往前跳 k 步，但你不能跳出数组的边界。也就是说，你可以从下标 i 跳到 [i + 1， min(n - 1, i + k)] 包含 两个端点的任意位置。<br>你的目标是到达数组最后一个位置（下标为 n - 1 ），你的 得分 为经过的所有数字之和。<br>请你返回你能得到的 最大得分 。<br><strong>Example</strong><br>示例 1：<br>输入：nums = [1,-1,-2,4,-7,3], k = 2<br>输出：7<br>解释：你可以选择子序列 [1,-1,4,3] （上面加粗的数字），和为 7 。</p>
<p>示例 2：<br>输入：nums = [10,-5,-2,4,0,3], k = 3<br>输出：17<br>解释：你可以选择子序列 [10,4,3] （上面加粗数字），和为 17 。</p>
<p>示例 3：<br>输入：nums = [1,-5,-20,4,-1,3,-6,-3], k = 2<br>输出：0</p>
<p>提示：<br>$1 &lt;= nums.length, k &lt;= 10^5$<br>$-10^4 &lt;= nums[i] &lt;= 10^4$<br><strong>Program</strong><br>设DP[i]=max(DP[j])+nums[i]，其中i-k&lt;=j&lt;i，时间复杂度：$O(n^2)$<br>优化如下<br><strong>优先队列</strong><br>max(DP[j])通过优先队列查找，且窗口外的dp值全部抛出<br>时间复杂度：$O(n\log{n})$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxResult</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">        pq.push({nums[<span class="number">0</span>], <span class="number">0</span>});</span><br><span class="line">        <span class="keyword">int</span> ans=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">while</span>(i-pq.top().second&gt;k) pq.pop(); <span class="comment">//超过窗口k的全部剔除</span></span><br><span class="line">            ans=pq.top().first+nums[i];</span><br><span class="line">            pq.push({ans, i});</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>单调队列</strong><br>窗口内的dp值保持单调递减，因为对于i-k&lt;=j1,j2&lt;i来说，如果dp[j1]&lt;dp[j2]，那么j1就应当永久剔除，因为不影响后续结果；<br>时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxResult</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">deque</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q; <span class="comment">//单调递减队列，p.first即dp[i]的值单调减</span></span><br><span class="line">        q.emplace_back(nums[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> ans=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">while</span>(i-q.front().second&gt;k) q.pop_front(); <span class="comment">//超过窗口范围</span></span><br><span class="line">            ans=q.front().first+nums[i];</span><br><span class="line">            <span class="keyword">while</span>(!q.empty()&amp;&amp;q.back().first&lt;ans) q.pop_back(); <span class="comment">//维持单调性</span></span><br><span class="line">            q.emplace_back(ans, i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="剑指-Offer-59-I-滑动窗口的最大值"><a href="#剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值"></a>剑指 Offer 59 - I. 滑动窗口的最大值</h2><p><strong>Description</strong><br>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。<br><strong>Example</strong><br>示例:<br>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></tbody></table></figure>

<p>提示：<br>你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。<br><strong>Program</strong><br>保持双端队列首位为最大值，队列降序排列！<br>一个窗口中，较小的数在前面可以剔除，因为后续窗口移动过程中，一定不会是它为窗口最大值。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++){</span><br><span class="line">            <span class="keyword">while</span>(!dq.empty()&amp;&amp;nums[dq.back()]&lt;nums[i]) dq.pop_back();</span><br><span class="line">            dq.push_back(i);</span><br><span class="line">        }</span><br><span class="line">        res.push_back(nums[dq[<span class="number">0</span>]]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(dq[<span class="number">0</span>]&lt;=i-k) dq.pop_front();</span><br><span class="line">             <span class="keyword">while</span>(!dq.empty()&amp;&amp;nums[dq.back()]&lt;nums[i]) dq.pop_back();</span><br><span class="line">             dq.push_back(i);</span><br><span class="line">             res.push_back(nums[dq[<span class="number">0</span>]]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="剑指-Offer-59-II-队列的最大值"><a href="#剑指-Offer-59-II-队列的最大值" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a>剑指 Offer 59 - II. 队列的最大值</h2><p><strong>Description</strong><br>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。<br>若队列为空，pop_front 和 max_value 需要返回 -1<br><strong>Example</strong><br>示例 1：<br>输入:<br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]<br>输出: [null,null,null,2,1,2]</p>
<p>示例 2：<br>输入:<br>[“MaxQueue”,”pop_front”,”max_value”]<br>[[],[],[]]<br>输出: [null,-1,-1]</p>
<p>限制：<br>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000<br>1 &lt;= value &lt;= 10^5<br><strong>Program</strong><br>双端队列保留队列最大值，思路与滑动窗口最大值相同。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">    MaxQueue() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(q.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dq[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        q.push(value);</span><br><span class="line">        <span class="keyword">while</span>(!dq.empty()&amp;&amp;dq.back()&lt;value) dq.pop_back(); <span class="comment">//双端队列保存队列最大值</span></span><br><span class="line">        dq.push_back(value);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(q.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(q.front()==dq[<span class="number">0</span>]) dq.pop_front();</span><br><span class="line">        <span class="keyword">int</span> res=q.front();q.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxQueue* obj = new MaxQueue();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;max_value();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push_back(value);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<h1 id="树状数组-差分数组"><a href="#树状数组-差分数组" class="headerlink" title="树状数组/差分数组"></a>树状数组/差分数组</h1></blockquote>
<h2 id="307-区域和检索-数组可修改"><a href="#307-区域和检索-数组可修改" class="headerlink" title="307. 区域和检索 - 数组可修改"></a>307. 区域和检索 - 数组可修改</h2><p><strong>Description</strong><br>给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。<br>update(i, val) 函数可以通过将下标为 i 的数值更新为 val，从而对数列进行修改。<br><strong>Example</strong><br>示例:<br>Given nums = [1, 3, 5]<br>sumRange(0, 2) -&gt; 9<br>update(1, 2)<br>sumRange(0, 2) -&gt; 8<br>说明:<br>数组仅可以在 update 函数下进行修改。<br>你可以假设 update 函数与 sumRange 函数的调用次数是均匀分布的。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> nCount;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;nCount=nums.size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;C.resize(nCount+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;nums.resize(nCount);</span><br><span class="line"></span><br><span class="line">        fill(<span class="keyword">this</span>-&gt;C.begin(), <span class="keyword">this</span>-&gt;C.end(), <span class="number">0</span>);</span><br><span class="line">        fill(<span class="keyword">this</span>-&gt;nums.begin(), <span class="keyword">this</span>-&gt;nums.end(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;nCount;i++){</span><br><span class="line">            update(i, nums[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> tmp=val;</span><br><span class="line">        val=val-<span class="keyword">this</span>-&gt;nums[i];</span><br><span class="line">        <span class="keyword">this</span>-&gt;nums[i]=tmp;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=i;x&lt;=nCount;x+=lowbit(x)){</span><br><span class="line">            C[x]+=val;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;<span class="number">0</span>;i-=lowbit(i)){</span><br><span class="line">            sum+=C[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">return</span> getSum(j)-getSum(i);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray* obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * obj-&gt;update(i,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="327-区间和的个数"><a href="#327-区间和的个数" class="headerlink" title="327. 区间和的个数"></a>327. 区间和的个数</h2><p><strong>Description</strong><br>给定一个整数数组 nums，返回区间和在 [lower, upper] 之间的个数，包含 lower 和 upper。<br>区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。<br>说明:<br>最直观的算法复杂度是 $O(n^2)$ ，请在此基础上优化你的算法。<br><strong>Example</strong><br>示例:<br>输入: nums = [-2,5,-1], lower = -2, upper = 2,<br>输出: 3<br>解释: 3个区间分别是: [0,0], [2,2], [0,2]，它们表示的和分别为: -2, -1, 2。<br><strong>Program</strong><br><strong>树状数组</strong><br>树状数组与线段树基于类似的思想，不过树状数组支持的基本查询为求出 [0, \textit{val}][0,val] 之间的整数数量。为了查询区间 [\textit{preSum}[j]-\textit{upper}, \textit{preSum}[j]-\textit{lower}][preSum[j]−upper,preSum[j]−lower] 内的整数数量，需要执行两次查询，即分别查询 [0, \textit{preSum}[j]-\textit{upper}-1][0,preSum[j]−upper−1] 区间的整数数量 LL 和[0,\textit{preSum}[j]-\textit{lower}][0,preSum[j]−lower]</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;=<span class="number">1</span>;i-=lowbit(i)){</span><br><span class="line">            sum+=C[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=n;i+=lowbit(i)) C[i]+=v;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countRangeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; preSum={<span class="number">0</span>};</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++){</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            preSum.push_back(sum);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//离散化</span></span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> x:preSum){</span><br><span class="line">            st.insert(x);</span><br><span class="line">            st.insert(x-upper);</span><br><span class="line">            st.insert(x-lower);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> x:st) m[x]=idx++;</span><br><span class="line">        n=idx<span class="number">-1</span>;</span><br><span class="line">        C.resize(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;preSum.size();i++){</span><br><span class="line">            <span class="keyword">int</span> left=m[preSum[i]-upper], right=m[preSum[i]-lower];</span><br><span class="line">            ans+=getSum(right)-getSum(left<span class="number">-1</span>);</span><br><span class="line">            update(m[preSum[i]], <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1674-使数组互补的最少操作次数"><a href="#1674-使数组互补的最少操作次数" class="headerlink" title="1674. 使数组互补的最少操作次数"></a>1674. 使数组互补的最少操作次数</h2><p><strong>Description</strong><br>给你一个长度为 偶数 n 的整数数组 nums 和一个整数 limit 。每一次操作，你可以将 nums 中的任何整数替换为 1 到 limit 之间的另一个整数。<br>如果对于所有下标 i（下标从 0 开始），nums[i] + nums[n - 1 - i] 都等于同一个数，则数组 nums 是 互补的 。例如，数组 [1,2,3,4] 是互补的，因为对于所有下标 i ，nums[i] + nums[n - 1 - i] = 5 。<br>返回使数组 互补 的 最少 操作次数。<br><strong>Example</strong><br>示例 1：<br>输入：nums = [1,2,4,3], limit = 4<br>输出：1<br>解释：经过 1 次操作，你可以将数组 nums 变成 [1,2,2,3]（加粗元素是变更的数字）：<br>nums[0] + nums[3] = 1 + 3 = 4.<br>nums[1] + nums[2] = 2 + 2 = 4.<br>nums[2] + nums[1] = 2 + 2 = 4.<br>nums[3] + nums[0] = 3 + 1 = 4.<br>对于每个 i ，nums[i] + nums[n-1-i] = 4 ，所以 nums 是互补的。</p>
<p>示例 2：<br>输入：nums = [1,2,2,1], limit = 2<br>输出：2<br>解释：经过 2 次操作，你可以将数组 nums 变成 [2,2,2,2] 。你不能将任何数字变更为 3 ，因为 3 &gt; limit 。</p>
<p>示例 3：<br>输入：nums = [1,2,1,2], limit = 2<br>输出：0<br>解释：nums 已经是互补的。</p>
<p>提示：<br>n == nums.length<br>$2 &lt;= n &lt;= 10^5$<br>$1 &lt;= nums[i] &lt;= limit &lt;= 10^5$<br>n 是偶数。<br><strong>Program</strong><br><strong>差分数组</strong><br>假设 res[x] 表示的是，nums[i] + nums[n - 1 - i] 为 x 的时候，需要多少次操作。<br>我们只需要计算出所有的 x 对应的 res[x], 取最小值就好了。<br>根据题意，nums[i] + nums[n - 1 - i] 最小是 2，即将两个数都修改为 1；最大是 2 * limit，即将两个数都修改成 limit。<br>所以，res[x] 中 x 的取值范围是 [2, 2 * limit]。我们用一个 res[2 * limit + 1] 的数组就好。<br>关键是，如何求出每一个 res[x] 位置的值，即修改后互补的数字和为 x，需要多少操作？<br>为了叙述方便，假设 nums[i] 为 A；nums[n - 1 - i] 为 B。</p>
<p>显然有：<br>如果修改后两个数字的和是 A + B，我们使用的操作数是 0 (没有修改));<br>否则的话，如果修改后两个数字和在 [1 + min(A, B), limit + max(A, B)] 的范围，我们使用的操作数是 1 (只需要修改 A 或者 B 就好);<br>否则的话，如果修改后两个数字和在 [2, 2 * limit] 的范围，我们使用的操作数是 <code>2</code>(两个数字都要修改));<br>所以，我们的算法是遍历每一组 nums[i] 和 nums[n - 1 - i]，然后：<br>先将 [2, 2 * limit] 的范围需要的操作数 + 2；<br>之后，将 [1 + min(A, B), limit + max(A, B)] 的范围需要的操作数 - 1（即 2 - 1 = 1，操作 1 次）；<br>之后，将 [A + B] 位置的值再 -1（即 1 - 1 = 0，操作 0 次）。<br>可以看出，整个过程都是在做区间更新。最后，我们查询每一个位置的值，取最小值就好。<br>对于这个需求，我们当然可以使用线段树或者树状数组解决，但代码量稍大，且复杂度也是 O(nlogn) 的。<br>但是仔细观察，我们发现，我们只需要作区间更新，和单点查询。<br>对于这个需求，有一种非常常规的”数据结构“，叫差分数组，完全满足需求，并且编程极其简单，整体可以在 O(n) 的时间解决。<br>打上引号，是因为差分数组就是一个数组而已。<br>简单来说，差分数组 diff[i]，存储的是 res[i] - res[i - 1]；而差分数组 diff[0…i] 的和，就是 res[i] 的值。<br>大家可以用一个小数据试验一下，很好理解。<br>如果我们想给 [l, r] 的区间加上一个数字 a, 只需要 diff[l] += a，diff[r + 1] -= a。<br>这样做，diff[0…i] 的和，就是更新后 res[i] 的值。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; diff(<span class="number">2</span>*limit+<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++){</span><br><span class="line">            <span class="keyword">int</span> A=nums[i], B=nums[n-i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">int</span> l=<span class="number">2</span>, r=<span class="number">2</span>*limit;</span><br><span class="line">            diff[l]+=<span class="number">2</span>, diff[r+<span class="number">1</span>]-=<span class="number">2</span>;</span><br><span class="line">            l=<span class="number">1</span>+min(A, B), r=limit+max(A, B);</span><br><span class="line">            diff[l]+=<span class="number">-1</span>, diff[r+<span class="number">1</span>]-=<span class="number">-1</span>;</span><br><span class="line">            l=A+B,r=A+B;</span><br><span class="line">            diff[l]+=<span class="number">-1</span>, diff[r+<span class="number">1</span>]-=<span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">2</span>*n;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">2</span>*limit;i++){</span><br><span class="line">            sum+=diff[i];</span><br><span class="line">            ans=min(sum, ans);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1></blockquote>
<h2 id="技巧："><a href="#技巧：" class="headerlink" title="技巧："></a>技巧：</h2><p>（1）与和k相关，哈希表记录前缀和；找区间[i + 1, j]的和为k, 即preSum[j] - preSum[i] = k<br>（2）与倍数k相关，哈希表记录取模后的余数；找区间[i + 1, j]的和为k的倍数，即preSum[j] - preSum[i] = n * k</p>
<hr>
<h2 id="面试题-17-05-字母与数字"><a href="#面试题-17-05-字母与数字" class="headerlink" title="面试题 17.05.  字母与数字"></a><a href="https://leetcode-cn.com/problems/find-longest-subarray-lcci/" target="_blank" rel="noopener">面试题 17.05.  字母与数字</a></h2><p><strong>Description</strong><br>给定一个放有字符和数字的数组，找到最长的子数组，且包含的字符和数字的个数相同。<br>返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。<br><strong>Example</strong><br>示例 1:<br>输入: [“A”,”1”,”B”,”C”,”D”,”2”,”3”,”4”,”E”,”5”,”F”,”G”,”6”,”7”,”H”,”I”,”J”,”K”,”L”,”M”]<br>输出: [“A”,”1”,”B”,”C”,”D”,”2”,”3”,”4”,”E”,”5”,”F”,”G”,”6”,”7”]</p>
<p>示例 2:<br>输入: [“A”,”A”]<br>输出: []</p>
<p>提示：<br>array.length &lt;= 100000<br><strong>Program</strong><br>digitCnt - charCnt = diff<br>如果哈希表中找到diff说明[m[diff] + 1, i]是一个结果</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findLongestSubarray(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; arr) {</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> charCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> digitCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        m[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">//特例，整个数组成立start = m[0] + 1 = 0，n - 1 - (-1) = n;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ){</span><br><span class="line">            <span class="keyword">if</span>(arr[i][<span class="number">0</span>] &gt;= <span class="string">'0'</span> &amp;&amp; arr[i][<span class="number">0</span>] &lt;= <span class="string">'9'</span>) digitCnt ++ ;</span><br><span class="line">            <span class="keyword">else</span> charCnt ++ ;</span><br><span class="line">            <span class="keyword">int</span> diff = digitCnt - charCnt;</span><br><span class="line">            <span class="keyword">if</span>(m.find(diff) == m.end()) m[diff] = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i - m[diff] &gt; len){</span><br><span class="line">                len = i - m[diff];</span><br><span class="line">                start = m[diff] + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(arr.begin() + start, arr.begin() + start + len);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1590-使数组和能被-P-整除"><a href="#1590-使数组和能被-P-整除" class="headerlink" title="1590. 使数组和能被 P 整除"></a><a href="https://leetcode-cn.com/problems/make-sum-divisible-by-p/" target="_blank" rel="noopener">1590. 使数组和能被 P 整除</a></h2><p><strong>Description</strong><br>给你一个正整数数组 nums，请你移除 最短 子数组（可以为 空），使得剩余元素的 和 能被 p 整除。 不允许 将整个数组都移除。<br>请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 -1 。<br>子数组 定义为原数组中连续的一组元素。<br><strong>Example</strong><br>示例 1：<br>输入：nums = [3,1,4,2], p = 6<br>输出：1<br>解释：nums 中元素和为 10，不能被 p 整除。我们可以移除子数组 [4] ，剩余元素的和为 6 。</p>
<p>示例 2：<br>输入：nums = [6,3,5,2], p = 9<br>输出：2<br>解释：我们无法移除任何一个元素使得和被 9 整除，最优方案是移除子数组 [5,2] ，剩余元素为 [6,3]，和为 9 。</p>
<p>示例 3：<br>输入：nums = [1,2,3], p = 3<br>输出：0<br>解释：和恰好为 6 ，已经能被 3 整除了。所以我们不需要移除任何元素。</p>
<p>示例  4：<br>输入：nums = [1,2,3], p = 7<br>输出：-1<br>解释：没有任何方案使得移除子数组后剩余元素的和被 7 整除。</p>
<p>示例 5：<br>输入：nums = [1000000000,1000000000,1000000000], p = 3<br>输出：0</p>
<p>提示：<br>1 &lt;= nums.length &lt;= 105<br>1 &lt;= nums[i] &lt;= 109<br>1 &lt;= p &lt;= 109<br><strong>Program</strong><br>记录同一个余数最后出现的位置，M为整个数组对p取模的余数<br>前缀数组A的余数为x，前缀数组B(B&gt;A)的余数为y=M+x，那么B-A的子数组为所求</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> p)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums) mod = (mod + x) % p; <span class="comment">//防止溢出</span></span><br><span class="line">        <span class="keyword">if</span>(mod == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//特例</span></span><br><span class="line">        <span class="keyword">int</span> subMod = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = n;</span><br><span class="line">        m[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ){</span><br><span class="line">            subMod = (subMod + nums[i]) % p;</span><br><span class="line">            <span class="keyword">int</span> target = (subMod - mod + p) % p; <span class="comment">//map中是否有target</span></span><br><span class="line">            <span class="keyword">if</span>(m.find(target) != m.end()){</span><br><span class="line">                res = min(res, i - m[target]);</span><br><span class="line">            }</span><br><span class="line">            m[subMod] = i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res == n ? <span class="number">-1</span> : res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="930-和相同的二元子数组"><a href="#930-和相同的二元子数组" class="headerlink" title="930. 和相同的二元子数组"></a><a href="https://leetcode-cn.com/problems/binary-subarrays-with-sum/" target="_blank" rel="noopener">930. 和相同的二元子数组</a></h2><p><strong>Description</strong><br>在由若干 0 和 1  组成的数组 A 中，有多少个和为 S 的非空子数组。<br><strong>Example</strong><br>示例：<br>输入：A = [1,0,1,0,1], S = 2<br>输出：4<br>解释：<br>如下面黑体所示，有 4 个满足题目要求的子数组：<br>[1,0,1,0,1]<br>[1,0,1,0,1]<br>[1,0,1,0,1]<br>[1,0,1,0,1]</p>
<p>提示：<br>A.length &lt;= 30000<br>0 &lt;= S &lt;= A.length<br>A[i] 为 0 或 1<br><strong>Program</strong><br>记录每个前缀和出现的次数，dp思想求解</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubarraysWithSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> S)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        m[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ){</span><br><span class="line">            s += A[i];</span><br><span class="line">            ans += m[s - S];</span><br><span class="line">            m[s] ++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1497-检查数组对是否可以被-k-整除"><a href="#1497-检查数组对是否可以被-k-整除" class="headerlink" title="1497. 检查数组对是否可以被 k 整除"></a><a href="https://leetcode-cn.com/problems/check-if-array-pairs-are-divisible-by-k/" target="_blank" rel="noopener">1497. 检查数组对是否可以被 k 整除</a></h2><p><strong>Description</strong><br>给你一个整数数组 arr 和一个整数 k ，其中数组长度是偶数，值为 n 。<br>现在需要把数组恰好分成 n / 2 对，以使每对数字的和都能够被 k 整除。<br>如果存在这样的分法，请返回 True ；否则，返回 False 。<br><strong>Example</strong><br>示例 1：<br>输入：arr = [1,2,3,4,5,10,6,7,8,9], k = 5<br>输出：true<br>解释：划分后的数字对为 (1,9),(2,8),(3,7),(4,6) 以及 (5,10) 。</p>
<p>示例 2：<br>输入：arr = [1,2,3,4,5,6], k = 7<br>输出：true<br>解释：划分后的数字对为 (1,6),(2,5) 以及 (3,4) 。</p>
<p>示例 3：<br>输入：arr = [1,2,3,4,5,6], k = 10<br>输出：false<br>解释：无法在将数组中的数字分为三对的同时满足每对数字和能够被 10 整除的条件。</p>
<p>示例 4：<br>输入：arr = [-10,10], k = 2<br>输出：true</p>
<p>示例 5：<br>输入：arr = [-1,1,-2,2,-3,3,-4,4], k = 3<br>输出：true</p>
<p>提示：<br>arr.length == n<br>1 &lt;= n &lt;= 10^5<br>n 为偶数<br>-10^9 &lt;= arr[i] &lt;= 10^9<br>1 &lt;= k &lt;= 10^5<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canArrange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; m(k, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) m[(arr[i] % k + k) % k] ++; <span class="comment">//余数可能为负数，化为正数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k / <span class="number">2</span>; i ++ ){</span><br><span class="line">            <span class="keyword">if</span>(m[i] != m[k - i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> m[<span class="number">0</span>] % <span class="number">2</span> == <span class="number">0</span>; <span class="comment">//特例</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1010-总持续时间可被-60-整除的歌曲"><a href="#1010-总持续时间可被-60-整除的歌曲" class="headerlink" title="1010. 总持续时间可被 60 整除的歌曲"></a><a href="https://leetcode-cn.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/" target="_blank" rel="noopener">1010. 总持续时间可被 60 整除的歌曲</a></h2><p><strong>Description</strong><br>在歌曲列表中，第 i 首歌曲的持续时间为 time[i] 秒。<br>返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量。形式上，我们希望索引的数字 i 和 j 满足  i &lt; j 且有 (time[i] + time[j]) % 60 == 0。<br><strong>Example</strong><br>示例 1：<br>输入：[30,20,150,100,40]<br>输出：3<br>解释：这三对的总持续时间可被 60 整数：<br>(time[0] = 30, time[2] = 150): 总持续时间 180<br>(time[1] = 20, time[3] = 100): 总持续时间 120<br>(time[1] = 20, time[4] = 40): 总持续时间 60</p>
<p>示例 2：<br>输入：[60,60,60]<br>输出：3<br>解释：所有三对的总持续时间都是 120，可以被 60 整数。</p>
<p>提示：<br>1 &lt;= time.length &lt;= 60000<br>1 &lt;= time[i] &lt;= 500<br><strong>Program</strong><br>同上一题，记录余数，然后统计。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numPairsDivisibleBy60</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; time)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = time.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; m(<span class="number">60</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:time) m[x % <span class="number">60</span>] ++ ;</span><br><span class="line">        <span class="keyword">int</span> ans = m[<span class="number">0</span>] * (m[<span class="number">0</span>] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">60</span> / <span class="number">2</span>; i ++ ){ <span class="comment">//60 /2 避免重复计算</span></span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">60</span> - i) ans += m[i] * m[<span class="number">60</span> -i];</span><br><span class="line">            <span class="keyword">else</span> ans += m[i] * (m[i] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="523-连续的子数组和"><a href="#523-连续的子数组和" class="headerlink" title="523. 连续的子数组和"></a><a href="https://leetcode-cn.com/problems/continuous-subarray-sum/" target="_blank" rel="noopener">523. 连续的子数组和</a></h2><p><strong>Description</strong><br>给定一个包含 非负数 的数组和一个目标 整数 k ，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，且总和为 k 的倍数，即总和为 n * k ，其中 n 也是一个整数。<br><strong>Example</strong><br>示例 1：<br>输入：[23,2,4,6,7], k = 6<br>输出：True<br>解释：[2,4] 是一个大小为 2 的子数组，并且和为 6。</p>
<p>示例 2：<br>输入：[23,2,6,4,7], k = 6<br>输出：True<br>解释：[23,2,6,4,7]是大小为 5 的子数组，并且和为 42。</p>
<p>说明：<br>数组的长度不会超过 10,000 。<br>你可以认为所有数字总和在 32 位有符号整数范围内。<br><strong>Program</strong><br>哈希表记录每个位置前缀和模k的结果对应的下标；<br>如果两个下标对应的模k结果相同，即[0, i]与[0,j]的前缀和模k结果相同，那么[i + 1, j]的和一定为k的倍数！<br>时间复杂度：$O(n)$<br>空间复杂度：$O(min(n, k))$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        m[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">//初始化边界</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ){</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(k != <span class="number">0</span>){</span><br><span class="line">                sum %= k;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(m.find(sum) != m.end()){</span><br><span class="line">                <span class="keyword">if</span>(i - m[sum] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }<span class="keyword">else</span> m[sum] = i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560. 和为K的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为K的子数组</a></h2><p><strong>Description</strong><br>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。<br><strong>Example</strong><br>示例 1 :<br>输入:nums = [1,1,1], k = 2<br>输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。<br>说明 :</p>
<p>数组的长度为 [1, 20,000]。<br>数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。<br><strong>Program</strong><br>哈希表记录前缀和出现的次数<br>preSum[j] - preSum[i] == k说明[i + 1, j]子数组的和为k！<br>m[preSum]记录同一个前缀和出现的次数；<br>时间复杂度：$O(n)$<br>空间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m; <span class="comment">//键为前缀和，值为前缀和出现的次数</span></span><br><span class="line">        <span class="keyword">int</span> preSum = <span class="number">0</span>;</span><br><span class="line">        m[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//边界</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums){</span><br><span class="line">            preSum += x;</span><br><span class="line">            <span class="keyword">if</span>(m.find(preSum - k) != m.end()) ans += m[preSum - k];</span><br><span class="line">            m[preSum] ++; <span class="comment">//同一个前缀和对应的次数加一</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1></blockquote>
<h2 id="648-单词替换"><a href="#648-单词替换" class="headerlink" title="648. 单词替换"></a>648. 单词替换</h2><p><strong>Description</strong><br>在英语中，我们有一个叫做 词根(root)的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。<br>现在，给定一个由许多词根组成的词典和一个句子。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。<br>你需要输出替换之后的句子。<br><strong>Example</strong><br>示例 1：<br>输入：dictionary = [“cat”,”bat”,”rat”], sentence = “the cattle was rattled by the battery”<br>输出：”the cat was rat by the bat”</p>
<p>示例 2：<br>输入：dictionary = [“a”,”b”,”c”], sentence = “aadsfasf absbs bbab cadsfafs”<br>输出：”a a b c”</p>
<p>示例 3：<br>输入：dictionary = [“a”, “aa”, “aaa”, “aaaa”], sentence = “a aa a aaaa aaa aaa aaa aaaaaa bbb baba ababa”<br>输出：”a a a a a a a a bbb baba a”</p>
<p>示例 4：<br>输入：dictionary = [“catt”,”cat”,”bat”,”rat”], sentence = “the cattle was rattled by the battery”<br>输出：”the cat was rat by the bat”</p>
<p>示例 5：<br>输入：dictionary = [“ac”,”ab”], sentence = “it is abnormal that this solution is accepted”<br>输出：”it is ab that this solution is ac”</p>
<p>提示：<br>1 &lt;= dictionary.length &lt;= 1000<br>1 &lt;= dictionary[i].length &lt;= 100<br>dictionary[i] 仅由小写字母组成。<br>1 &lt;= sentence.length &lt;= 10^6<br>sentence 仅由小写字母和空格组成。<br>sentence 中单词的总量在范围 [1, 1000] 内。<br>sentence 中每个单词的长度在范围 [1, 1000] 内。<br>sentence 中单词之间由一个空格隔开。<br>sentence 没有前导或尾随空格。<br><strong>Program</strong><br><strong>思路</strong><br>（1）根据字典进行前缀字典树构造，注意判断词根结尾；<br>（2）对句子中每个单词进行前缀判断即可，详见代码；<br>时间复杂度：$O(m+n)$，$m、n$分别是字典和句子的字母总数</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>{</span></span><br><span class="line">        <span class="keyword">bool</span> isEnd;</span><br><span class="line">        Trie* next[<span class="number">26</span>];</span><br><span class="line">        Trie(){</span><br><span class="line">            isEnd=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) next[i]=<span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    Trie* root=<span class="keyword">new</span> Trie();</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">findRoot</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">        Trie* p=root;</span><br><span class="line">        <span class="keyword">int</span> n=str.length();</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span>(idx&lt;n){</span><br><span class="line">            <span class="keyword">int</span> pos=str[idx]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next[pos]==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            res+=pos+<span class="string">'a'</span>;</span><br><span class="line">            p=p-&gt;next[pos];</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;isEnd==<span class="literal">true</span>) <span class="keyword">return</span> res;</span><br><span class="line">            idx++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; dictionary, <span class="built_in">string</span> sentence)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=dictionary.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){  <span class="comment">//建立字典树</span></span><br><span class="line">            Trie* p=root;</span><br><span class="line">            <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> len=dictionary[i].length();</span><br><span class="line">            <span class="keyword">while</span>(idx&lt;len){</span><br><span class="line">                <span class="keyword">int</span> pos=dictionary[i][idx]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;next[pos]==<span class="literal">NULL</span>) p-&gt;next[pos]=<span class="keyword">new</span> Trie();</span><br><span class="line">                p=p-&gt;next[pos];</span><br><span class="line">                <span class="keyword">if</span>(idx==len<span class="number">-1</span>) p-&gt;isEnd=<span class="literal">true</span>;</span><br><span class="line">                idx++;</span><br><span class="line">            }    </span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">        n=sentence.length();</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos=sentence.find_first_of(<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">while</span>(pos!=<span class="built_in">string</span>::npos){</span><br><span class="line">            <span class="built_in">string</span> str=sentence.substr(start, pos-start);</span><br><span class="line">            vec.push_back(str);</span><br><span class="line">            start=pos+<span class="number">1</span>;</span><br><span class="line">            pos=sentence.find_first_of(<span class="string">' '</span>, pos+<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        vec.push_back(sentence.substr(start, n-start));</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size();i++){</span><br><span class="line">            <span class="built_in">string</span> str=findRoot(vec[i]);</span><br><span class="line">            <span class="keyword">if</span>(str==<span class="string">""</span>) res+=vec[i];</span><br><span class="line">            <span class="keyword">else</span> res+=str;</span><br><span class="line">            <span class="keyword">if</span>(i!=vec.size()<span class="number">-1</span>) res+=<span class="string">" "</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="676-实现一个魔法字典"><a href="#676-实现一个魔法字典" class="headerlink" title="676. 实现一个魔法字典"></a>676. 实现一个魔法字典</h2><p><strong>Description</strong><br>实现一个带有buildDict, 以及 search方法的魔法字典。<br>对于buildDict方法，你将被给定一串不重复的单词来构建一个字典。<br>对于search方法，你将被给定一个单词，并且判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。<br><strong>Example</strong><br>示例 1:<br>Input: buildDict([“hello”, “leetcode”]), Output: Null<br>Input: search(“hello”), Output: False<br>Input: search(“hhllo”), Output: True<br>Input: search(“hell”), Output: False<br>Input: search(“leetcoded”), Output: False</p>
<p>注意:<br>你可以假设所有输入都是小写字母 a-z。<br>为了便于竞赛，测试所用的数据量很小。你可以在竞赛结束后，考虑更高效的算法。<br>请记住重置MagicDictionary类中声明的类变量，因为静态/类变量会在多个测试用例中保留。 请参阅这里了解更多详情。<br><strong>Program</strong><br><strong>错误思路：直接字典树递归</strong><br>对于无需任何转换就能走通的搜索单词，将不能得到正确答案。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicDictionary</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>{</span></span><br><span class="line">        <span class="keyword">bool</span> isEnd;</span><br><span class="line">        Trie* next[<span class="number">26</span>];</span><br><span class="line">        Trie(){</span><br><span class="line">            isEnd = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) next[i]=<span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    Trie* root;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MagicDictionary() {</span><br><span class="line">        root=<span class="keyword">new</span> Trie();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildDict</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; dictionary)</span> </span>{</span><br><span class="line">        Trie* p=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> str:dictionary){</span><br><span class="line">            <span class="keyword">int</span> n=str.length();</span><br><span class="line">            <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">            p=root;</span><br><span class="line">            <span class="keyword">while</span>(idx&lt;n){</span><br><span class="line">                <span class="keyword">int</span> pos=str[idx]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;next[pos]==<span class="literal">NULL</span>) p-&gt;next[pos]=<span class="keyword">new</span> Trie();</span><br><span class="line">                p=p-&gt;next[pos];</span><br><span class="line">                <span class="keyword">if</span>(idx==n<span class="number">-1</span>) p-&gt;isEnd=<span class="literal">true</span>;</span><br><span class="line">                idx++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> searchWord)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> helper(root, searchWord, <span class="literal">true</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(Trie* p, <span class="built_in">string</span> searchWord, <span class="keyword">bool</span> isFirst)</span></span>{ <span class="comment">//错误思路，这里是更改0或1次后能在字典匹配，与题目要求的有且只有更改1次不符</span></span><br><span class="line">        <span class="keyword">int</span> n=searchWord.length();</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx&lt;n&amp;&amp;p!=<span class="literal">NULL</span>){</span><br><span class="line">            <span class="keyword">int</span> pos=searchWord[idx]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next[pos]==<span class="literal">NULL</span>){</span><br><span class="line">                <span class="keyword">if</span>(isFirst){</span><br><span class="line">                    <span class="keyword">bool</span> isPass=<span class="literal">false</span>;</span><br><span class="line">                    isFirst=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++){</span><br><span class="line">                        <span class="keyword">if</span>(i!=pos&amp;&amp;p-&gt;next[i]!=<span class="literal">NULL</span>){</span><br><span class="line">                            <span class="built_in">string</span> ss=searchWord.substr(idx+<span class="number">1</span>);</span><br><span class="line">                            isPass=helper(p-&gt;next[i], ss, isFirst);</span><br><span class="line">                            <span class="keyword">if</span>(isPass) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//已替换过一次</span></span><br><span class="line">            }</span><br><span class="line">            p=p-&gt;next[pos];</span><br><span class="line">            <span class="keyword">if</span>(idx==n<span class="number">-1</span>&amp;&amp;p-&gt;isEnd==<span class="literal">true</span>&amp;&amp;!isFirst) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//已匹配</span></span><br><span class="line">            idx++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MagicDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MagicDictionary* obj = new MagicDictionary();</span></span><br><span class="line"><span class="comment"> * obj-&gt;buildDict(dictionary);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(searchWord);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>正确思路</strong><br>对于搜索单词的每个字母进行递归深搜</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicDictionary</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>{</span></span><br><span class="line">        <span class="keyword">bool</span> isEnd;</span><br><span class="line">        Trie* next[<span class="number">26</span>];</span><br><span class="line">        Trie(){</span><br><span class="line">            isEnd = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) next[i]=<span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    Trie* root;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MagicDictionary() {</span><br><span class="line">        root=<span class="keyword">new</span> Trie();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildDict</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; dictionary)</span> </span>{</span><br><span class="line">        Trie* p=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> str:dictionary){</span><br><span class="line">            <span class="keyword">int</span> n=str.length();</span><br><span class="line">            <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">            p=root;</span><br><span class="line">            <span class="keyword">while</span>(idx&lt;n){</span><br><span class="line">                <span class="keyword">int</span> pos=str[idx]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;next[pos]==<span class="literal">NULL</span>) p-&gt;next[pos]=<span class="keyword">new</span> Trie();</span><br><span class="line">                p=p-&gt;next[pos];</span><br><span class="line">                <span class="keyword">if</span>(idx==n<span class="number">-1</span>) p-&gt;isEnd=<span class="literal">true</span>;</span><br><span class="line">                idx++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> searchWord)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> helper(root, searchWord, <span class="number">0</span>, searchWord.length(), <span class="literal">false</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(Trie* p, <span class="built_in">string</span>&amp; searchWord, <span class="keyword">int</span> i, <span class="keyword">int</span> n, <span class="keyword">bool</span> isChanged)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(i==n){</span><br><span class="line">            <span class="keyword">return</span> isChanged&amp;&amp;p-&gt;isEnd;<span class="comment">//已搜索完单词，确定是否改变以及当前是否为字典树单词结尾</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> pos=searchWord[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(isChanged){ <span class="comment">//已更改</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next[pos]==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> helper(p-&gt;next[pos], searchWord, i+<span class="number">1</span>, n, isChanged);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//未更改！</span></span><br><span class="line">        <span class="keyword">bool</span> isPass=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++){</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next[j]!=<span class="literal">NULL</span>){</span><br><span class="line">                isPass |= helper(p-&gt;next[j], searchWord, i+<span class="number">1</span>, n, pos!=j);</span><br><span class="line">                <span class="keyword">if</span>(isPass) <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> isPass;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MagicDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MagicDictionary* obj = new MagicDictionary();</span></span><br><span class="line"><span class="comment"> * obj-&gt;buildDict(dictionary);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(searchWord);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="720-词典中最长的单词"><a href="#720-词典中最长的单词" class="headerlink" title="720. 词典中最长的单词"></a>720. 词典中最长的单词</h2><p><strong>Description</strong><br>给出一个字符串数组words组成的一本英语词典。从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。<br>若无答案，则返回空字符串。<br><strong>Example</strong><br>示例 1：<br>输入：<br>words = [“w”,”wo”,”wor”,”worl”, “world”]<br>输出：”world”<br>解释：<br>单词”world”可由”w”, “wo”, “wor”, 和 “worl”添加一个字母组成。</p>
<p>示例 2：<br>输入：<br>words = [“a”, “banana”, “app”, “appl”, “ap”, “apply”, “apple”]<br>输出：”apple”<br>解释：<br>“apply”和”apple”都能由词典中的单词组成。但是”apple”的字典序小于”apply”。</p>
<p>提示：<br>所有输入的字符串都只包含小写字母。<br>words数组长度范围为[1,1000]。<br>words[i]的长度范围为[1,30]。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>{</span></span><br><span class="line">        <span class="keyword">bool</span> isEnd;</span><br><span class="line">        Trie* next[<span class="number">26</span>];</span><br><span class="line">        Trie(){</span><br><span class="line">            isEnd=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) next[i]=<span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    Trie* root=<span class="keyword">new</span> Trie();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> str:words){</span><br><span class="line">            Trie* cur=root;</span><br><span class="line">            <span class="keyword">int</span> n=str.length();</span><br><span class="line">            <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(idx&lt;n){</span><br><span class="line">                <span class="keyword">int</span> pos=str[idx]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;next[pos]==<span class="literal">NULL</span>) cur-&gt;next[pos]=<span class="keyword">new</span> Trie();</span><br><span class="line">                cur=cur-&gt;next[pos];</span><br><span class="line">                <span class="keyword">if</span>(idx==n<span class="number">-1</span>) cur-&gt;isEnd=<span class="literal">true</span>;</span><br><span class="line">                idx++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(Trie* root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;res.length()){</span><br><span class="line">            res=str;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++){</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;next[i]!=<span class="literal">NULL</span>&amp;&amp;root-&gt;next[i]-&gt;isEnd){</span><br><span class="line">                str+=i+<span class="string">'a'</span>;</span><br><span class="line">                search(root-&gt;next[i]);</span><br><span class="line">                str.erase(str.length()<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestWord</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>{</span><br><span class="line">        buildTree(words);</span><br><span class="line">        search(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="421-数组中两个数的最大异或值"><a href="#421-数组中两个数的最大异或值" class="headerlink" title="421. 数组中两个数的最大异或值"></a>421. 数组中两个数的最大异或值</h2><p><strong>Description</strong><br>给定一个非空数组，数组中元素为 a0, a1, a2, … , an-1，其中 0 ≤ ai &lt; 231 。<br>找到 ai 和aj 最大的异或 (XOR) 运算结果，其中0 ≤ i,  j &lt; n 。<br>你能在O(n)的时间解决这个问题吗？<br><strong>Example</strong><br>示例:<br>输入: [3, 10, 5, 25, 2, 8]<br>输出: 28<br>解释: 最大的结果是 5 ^ 25 = 28.<br><strong>Program</strong><br>参考大佬们的题解。<br><strong>异或性质</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mask=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            mask=mask|(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x:nums) st.insert(x&amp;mask); <span class="comment">//每个数的前缀</span></span><br><span class="line">            <span class="keyword">int</span> tmp= res | (<span class="number">1</span>&lt;&lt;i); <span class="comment">//前i-1位已经确定，现在假设第i位为1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> prefix:st){</span><br><span class="line">                <span class="keyword">if</span>(st.find(prefix^tmp)!=st.end()){ <span class="comment">//异或的性质</span></span><br><span class="line">                    res=tmp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>前缀字典树</strong><br>（1）对于数组的每个元素x，进行字典树构造；<br>（1）对于数组的每个元素x的每个高位bit，找其互补位，如果bit为1，找0，如果不存在找1；</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>{</span></span><br><span class="line">        Trie *zero, *one;</span><br><span class="line">        Trie(){</span><br><span class="line">            zero=one=<span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    Trie* root;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums){</span><br><span class="line">            Trie* cur=root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">                <span class="keyword">int</span> bit= ((x&gt;&gt;i) &amp; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(bit==<span class="number">1</span>){</span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;one==<span class="literal">NULL</span>) cur-&gt;one=<span class="keyword">new</span> Trie();</span><br><span class="line">                    cur=cur-&gt;one;</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;zero==<span class="literal">NULL</span>) cur-&gt;zero=<span class="keyword">new</span> Trie();</span><br><span class="line">                    cur=cur-&gt;zero;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        root=<span class="keyword">new</span> Trie();</span><br><span class="line">        buildTree(nums);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums){</span><br><span class="line">            <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">            Trie* cur=root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--){ <span class="comment">//对应找互补位</span></span><br><span class="line">                <span class="keyword">int</span> bit=((x&gt;&gt;i) &amp; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(bit==<span class="number">1</span>){</span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;zero!=<span class="literal">NULL</span>){</span><br><span class="line">                        cur=cur-&gt;zero;</span><br><span class="line">                        tmp+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">                    }<span class="keyword">else</span> cur=cur-&gt;one;</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;one!=<span class="literal">NULL</span>){</span><br><span class="line">                        cur=cur-&gt;one;</span><br><span class="line">                        tmp+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">                    }<span class="keyword">else</span> cur=cur-&gt;zero;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            ans=max(ans, tmp);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1707-与数组中元素的最大异或值"><a href="#1707-与数组中元素的最大异或值" class="headerlink" title="1707. 与数组中元素的最大异或值"></a>1707. 与数组中元素的最大异或值</h2><p><strong>Description</strong><br>给你一个由非负整数组成的数组 nums 。另有一个查询数组 queries ，其中 queries[i] = [xi, mi] 。<br>第 i 个查询的答案是 xi 和任何 nums 数组中不超过 mi 的元素按位异或（XOR）得到的最大值。换句话说，答案是 max(nums[j] XOR xi) ，其中所有 j 均满足 nums[j] &lt;= mi 。如果 nums 中的所有元素都大于 mi，最终答案就是 -1 。<br>返回一个整数数组 answer 作为查询的答案，其中 answer.length == queries.length 且 answer[i] 是第 i 个查询的答案。<br><strong>Example</strong><br>示例 1：<br>输入：nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]<br>输出：[3,3,7]<br>解释：</p>
<p>1) 0 和 1 是仅有的两个不超过 1 的整数。0 XOR 3 = 3 而 1 XOR 3 = 2 。二者中的更大值是 3 。<br>2) 1 XOR 2 = 3.<br>3) 5 XOR 2 = 7.</p>
<p>示例 2：<br>输入：nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]<br>输出：[15,-1,5]</p>
<p>提示：<br>1 &lt;= nums.length, queries.length &lt;= 10^5<br>queries[i].length == 2<br>0 &lt;= nums[j], xi, mi &lt;= 10^9<br><strong>Program</strong><br><strong>思路</strong><br>0-1字典树优化，取互补操作</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>{</span></span><br><span class="line">        <span class="keyword">int</span> minValue;</span><br><span class="line">        Trie* children[<span class="number">2</span>];</span><br><span class="line">        Trie(){</span><br><span class="line">            minValue=INT_MAX;</span><br><span class="line">            children[<span class="number">0</span>]=children[<span class="number">1</span>]=<span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    Trie* root=<span class="keyword">new</span> Trie();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maximizeXor(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums){</span><br><span class="line">            Trie* cur=root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">                <span class="keyword">int</span> bit=((x&gt;&gt;i) &amp; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> idx=(bit==<span class="number">0</span>?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;children[idx]==<span class="literal">NULL</span>) cur-&gt;children[idx]=<span class="keyword">new</span> Trie();</span><br><span class="line">                cur=cur-&gt;children[idx];</span><br><span class="line">                cur-&gt;minValue=min(cur-&gt;minValue, x);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v:queries){</span><br><span class="line">            <span class="keyword">int</span> x=v[<span class="number">0</span>], mi=v[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">            Trie* cur=root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">                <span class="keyword">int</span> bit=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> idx=(bit==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;children[idx]!=<span class="literal">NULL</span>&amp;&amp;cur-&gt;children[idx]-&gt;minValue&lt;=mi){</span><br><span class="line">                    cur=cur-&gt;children[idx];</span><br><span class="line">                    ans^=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;children[<span class="number">1</span>-idx]==<span class="literal">NULL</span>||cur-&gt;children[<span class="number">1</span>-idx]-&gt;minValue&gt;mi){</span><br><span class="line">                    res.emplace_back(<span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">//无解</span></span><br><span class="line">                }<span class="keyword">else</span> cur=cur-&gt;children[<span class="number">1</span>-idx];</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) res.emplace_back(ans);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1></blockquote>
<h2 id="684-冗余连接"><a href="#684-冗余连接" class="headerlink" title="684. 冗余连接"></a>684. 冗余连接</h2><p><strong>Description</strong><br>在本问题中, 树指的是一个连通且无环的无向图。<br>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。<br>结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。<br>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。<br><strong>Example</strong><br>示例 1：<br>输入: [[1,2], [1,3], [2,3]]<br>输出: [2,3]<br>解释: 给定的无向图为:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2 - 3</span><br></pre></td></tr></tbody></table></figure>
<p>示例 2：<br>输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]<br>输出: [1,4]<br>解释: 给定的无向图为:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 - 1 - 2</span><br><span class="line">    |   |</span><br><span class="line">    4 - 3</span><br></pre></td></tr></tbody></table></figure>
<p>注意:<br>输入的二维数组大小在 3 到 1000。<br>二维数组中的整数在1到N之间，其中N是输入数组的大小。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father;</span><br><span class="line">    <span class="keyword">int</span> nCount;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(x!=father[x]){</span><br><span class="line">            father[x]=findFather(father[x]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> father[x];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">unionSet</span><span class="params">(<span class="keyword">int</span> x ,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> fa=findFather(x);</span><br><span class="line">        <span class="keyword">int</span> fb=findFather(y);</span><br><span class="line">        <span class="keyword">if</span>(fa!=fb){</span><br><span class="line">            father[fa]=fb;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findRedundantConnection(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(s.find(edges[i][<span class="number">0</span>])==s.end()) nCount++;</span><br><span class="line">            <span class="keyword">if</span>(s.find(edges[i][<span class="number">1</span>])==s.end()) nCount++;</span><br><span class="line">        }</span><br><span class="line">        father.resize(nCount+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nCount;i++) father[i]=i;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(unionSet(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>])){</span><br><span class="line">                result.push_back(edges[i][<span class="number">0</span>]);</span><br><span class="line">                result.push_back(edges[i][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="685-冗余连接-II"><a href="#685-冗余连接-II" class="headerlink" title="685. 冗余连接 II"></a>685. 冗余连接 II</h2><p><strong>Description</strong><br>在本问题中，有根树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。<br>输入一个有向图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。<br>结果图是一个以边组成的二维数组。 每一个边 的元素是一对 [u, v]，用以表示有向图中连接顶点 u 和顶点 v 的边，其中 u 是 v 的一个父节点。<br>返回一条能删除的边，使得剩下的图是有N个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。<br><strong>Example</strong><br>示例 1:<br>输入: [[1,2], [1,3], [2,3]]<br>输出: [2,3]<br>解释: 给定的有向图如下:<br>  1<br> / <br>v   v<br>2–&gt;3</p>
<p>示例 2:<br>输入: [[1,2], [2,3], [3,4], [4,1], [1,5]]<br>输出: [4,1]<br>解释: 给定的有向图如下:<br>5 &lt;- 1 -&gt; 2<br>     ^    |<br>     |    v<br>     4 &lt;- 3<br>注意:<br>二维数组大小的在3到1000范围内。<br>二维数组中的每个整数在1到N之间，其中 N 是二维数组的大小。<br><strong>Program</strong><br><strong>并查集</strong><br>（1）有根树性质：</p>
<ul>
<li>无有向环</li>
<li>无入度为2的节点，因为题目是有根树附加另一条边，这条边使得有根树不成立，所以入度最多为2<br>（2）首先统计入度，判断是否入度为2；<br>（3）如果入度为2，那么可以发现两条边(u1,v),(u2,v)使得v的入度为2，那么依次删掉这两条边，判断是否构成有根树即可；注意逆序遍历边<br>（4）如果没有入度为2，那么说明存在有向环，那么<strong>只要正序构建并查集</strong>，判断是否构成有向环的边即可，找到第一个构成环的边就是答案；<br>时间复杂度：$O(n)$<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line">        father.resize(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) father[i]=i;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(father[x]!=x){</span><br><span class="line">            father[x]=findFather(father[x]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> father[x];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionSet</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{ <span class="comment">//x为父节点，y为子节点</span></span><br><span class="line">        <span class="keyword">int</span> fa=findFather(x);</span><br><span class="line">        <span class="keyword">int</span> fb=findFather(y);</span><br><span class="line">        <span class="keyword">if</span>(fa!=fb){</span><br><span class="line">            father[fb]=fa;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> fa=findFather(u);</span><br><span class="line">        <span class="keyword">int</span> fb=findFather(v);</span><br><span class="line">        <span class="keyword">return</span> fa==fb;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//在有向图里找到删除的那条边，使其变成树</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getRemoveEdge(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges){</span><br><span class="line">        init(); <span class="comment">//初始化并查集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){ <span class="comment">//遍历所有边</span></span><br><span class="line">            <span class="keyword">if</span>(isSame(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>])){ <span class="comment">//构成有向环</span></span><br><span class="line">                <span class="keyword">return</span> edges[i];</span><br><span class="line">            }</span><br><span class="line">            unionSet(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> {}; <span class="comment">//无环</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isTreeAfterRemoveEdge</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="keyword">int</span> deletEdge)</span></span>{</span><br><span class="line">        init(); <span class="comment">//初始化并查集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i==deletEdge) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(isSame(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>])) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//构成有向环</span></span><br><span class="line">            unionSet(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findRedundantDirectedConnection(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges) {</span><br><span class="line">        n=edges.size();</span><br><span class="line">        father.resize(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inDegree(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            inDegree[edges[i][<span class="number">1</span>]]++;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">if</span>(inDegree[edges[i][<span class="number">1</span>]]==<span class="number">2</span>) vec.push_back(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//如果有入度为2的节点，那么一定是两条边中的一个</span></span><br><span class="line">        <span class="keyword">if</span>(vec.size()&gt;<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">if</span>(isTreeAfterRemoveEdge(edges, vec[<span class="number">0</span>])) <span class="keyword">return</span> edges[vec[<span class="number">0</span>]];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> edges[vec[<span class="number">1</span>]];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> getRemoveEdge(edges);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1></blockquote>
</li>
</ul>
<h2 id="933-最近的请求次数"><a href="#933-最近的请求次数" class="headerlink" title="933. 最近的请求次数"></a>933. 最近的请求次数</h2><p><strong>Description</strong><br>写一个 RecentCounter 类来计算最近的请求。<br>它只有一个方法：ping(int t)，其中 t 代表以毫秒为单位的某个时间。<br>返回从 3000 毫秒前到现在的 ping 数。<br>任何处于 [t - 3000, t] 时间范围之内的 ping 都将会被计算在内，包括当前（指 t 时刻）的 ping。<br>保证每次对 ping 的调用都使用比之前更大的 t 值。<br><strong>Example</strong><br>示例：<br>输入：inputs = [“RecentCounter”,”ping”,”ping”,”ping”,”ping”], inputs = [[],[1],[100],[3001],[3002]]<br>输出：[null,1,2,3,3]</p>
<p>提示：<br>每个测试用例最多调用 10000 次 ping。<br>每个测试用例会使用严格递增的 t 值来调用 ping。<br>每次调用 ping 都有 1 &lt;= t &lt;= 10^9。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecentCounter</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">    RecentCounter() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ping</span><span class="params">(<span class="keyword">int</span> t)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span>(!dq.empty()&amp;&amp;t<span class="number">-3000</span>&gt;dq[<span class="number">0</span>]) dq.pop_front();</span><br><span class="line">        dq.push_back(t);</span><br><span class="line">        <span class="keyword">return</span> dq.size();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RecentCounter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RecentCounter* obj = new RecentCounter();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;ping(t);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<h1 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h1></blockquote>
<h2 id="691-贴纸拼词"><a href="#691-贴纸拼词" class="headerlink" title="691. 贴纸拼词"></a>691. 贴纸拼词</h2><p><strong>Description</strong><br>我们给出了 N 种不同类型的贴纸。每个贴纸上都有一个小写的英文单词。<br>你希望从自己的贴纸集合中裁剪单个字母并重新排列它们，从而拼写出给定的目标字符串 target。<br>如果你愿意的话，你可以不止一次地使用每一张贴纸，而且每一张贴纸的数量都是无限的。<br>拼出目标 target 所需的最小贴纸数量是多少？如果任务不可能，则返回 -1。<br><strong>Example</strong><br>示例 1：<br>输入：<br>[“with”, “example”, “science”], “thehat”<br>输出：<br>3<br>解释：<br>我们可以使用 2 个 “with” 贴纸，和 1 个 “example” 贴纸。<br>把贴纸上的字母剪下来并重新排列后，就可以形成目标 “thehat“ 了。<br>此外，这是形成目标字符串所需的最小贴纸数量。</p>
<p>示例 2：<br>输入：<br>[“notice”, “possible”], “basicbasic”<br>输出：<br>-1<br>解释：<br>我们不能通过剪切给定贴纸的字母来形成目标“basicbasic”。</p>
<p>提示：<br>stickers 长度范围是 [1, 50]。<br>stickers 由小写英文单词组成（不带撇号）。<br>target 的长度在 [1, 15] 范围内，由小写字母组成。<br>在所有的测试案例中，所有的单词都是从 1000 个最常见的美国英语单词中随机选取的，目标是两个随机单词的串联。<br>时间限制可能比平时更具挑战性。预计 50 个贴纸的测试案例平均可在35ms内解决。<br><strong>Program</strong><br><strong>BFS+状态压缩</strong><br>（1）step[i]表示i(二进制1的位置表示与target的对应匹配)状态下的最少贴纸数量；<br>（2）BFS从0状态（无一个匹配）搜索，肯定是最短，即step[i]更新了一次，下次搜索到就不用更新了，之后的更新肯定不是最优；<br>（3）从长的单词开始搜索；</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minStickers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; stickers, <span class="built_in">string</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> has[<span class="number">26</span>]={<span class="number">0</span>}, lmask[<span class="number">26</span>]={<span class="number">0</span>}, res=(<span class="number">1</span>&lt;&lt;target.size())<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        sort(target.begin(), target.end()); <span class="comment">//排序，使得相同字符相邻，方便后面BFS</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;target.size();i++) lmask[target[i]-<span class="string">'a'</span>] |= (<span class="number">1</span>&lt;&lt;i); <span class="comment">//记录target的字母以及出现的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span>&amp; s:stickers){  <span class="comment">//记录tickers中出现的字母</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> ch:s){</span><br><span class="line">                has[ch-<span class="string">'a'</span>] |= <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;<span class="number">26</span>;l++){</span><br><span class="line">            <span class="keyword">if</span>(!has[l]&amp;&amp;lmask[l]) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//无解</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按照单词长度排序，较长的单词匹配的概率大</span></span><br><span class="line">        sort(stickers.begin(), stickers.end(), [](<span class="keyword">const</span> <span class="built_in">string</span>&amp; a, <span class="keyword">const</span> <span class="built_in">string</span>&amp; b){</span><br><span class="line">            <span class="keyword">return</span> a.length()&gt;b.length();</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录每个单词匹配了target的哪些字母</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; smask[stickers.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;stickers.size();i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> ch:stickers[i]){</span><br><span class="line">                <span class="keyword">if</span>(lmask[ch-<span class="string">'a'</span>]){</span><br><span class="line">                    smask[i].push_back(lmask[ch-<span class="string">'a'</span>]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态压缩DP</span></span><br><span class="line">        <span class="keyword">int</span> step[<span class="number">1</span>&lt;&lt;target.size()];</span><br><span class="line">        <span class="built_in">memset</span>(step, <span class="number">-1</span>, <span class="keyword">sizeof</span>(step));</span><br><span class="line">        step[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//BFS</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            <span class="keyword">int</span> cur=q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;stickers.size();i++){</span><br><span class="line">                <span class="keyword">int</span> next=cur;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> m:smask[i]){</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> bit=m&amp;(-m);bit&amp;m;bit&lt;&lt;=<span class="number">1</span>){</span><br><span class="line">                        <span class="keyword">if</span>(!(next&amp;bit)){  <span class="comment">//匹配m上的非零位，next也要非零，才能多次匹配</span></span><br><span class="line">                            next|=bit;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(next==res) <span class="keyword">return</span> step[cur]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(step[next]==<span class="number">-1</span>) step[next]=step[cur]+<span class="number">1</span>, q.push(next); <span class="comment">//条件判断step[next]==-1，表示未计算，如果已计算，那么其比step[cur]+1更小！</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<h1 id="欧拉回路"><a href="#欧拉回路" class="headerlink" title="欧拉回路"></a>欧拉回路</h1></blockquote>
<h2 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332. 重新安排行程"></a>332. 重新安排行程</h2><p><strong>Description</strong><br>给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 出发。<br>说明:</p>
<ul>
<li>如果存在多种有效的行程，你可以按字符自然排序返回最小的行程组合。例如，行程 [“JFK”, “LGA”] 与 [“JFK”, “LGB”] 相比就更小，排序更靠前</li>
<li>所有的机场都用三个大写字母表示（机场代码）。</li>
<li>假定所有机票至少存在一种合理的行程。</li>
</ul>
<p><strong>Example</strong><br>示例 1:<br>输入: [[“MUC”, “LHR”], [“JFK”, “MUC”], [“SFO”, “SJC”], [“LHR”, “SFO”]]<br>输出: [“JFK”, “MUC”, “LHR”, “SFO”, “SJC”]</p>
<p>示例 2:<br>输入: [[“JFK”,”SFO”],[“JFK”,”ATL”],[“SFO”,”ATL”],[“ATL”,”JFK”],[“ATL”,”SFO”]]<br>输出: [“JFK”,”ATL”,”JFK”,”SFO”,”ATL”,”SFO”]<br>解释: 另一种有效的行程是 [“JFK”,”SFO”,”ATL”,”JFK”,”ATL”,”SFO”]。但是它自然排序更大更靠后。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, priority_queue&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;, greater&lt;<span class="built_in">string</span>&gt;&gt;&gt; Adj;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; stk;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; cur)</span></span>{</span><br><span class="line">        <span class="keyword">while</span>(Adj[cur].size()&gt;<span class="number">0</span>){</span><br><span class="line">            <span class="built_in">string</span> str=Adj[cur].top();</span><br><span class="line">            Adj[cur].pop();</span><br><span class="line">            backtracking(str);</span><br><span class="line">        }</span><br><span class="line">        stk.push_back(cur);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findItinerary(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; tickets) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; vec:tickets){</span><br><span class="line">            Adj[vec[<span class="number">0</span>]].push(vec[<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        backtracking(<span class="string">"JFK"</span>);</span><br><span class="line">        reverse(stk.begin(), stk.end());</span><br><span class="line">        <span class="keyword">return</span> stk;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1></blockquote>
<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h2><p><strong>Description</strong><br>给出一个区间的集合，请合并所有重叠的区间。<br><strong>Example</strong><br>示例 1:<br>输入: intervals = [[1,3],[2,6],[8,10],[15,18]]<br>输出: [[1,6],[8,10],[15,18]]<br>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p>
<p>示例 2:<br>输入: intervals = [[1,4],[4,5]]<br>输出: [[1,5]]<br>解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。<br>注意：输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。</p>
<p>提示：<br>intervals[i][0] &lt;= intervals[i][1]<br><strong>program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; merge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) {</span><br><span class="line">        <span class="comment">//先按起点排序，否则按终点排序，升序！</span></span><br><span class="line">        sort(intervals.begin(), intervals.end(), [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b){</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>]&lt;b[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">        });</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre;</span><br><span class="line">        pre.push_back(<span class="number">-1</span>);</span><br><span class="line">        pre.push_back(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> n=intervals.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(pre[<span class="number">1</span>]&lt;intervals[i][<span class="number">0</span>]){</span><br><span class="line">                pre[<span class="number">0</span>]=intervals[i][<span class="number">0</span>];</span><br><span class="line">                pre[<span class="number">1</span>]=intervals[i][<span class="number">1</span>];</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                pre[<span class="number">0</span>]=min(pre[<span class="number">0</span>], intervals[i][<span class="number">0</span>]);</span><br><span class="line">                pre[<span class="number">1</span>]=max(pre[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">                res.pop_back();</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">            res.push_back(pre);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="57-插入区间"><a href="#57-插入区间" class="headerlink" title="57. 插入区间"></a>57. 插入区间</h2><p><strong>Description</strong><br>给出一个无重叠的 ，按照区间起始端点排序的区间列表。<br>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。<br><strong>Example</strong><br>示例 1：<br>输入：intervals = [[1,3],[6,9]], newInterval = [2,5]<br>输出：[[1,5],[6,9]]</p>
<p>示例 2：<br>输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]<br>输出：[[1,2],[3,10],[12,16]]<br>解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。<br>注意：输入类型已在 2019 年 4 月 15 日更改。请重置为默认代码定义以获取新的方法签名。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; insert(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; newInterval) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n=intervals.size();</span><br><span class="line">        <span class="keyword">bool</span> isPass=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(isPass) {res.push_back(intervals[i]);<span class="keyword">continue</span>;}</span><br><span class="line">            <span class="keyword">if</span>(newInterval[<span class="number">0</span>]&gt;intervals[i][<span class="number">1</span>]) res.push_back(intervals[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(newInterval[<span class="number">1</span>]&lt;intervals[i][<span class="number">0</span>]) {</span><br><span class="line">                res.push_back(newInterval);</span><br><span class="line">                isPass=<span class="literal">true</span>;</span><br><span class="line">                res.push_back(intervals[i]);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                newInterval[<span class="number">0</span>]=min(newInterval[<span class="number">0</span>], intervals[i][<span class="number">0</span>]);</span><br><span class="line">                newInterval[<span class="number">1</span>]=max(newInterval[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(!isPass){</span><br><span class="line">            res.push_back(newInterval);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a>75. 颜色分类</h2><p><strong>Description</strong><br>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br>注意:<br>不能使用代码库中的排序函数来解决这道题。<br><strong>Example</strong><br>示例:<br>输入: [2,0,2,1,1,0]<br>输出: [0,0,1,1,2,2]<br>进阶：<br>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。<br>你能想出一个仅使用常数空间的一趟扫描算法吗？<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> temp=nums[left];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]&gt;=temp) right--;</span><br><span class="line">            swap(nums[left], nums[right]);</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]&lt;=temp) left++;</span><br><span class="line">            swap(nums[left], nums[right]);</span><br><span class="line">        }</span><br><span class="line">        nums[left]=temp;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">int</span> pos=partition(nums, left, right);</span><br><span class="line">            quickSort(nums, left, pos<span class="number">-1</span>);</span><br><span class="line">            quickSort(nums, pos+<span class="number">1</span>, right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="147-对链表进行插入排序"><a href="#147-对链表进行插入排序" class="headerlink" title="147. 对链表进行插入排序"></a>147. 对链表进行插入排序</h2><p><strong>Description</strong><br>对链表进行插入排序。<br><img src="/assets/img/algorithm/Insertion-sort-example-300px.gif" alt="image"><br>插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。<br>每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。</p>
<p>插入排序算法：<br>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。<br>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。<br>重复直到所有输入数据插入完为止。<br><strong>Example</strong><br>示例 1：<br>输入: 4-&gt;2-&gt;1-&gt;3<br>输出: 1-&gt;2-&gt;3-&gt;4</p>
<p>示例 2：<br>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0<br>输出: -1-&gt;0-&gt;3-&gt;4-&gt;5<br><strong>Progam</strong></p>
<ul>
<li>维护一个标兵节点，便于访问链表头，因为在插入排序的过程中，表头可能变化；</li>
<li>维护一个已排序链表尾节点，模拟数组插入排序，这样方便对链表待排序节点前后位置进行连接！<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* tHead=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        tHead-&gt;next=head;</span><br><span class="line">        ListNode* tail=head;<span class="comment">// 已排序的最后一个节点</span></span><br><span class="line">        ListNode* now=head-&gt;next; <span class="comment">//当前待排序的节点</span></span><br><span class="line">        <span class="keyword">while</span>(now!=<span class="literal">NULL</span>){</span><br><span class="line">            ListNode* node=tHead;</span><br><span class="line">            <span class="keyword">while</span>(node-&gt;next!=<span class="literal">NULL</span>&amp;&amp;node-&gt;next-&gt;val&lt;now-&gt;val) node=node-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node==tail){</span><br><span class="line">                tail=now;</span><br><span class="line">                now=now-&gt;next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            tail-&gt;next=now-&gt;next;</span><br><span class="line">            now-&gt;next=node-&gt;next;</span><br><span class="line">            node-&gt;next=now;</span><br><span class="line">            now=tail-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> tHead-&gt;next;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a>148. 排序链表</h2></li>
</ul>
<p><strong>Description</strong><br>在 $O(n\log{n})$ 时间复杂度和常数级空间复杂度下，对链表进行排序。<br><strong>Example</strong><br>示例 1:<br>输入: 4-&gt;2-&gt;1-&gt;3<br>输出: 1-&gt;2-&gt;3-&gt;4</p>
<p>示例 2:<br>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0<br>输出: -1-&gt;0-&gt;3-&gt;4-&gt;5<br><strong>Program</strong><br><strong>思路</strong><br>（1）总体为数组版的非递归二路归并；<br>（2）每次选择两个长度最多为为step(最多：有的时候链表末尾元素不足)的链表进行合并；<br>（3）cut(p, n)：表示从p开始切除n个元素的链表，并返回后面的头结点，注意切出的链表尾部应当为NULL，注意处理！；merge则表示合并两个链表<br>时间复杂度：$O(n\log{n})$<br>空间复杂度：$O(1)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">        ListNode* dummyHead=<span class="keyword">new</span> ListNode(<span class="number">-1</span>); <span class="comment">//伪头结点</span></span><br><span class="line">        dummyHead-&gt;next=head;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>){</span><br><span class="line">            n++;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> step=<span class="number">1</span>;step&lt;=n;step*=<span class="number">2</span>){ <span class="comment">//非递归二路归并链表实现</span></span><br><span class="line">            ListNode* cur=dummyHead-&gt;next;</span><br><span class="line">            ListNode* tail=dummyHead;<span class="comment">//当前完成排序的尾节点</span></span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>){</span><br><span class="line">                <span class="comment">//剪开两部分</span></span><br><span class="line">                ListNode* leftTail=cut(cur, step);</span><br><span class="line">                ListNode* rightTail=cut(leftTail, step);</span><br><span class="line">                <span class="comment">//两部分的头结点</span></span><br><span class="line">                ListNode* leftHead=cur;</span><br><span class="line">                ListNode* rightHead=leftTail;</span><br><span class="line">                pair&lt;ListNode*, ListNode*&gt; pir=merge(leftHead, rightHead);</span><br><span class="line">                <span class="comment">//拼接已经排好序的一段</span></span><br><span class="line">                tail-&gt;next=pir.first;</span><br><span class="line">                tail=pir.second;</span><br><span class="line">                cur=rightTail;<span class="comment">//下一次迭代</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        head=dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyHead; <span class="comment">//避免内存泄漏</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">ListNode* <span class="title">cut</span><span class="params">(ListNode* cur, <span class="keyword">int</span> n)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        ListNode* pre=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>&amp;&amp;ans&lt;n){</span><br><span class="line">            ans++;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        pre-&gt;next=<span class="literal">NULL</span>; <span class="comment">//断开！</span></span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    }</span><br><span class="line">    pair&lt;ListNode*, ListNode*&gt; merge(ListNode* left, ListNode* right){</span><br><span class="line">        ListNode* dummyHead=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* p=dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(left!=<span class="literal">NULL</span>&amp;&amp;right!=<span class="literal">NULL</span>){</span><br><span class="line">            <span class="keyword">if</span>(left-&gt;val&lt;right-&gt;val) {p-&gt;next=left; left=left-&gt;next;}</span><br><span class="line">            <span class="keyword">else</span> {p-&gt;next=right; right=right-&gt;next;}</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(left!=<span class="literal">NULL</span>){</span><br><span class="line">            p-&gt;next=left;</span><br><span class="line">            left=left-&gt;next;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(right!=<span class="literal">NULL</span>){</span><br><span class="line">            p-&gt;next=right;</span><br><span class="line">            right=right-&gt;next;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        ListNode* head=dummyHead-&gt;next;<span class="comment">//避免内存泄漏</span></span><br><span class="line">        <span class="keyword">return</span> {head, p};</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179. 最大数"></a>179. 最大数</h2><p><strong>Description</strong><br>给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。<br><strong>Example</strong><br>示例 1:<br>输入: [10,2]<br>输出: 210</p>
<p>示例 2:<br>输入: [3,30,34,5,9]<br>输出: 9534330<br>说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数。<br><strong>Program</strong><br><strong>思路</strong><br>首先整数转成字符串，然后按照字典序降序，但是类似于样例2，”34”,”30”,”3”这种情况就不行了，任何两个字符串a,b，如果a+b&gt;b+a，那么a在前面。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums) vec.push_back(to_string(x));</span><br><span class="line">        sort(vec.begin(), vec.end(), [](<span class="keyword">const</span> <span class="built_in">string</span>&amp; a, <span class="keyword">const</span> <span class="built_in">string</span>&amp; b){</span><br><span class="line">            <span class="built_in">string</span> str1=a+b;</span><br><span class="line">            <span class="built_in">string</span> str2=b+a;</span><br><span class="line">            <span class="keyword">return</span> str1&gt;str2;</span><br><span class="line">        });</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> str:vec) res+=str;</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>]==<span class="string">'0'</span>?<span class="string">"0"</span>:res; <span class="comment">//注意特例全零</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="220-存在重复元素-III"><a href="#220-存在重复元素-III" class="headerlink" title="220. 存在重复元素 III"></a>220. 存在重复元素 III</h2><p><strong>Description</strong><br>在整数数组 nums 中，是否存在两个下标 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值小于等于 t ，且满足 i 和 j 的差的绝对值也小于等于 ķ 。<br>如果存在则返回 true，不存在返回 false。<br><strong>Example</strong><br>示例 1:<br>输入: nums = [1,2,3,1], k = 3, t = 0<br>输出: true</p>
<p>示例 2:<br>输入: nums = [1,0,1,1], k = 1, t = 2<br>输出: true</p>
<p>示例 3:<br>输入: nums = [1,5,9,1,5,9], k = 2, t = 3<br>输出: false<br><strong>Program</strong><br><strong>排序+暴力</strong><br>时间复杂度：$O(n^2)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">long</span> val;</span><br><span class="line">        <span class="keyword">int</span> idx;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">long</span> _val, <span class="keyword">int</span> _idx):val(_val), idx(_idx){}</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node&amp; tmp) <span class="keyword">const</span>{</span><br><span class="line">            <span class="keyword">return</span> val&lt;tmp.val;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            vec.push_back(Node(nums[i], i));</span><br><span class="line">        }</span><br><span class="line">        sort(vec.begin(), vec.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n&amp;&amp;<span class="built_in">abs</span>(vec[i].val-vec[j].val)&lt;=t;j++){</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(vec[i].idx-vec[j].idx)&lt;=k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>滑动窗口</strong><br>（1）$|nums[i] - nums[j]| &lt;=t $等价于$nums[j]-t &lt;= nums[i] &lt;= nums[j]+t$<br>（2）窗口内的数有序，且找到当前窗口内大于等于$nums[j]-t$第一个数nums[i]，如果$nums[i]&lt;=nums[j]+t$成立，那么说明存在；否则不存在。<br>时间复杂度：$O(n\log{k})$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">long</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">            <span class="built_in">set</span>&lt;<span class="keyword">long</span>&gt;::iterator it=s.lower_bound((<span class="keyword">long</span>)nums[j]-t);</span><br><span class="line">            <span class="keyword">if</span>(it != s.end() &amp;&amp; *it &lt;= (<span class="keyword">long</span>)nums[j]+t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            s.insert(nums[j]);</span><br><span class="line">            <span class="keyword">if</span>(s.size() == k+<span class="number">1</span>) s.erase((<span class="keyword">long</span>)nums[j-k]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h2><p><strong>Description</strong><br>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。<br><strong>Example</strong><br>示例 1:<br>输入: s = “anagram”, t = “nagaram”<br>输出: true</p>
<p>示例 2:<br>输入: s = “rat”, t = “car”<br>输出: false<br>说明:<br>你可以假设字符串只包含小写字母。<br>进阶:<br>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？<br><strong>Program</strong><br><strong>排序</strong><br>时间复杂度：$O(n\log{n})$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>{</span><br><span class="line">        sort(s.begin(), s.end());</span><br><span class="line">        sort(t.begin(), t.end());</span><br><span class="line">        <span class="keyword">return</span> s == t;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>哈希表</strong><br>时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(s.length()!=t.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> SH[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> TH[<span class="number">26</span>];</span><br><span class="line">        <span class="built_in">memset</span>(SH, <span class="number">0</span>, <span class="keyword">sizeof</span>(SH));</span><br><span class="line">        <span class="built_in">memset</span>(TH, <span class="number">0</span>, <span class="keyword">sizeof</span>(TH));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++){</span><br><span class="line">            SH[s[i]-<span class="string">'a'</span>]++;</span><br><span class="line">            TH[t[i]-<span class="string">'a'</span>]++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++){</span><br><span class="line">            <span class="keyword">if</span>(SH[i]!=TH[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="324-摆动排序-II"><a href="#324-摆动排序-II" class="headerlink" title="324. 摆动排序 II"></a>324. 摆动排序 II</h2><p><strong>Description</strong><br>给定一个无序的数组 nums，将它重新排列成 nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]… 的顺序。<br><strong>Example</strong><br>示例 1:<br>输入: nums = [1, 5, 1, 1, 6, 4]<br>输出: 一个可能的答案是 [1, 4, 1, 5, 1, 6]</p>
<p>示例 2:<br>输入: nums = [1, 3, 2, 2, 3, 1]<br>输出: 一个可能的答案是 [2, 3, 1, 3, 1, 2]<br>说明:<br>你可以假设所有输入都会得到有效的结果。</p>
<p>进阶:<br>你能用 O(n) 时间复杂度和 / 或原地 O(1) 额外空间来实现吗？<br><strong>Program</strong><br>首先，我们可以很容易想到一种简单的解法：将数组进行排序，然后从中间位置进行等分（如果数组长度为奇数，则将中间的元素分到前面），然后将两个数组进行穿插。</p>
<p>例如：<br>对于数组[1, 5, 2, 4, 3]，我们将其排序，得到[1, 2, 3, 4, 5]，然后将其分割为[1, 2, 3]和[4, 5]，对两个数组进行穿插，得到[1, 4, 2, 5, 3]。</p>
<p>但是这一解法有一个问题，例如，对于数组[1, 2, 2, 3]，按照这种做法求得的结果仍为[1, 2, 2, 3]。如果题目不要求各元素严格大于或小于相邻元素，即，只要求nums[0] &lt;= nums[1] &gt;= nums[2] &lt;= nums[3]…，那么这一解法是符合要求的，但题目要求元素相互严格大于或小于，那么需要稍微做一点改进。</p>
<p>为了方便阅读，我们在下文中定义较小的子数组为数组A，较大的子数组为数组B。显然，出现上述现象是因为nums中存在重复元素。实际上，由于穿插之后，相邻元素必来自不同子数组，所以A或B内部出现重复元素是不会出现上述现象的。所以，出现上述情况其实是因为数组A和数组B出现了相同元素，我们用r来表示这一元素。而且我们可以很容易发现，如果A和B都存在r，那么r一定是A的最大值，B的最小值，这意味着r一定出现在A的尾部，B的头部。其实，如果这一数字的个数较少，不会出现这一现象，只有当这一数字个数达到原数组元素总数的一半，才会在穿插后的出现在相邻位置。以下举几个例子进行形象地说明：</p>
<p>例如，对于数组[1,1,2,2,3,3],分割为[1,1,2]和[2,3,3]，虽然A和B都出现了2，但穿插后为[1,2,1,3,2,3]，满足要求。<br>而如果2的个数再多一些，即[1,1,2,2,2,3]，分割为[1,1,2]和[2,2,3]，最终结果为[1,2,1,2,2,3]，来自A的2和来自B的2出现在了相邻位置。</p>
<p>出现这一问题是因为重复数在A和B中的位置决定的，因为r在A尾部，B头部，所以如果r个数太多（大于等于(length(nums) + 1)/2），就可能在穿插后相邻。要解决这一问题，我们需要使A的r和B的r在穿插后尽可能分开。一种可行的办法是将A和B反序：</p>
<p>例如，对于数组[1,1,2,2,2,3]，分割为[1,1,2]和[2,2,3]，分别反序后得到[2, 1, 1]和[3, 2, 2]，此时2在A头部，B尾部，穿插后就不会发生相邻了。</p>
<p>当然，这只能解决r的个数等于(length(nums) + 1)/2的情况，如果r的个数大于(length(nums) + 1)/2，还是会出现相邻。但实际上，这种情况是不存在有效解的，也就是说，这种数组对于本题来说是非法的。</p>
<p>此时我们得到了第一个解法，由于需要使用排序，所以时间复杂度为O(NlogN)，由于需要存储A和B，所以空间复杂度为O(N)。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec=nums;</span><br><span class="line">        sort(vec.begin(), vec.end());</span><br><span class="line">        <span class="keyword">int</span> mid=(n<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> i=mid, j=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++){</span><br><span class="line">            <span class="keyword">if</span>(k%<span class="number">2</span>==<span class="number">0</span>) nums[k]=vec[i--];</span><br><span class="line">            <span class="keyword">else</span> nums[k]=vec[j--];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="524-通过删除字母匹配到字典里最长单词"><a href="#524-通过删除字母匹配到字典里最长单词" class="headerlink" title="524. 通过删除字母匹配到字典里最长单词"></a>524. 通过删除字母匹配到字典里最长单词</h2><p><strong>Description</strong><br>给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。<br><strong>Example</strong><br>示例 1:<br>输入:<br>s = “abpcplea”, d = [“ale”,”apple”,”monkey”,”plea”]<br>输出:<br>“apple”</p>
<p>示例 2:<br>输入:<br>s = “abpcplea”, d = [“a”,”b”,”c”]</p>
<p>输出:<br>“a”<br>说明:<br>所有输入的字符串只包含小写字母。<br>字典的大小不会超过 1000。<br>所有输入的字符串长度不会超过 1000。<br><strong>Program</strong><br><strong>思路</strong><br>（1）题目意思“给定字符串删除某些字符”能够与字典中的字符串匹配，且要求匹配的字符最长，也就是说字典中匹配的字符串是给定字符串的子序列！且要求子序列尽可能最长！<br>（2）题目需要字典序小的最长匹配字符串，则需要先排序<br>（3）字典中每个字符串与给定字符进行比较，保留最长的那个即可<br>时间复杂度：$O(n^2)$<br>空间复杂度：$O(1)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calLongest</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span></span>{ <span class="comment">//比较s与t的最长相等子序列长度</span></span><br><span class="line">        <span class="keyword">int</span> m=s.length(), n=t.length();</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m&amp;&amp;j&lt;n){</span><br><span class="line">            <span class="keyword">if</span>(s[i]==t[j]){i++;j++;ans++;}</span><br><span class="line">            <span class="keyword">else</span> j++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> i==m?m:<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">findLongestWord</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; d)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=d.size();</span><br><span class="line">        sort(d.begin(), d.end());</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> l=calLongest(d[i], s);</span><br><span class="line">            <span class="keyword">if</span>(l&gt;ans){</span><br><span class="line">                ans=l;</span><br><span class="line">                res=d[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="853-车队"><a href="#853-车队" class="headerlink" title="853. 车队"></a>853. 车队</h2><p><strong>Description</strong><br>N  辆车沿着一条车道驶向位于 target 英里之外的共同目的地。<br>每辆车 i 以恒定的速度 speed[i] （英里/小时），从初始位置 position[i] （英里） 沿车道驶向目的地。<br>一辆车永远不会超过前面的另一辆车，但它可以追上去，并与前车以相同的速度紧接着行驶。<br>此时，我们会忽略这两辆车之间的距离，也就是说，它们被假定处于相同的位置。<br>车队 是一些由行驶在相同位置、具有相同速度的车组成的非空集合。注意，一辆车也可以是一个车队。<br>即便一辆车在目的地才赶上了一个车队，它们仍然会被视作是同一个车队。<br>会有多少车队到达目的地?<br><strong>Example</strong><br>示例：<br>输入：target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]<br>输出：3</p>
<p>解释：<br>从 10 和 8 开始的车会组成一个车队，它们在 12 处相遇。<br>从 0 处开始的车无法追上其它车，所以它自己就是一个车队。<br>从 5 和 3 开始的车会组成一个车队，它们在 6 处相遇。<br>请注意，在到达目的地之前没有其它车会遇到这些车队，所以答案是 3。</p>
<p>提示：<br>0 &lt;= N &lt;= 10 ^ 4<br>0 &lt; target &lt;= 10 ^ 6<br>0 &lt; speed[i] &lt;= 10 ^ 6<br>0 &lt;= position[i] &lt; target<br>所有车的初始位置各不相同。<br><strong>Program</strong><br><strong>排序+单调栈</strong><br>（1）首先，根据pos进行排序；<br>（2）然后计算各自的用时；<br>（3）从后往前实现单调递增栈：</p>
<ul>
<li>因为后车追上前车时，后车将与前车同行同速，此时直接忽视后车即可；</li>
<li>如果后车和前车同样用时，忽略后车；</li>
<li>如果后车用时比前车大，则后车永远追不上前车，应当保留；</li>
<li>这个过程使用单调递增栈，注意后车追上前车，仅保留前车结果！<br>时间复杂度：$O(n\log{n})$，排序复杂度$O(n\log{n})$，遍历+栈总体复杂度$O(n)$<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">**排序+单调栈**</span><br><span class="line">（<span class="number">1</span>）首先，根据pos进行排序；</span><br><span class="line">（<span class="number">2</span>）然后计算各自的用时；</span><br><span class="line">（<span class="number">3</span>）从后往前实现单调递增栈：</span><br><span class="line">- 因为后车追上前车时，后车将与前车同行同速，此时直接忽视后车即可；</span><br><span class="line">- 如果后车和前车同样用时，忽略后车；</span><br><span class="line">- 如果后车用时比前车大，则后车永远追不上前车，应当保留；</span><br><span class="line">- 这个过程使用单调递增栈，注意后车追上前车，仅保留前车结果！</span><br><span class="line">时间复杂度：$O(n\<span class="built_in">log</span>{n})$，排序复杂度$O(n\<span class="built_in">log</span>{n})$，遍历+栈总体复杂度$O(n)$</span><br><span class="line">```cpp</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> pos;</span><br><span class="line">        <span class="keyword">int</span> speed;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> _pos, <span class="keyword">int</span> _speed):pos(_pos),speed(_speed){}</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node&amp; other) <span class="keyword">const</span>{</span><br><span class="line">            <span class="keyword">return</span> pos&lt;other.pos;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">carFleet</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; position, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; speed)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=position.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            vec.push_back(Node(position[i], speed[i]));</span><br><span class="line">        }</span><br><span class="line">        sort(vec.begin(), vec.end()); <span class="comment">//按照pos排序</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; times;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){ <span class="comment">//计算各自用时</span></span><br><span class="line">            <span class="keyword">double</span> time=(target-vec[i].pos)/(<span class="keyword">double</span>)vec[i].speed;</span><br><span class="line">            times.push_back(time);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">double</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){ <span class="comment">//单调递增栈</span></span><br><span class="line">            <span class="keyword">if</span>(stk.empty()||stk.top()&lt;times[i]){</span><br><span class="line">                stk.push(times[i]);</span><br><span class="line">            } <span class="comment">//注意后车不可能超过前车，只能与前车同速，故如果后车用时更少，忽略即可</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> stk.size(); <span class="comment">//栈中元素个数即最终答案</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">## 922. 按奇偶排序数组 II</span><br><span class="line">**Description**</span><br><span class="line">给定一个非负整数数组&nbsp;A， A 中一半整数是奇数，一半整数是偶数。</span><br><span class="line">对数组进行排序，以便当&nbsp;A[i] 为奇数时，i&nbsp;也是奇数；当&nbsp;A[i]&nbsp;为偶数时， i 也是偶数。</span><br><span class="line">你可以返回任何满足上述条件的数组作为答案。</span><br><span class="line">**Example**</span><br><span class="line">示例：</span><br><span class="line">输入：[4,2,5,7]</span><br><span class="line">输出：[4,5,2,7]</span><br><span class="line">解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。</span><br><span class="line">&nbsp;</span><br><span class="line">提示：</span><br><span class="line">2 &lt;= A.length &lt;= 20000</span><br><span class="line">A.length % 2 == 0</span><br><span class="line">0 &lt;= A[i] &lt;= 1000</span><br><span class="line">**Program**</span><br><span class="line">```cpp</span><br><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; sortArrayByParityII(vector&lt;int&gt;&amp; A) {</span><br><span class="line">        vector&lt;int&gt; evens, odds;</span><br><span class="line">        for(int x:A){</span><br><span class="line">            if(x%2==0) evens.push_back(x);</span><br><span class="line">            else odds.push_back(x);</span><br><span class="line">        }</span><br><span class="line">        int p1=0,p2=0;</span><br><span class="line">        int n=A.size();</span><br><span class="line">        for(int i=0;i&lt;n;i++){</span><br><span class="line">            if(i%2==0) A[i]=evens[p1++];</span><br><span class="line">            else A[i]=odds[p2++];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return A;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="969-煎饼排序"><a href="#969-煎饼排序" class="headerlink" title="969. 煎饼排序"></a>969. 煎饼排序</h2></li>
</ul>
<p><strong>Description</strong><br>给定数组 A，我们可以对其进行煎饼翻转：我们选择一些正整数 k &lt;= A.length，然后反转 A 的前 k 个元素的顺序。我们要执行零次或多次煎饼翻转（按顺序一次接一次地进行）以完成对数组 A 的排序。<br>返回能使 A 排序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * A.length 范围内的有效答案都将被判断为正确。<br><strong>Example</strong><br>示例 1：<br>输入：[3,2,4,1]<br>输出：[4,2,4,3]<br>解释：<br>我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。<br>初始状态 A = [3, 2, 4, 1]<br>第一次翻转后 (k=4): A = [1, 4, 2, 3]<br>第二次翻转后 (k=2): A = [4, 1, 2, 3]<br>第三次翻转后 (k=4): A = [3, 2, 1, 4]<br>第四次翻转后 (k=3): A = [1, 2, 3, 4]，此时已完成排序。</p>
<p>示例 2：<br>输入：[1,2,3]<br>输出：[]<br>解释：<br>输入已经排序，因此不需要翻转任何内容。<br>请注意，其他可能的答案，如[3，3]，也将被接受。</p>
<p>提示：<br>1 &lt;= A.length &lt;= 100<br>A[i] 是 [1, 2, …, A.length] 的排列<br><strong>Program</strong><br><strong>数学</strong><br>（1）对区间[0,i]，找到最大值下标j：<br>（2）翻转[0,j]，将最大值移到第一个位置；<br>（3）翻转[0,i]，将最大值移到最后一个位置；<br>时间复杂度：$O(n^2)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pancakeSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr) {</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">int</span> j=max_element(arr.begin(), arr.begin()+i+<span class="number">1</span>)-arr.begin();</span><br><span class="line">            <span class="keyword">if</span>(j==i) <span class="keyword">continue</span>; <span class="comment">//不需要翻转</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;<span class="number">0</span>){ <span class="comment">//不在首位则需要翻转</span></span><br><span class="line">                reverse(arr.begin(), arr.begin()+j+<span class="number">1</span>);</span><br><span class="line">                res.push_back(j+<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            reverse(arr.begin(), arr.begin()+i+<span class="number">1</span>);</span><br><span class="line">            res.push_back(i+<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1030-距离顺序排列矩阵单元格"><a href="#1030-距离顺序排列矩阵单元格" class="headerlink" title="1030. 距离顺序排列矩阵单元格"></a>1030. 距离顺序排列矩阵单元格</h2><p><strong>Description</strong><br>给出 R 行 C 列的矩阵，其中的单元格的整数坐标为 (r, c)，满足 0 &lt;= r &lt; R 且 0 &lt;= c &lt; C。</p>
<p>另外，我们在该矩阵中给出了一个坐标为 (r0, c0) 的单元格。</p>
<p>返回矩阵中的所有单元格的坐标，并按到 (r0, c0) 的距离从最小到最大的顺序排，其中，两单元格(r1, c1) 和 (r2, c2) 之间的距离是曼哈顿距离，|r1 - r2| + |c1 - c2|。（你可以按任何满足此条件的顺序返回答案。）<br><strong>Example</strong><br>示例 1：<br>输入：R = 1, C = 2, r0 = 0, c0 = 0<br>输出：[[0,0],[0,1]]<br>解释：从 (r0, c0) 到其他单元格的距离为：[0,1]</p>
<p>示例 2：<br>输入：R = 2, C = 2, r0 = 0, c0 = 1<br>输出：[[0,1],[0,0],[1,1],[1,0]]<br>解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2]<br>[[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案。</p>
<p>示例 3：<br>输入：R = 2, C = 3, r0 = 1, c0 = 2<br>输出：[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]<br>解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2,2,3]<br>其他满足题目要求的答案也会被视为正确，例如 [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]。</p>
<p>提示：<br>1 &lt;= R &lt;= 100<br>1 &lt;= C &lt;= 100<br>0 &lt;= r0 &lt; R<br>0 &lt;= c0 &lt; C<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; allCellsDistOrder(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;R;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;C;j++){</span><br><span class="line">                res.push_back({i,j});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        sort(res.begin(), res.end(), [r0, c0](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b){ <span class="comment">//[=]表示访问所有外部变量，[r0,c0]指定可以访问的变量</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(a[<span class="number">0</span>]-r0)+<span class="built_in">abs</span>(a[<span class="number">1</span>]-c0)&lt;<span class="built_in">abs</span>(b[<span class="number">0</span>]-r0)+<span class="built_in">abs</span>(b[<span class="number">1</span>]-c0);</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1122-数组的相对排序"><a href="#1122-数组的相对排序" class="headerlink" title="1122. 数组的相对排序"></a>1122. 数组的相对排序</h2><p><strong>Description</strong><br>给你两个数组，arr1 和 arr2，<br>arr2 中的元素各不相同<br>arr2 中的每个元素都出现在 arr1 中<br>对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。<br><strong>Example</strong><br>示例：<br>输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]<br>输出：[2,2,2,1,4,3,3,9,6,7,19]</p>
<p>提示：<br>arr1.length, arr2.length &lt;= 1000<br>0 &lt;= arr1[i], arr2[i] &lt;= 1000<br>arr2 中的元素 arr2[i] 各不相同<br>arr2 中的每个元素 arr2[i] 都出现在 arr1 中<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; relativeSortArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2) {</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:arr1) m[x]++;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:arr2){</span><br><span class="line">            <span class="keyword">while</span>(m[x]&gt;<span class="number">0</span>){</span><br><span class="line">                res.push_back(x);</span><br><span class="line">                m[x]--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        sort(arr1.begin(), arr1.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:arr1){</span><br><span class="line">            <span class="keyword">while</span>(m[x]&gt;<span class="number">0</span>){</span><br><span class="line">                res.push_back(x);</span><br><span class="line">                m[x]--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1305-两棵二叉搜索树中的所有元素"><a href="#1305-两棵二叉搜索树中的所有元素" class="headerlink" title="1305. 两棵二叉搜索树中的所有元素"></a>1305. 两棵二叉搜索树中的所有元素</h2><p><strong>Description</strong><br>给你 root1 和 root2 这两棵二叉搜索树。<br>请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。.<br><strong>Example</strong><br>示例 1：<br><img src="/assets/img/algorithm/q2-e1.png" alt="image"><br>输入：root1 = [2,1,4], root2 = [1,0,3]<br>输出：[0,1,1,2,3,4]</p>
<p>示例 2：<br>输入：root1 = [0,-10,10], root2 = [5,1,7,0,2]<br>输出：[-10,0,0,1,2,5,7,10]</p>
<p>示例 3：<br>输入：root1 = [], root2 = [5,1,7,0,2]<br>输出：[0,1,2,5,7]</p>
<p>示例 4：<br>输入：root1 = [0,-10,10], root2 = []<br>输出：[-10,0,10]</p>
<p>示例 5：<br><img src="/assets/img/algorithm/q2-e5-.png" alt="image"><br>输入：root1 = [1,null,8], root2 = [8,1]<br>输出：[1,1,8,8]</p>
<p>提示：<br>每棵树最多有 5000 个节点。<br>每个节点的值在 [-10^5, 10^5] 之间。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getAllElements(TreeNode* root1, TreeNode* root2) {</span><br><span class="line">        dfs(root1);</span><br><span class="line">        dfs(root2);</span><br><span class="line">        sort(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1329-将矩阵按对角线排序"><a href="#1329-将矩阵按对角线排序" class="headerlink" title="1329. 将矩阵按对角线排序"></a>1329. 将矩阵按对角线排序</h2><p><strong>Description</strong><br>给你一个 m * n 的整数矩阵 mat ，请你将同一条对角线上的元素（从左上到右下）按升序排序后，返回排好序的矩阵。<br><strong>Example</strong><br>示例 1：<br><img src="/assets/img/algorithm/1482_example_1_2.png" alt="image"><br>输入：mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]<br>输出：[[1,1,1,1],[1,2,2,2],[1,2,3,3]]</p>
<p>提示：<br>m == mat.length<br>n == mat[i].length<br>1 &lt;= m, n &lt;= 100<br>1 &lt;= mat[i][j] &lt;= 100<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; diagonalSort(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat) {</span><br><span class="line">        <span class="keyword">int</span> m=mat.size(), n=mat[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; diag(m+n<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                diag[j-i+m<span class="number">-1</span>].push_back(mat[i][j]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m+n<span class="number">-1</span>;i++){</span><br><span class="line">            sort(diag[i].begin(), diag[i].end(), greater&lt;<span class="keyword">int</span>&gt;()); <span class="comment">//从大到小排序，方便后面放置元素</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                res[i][j]=diag[j-i+m<span class="number">-1</span>].back();diag[j-i+m<span class="number">-1</span>].pop_back();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1366-通过投票对团队排名"><a href="#1366-通过投票对团队排名" class="headerlink" title="1366. 通过投票对团队排名"></a>1366. 通过投票对团队排名</h2><p><strong>Description</strong><br>现在有一个特殊的排名系统，依据参赛团队在投票人心中的次序进行排名，每个投票者都需要按从高到低的顺序对参与排名的所有团队进行排位。</p>
<p>排名规则如下：</p>
<p>参赛团队的排名次序依照其所获「排位第一」的票的多少决定。如果存在多个团队并列的情况，将继续考虑其「排位第二」的票的数量。以此类推，直到不再存在并列的情况。<br>如果在考虑完所有投票情况后仍然出现并列现象，则根据团队字母的字母顺序进行排名。<br>给你一个字符串数组 votes 代表全体投票者给出的排位情况，请你根据上述排名规则对所有参赛团队进行排名。</p>
<p>请你返回能表示按排名系统 排序后 的所有团队排名的字符串。<br><strong>Example</strong><br>示例 1：<br>输入：votes = [“ABC”,”ACB”,”ABC”,”ACB”,”ACB”]<br>输出：”ACB”<br>解释：A 队获得五票「排位第一」，没有其他队获得「排位第一」，所以 A 队排名第一。<br>B 队获得两票「排位第二」，三票「排位第三」。<br>C 队获得三票「排位第二」，两票「排位第三」。<br>由于 C 队「排位第二」的票数较多，所以 C 队排第二，B 队排第三。</p>
<p>示例 2：<br>输入：votes = [“WXYZ”,”XYZW”]<br>输出：”XWYZ”<br>解释：X 队在并列僵局打破后成为排名第一的团队。X 队和 W 队的「排位第一」票数一样，但是 X 队有一票「排位第二」，而 W 没有获得「排位第二」。</p>
<p>示例 3：<br>输入：votes = [“ZMNAGUEDSJYLBOPHRQICWFXTVK”]<br>输出：”ZMNAGUEDSJYLBOPHRQICWFXTVK”<br>解释：只有一个投票者，所以排名完全按照他的意愿。</p>
<p>示例 4：<br>输入：votes = [“BCA”,”CAB”,”CBA”,”ABC”,”ACB”,”BAC”]<br>输出：”ABC”<br>解释：<br>A 队获得两票「排位第一」，两票「排位第二」，两票「排位第三」。<br>B 队获得两票「排位第一」，两票「排位第二」，两票「排位第三」。<br>C 队获得两票「排位第一」，两票「排位第二」，两票「排位第三」。<br>完全并列，所以我们需要按照字母升序排名。</p>
<p>示例 5：<br>输入：votes = [“M”,”M”,”M”,”M”]<br>输出：”M”<br>解释：只有 M 队参赛，所以它排名第一。</p>
<p>提示：<br>1 &lt;= votes.length &lt;= 1000<br>1 &lt;= votes[i].length &lt;= 26<br>votes[i].length == votes[j].length for 0 &lt;= i, j &lt; votes.length<br>votes[i][j] 是英文 大写 字母<br>votes[i] 中的所有字母都是唯一的<br>votes[0] 中出现的所有字母 同样也 出现在 votes[j] 中，其中 1 &lt;= j &lt; votes.length<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n; <span class="comment">//votes长度</span></span><br><span class="line">    <span class="keyword">int</span> m; <span class="comment">//参赛队数</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ranks; <span class="comment">//队名转索引</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">rankTeams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; votes)</span> </span>{</span><br><span class="line">        n=votes.size(), m=votes[<span class="number">0</span>].length();</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            res+=votes[<span class="number">0</span>][i];</span><br><span class="line">            ranks[votes[<span class="number">0</span>][i]].resize(m, <span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++){</span><br><span class="line">                ranks[votes[i][j]][j]++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        sort(res.begin(), res.end(), [&amp;](<span class="keyword">const</span> <span class="keyword">char</span> &amp;a, <span class="keyword">const</span> <span class="keyword">char</span> &amp;b){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">                <span class="keyword">if</span>(ranks[a][i]==ranks[b][i]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">return</span> ranks[a][i]&gt;ranks[b][i];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> a&lt;b;</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1387-将整数按权重排序"><a href="#1387-将整数按权重排序" class="headerlink" title="1387. 将整数按权重排序"></a>1387. 将整数按权重排序</h2><p><strong>Description</strong><br>我们将整数 x 的 权重 定义为按照下述规则将 x 变成 1 所需要的步数：</p>
<p>如果 x 是偶数，那么 x = x / 2<br>如果 x 是奇数，那么 x = 3 * x + 1<br>比方说，x=3 的权重为 7 。因为 3 需要 7 步变成 1 （3 –&gt; 10 –&gt; 5 –&gt; 16 –&gt; 8 –&gt; 4 –&gt; 2 –&gt; 1）。</p>
<p>给你三个整数 lo， hi 和 k 。你的任务是将区间 [lo, hi] 之间的整数按照它们的权重 升序排序 ，如果大于等于 2 个整数有 相同 的权重，那么按照数字自身的数值 升序排序 。<br>请你返回区间 [lo, hi] 之间的整数按权重排序后的第 k 个数。<br>注意，题目保证对于任意整数 x （lo &lt;= x &lt;= hi） ，它变成 1 所需要的步数是一个 32 位有符号整数。<br><strong>Example</strong><br>示例 1：<br>输入：lo = 12, hi = 15, k = 2<br>输出：13<br>解释：12 的权重为 9（12 –&gt; 6 –&gt; 3 –&gt; 10 –&gt; 5 –&gt; 16 –&gt; 8 –&gt; 4 –&gt; 2 –&gt; 1）<br>13 的权重为 9<br>14 的权重为 17<br>15 的权重为 17<br>区间内的数按权重排序以后的结果为 [12,13,14,15] 。对于 k = 2 ，答案是第二个整数也就是 13 。<br>注意，12 和 13 有相同的权重，所以我们按照它们本身升序排序。14 和 15 同理。</p>
<p>示例 2：<br>输入：lo = 1, hi = 1, k = 1<br>输出：1</p>
<p>示例 3：<br>输入：lo = 7, hi = 11, k = 4<br>输出：7<br>解释：区间内整数 [7, 8, 9, 10, 11] 对应的权重为 [16, 3, 19, 6, 14] 。<br>按权重排序后得到的结果为 [8, 10, 11, 7, 9] 。<br>排序后数组中第 4 个数字为 7 。</p>
<p>示例 4：<br>输入：lo = 10, hi = 20, k = 5<br>输出：13</p>
<p>示例 5：<br>输入：lo = 1, hi = 1000, k = 777<br>输出：570</p>
<p>提示：<br>1 &lt;= lo &lt;= hi &lt;= 1000<br>1 &lt;= k &lt;= hi - lo + 1<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">int</span> weight;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> _num, <span class="keyword">int</span> _weight):num(_num), weight(_weight){}</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; other) <span class="keyword">const</span>{</span><br><span class="line">            <span class="keyword">if</span>(weight==other.weight) <span class="keyword">return</span> num&lt;other.num;</span><br><span class="line">            <span class="keyword">return</span> weight&lt;other.weight;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calWeight</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">1</span>){</span><br><span class="line">            <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>) x=x/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> x=<span class="number">3</span>*x+<span class="number">1</span>;</span><br><span class="line">            ans++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">       <span class="built_in">vector</span>&lt;Node&gt; vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=lo;i&lt;=hi;i++){</span><br><span class="line">            vec.push_back(Node(i, calWeight(i)));</span><br><span class="line">        }</span><br><span class="line">        sort(vec.begin(), vec.end());</span><br><span class="line">        <span class="keyword">return</span> vec[k<span class="number">-1</span>].num;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1424-对角线遍历-II"><a href="#1424-对角线遍历-II" class="headerlink" title="1424. 对角线遍历 II"></a>1424. 对角线遍历 II</h2><p><strong>Description</strong><br>给你一个列表 nums ，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 nums 中对角线上的整数。<br><strong>Example</strong><br>示例 1：</p>
<p>输入：nums = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,4,2,7,5,3,8,6,9]</p>
<p>示例 2：<br><img src="/assets/img/algorithm/sample_2_1784.png" alt="image"><br>输入：nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]<br>输出：[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]</p>
<p>示例 3：<br>输入：nums = [[1,2,3],[4],[5,6,7],[8],[9,10,11]]<br>输出：[1,4,2,5,3,8,6,9,7,10,11]</p>
<p>示例 4：<br>输入：nums = [[1,2,3,4,5,6]]<br>输出：[1,2,3,4,5,6]</p>
<p>提示：<br>1 &lt;= nums.length &lt;= 10^5<br>1 &lt;= nums[i].length &lt;= 10^5<br>1 &lt;= nums[i][j] &lt;= 10^9<br>nums 中最多有 10^5 个数字。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> _val, <span class="keyword">int</span> _i, <span class="keyword">int</span> _j):val(_val), i(_i), j(_j){}</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; other) <span class="keyword">const</span>{</span><br><span class="line">            <span class="keyword">if</span>(i+j==other.i+other.j){</span><br><span class="line">                <span class="keyword">return</span> i&gt;other.i;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">return</span> i+j&lt;other.i+other.j;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findDiagonalOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums) {</span><br><span class="line">        <span class="keyword">int</span> m=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums[i].size();j++){</span><br><span class="line">                vec.push_back(Node(nums[i][j], i, j));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        sort(vec.begin(), vec.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(Node node:vec) res.push_back(node.val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1452-收藏清单"><a href="#1452-收藏清单" class="headerlink" title="1452. 收藏清单"></a>1452. 收藏清单</h2><p><strong>Description</strong><br>给你一个数组 favoriteCompanies ，其中 favoriteCompanies[i] 是第 i 名用户收藏的公司清单（下标从 0 开始）。<br>请找出不是其他任何人收藏的公司清单的子集的收藏清单，并返回该清单下标。下标需要按升序排列。<br><strong>Example</strong><br>示例 1：<br>输入：favoriteCompanies = [[“leetcode”,”google”,”facebook”],[“google”,”microsoft”],[“google”,”facebook”],[“google”],[“amazon”]]<br>输出：[0,1,4]<br>解释：<br>favoriteCompanies[2]=[“google”,”facebook”] 是 favoriteCompanies[0]=[“leetcode”,”google”,”facebook”] 的子集。<br>favoriteCompanies[3]=[“google”] 是 favoriteCompanies[0]=[“leetcode”,”google”,”facebook”] 和 favoriteCompanies[1]=[“google”,”microsoft”] 的子集。<br>其余的收藏清单均不是其他任何人收藏的公司清单的子集，因此，答案为 [0,1,4] 。</p>
<p>示例 2：<br>输入：favoriteCompanies = [[“leetcode”,”google”,”facebook”],[“leetcode”,”amazon”],[“facebook”,”google”]]<br>输出：[0,1]<br>解释：favoriteCompanies[2]=[“facebook”,”google”] 是 favoriteCompanies[0]=[“leetcode”,”google”,”facebook”] 的子集，因此，答案为 [0,1] 。</p>
<p>示例 3：<br>输入：favoriteCompanies = [[“leetcode”],[“google”],[“facebook”],[“amazon”]]<br>输出：[0,1,2,3]</p>
<p>提示：<br>1 &lt;= favoriteCompanies.length &lt;= 100<br>1 &lt;= favoriteCompanies[i].length &lt;= 500<br>1 &lt;= favoriteCompanies[i][j].length &lt;= 20<br>favoriteCompanies[i] 中的所有字符串 各不相同 。<br>用户收藏的公司清单也 各不相同 ，也就是说，即便我们按字母顺序排序每个清单， favoriteCompanies[i] != favoriteCompanies[j] 仍然成立。<br>所有字符串仅包含小写英文字母。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; peopleIndexes(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; favoriteCompanies) {</span><br><span class="line">        <span class="keyword">int</span> n=favoriteCompanies.size();</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vec(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;favoriteCompanies[i].size();j++){</span><br><span class="line">                <span class="built_in">string</span> str=favoriteCompanies[i][j];</span><br><span class="line">                <span class="keyword">if</span>(m.find(str)==m.end()) m[str]=idx++;</span><br><span class="line">                vec[i].push_back(m[str]);</span><br><span class="line">            }</span><br><span class="line">            sort(vec[i].begin(), vec[i].end());</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">bool</span> isSubset=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">if</span>(i==j) <span class="keyword">continue</span>; <span class="comment">//自身</span></span><br><span class="line">                <span class="keyword">if</span>(vec[i].size()&gt;vec[j].size()) <span class="keyword">continue</span>; <span class="comment">//肯定不是子集</span></span><br><span class="line">                <span class="keyword">int</span> size1=vec[i].size(), size2=vec[j].size();</span><br><span class="line">                <span class="keyword">int</span> p1=<span class="number">0</span>, p2=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(p1&lt;size1&amp;&amp;p2&lt;size2){</span><br><span class="line">                    <span class="keyword">if</span>(vec[i][p1]==vec[j][p2]){</span><br><span class="line">                        p1++;p2++;</span><br><span class="line">                    }<span class="keyword">else</span> p2++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(p1==size1){ <span class="comment">//是其他收藏的子集</span></span><br><span class="line">                    isSubset=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(!isSubset) res.push_back(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1471-数组中的-k-个最强值"><a href="#1471-数组中的-k-个最强值" class="headerlink" title="1471. 数组中的 k 个最强值"></a>1471. 数组中的 k 个最强值</h2><p><strong>Description</strong><br>给你一个整数数组 arr 和一个整数 k 。</p>
<p>设 m 为数组的中位数，只要满足下述两个前提之一，就可以判定 arr[i] 的值比 arr[j] 的值更强：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&nbsp;|arr[i] - m| &gt; |arr[j]&nbsp;- m|</span><br><span class="line">&nbsp;|arr[i] - m| == |arr[j] - m|，且 arr[i] &gt; arr[j]</span><br></pre></td></tr></tbody></table></figure>
<p>请返回由数组中最强的 k 个值组成的列表。答案可以以 任意顺序 返回。</p>
<p>中位数 是一个有序整数列表中处于中间位置的值。形式上，如果列表的长度为 n ，那么中位数就是该有序列表（下标从 0 开始）中位于 ((n - 1) / 2) 的元素。<br>例如 arr = [6, -3, 7, 2, 11]，n = 5：数组排序后得到 arr = [-3, 2, 6, 7, 11] ，数组的中间位置为 m = ((5 - 1) / 2) = 2 ，中位数 arr[m] 的值为 6 。<br>例如 arr = [-7, 22, 17, 3]，n = 4：数组排序后得到 arr = [-7, 3, 17, 22] ，数组的中间位置为 m = ((4 - 1) / 2) = 1 ，中位数 arr[m] 的值为 3 。<br><strong>Example</strong><br>示例 1：<br>输入：arr = [1,2,3,4,5], k = 2<br>输出：[5,1]<br>解释：中位数为 3，按从强到弱顺序排序后，数组变为 [5,1,4,2,3]。最强的两个元素是 [5, 1]。[1, 5] 也是正确答案。<br>注意，尽管 |5 - 3| == |1 - 3| ，但是 5 比 1 更强，因为 5 &gt; 1 。</p>
<p>示例 2：<br>输入：arr = [1,1,3,5,5], k = 2<br>输出：[5,5]<br>解释：中位数为 3, 按从强到弱顺序排序后，数组变为 [5,5,1,1,3]。最强的两个元素是 [5, 5]。</p>
<p>示例 3：<br>输入：arr = [6,7,11,7,6,8], k = 5<br>输出：[11,8,6,6,7]<br>解释：中位数为 7, 按从强到弱顺序排序后，数组变为 [11,8,6,6,7,7]。<br>[11,8,6,6,7] 的任何排列都是正确答案。</p>
<p>示例 4：<br>输入：arr = [6,-3,7,2,11], k = 3<br>输出：[-3,11,2]</p>
<p>示例 5：<br>输入：arr = [-7,22,17,3], k = 2<br>输出：[22,17]</p>
<p>提示：<br>1 &lt;= arr.length &lt;= 10^5<br>-10^5 &lt;= arr[i] &lt;= 10^5<br>1 &lt;= k &lt;= arr.length<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getStrongest(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        sort(arr.begin(), arr.end());</span><br><span class="line">        <span class="keyword">int</span> m=arr[(n<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">        sort(arr.begin(), arr.end(),[&amp;](<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b){</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(a-m)==<span class="built_in">abs</span>(b-m)) <span class="keyword">return</span> a&gt;b;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">abs</span>(a-m)&gt;<span class="built_in">abs</span>(b-m);</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(arr.begin(), arr.begin()+k);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1481-不同整数的最少数目"><a href="#1481-不同整数的最少数目" class="headerlink" title="1481. 不同整数的最少数目"></a>1481. 不同整数的最少数目</h2><p><strong>Description</strong><br>给你一个整数数组 arr 和一个整数 k 。现需要从数组中恰好移除 k 个元素，请找出移除后数组中不同整数的最少数目。<br><strong>Example</strong><br>示例 1：<br>输入：arr = [5,5,4], k = 1<br>输出：1<br>解释：移除 1 个 4 ，数组中只剩下 5 一种整数。</p>
<p>示例 2：<br>输入：arr = [4,3,1,1,3,3,2], k = 3<br>输出：2<br>解释：先移除 4、2 ，然后再移除两个 1 中的任意 1 个或者三个 3 中的任意 1 个，最后剩下 1 和 3 两种整数。</p>
<p>提示：<br>1 &lt;= arr.length &lt;= 10^5<br>1 &lt;= arr[i] &lt;= 10^9<br>0 &lt;= k &lt;= arr.length<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> _num, <span class="keyword">int</span> _count):num(_num),count(_count){}</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node&amp; other)<span class="keyword">const</span>{</span><br><span class="line">            <span class="keyword">return</span> count&gt;other.count;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLeastNumOfUniqueInts</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:arr){</span><br><span class="line">            m[x]++;</span><br><span class="line">        }</span><br><span class="line">        priority_queue&lt;Node&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it=m.begin();it!=m.end();it++){</span><br><span class="line">            pq.push(Node(it-&gt;first, it-&gt;second));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty()&amp;&amp;k&gt;<span class="number">0</span>){</span><br><span class="line">            Node node=pq.top();pq.pop();</span><br><span class="line">            <span class="keyword">if</span>(k&gt;=node.count) k-=node.count;</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                node.count-=k;</span><br><span class="line">                k=<span class="number">0</span>;</span><br><span class="line">                pq.push(node);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pq.size();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1491-去掉最低工资和最高工资后的工资平均值"><a href="#1491-去掉最低工资和最高工资后的工资平均值" class="headerlink" title="1491. 去掉最低工资和最高工资后的工资平均值"></a>1491. 去掉最低工资和最高工资后的工资平均值</h2><p><strong>Description</strong><br>给你一个整数数组 salary ，数组里每个数都是 唯一 的，其中 salary[i] 是第 i 个员工的工资。<br>请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。<br><strong>Example</strong><br>示例 1：<br>输入：salary = [4000,3000,1000,2000]<br>输出：2500.00000<br>解释：最低工资和最高工资分别是 1000 和 4000 。<br>去掉最低工资和最高工资以后的平均工资是 (2000+3000)/2= 2500</p>
<p>示例 2：<br>输入：salary = [1000,2000,3000]<br>输出：2000.00000<br>解释：最低工资和最高工资分别是 1000 和 3000 。<br>去掉最低工资和最高工资以后的平均工资是 (2000)/1= 2000</p>
<p>示例 3：<br>输入：salary = [6000,5000,4000,3000,2000,1000]<br>输出：3500.00000</p>
<p>示例 4：<br>输入：salary = [8000,9000,2000,3000,6000,1000]<br>输出：4750.00000</p>
<p>提示：<br>3 &lt;= salary.length &lt;= 100<br>10^3 &lt;= salary[i] &lt;= 10^6<br>salary[i] 是唯一的。<br>与真实值误差在 10^-5 以内的结果都将视为正确答案。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; salary)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=salary.size();</span><br><span class="line">        sort(salary.begin(), salary.end());</span><br><span class="line">        <span class="keyword">double</span> avg=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++){</span><br><span class="line">            avg+=salary[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> avg/(n<span class="number">-2</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1502-判断能否形成等差数列"><a href="#1502-判断能否形成等差数列" class="headerlink" title="1502. 判断能否形成等差数列"></a>1502. 判断能否形成等差数列</h2><p><strong>Description</strong><br>给你一个数字数组 arr 。<br>如果一个数列中，任意相邻两项的差总等于同一个常数，那么这个数列就称为 等差数列 。<br>如果可以重新排列数组形成等差数列，请返回 true ；否则，返回 false 。<br><strong>Example</strong><br>示例 1：<br>输入：arr = [3,5,1]<br>输出：true<br>解释：对数组重新排序得到 [1,3,5] 或者 [5,3,1] ，任意相邻两项的差分别为 2 或 -2 ，可以形成等差数列。</p>
<p>示例 2：<br>输入：arr = [1,2,4]<br>输出：false<br>解释：无法通过重新排序得到等差数列。</p>
<p>提示：<br>2 &lt;= arr.length &lt;= 1000<br>-10^6 &lt;= arr[i] &lt;= 10^6<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canMakeArithmeticProgression</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        sort(arr.begin(), arr.end());</span><br><span class="line">        <span class="keyword">int</span> dif=arr[<span class="number">1</span>]-arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(arr[i]-arr[i<span class="number">-1</span>]!=dif) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1508-子数组和排序后的区间和"><a href="#1508-子数组和排序后的区间和" class="headerlink" title="1508. 子数组和排序后的区间和"></a>1508. 子数组和排序后的区间和</h2><p><strong>Description</strong><br>给你一个数组 nums ，它包含 n 个正整数。你需要计算所有非空连续子数组的和，并将它们按升序排序，得到一个新的包含 n * (n + 1) / 2 个数字的数组。<br>请你返回在新数组中下标为 left 到 right （下标从 1 开始）的所有数字和（包括左右端点）。由于答案可能很大，请你将它对 10^9 + 7 取模后返回。<br><strong>Example</strong><br>示例 1：<br>输入：nums = [1,2,3,4], n = 4, left = 1, right = 5<br>输出：13<br>解释：所有的子数组和为 1, 3, 6, 10, 2, 5, 9, 3, 7, 4 。将它们升序排序后，我们得到新的数组 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。下标从 le = 1 到 ri = 5 的和为 1 + 2 + 3 + 3 + 4 = 13 。</p>
<p>示例 2：<br>输入：nums = [1,2,3,4], n = 4, left = 3, right = 4<br>输出：6<br>解释：给定数组与示例 1 一样，所以新数组为 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。下标从 le = 3 到 ri = 4 的和为 3 + 3 = 6 。</p>
<p>示例 3：<br>输入：nums = [1,2,3,4], n = 4, left = 1, right = 10<br>输出：50</p>
<p>提示：<br>1 &lt;= nums.length &lt;= 10^3<br>nums.length == n<br>1 &lt;= nums[i] &lt;= 100<br>1 &lt;= left &lt;= right &lt;= n * (n + 1) / 2<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++){</span><br><span class="line">                sum+=nums[j];</span><br><span class="line">                vec.push_back(sum);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        sort(vec.begin(), vec.end());</span><br><span class="line">        <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left<span class="number">-1</span>;i&lt;right;i++){</span><br><span class="line">            res=(res+vec[i])%MOD;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1528-重新排列字符串"><a href="#1528-重新排列字符串" class="headerlink" title="1528. 重新排列字符串"></a>1528. 重新排列字符串</h2><p><strong>Description</strong><br>给你一个字符串 s 和一个 长度相同 的整数数组 indices 。<br>请你重新排列字符串 s ，其中第 i 个字符需要移动到 indices[i] 指示的位置。<br>返回重新排列后的字符串。<br><strong>Example</strong><br>示例 1：<br>输入：s = “codeleet”, indices = [4,5,6,7,0,2,1,3]<br>输出：”leetcode”<br>解释：如图所示，”codeleet” 重新排列后变为 “leetcode” 。</p>
<p>示例 2：<br>输入：s = “abc”, indices = [0,1,2]<br>输出：”abc”<br>解释：重新排列后，每个字符都还留在原来的位置上。</p>
<p>示例 3：<br>输入：s = “aiohn”, indices = [3,1,4,2,0]<br>输出：”nihao”</p>
<p>示例 4：<br>输入：s = “aaiougrt”, indices = [4,0,2,6,7,3,1,5]<br>输出：”arigatou”</p>
<p>示例 5：<br>输入：s = “art”, indices = [1,0,2]<br>输出：”rat”</p>
<p>提示：<br>s.length == indices.length == n<br>1 &lt;= n &lt;= 100<br>s 仅包含小写英文字母。<br>0 &lt;= indices[i] &lt; n<br>indices 的所有的值都是唯一的（也就是说，indices 是整数 0 到 n - 1 形成的一组排列）。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">restoreString</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; indices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">res</span><span class="params">(n, <span class="string">'a'</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            res[indices[i]] = s[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1561-你可以获得的最大硬币数目"><a href="#1561-你可以获得的最大硬币数目" class="headerlink" title="1561. 你可以获得的最大硬币数目"></a>1561. 你可以获得的最大硬币数目</h2><p><strong>Description</strong><br>有 3n 堆数目不一的硬币，你和你的朋友们打算按以下方式分硬币：</p>
<p>每一轮中，你将会选出 任意 3 堆硬币（不一定连续）。<br>Alice 将会取走硬币数量最多的那一堆。<br>你将会取走硬币数量第二多的那一堆。<br>Bob 将会取走最后一堆。<br>重复这个过程，直到没有更多硬币。<br>给你一个整数数组 piles ，其中 piles[i] 是第 i 堆中硬币的数目。</p>
<p>返回你可以获得的最大硬币数目。<br><strong>Example</strong><br>示例 1：<br>输入：piles = [2,4,1,2,7,8]<br>输出：9<br>解释：选出 (2, 7, 8) ，Alice 取走 8 枚硬币的那堆，你取走 7 枚硬币的那堆，Bob 取走最后一堆。<br>选出 (1, 2, 4) , Alice 取走 4 枚硬币的那堆，你取走 2 枚硬币的那堆，Bob 取走最后一堆。<br>你可以获得的最大硬币数目：7 + 2 = 9.<br>考虑另外一种情况，如果选出的是 (1, 2, 8) 和 (2, 4, 7) ，你就只能得到 2 + 4 = 6 枚硬币，这不是最优解。</p>
<p>示例 2：<br>输入：piles = [2,4,5]<br>输出：4</p>
<p>示例 3：<br>输入：piles = [9,8,7,6,5,1,2,3,4]<br>输出：18</p>
<p>提示：<br>3 &lt;= piles.length &lt;= 10^5<br>piles.length % 3 == 0<br>1 &lt;= piles[i] &lt;= 10^4<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=piles.size();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        sort(piles.begin(), piles.end());</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            left++;right--;</span><br><span class="line">            ans+=piles[right--];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1636-按照频率将数组升序排序"><a href="#1636-按照频率将数组升序排序" class="headerlink" title="1636. 按照频率将数组升序排序"></a>1636. 按照频率将数组升序排序</h2><p><strong>Description</strong><br>给你一个整数数组 nums ，请你将数组按照每个值的频率 升序 排序。如果有多个值的频率相同，请你按照数值本身将它们 降序 排序。<br>请你返回排序后的数组。<br><strong>Example</strong><br>示例 1：<br>输入：nums = [1,1,2,2,2,3]<br>输出：[3,1,1,2,2,2]<br>解释：’3’ 频率为 1，’1’ 频率为 2，’2’ 频率为 3 。</p>
<p>示例 2：<br>输入：nums = [2,3,1,3,2]<br>输出：[1,3,3,2,2]<br>解释：’2’ 和 ‘3’ 频率都为 2 ，所以它们之间按照数值本身降序排序。</p>
<p>示例 3：<br>输入：nums = [-1,1,-6,4,5,-6,1,4,1]<br>输出：[5,-1,4,4,-6,-6,1,1,1]</p>
<p>提示：<br>1 &lt;= nums.length &lt;= 100<br>-100 &lt;= nums[i] &lt;= 100<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; frequencySort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums) m[x]++;</span><br><span class="line">        sort(nums.begin(), nums.end(), [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b){</span><br><span class="line">            <span class="keyword">return</span> m[a]==m[b]?a&gt;b:m[a]&lt;m[b];</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1637-两点之间不包含任何点的最宽垂直面积"><a href="#1637-两点之间不包含任何点的最宽垂直面积" class="headerlink" title="1637. 两点之间不包含任何点的最宽垂直面积"></a>1637. 两点之间不包含任何点的最宽垂直面积</h2><p><strong>Description</strong><br>给你 n 个二维平面上的点 points ，其中 points[i] = [xi, yi] ，请你返回两点之间内部不包含任何点的 最宽垂直面积 的宽度。<br>垂直面积 的定义是固定宽度，而 y 轴上无限延伸的一块区域（也就是高度为无穷大）。 最宽垂直面积 为宽度最大的一个垂直面积。<br>请注意，垂直区域 边上 的点 不在 区域内。<br><strong>Example</strong><br>示例 1：<br><img src="/assets/img/algorithm/points3.png" alt="image"><br>输入：points = [[8,7],[9,9],[7,4],[9,7]]<br>输出：1<br>解释：红色区域和蓝色区域都是最优区域。</p>
<p>示例 2：<br>输入：points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]<br>输出：3</p>
<p>提示：<br>$n == points.length$<br>$2 &lt;= n &lt;= 10^5$<br>$points[i].length == 2$<br>$0 &lt;= x_i, y_i &lt;= 10^9$<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxWidthOfVerticalArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>{</span><br><span class="line">        sort(points.begin(), points.end(), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b){</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;points.size();i++){</span><br><span class="line">            res=max(res, points[i][<span class="number">0</span>]-points[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="深搜"><a href="#深搜" class="headerlink" title="深搜"></a>深搜</h1></blockquote>
<h2 id="733-图像渲染"><a href="#733-图像渲染" class="headerlink" title="733. 图像渲染"></a>733. 图像渲染</h2><p><strong>Description</strong><br>有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。<br>给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。<br>为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。<br>最后返回经过上色渲染后的图像。<br><strong>Example</strong><br>示例 1:<br>输入:<br>image = [[1,1,1],[1,1,0],[1,0,1]]<br>sr = 1, sc = 1, newColor = 2<br>输出: [[2,2,2],[2,2,0],[2,0,1]]<br>解析:<br>在图像的正中间，(坐标(sr,sc)=(1,1)),<br>在路径上所有符合条件的像素点的颜色都被更改成2。<br>注意，右下角的像素没有更改为2，<br>因为它不是在上下左右四个方向上与初始点相连的像素点。<br>注意:<br>image 和 image[0] 的长度在范围 [1, 50] 内。<br>给出的初始点将满足 0 &lt;= sr &lt; image.length 和 0 &lt;= sc &lt; image[0].length。<br>image[i][j] 和 newColor 表示的颜色值在范围 [0, 65535]内。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> steps[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">         <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">         <span class="number">0</span>,<span class="number">-1</span>,</span><br><span class="line">         <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line">    <span class="keyword">int</span> originColor;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span>&amp; newColor, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        image[x][y]=newColor;</span><br><span class="line">        vis[x][y]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line">            <span class="keyword">int</span> new_x=x+steps[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> new_y=y+steps[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(new_x&gt;=<span class="number">0</span>&amp;&amp;new_x&lt;rows&amp;&amp;new_y&gt;=<span class="number">0</span>&amp;&amp;new_y&lt;cols&amp;&amp;image[new_x][new_y]==originColor&amp;&amp;!vis[new_x][new_y]){</span><br><span class="line">                dfs(image, newColor, new_x, new_y);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; floodFill(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) {</span><br><span class="line">        rows=image.size(), cols=image[<span class="number">0</span>].size();</span><br><span class="line">        vis.resize(rows, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cols, <span class="literal">false</span>));</span><br><span class="line">        originColor=image[sr][sc];</span><br><span class="line">        dfs(image, newColor, sr, sc);</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="841-钥匙和房间"><a href="#841-钥匙和房间" class="headerlink" title="841. 钥匙和房间"></a>841. 钥匙和房间</h2><p><strong>Description</strong><br>有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，…，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。<br>在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 rooms[i][j] 由 [0,1，…，N-1] 中的一个整数表示，其中 N = rooms.length。 钥匙 rooms[i][j] = v 可以打开编号为 v 的房间。<br>最初，除 0 号房间外的其余所有房间都被锁住。<br>你可以自由地在房间之间来回走动。<br>如果能进入每个房间返回 true，否则返回 false。<br><strong>Example</strong><br>示例 1：<br>输入: [[1],[2],[3],[]]<br>输出: true<br>解释:<br>我们从 0 号房间开始，拿到钥匙 1。<br>之后我们去 1 号房间，拿到钥匙 2。<br>然后我们去 2 号房间，拿到钥匙 3。<br>最后我们去了 3 号房间。<br>由于我们能够进入每个房间，我们返回 true。</p>
<p>示例 2：<br>输入：[[1,3],[3,0,1],[2],[0]]<br>输出：false<br>解释：我们不能进入 2 号房间。</p>
<p>提示：<br>1 &lt;= rooms.length &lt;= 1000<br>0 &lt;= rooms[i].length &lt;= 1000<br>所有房间中的钥匙数量总计不超过 3000。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms, <span class="keyword">int</span> u)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(ans==n) <span class="keyword">return</span>;</span><br><span class="line">        ans++;</span><br><span class="line">        vis[u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rooms[u].size();i++){</span><br><span class="line">            <span class="keyword">int</span> v=rooms[u][i];</span><br><span class="line">            <span class="keyword">if</span>(!vis[v]){</span><br><span class="line">                dfs(rooms, v);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canVisitAllRooms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms)</span> </span>{</span><br><span class="line">        n=rooms.size();</span><br><span class="line">        vis.resize(n, <span class="literal">false</span>);</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        dfs(rooms, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans==n;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1></blockquote>
<h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h2><p><strong>Description</strong><br>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>说明：你不能倾斜容器，且 n 的值至少为 2。<br><img src="/assets/img/algorithm/question_11.jpg" alt="image"><br>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。<br><strong>Example</strong><br>示例：<br>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br><strong>Program</strong><br><strong>思路</strong><br>（1）双指针left,right分别指向数组头尾；<br>（2）每次高度更小的索引更新，$min(height[left],height[right])*(right-left)$，因为高度大的肯定面积更小，高度小的更新后才可能出现更大的值；<br>如下图所示，在一开始，我们考虑相距最远的两个柱子所能容纳水的面积。水的宽度是两根柱子之间的距离 d = 8d=8；水的高度取决于两根柱子之间较短的那个，即左边柱子的高度 h = 3。水的面积就是3×8=24。</p>
<ul>
<li>如果选择固定一根柱子，另外一根变化，水的面积会有什么变化吗？稍加思考可得：</li>
<li>当前柱子是最两侧的柱子，水的宽度 dd 为最大，其他的组合，水的宽度都比这个小。</li>
<li>左边柱子较短，决定了水的高度为 3。如果移动左边的柱子，新的水面高度不确定，一定不会超过右边的柱子高度 7。</li>
<li>如果移动右边的柱子，新的水面高度一定不会超过左边的柱子高度 3，也就是不会超过现在的水面高度。</li>
</ul>
<p>由此可见，如果固定左边的柱子，移动右边的柱子，那么水的高度一定不会增加，且宽度一定减少，所以水的面积一定减少。这个时候，左边的柱子和任意一个其他柱子的组合，其实都可以排除了。也就是我们可以排除掉左边的柱子了。<br>这个排除掉左边柱子的操作，就是双指针代码里的 i++。i 和 j 两个指针中间的区域都是还未排除掉的区域。随着不断的排除，i 和 j 都会往中间移动。当 i 和 j 相遇，算法就结束了</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=height.size();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=min(height[left], height[right]) * (right-left);</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">if</span>(height[left]&lt;height[right]) left++;</span><br><span class="line">            <span class="keyword">else</span> right--;</span><br><span class="line">            ans=max(ans, min(height[left], height[right]) * (right-left));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a>31. 下一个排列</h2><p><strong>Description</strong><br>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。<br>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。<br>必须原地修改，只允许使用额外常数空间。</p>
<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1,2,3 → 1,3,2</span><br><span class="line">3,2,1 → 1,2,3</span><br><span class="line">1,1,5 → 1,5,1</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong><br><strong>思路</strong><br>（1）我们希望下一个数比当前数大，因此需要从后面选择一个较大的数跟前面的小数交换；<br>（2）而我们又希望下一个数增加的幅度尽可能小<br>（3）从后往前遍历，查找可能的较小大数与前面的小数交换；<br>算法过程：<br>（1）从后往前查找第一个相邻升序的元素对(i, j)，满足A[i]&lt;A[j]。<br>（2）[j,end)从后往前找第一个满足A[i]&lt;A[k]的k，二者交换；<br>（3）交换后，[j,end]肯定是降序的，所以只需要逆置就可以。<br>（4）注意已经是最大排列的情况。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> i=n<span class="number">-2</span>, j=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;nums[i]&gt;=nums[j]){</span><br><span class="line">            i--;j--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">int</span> k=n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(nums[i]&gt;=nums[k]) k--;</span><br><span class="line">            swap(nums[i], nums[k]);</span><br><span class="line">        }</span><br><span class="line">        reverse(nums.begin() + j, nums.end());</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h2><p><strong>Description</strong><br>写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。<br>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。<br>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。<br><strong>Example</strong><br>示例 1：<br>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p>
<p>示例 2：<br>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.size();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            swap(s[left], s[right]);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="面试题-16-06-最小差"><a href="#面试题-16-06-最小差" class="headerlink" title="面试题 16.06. 最小差"></a>面试题 16.06. 最小差</h2><p><strong>Description</strong><br>给定两个整数数组a和b，计算具有最小差绝对值的一对数值（每个数组中取一个值），并返回该对数值的差<br><strong>Example</strong><br>示例：<br>输入：{1, 3, 15, 11, 2}, {23, 127, 235, 19, 8}<br>输出： 3，即数值对(11, 8)<br>提示：<br>1 &lt;= a.length, b.length &lt;= 100000<br>-2147483648 &lt;= a[i], b[i] &lt;= 2147483647<br>正确结果在区间[-2147483648, 2147483647]内<br><strong>Program</strong><br><strong>排序+双指针</strong><br>详见代码</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">smallestDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>{</span><br><span class="line">        sort(a.begin(), a.end());</span><br><span class="line">        sort(b.begin(), b.end());</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m=a.size(), n=b.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res=LONG_LONG_MAX;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;m&amp;&amp;right&lt;n){</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> x = (<span class="keyword">long</span> <span class="keyword">long</span>)<span class="built_in">abs</span>((<span class="keyword">long</span> <span class="keyword">long</span>)a[left]-b[right]);</span><br><span class="line">            res=min(res, x);</span><br><span class="line">            <span class="keyword">if</span>(a[left]&lt;b[right]) left++;</span><br><span class="line">            <span class="keyword">else</span> right++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="面试题-17-11-单词距离"><a href="#面试题-17-11-单词距离" class="headerlink" title="面试题 17.11. 单词距离"></a>面试题 17.11. 单词距离</h2><p><strong>Description</strong><br>有个内含单词的超大文本文件，给定任意两个单词，找出在这个文件中这两个单词的最短距离(相隔单词数)。如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，你能对此优化吗?<br><strong>Example</strong><br>示例：<br>输入：words = [“I”,”am”,”a”,”student”,”from”,”a”,”university”,”in”,”a”,”city”], word1 = “a”, word2 = “student”<br>输出：1<br>提示：<br>words.length &lt;= 100000<br><strong>Program</strong><br><strong>哈希+双指针</strong><br>（1）哈希表建立重复单词出现的位置；<br>（2）双指针查找两个待查单词的索引数组（升序）：<br>由于索引数组有序，比较两个索引的时候，A[i]&lt;B[j]则i++，反之j++；这是因为要使得abs(A[i]-B[j])绝对值最小，较小的数组指针后移才能缩小。<br>时间复杂度：$O(m+n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>{</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">int</span> n=words.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            m[words[i]].push_back(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=INT_MAX;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m[word1].size()&amp;&amp;j&lt;m[word2].size()){</span><br><span class="line">            res=min(res, <span class="built_in">abs</span>(m[word1][i]-m[word2][j]));</span><br><span class="line">            <span class="keyword">if</span>(m[word1][i]&lt;m[word2][j]) i++;</span><br><span class="line">            <span class="keyword">else</span> j++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<h1 id="栈-字符串"><a href="#栈-字符串" class="headerlink" title="栈/字符串"></a>栈/字符串</h1></blockquote>
<h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a>32. 最长有效括号</h2><p><strong>Description</strong><br>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。<br><strong>Example</strong><br>示例 1:<br>输入: “(()”<br>输出: 2<br>解释: 最长有效括号子串为 “()”</p>
<p>示例 2:<br>输入: “)()())”<br>输出: 4<br>解释: 最长有效括号子串为 “()()”<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;<span class="comment">//保存最后一个不匹配的右括号或左括号</span></span><br><span class="line">        st.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'('</span>) st.push(i);</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">if</span>(!st.empty()) {</span><br><span class="line">                    ans=max(ans, i-st.top());</span><br><span class="line">                }<span class="keyword">else</span> st.push(i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a>43. 字符串相乘</h2><p><strong>Description</strong><br>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。<br><strong>Example</strong><br>示例 1:<br>输入: num1 = “2”, num2 = “3”<br>输出: “6”</p>
<p>示例 2:<br>输入: num1 = “123”, num2 = “456”<br>输出: “56088”<br>说明：<br>num1 和 num2 的长度小于110。<br>num1 和 num2 只包含数字 0-9。<br>num1 和 num2 均不以零开头，除非是数字 0 本身。<br>不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(num1==<span class="string">"0"</span>||num2==<span class="string">"0"</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">int</span> m=num1.length(), n=num2.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">        <span class="comment">//模拟乘法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">string</span> str;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=m<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--){</span><br><span class="line">                <span class="keyword">int</span> x=(num2[i]-<span class="string">'0'</span>)*(num1[j]-<span class="string">'0'</span>)+carry;</span><br><span class="line">                str+=x%<span class="number">10</span>+<span class="string">'0'</span>;</span><br><span class="line">                carry=x/<span class="number">10</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(carry!=<span class="number">0</span>) str+=carry+<span class="string">'0'</span>;</span><br><span class="line">            reverse(str.begin(), str.end());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(n<span class="number">-1</span>-i);k++) str+=<span class="string">'0'</span>;<span class="comment">//后缀补零</span></span><br><span class="line">            <span class="comment">// cout&lt;&lt;str&lt;&lt;" ";</span></span><br><span class="line">            vec.push_back(str);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//累加</span></span><br><span class="line">        <span class="built_in">string</span> res=vec[<span class="number">0</span>];</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;vec.size();i++){</span><br><span class="line">            <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> len1=res.length(), len2=vec[i].length();</span><br><span class="line">            <span class="keyword">int</span> idx1=<span class="number">0</span>, idx2=<span class="number">0</span>;</span><br><span class="line">            reverse(vec[i].begin(), vec[i].end());</span><br><span class="line">            <span class="built_in">string</span> str;</span><br><span class="line">            <span class="keyword">while</span>(idx1&lt;len1&amp;&amp;idx2&lt;len2){</span><br><span class="line">                <span class="keyword">int</span> x=res[idx1]-<span class="string">'0'</span>+vec[i][idx2]-<span class="string">'0'</span>+carry;</span><br><span class="line">                str+=x%<span class="number">10</span>+<span class="string">'0'</span>;</span><br><span class="line">                carry=x/<span class="number">10</span>;</span><br><span class="line">                idx1++, idx2++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span>(idx1&lt;len1){</span><br><span class="line">                <span class="keyword">int</span> x=res[idx1]-<span class="string">'0'</span>+carry;</span><br><span class="line">                str+=x%<span class="number">10</span>+<span class="string">'0'</span>;</span><br><span class="line">                carry=x/<span class="number">10</span>;</span><br><span class="line">                idx1++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span>(idx2&lt;len2){</span><br><span class="line">                <span class="keyword">int</span> x=vec[i][idx2]-<span class="string">'0'</span>+carry;</span><br><span class="line">                str+=x%<span class="number">10</span>+<span class="string">'0'</span>;</span><br><span class="line">                carry=x/<span class="number">10</span>;</span><br><span class="line">                idx2++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(carry!=<span class="number">0</span>) str+=carry+<span class="string">'0'</span>;</span><br><span class="line">            res=str;</span><br><span class="line">        }</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71. 简化路径"></a>71. 简化路径</h2><p><strong>Description</strong><br>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。<br>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径<br>请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。<br><strong>Example</strong><br>示例 1：<br>输入：”/home/“<br>输出：”/home”<br>解释：注意，最后一个目录名后面没有斜杠。</p>
<p>示例 2：<br>输入：”/../“<br>输出：”/“<br>解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。</p>
<p>示例 3：<br>输入：”/home//foo/“<br>输出：”/home/foo”<br>解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</p>
<p>示例 4：<br>输入：”/a/./b/../../c/“<br>输出：”/c”</p>
<p>示例 5：<br>输入：”/a/../../b/../c//.//“<br>输出：”/c”</p>
<p>示例 6：<br>输入：”/a//b////c/d//././/..”<br>输出：”/a/b/c”<br><strong>Program</strong><br><strong>思路</strong><br>首先，预处理字符串，剔除‘/’，然后通过栈（这里为了方便用双端队列）进行简化操作：</p>
<ul>
<li>①如果遇到’.’，不加入最终路径；</li>
<li>②如果遇到’..’，返回上一级目录，即从当前路径中删除最后一级目录（当前路径不是根目录，如果是根目录不变，这里用双端队列dq表示当前路径）；</li>
<li>③如果遇到一般的字符串，加入当前路径；<br>最后通过加入必要的’/‘得到最终简化的路径。<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">simplifyPath</span><span class="params">(<span class="built_in">string</span> path)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">int</span> n=path.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){ <span class="comment">//处理'/'之间的字符串，用str保存，如果str为空不加入数组vec</span></span><br><span class="line">            <span class="keyword">if</span>(path[i]==<span class="string">'/'</span>){</span><br><span class="line">                <span class="keyword">if</span>(str!=<span class="string">""</span>) vec.push_back(str);</span><br><span class="line">                str=<span class="string">""</span>;</span><br><span class="line">            }<span class="keyword">else</span> str+=path[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(path[n<span class="number">-1</span>]!=<span class="string">'/'</span>&amp;&amp;str!=<span class="string">""</span>) vec.push_back(str); <span class="comment">//最后一个字符串</span></span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; dq;<span class="comment">//用双端队列替换栈，方便操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(vec[i]==<span class="string">"."</span>) <span class="keyword">continue</span>; <span class="comment">//当前目录不加入栈</span></span><br><span class="line">            <span class="keyword">if</span>(vec[i]==<span class="string">".."</span>) {<span class="keyword">if</span>(dq.size()&gt;<span class="number">0</span>)dq.pop_back();<span class="keyword">continue</span>;} <span class="comment">//跳至上一目录</span></span><br><span class="line">            dq.push_back(vec[i]); <span class="comment">//加入目录</span></span><br><span class="line">        }</span><br><span class="line">        str=<span class="string">"/"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dq.size();i++){</span><br><span class="line">            str+=dq[i];</span><br><span class="line">            <span class="keyword">if</span>(i!=dq.size()<span class="number">-1</span>) str+=<span class="string">'/'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h2></li>
</ul>
<p><strong>Description</strong><br>根据 逆波兰表示法，求表达式的值。<br>有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p>说明：<br>整数除法只保留整数部分。<br>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。<br><strong>Example</strong><br>示例 1：<br>输入: [“2”, “1”, “+”, “3”, “*”]<br>输出: 9<br>解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</p>
<p>示例 2：<br>输入: [“4”, “13”, “5”, “/“, “+”]<br>输出: 6<br>解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</p>
<p>示例 3：<br>输入: [“10”, “6”, “9”, “3”, “+”, “-11”, “*”, “/“, “*”, “17”, “+”, “5”, “+”]<br>输出: 22<br>解释:<br>该算式转化为常见的中缀算术表达式为：<br>  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5<br>= ((10 * (6 / (12 * -11))) + 17) + 5<br>= ((10 * (6 / -132)) + 17) + 5<br>= ((10 * 0) + 17) + 5<br>= (0 + 17) + 5<br>= 17 + 5<br>= 22</p>
<p>逆波兰表达式：<br>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。<br>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。<br>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。<br>逆波兰表达式主要有以下两个优点：<br>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。<br>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sToi</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'-'</span>) {flag=<span class="number">-1</span>;str=str.substr(<span class="number">1</span>);}</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++) ans=ans*<span class="number">10</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">return</span> flag*ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="built_in">string</span> op)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">"+"</span>) <span class="keyword">return</span> a + b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">"-"</span>) <span class="keyword">return</span> a - b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">"*"</span>) <span class="keyword">return</span> a * b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> a / b;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(tokens.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> n=tokens.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(tokens[i]!=<span class="string">"+"</span>&amp;&amp;tokens[i]!=<span class="string">"-"</span>&amp;&amp;tokens[i]!=<span class="string">"*"</span>&amp;&amp;tokens[i]!=<span class="string">"/"</span>){</span><br><span class="line">                st.push(tokens[i]);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">int</span> a=sToi(st.top());st.pop();</span><br><span class="line">                <span class="keyword">int</span> b=sToi(st.top());st.pop();</span><br><span class="line">                <span class="keyword">int</span> res=cal(b,a ,tokens[i]); <span class="comment">//注意顺序</span></span><br><span class="line">                st.push(to_string(res));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sToi(st.top());</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="214-最短回文串"><a href="#214-最短回文串" class="headerlink" title="214. 最短回文串"></a>214. 最短回文串</h2><p><strong>Description</strong><br>给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。<br><strong>Example</strong><br>示例 1:<br>输入: “aacecaaa”<br>输出: “aaacecaaa”</p>
<p>示例 2:<br>输入: “abcd”<br>输出: “dcbabcd”<br><strong>Program</strong><br><strong>暴力</strong><br>找前缀为最长回文的位置，然后拼接！<br>时间复杂度：$O(n^2)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPass</span><span class="params">(<span class="built_in">string</span>&amp; str ,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">if</span>(str[left]!=str[right]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">if</span>(isPass(s, <span class="number">0</span>, i)){</span><br><span class="line">                <span class="built_in">string</span> res=s.substr(i+<span class="number">1</span>);</span><br><span class="line">                reverse(res.begin(), res.end());</span><br><span class="line">                <span class="keyword">return</span> res + s;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>KMP的next前后缀求法</strong><br>首先一个字符串与其逆串拼接肯定是回文串，问题使未必是最小！！<br>例如：s=abcd与rs=dcba，拼接为dcbaabcd，明显有冗余，冗余的部分为s前缀和rs后缀公共的部分！<br>那么需要求出这个公共部分最大的部分剔除就是答案了！<br>那么怎么求呢？<br>s+rs=abcddcba，要求最大重叠前后缀，与KMP的next数组一致！！！<br>但是得注意这里直接拼接s+rs会导致可能最长前后缀长度超过原本s的长度，所以中间插入”#”即可，即s+”#”+rs=abcd#dcba，再来求其最长重叠前后缀，就是next数组计算了！<br>时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="built_in">string</span> rs=s;</span><br><span class="line">        reverse(rs.begin(), rs.end());</span><br><span class="line">        <span class="built_in">string</span> str=s+<span class="string">"#"</span>+rs;</span><br><span class="line">        n=str.length();</span><br><span class="line">        <span class="keyword">int</span> next[n];</span><br><span class="line">        next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;str[i]!=str[j+<span class="number">1</span>]){</span><br><span class="line">                j=next[j];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(str[i]==str[j+<span class="number">1</span>]) j++;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> rs+s.substr(next[n<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="316-去除重复字母"><a href="#316-去除重复字母" class="headerlink" title="316. 去除重复字母"></a>316. 去除重复字母</h2><p><strong>Description</strong><br>给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。<br>注意：该题与 1081 <a href="https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters</a> 相同<br><strong>Example</strong><br>示例 1：<br>输入：s = “bcabc”<br>输出：”abc”</p>
<p>示例 2：<br>输入：s = “cbacdcbc”<br>输出：”acdb”</p>
<p>提示：<br>1 &lt;= s.length &lt;= 104<br>s 由小写英文字母组成<br><strong>Program</strong><br><strong>思路</strong><br>题意需要三个条件：<br>（1）去重；<br>（2）相对位置不变；<br>（3）字典序最小；<br>由前两个条件只需要维护一个单调栈，遇到更小的字母，前面较大的字母出栈，即可，注意判重；<br>第三个条件则需要在出栈时检查即将出栈的元素是否后续没有该字母，如果是，不出栈，否则出栈。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> cnt[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> vis[<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        fill(vis, vis+<span class="number">26</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:s) cnt[ch-<span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++){</span><br><span class="line">            <span class="keyword">if</span>(cnt[i]&gt;<span class="number">0</span>) vis[i]=<span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; stk; <span class="comment">//单调栈</span></span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">while</span>(!vis[s[i]-<span class="string">'a'</span>]&amp;&amp;!stk.empty()&amp;&amp;stk.top()&gt;s[i]&amp;&amp;cnt[stk.top()-<span class="string">'a'</span>]&gt;<span class="number">0</span>){</span><br><span class="line">                vis[stk.top()-<span class="string">'a'</span>]=<span class="literal">false</span>;</span><br><span class="line">                stk.pop();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(!vis[s[i]-<span class="string">'a'</span>]){</span><br><span class="line">                vis[s[i]-<span class="string">'a'</span>]=<span class="literal">true</span>;</span><br><span class="line">                stk.push(s[i]);</span><br><span class="line">            }</span><br><span class="line">            cnt[s[i]-<span class="string">'a'</span>]--;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty()){</span><br><span class="line">            res+=stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">        }</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="321-拼接最大数"><a href="#321-拼接最大数" class="headerlink" title="321. 拼接最大数"></a>321. 拼接最大数</h2><p><strong>Description</strong><br>给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k &lt;= m + n) 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。<br>求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。<br>说明: 请尽可能地优化你算法的时间和空间复杂度。<br><strong>Example</strong><br>示例 1:<br>输入:<br>nums1 = [3, 4, 6, 5]<br>nums2 = [9, 1, 2, 5, 8, 3]<br>k = 5<br>输出:<br>[9, 8, 6, 5, 3]</p>
<p>示例 2:<br>输入:<br>nums1 = [6, 7]<br>nums2 = [6, 0, 4]<br>k = 5<br>输出:<br>[6, 7, 6, 0, 4]</p>
<p>示例 3:<br>输入:<br>nums1 = [3, 9]<br>nums2 = [8, 9]<br>k = 3<br>输出:<br>[9, 8, 9]<br><strong>Program</strong><br><strong>单调栈</strong><br>（1）老套路，与但数组下求保留k个数要求序列最大类似，这里为两个数组；<br>（2）分治：第一个数组保留i个，第二个数组保留k-i个，使得各自满足最大序列；<br>（3）合并：这里不同于归并排序的直接比较两个数组索引下的单个值，而需要考虑字典序最大！即取字典序较大的数组的头元素！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="keyword">int</span> j)</span></span>{ <span class="comment">//比较A的字典序是否比B大</span></span><br><span class="line">        <span class="keyword">if</span>(j&gt;=B.size()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=A.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(A[i]&gt;B[j]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;B[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> compare(A, i+<span class="number">1</span>, B, j+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; merge(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B){</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> m=A.size(), n=B.size();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m&amp;&amp;j&lt;n){</span><br><span class="line">            <span class="comment">// if(!lexicographical_compare(A.begin()+i, A.end(), B.begin()+j, B.end())) res.push_back(A[i++]); //按字典序比较两个序列，大的进队</span></span><br><span class="line">            <span class="comment">// else res.push_back(B[j++]);</span></span><br><span class="line">            <span class="keyword">if</span>(compare(A, i, B, j)) res.push_back(A[i++]); <span class="comment">//按字典序比较两个序列，大的进队</span></span><br><span class="line">            <span class="keyword">else</span> res.push_back(B[j++]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m) res.push_back(A[i++]);</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n) res.push_back(B[j++]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; select(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k){</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">while</span>(!dq.empty()&amp;&amp;dq.back()&lt;nums[i]&amp;&amp;dq.size()+n-i&gt;k){</span><br><span class="line">                dq.pop_back();</span><br><span class="line">            }</span><br><span class="line">            dq.push_back(nums[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(dq.begin(), dq.begin()+k);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxNumber(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">int</span> m=nums1.size(), n=nums2.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++){</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=m&amp;&amp;k-i&lt;=n){</span><br><span class="line">                vec=max(vec, merge(select(nums1, i), select(nums2, k-i)));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="331-验证二叉树的前序序列化"><a href="#331-验证二叉树的前序序列化" class="headerlink" title="331. 验证二叉树的前序序列化"></a>331. 验证二叉树的前序序列化</h2><p><strong>Description</strong><br>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _9_</span><br><span class="line">    /   \</span><br><span class="line">   3     2</span><br><span class="line">  / \   / \</span><br><span class="line"> 4   1  #  6</span><br><span class="line">/ \ / \   / \</span><br><span class="line"># # # #   # #</span><br></pre></td></tr></tbody></table></figure>
<p>例如，上面的二叉树可以被序列化为字符串 “9,3,4,#,#,1,#,#,2,#,6,#,#”，其中 # 代表一个空节点。<br>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p>
<p>每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 ‘#’ 。<br>你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 “1,,3” 。<br><strong>Example</strong><br>示例 1:<br>输入: “9,3,4,#,#,1,#,#,2,#,6,#,#”<br>输出: true</p>
<p>示例 2:<br>输入: “1,#”<br>输出: false</p>
<p>示例 3:<br>输入: “9,#,#,1”<br>输出: false<br><strong>Program</strong><br><strong>利用前序的特性，无需考虑数据</strong><br>一个正确的二查数据结构，空节点数目=非空节点数目+1，其中空节点就是指”#”。<br>所以考虑前序遍历先跟后左右子树的特性，遇到数字就push，遇到“#”就pop，这一点与前序遍历的非递归栈实现相同（先遍历到左子树最左边的节点，当为空时就pop，这里就相当于遇到“#”就pop掉当前根结点，然后进入当前右子树）。</p>
<ul>
<li>遇到“#”，如果栈为空，return i == n-1，即判断是否是最后一个，是则为正确结构，否则错误；</li>
<li>遇到数字，push即可。<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSerialization</span><span class="params">(<span class="built_in">string</span> preorder)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=preorder.length();</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(preorder[i]==<span class="string">'#'</span>){</span><br><span class="line">                <span class="keyword">if</span>(st.empty()) <span class="keyword">return</span> i==n<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span>{</span><br><span class="line">                    st.pop();</span><br><span class="line">                    i++;<span class="comment">//跳过逗号</span></span><br><span class="line">                }</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">while</span>(i&lt;n&amp;&amp;preorder[i]!=<span class="string">','</span>) i++; <span class="comment">//需要跳过逗号分隔符</span></span><br><span class="line">                st.push(<span class="number">0</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="385-迷你语法分析器"><a href="#385-迷你语法分析器" class="headerlink" title="385. 迷你语法分析器"></a>385. 迷你语法分析器</h2></li>
</ul>
<p><strong>Description</strong><br>给定一个用字符串表示的整数的嵌套列表，实现一个解析它的语法分析器。<br>列表中的每个元素只可能是整数或整数嵌套列表<br>提示：你可以假定这些字符串都是格式良好的：</p>
<ul>
<li>字符串非空</li>
<li>字符串不包含空格</li>
<li>字符串只包含数字0-9、[、-、,、]</li>
</ul>
<p><strong>Example</strong><br>示例 1：<br>给定 s = “324”,<br>你应该返回一个 NestedInteger 对象，其中只包含整数值 324。</p>
<p>示例 2：<br>给定 s = “[123,[456,[789]]]”,<br>返回一个 NestedInteger 对象包含一个有两个元素的嵌套列表：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 一个 integer 包含值 123</span><br><span class="line">2. 一个包含两个元素的嵌套列表：</span><br><span class="line">    i.  一个 integer 包含值 456</span><br><span class="line">    ii. 一个包含一个元素的嵌套列表</span><br><span class="line">         a. 一个 integer 包含值 789</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong><br><strong>字符串处理+栈</strong><br>（1）字符串是纯数字，直接返回NestInteger的单整数版本；<br>（2）如果遇到“[”，则表示需要嵌套整数，即必须将默认的单整数版本通过add()转成嵌套链表，<strong>即使遇到”[]”这种也要转!</strong>，然后将其压入栈<br>（3）每次遇到“,”，判断当前str是否为空，不为空表示就是数字，栈顶嵌套链表add()加入该单整数版本的NestedInteger；<br>（4）如果遇到“]”：<br>①如果str非空，需要将其作为NestInteger通过add()加入栈顶嵌套链表；<br>②如果栈元素个数多余1，则需要将栈顶元素出栈，新的栈顶元素add()昂刚出栈的栈顶元素，完成嵌套链表合并。<br>因为例如”[123,456,[788,799,833],[[]],10,[]]”，在833后的第一个”]”就需要先合并两个嵌套，使得栈顶元素降维下一层。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger {</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes an empty nested list.</span></span><br><span class="line"><span class="comment"> *     NestedInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes a single integer.</span></span><br><span class="line"><span class="comment"> *     NestedInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a single integer.</span></span><br><span class="line"><span class="comment"> *     void setInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.</span></span><br><span class="line"><span class="comment"> *     void add(const NestedInteger &amp;ni);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sToi</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'-'</span>){</span><br><span class="line">            flag=<span class="number">-1</span>;</span><br><span class="line">            str=str.substr(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++){</span><br><span class="line">            ans=ans*<span class="number">10</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> flag*ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">NestedInteger <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">""</span>) <span class="keyword">return</span> NestedInteger();</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]!=<span class="string">'['</span>) <span class="keyword">return</span> NestedInteger(sToi(s));</span><br><span class="line">        <span class="built_in">stack</span>&lt;NestedInteger&gt; st;</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="built_in">string</span> str=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'['</span>){</span><br><span class="line">                <span class="comment">//同一层次嵌套中，如果是数字添加，如果是新的嵌套链表，push下一层</span></span><br><span class="line">                st.push(NestedInteger());</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">'-'</span>||(s[i]&gt;=<span class="string">'0'</span>&amp;&amp;s[i]&lt;=<span class="string">'9'</span>)){</span><br><span class="line">                str+=s[i];</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">','</span>&amp;&amp;str!=<span class="string">""</span>){ <span class="comment">//非空是因为逗号可能是在"]"后</span></span><br><span class="line">                st.top().add(NestedInteger(sToi(str)));</span><br><span class="line">                str=<span class="string">""</span>;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">']'</span>){</span><br><span class="line">                <span class="keyword">if</span>(str!=<span class="string">""</span>){</span><br><span class="line">                    st.top().add(NestedInteger(sToi(str)));</span><br><span class="line">                    str=<span class="string">""</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(st.size()&gt;<span class="number">1</span>){ <span class="comment">//遇到"]"需要合并嵌套，如果可以的话</span></span><br><span class="line">                    NestedInteger now=st.top();st.pop();</span><br><span class="line">                    st.top().add(now);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> st.top();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a>394. 字符串解码</h2><p><strong>Description</strong><br>给定一个经过编码的字符串，返回它解码后的字符串。<br>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。<br>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。<br>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。<br><strong>Example</strong><br>示例 1：<br>输入：s = “3[a]2[bc]”<br>输出：”aaabcbc”</p>
<p>示例 2：<br>输入：s = “3[a2[c]]”<br>输出：”accaccacc”</p>
<p>示例 3：<br>输入：s = “2[abc]3[cd]ef”<br>输出：”abcabccdcdcdef”</p>
<p>示例 4：<br>输入：s = “abc3[cd]xyz”<br>输出：”abccdcdcdxyz”<br><strong>Program</strong><br><strong>思路</strong><br>（1）遍历字符串，遇到数字就开始处理该满足编码规则的字符串：</p>
<ul>
<li>先处理数字；</li>
<li>后处理[]内的字符串，这里很容易想到递归处理，因为[]内的字符串也是一个有效的字符串，也需要解码！但是需要注意[]内可能有嵌套！</li>
<li>重复k次；<br>（2）输出结果<br>时间复杂度：$O(N+n)$，N为解码后的字符串长度，n为原字符串长度。<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sToi</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++){</span><br><span class="line">            ans=ans*<span class="number">10</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(s[i]&gt;=<span class="string">'0'</span>&amp;&amp;s[i]&lt;=<span class="string">'9'</span>){</span><br><span class="line">                <span class="built_in">string</span> numStr;</span><br><span class="line">                <span class="keyword">while</span>(s[i]&gt;=<span class="number">0</span>&amp;&amp;s[i]&lt;=<span class="string">'9'</span>){ <span class="comment">//处理数字</span></span><br><span class="line">                    numStr+=s[i];</span><br><span class="line">                    i++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">int</span> start=i; <span class="comment">//[坐标</span></span><br><span class="line">                <span class="keyword">int</span> nBracket=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(i&lt;n){ <span class="comment">//处理数字后的第一个[]，这里得注意可能有嵌套[]，故需要类似栈的判断</span></span><br><span class="line">                    <span class="keyword">if</span>(s[i]==<span class="string">'['</span>) nBracket++;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">']'</span>) nBracket--;</span><br><span class="line">                    <span class="keyword">if</span>(nBracket==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                }</span><br><span class="line">                <span class="built_in">string</span> str=decodeString(s.substr(start+<span class="number">1</span>, i-start<span class="number">-1</span>));<span class="comment">//递归</span></span><br><span class="line">                <span class="keyword">int</span> k=sToi(numStr);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++) res+=str;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                res+=s[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="456-132模式"><a href="#456-132模式" class="headerlink" title="456. 132模式"></a>456. 132模式</h2></li>
</ul>
<p><strong>Description</strong><br>给定一个整数序列：a1, a2, …, an，一个132模式的子序列 ai, aj, ak 被定义为：当 i &lt; j &lt; k 时，ai &lt; ak &lt; aj。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。<br>注意：n 的值小于15000。<br><strong>Example</strong><br>示例1:<br>输入: [1, 2, 3, 4]<br>输出: False<br>解释: 序列中不存在132模式的子序列。</p>
<p>示例 2:<br>输入: [3, 1, 4, 2]<br>输出: True<br>解释: 序列中有 1 个132模式的子序列： [1, 4, 2].</p>
<p>示例 3:<br>输入: [-1, 3, 2, 0]<br>输出: True<br>解释: 序列中有 3 个132模式的的子序列: [-1, 3, 2], [-1, 3, 0] 和 [-1, 2, 0].<br><strong>Program</strong><br><strong>单调递减栈</strong><br>（1）维护一个数组minVec，minVec[i]表示在截止到索引i时的当前最小值，因为需要$a_i&lt;a_k&lt;a_j$，贪心的希望a_i越小越好；<br>（2）对$i&lt;j&lt;k$，需要$a_i&lt;a_k&lt;a_j$，那么考虑位置$j$，将数组分成左右两部分$[0,j-1],[j+1,n-1]$，由(1)可以找到左边小于nums[j]的值，那么只需要判断右边[j+1,n-1]这部分是否存在满足$a_i&lt;a_k&lt;a_j$的$k$。<br>（3）从左往右遍历不好操作，那么考虑从右往左遍历；<br>对于$j$，满足$a_i&lt;a_k&lt;a_j$的nums[i]就是minVec[j]，即需要满足minVec[j]&lt;nums[j]。那么右边也就是先遍历的部分nums[k]需要满足$minVec[j]&lt;nums[k]&lt;nums[j]$，这些nums[k]就是我们需要维护的部分，<strong>假设有这么个数据结构存储这一部分，那么只要找到一个就说明存在132模式，直接返回即可！</strong> 否则，即minVec[j]==nums[j]（由于minVec的性质，不可能大于），不可能满足直接跳过。<br>（4）现在考虑如何维护这一部分。</p>
<ul>
<li>①首先这一部分需要尽可能小，但是要先满足$minVec[j]&lt;nums[k]$，不满足直接丢弃不满足此条件的那些nums[k]；</li>
<li>②然后看是否满足$nums[k]&lt;nums[j]$，如果满足直接返回，否则，即$nums[k]&gt;=nums[j]$，那么nums[j]就是上一步我们所说的尽可能小的部分，需要保留，那么原本维护的nums[k]呢？我们知道从右往左遍历，minVec[j]是递增的，那么当前保留的尽可能小的nums[j]只是满足当前的$minVec[j]&lt;nums[j]&lt;=nums[k]$，对于下一个minVec[j-1]就不一定满足$minVec[j]&lt;nums[j]$了！所以也需要保留满足①的那部分nums[k]。<br>（5）好了，现在我们知道需要维护相对于j的哪一部分nums[k]了，其实已经基本出来了数据结构了——单调递减栈！<br>时间复杂度：$O(n)$<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minVec;<span class="comment">//minVec[i]为截止目前i索引所得最小值</span></span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        minVec.push_back(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) minVec.push_back(min(minVec.back(), nums[i]));</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; desSt;<span class="comment">//单调递减栈</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">if</span>(minVec[i]&lt;nums[i]){</span><br><span class="line">                <span class="keyword">while</span>(!desSt.empty()&amp;&amp;minVec[i]&gt;=desSt.top()) desSt.pop();<span class="comment">//所有小于等于minVec[i]的都出栈</span></span><br><span class="line">                <span class="keyword">if</span>(!desSt.empty()&amp;&amp;desSt.top()&lt;nums[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                desSt.push(nums[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a>459. 重复的子字符串</h2></li>
</ul>
<p><strong>Description</strong><br>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。<br><strong>Example</strong><br>示例 1:<br>输入: “abab”<br>输出: True<br>解释: 可由子字符串 “ab” 重复两次构成。</p>
<p>示例 2:<br>输入: “aba”<br>输出: False</p>
<p>示例 3:<br>输入: “abcabcabcabc”<br>输出: True<br>解释: 可由子字符串 “abc” 重复四次构成。 (或者子字符串 “abcabc” 重复两次构成。)<br><strong>Program</strong><br><strong>思路</strong><br>如果s满足题目要求，那么s至少由其子串重复两次，那么两个s拼接后出去首尾各一个字符，如果该字符串中能够找到s，说明s满足题意。<br>时间复杂度：$O(mn)$。</p>
<ul>
<li>KMP 算法虽然有着良好的理论时间复杂度上限，但大部分语言自带的字符串查找函数并不是用 KMP 算法实现的。这是因为在实现 API 时，我们需要在平均时间复杂度和最坏时间复杂度二者之间权衡。普通的暴力匹配算法以及优化的 BM 算法拥有比 KMP 算法更为优秀的平均时间复杂度；<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="built_in">string</span> str=s+s;</span><br><span class="line">        str=str.substr(<span class="number">1</span>, <span class="number">2</span>*n<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">return</span> str.find(s)!=<span class="built_in">string</span>::npos;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p><strong>KMP</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getNext(<span class="keyword">const</span> <span class="built_in">string</span>&amp; pattern){ <span class="comment">//求pattern的[0,i]的最长前后缀，next[i]表示[0,i]最长前后缀的下标k,即[0,k]==[k+1,i]，其中i&gt;k，不匹配则为-1</span></span><br><span class="line">        <span class="keyword">int</span> n=pattern.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(n, <span class="number">0</span>);</span><br><span class="line">        next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;pattern[i]!=pattern[j+<span class="number">1</span>]){ <span class="comment">//i与j+1失配，回退j</span></span><br><span class="line">                j=next[j];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(pattern[i]==pattern[j+<span class="number">1</span>]) j++;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">KMP</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; text, <span class="keyword">const</span> <span class="built_in">string</span>&amp; pattern)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> n=text.length(), m=pattern.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next=getNext(pattern);</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;text[i]!=pattern[j+<span class="number">1</span>]){</span><br><span class="line">                j=next[j];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(text[i]==pattern[j+<span class="number">1</span>]) j++;</span><br><span class="line">            <span class="keyword">if</span>(j==m<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="built_in">string</span> str=s+s;</span><br><span class="line">        str=str.substr(<span class="number">1</span>, <span class="number">2</span>*n<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">return</span> KMP(str, s);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a>496. 下一个更大元素 I</h2><p><strong>Description</strong><br>给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。<br>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。<br><strong>Example</strong><br>示例 1:<br>输入: nums1 = [4,1,2], nums2 = [1,3,4,2].<br>输出: [-1,3,-1]<br>解释:<br>    对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。<br>    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。<br>    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。</p>
<p>示例 2:<br>输入: nums1 = [2,4], nums2 = [1,2,3,4].<br>输出: [3,-1]<br>解释:<br>    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。<br>    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</p>
<p>提示：<br>nums1和nums2中所有元素是唯一的。<br>nums1和nums2 的数组大小都不超过1000。<br><strong>Program</strong><br><strong>暴力</strong><br>时间复杂度：$O(n^2)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextGreaterElement(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) {</span><br><span class="line">        <span class="keyword">int</span> m=nums1.size(), n=nums2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(m, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">bool</span> isFind=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">if</span>(!isFind){</span><br><span class="line">                    <span class="keyword">if</span>(nums1[i]==nums2[j]) isFind=<span class="literal">true</span>;</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    <span class="keyword">if</span>(nums1[i]&lt;nums2[j]){</span><br><span class="line">                        res[i]=nums2[j];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>单调栈</strong><br>Next Greater Element问题模板。<br>时间复杂度：$O(m+n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextGreaterElement(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) {</span><br><span class="line">        <span class="keyword">int</span> m=nums1.size(), n=nums2.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">while</span>(!st.empty()&amp;&amp;st.top()&lt;nums2[i]) st.pop();</span><br><span class="line">            mp[nums2[i]]=st.empty()?<span class="number">-1</span>:st.top();</span><br><span class="line">            st.push(nums2[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            res.push_back(mp[nums1[i]]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a>503. 下一个更大元素 II</h2><p><strong>Description</strong><br>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。<br><strong>Example</strong><br>示例 1:<br>输入: [1,2,1]<br>输出: [2,-1,2]<br>解释: 第一个 1 的下一个更大的数是 2；<br>数字 2 找不到下一个更大的数；<br>第二个 1 的下一个最大的数需要循环搜索，结果也是 2。<br>注意: 输入数组的长度不会超过 10000。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextGreaterElements(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums) vec.push_back(x);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr(vec.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=vec.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">while</span>(!st.empty()&amp;&amp;st.top()&lt;=vec[i]) st.pop();</span><br><span class="line">            arr[i]=st.empty()?<span class="number">-1</span>:st.top();</span><br><span class="line">            st.push(vec[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++) res.push_back(arr[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextGreaterElements(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">while</span>(!st.empty()&amp;&amp;st.top()&lt;=nums[i%n]) st.pop();</span><br><span class="line">            res[i%n]=st.empty()?<span class="number">-1</span>:st.top();</span><br><span class="line">            st.push(nums[i%n]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="557-反转字符串中的单词-III"><a href="#557-反转字符串中的单词-III" class="headerlink" title="557. 反转字符串中的单词 III"></a>557. 反转字符串中的单词 III</h2><p><strong>Description</strong><br>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。<br><strong>Example</strong><br>示例：<br>输入：”Let’s take LeetCode contest”<br>输出：”s’teL ekat edoCteeL tsetnoc”</p>
<p>提示：<br>在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> prePos=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> pos=s.find_first_of(<span class="string">" "</span>, prePos+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(pos!=<span class="built_in">string</span>::npos){</span><br><span class="line">            <span class="built_in">string</span> str=s.substr(prePos+<span class="number">1</span>, pos-prePos<span class="number">-1</span>);</span><br><span class="line">            reverse(str.begin(), str.end());</span><br><span class="line">            res+=str+<span class="string">" "</span>;</span><br><span class="line">            prePos=pos;</span><br><span class="line">            pos=s.find_first_of(<span class="string">" "</span>, prePos+<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">string</span> str=s.substr(prePos+<span class="number">1</span>, n-prePos<span class="number">-1</span>);</span><br><span class="line">        reverse(str.begin(), str.end());</span><br><span class="line">        res+=str;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="636-函数的独占时间"><a href="#636-函数的独占时间" class="headerlink" title="636. 函数的独占时间"></a>636. 函数的独占时间</h2><p><strong>Description</strong><br>给出一个非抢占单线程CPU的 n 个函数运行日志，找到函数的独占时间。<br>每个函数都有一个唯一的 Id，从 0 到 n-1，函数可能会递归调用或者被其他函数调用。<br>日志是具有以下格式的字符串：function_id：start_or_end：timestamp。例如：”0:start:0” 表示函数 0 从 0 时刻开始运行。”0<span class="github-emoji"><span>🔚</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f51a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>0” 表示函数 0 在 0 时刻结束。<br>函数的独占时间定义是在该方法中花费的时间，调用其他函数花费的时间不算该函数的独占时间。你需要根据函数的 Id 有序地返回每个函数的独占时间。<br><strong>Example</strong><br>示例 1:<br>输入:<br>n = 2<br>logs =<br>[“0:start:0”,<br> “1:start:2”,<br> “1<span class="github-emoji"><span>🔚</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f51a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>5”,<br> “0<span class="github-emoji"><span>🔚</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f51a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>6”]<br>输出:[3, 4]<br>说明：<br>函数 0 在时刻 0 开始，在执行了  2个时间单位结束于时刻 1。<br>现在函数 0 调用函数 1，函数 1 在时刻 2 开始，执行 4 个时间单位后结束于时刻 5。<br>函数 0 再次在时刻 6 开始执行，并在时刻 6 结束运行，从而执行了 1 个时间单位。<br>所以函数 0 总共的执行了 2 +1 =3 个时间单位，函数 1 总共执行了 4 个时间单位。</p>
<p>说明：<br>输入的日志会根据时间戳排序，而不是根据日志Id排序。<br>你的输出会根据函数Id排序，也就意味着你的输出数组中序号为 0 的元素相当于函数 0 的执行时间。<br>两个函数不会在同时开始或结束。<br>函数允许被递归调用，直到运行结束。<br>1 &lt;= n &lt;= 100<br><strong>Program</strong><br><strong>栈</strong><br>（1）首先，整体思路肯定是栈，遇到start就入栈，遇到end就出栈，计算时间；<br>（2）关键问题在于同一个id的开始结束之中有其他id(可能与自己相同)的函数，且有可能是顺序的也可能是嵌套的;<br>（3）形象的用括号表示“[[[[], []]],[],[]]”，其中每一对“[]”表示函数调用开始和结束，例如我们计算最外层的函数所学时间，必须记录其中顺序包含的每个子“[]”所独占时间，最终最外层独占时间是其起始结束之差再减去子函数所占时间，同理，每个子函数所独占时间也是这么算的！<br>（4）除了栈外，我们需要记录子函数占用时间：用一个结构体记录id，起始时间戳，子函数占用时间。同时用数组记录每次一个函数独占时间<br>（5）算法过程：<br>①遇到start入栈；<br>②遇到end出栈：</p>
<ul>
<li>如果栈非空，刚出栈的调用时间加入栈顶元素的substime中，表示栈顶函数调用了刚刚出栈的函数，需要记录其所占时间（非独占）；</li>
<li>无论栈空否，刚出栈的函数调用完毕，计算其独占时间：end-start+1-subtime，即自身函数占用时间-其调用子函数调用的时间，将其通过数组进行累加（因为可能会递归调用自身）。</li>
</ul>
<p>时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> id, timestamp, subtime;<span class="comment">//函数id,开始时间戳，调用其他函数所占时间</span></span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> _id, <span class="keyword">int</span> _timestamp, <span class="keyword">int</span> _subtime)</span><br><span class="line">            :id(_id),timestamp(_timestamp),subtime(_subtime){}</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sToi</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++) ans=ans*<span class="number">10</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; exclusiveTime(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; logs) {</span><br><span class="line">        <span class="built_in">stack</span>&lt;Node&gt; st;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;logs.size();i++){</span><br><span class="line">            <span class="keyword">int</span> pos1 = logs[i].find_first_of(<span class="string">':'</span>);</span><br><span class="line">            <span class="keyword">int</span> pos2 = logs[i].find_first_of(<span class="string">':'</span>, pos1+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> id=sToi(logs[i].substr(<span class="number">0</span>, pos1));</span><br><span class="line">            <span class="keyword">int</span> timestamp=sToi(logs[i].substr(pos2+<span class="number">1</span>));</span><br><span class="line">            <span class="built_in">string</span> str=logs[i].substr(pos1+<span class="number">1</span>, pos2-pos1<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(str==<span class="string">"start"</span>) st.push(Node(id, timestamp, <span class="number">0</span>));</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                Node node=st.top();st.pop();</span><br><span class="line">                <span class="keyword">if</span>(!st.empty()) st.top().subtime+=timestamp-node.timestamp+<span class="number">1</span>;</span><br><span class="line">                res[node.id]+=timestamp-node.timestamp+<span class="number">1</span>-node.subtime;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="657-机器人能否返回原点"><a href="#657-机器人能否返回原点" class="headerlink" title="657. 机器人能否返回原点"></a>657. 机器人能否返回原点</h2><p><strong>Description</strong><br>在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。<br>移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。<br>注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。<br><strong>Example</strong><br>示例 1:<br>输入: “UD”<br>输出: true<br>解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。</p>
<p>示例 2:<br>输入: “LL”<br>输出: false<br>解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> steps[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,<span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>,<span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>,<span class="number">0</span></span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeCircle</span><span class="params">(<span class="built_in">string</span> moves)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=moves.length();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;m;</span><br><span class="line">        m[<span class="string">'R'</span>]=<span class="number">0</span>;</span><br><span class="line">        m[<span class="string">'L'</span>]=<span class="number">1</span>;</span><br><span class="line">        m[<span class="string">'U'</span>]=<span class="number">2</span>;</span><br><span class="line">        m[<span class="string">'D'</span>]=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        x=y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            x+=steps[m[moves[i]]][<span class="number">0</span>];</span><br><span class="line">            y+=steps[m[moves[i]]][<span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="682-棒球比赛"><a href="#682-棒球比赛" class="headerlink" title="682. 棒球比赛"></a>682. 棒球比赛</h2><p><strong>Description</strong><br>你现在是棒球比赛记录员。<br>给定一个字符串列表，每个字符串可以是以下四种类型之一：<br>1.整数（一轮的得分）：直接表示您在本轮中获得的积分数。<br>2. “+”（一轮的得分）：表示本轮获得的得分是前两轮有效 回合得分的总和。<br>3. “D”（一轮的得分）：表示本轮获得的得分是前一轮有效 回合得分的两倍。<br>4. “C”（一个操作，这不是一个回合的分数）：表示您获得的最后一个有效 回合的分数是无效的，应该被移除。</p>
<p>每一轮的操作都是永久性的，可能会对前一轮和后一轮产生影响。<br>你需要返回你在所有回合中得分的总和。<br><strong>Example</strong><br>示例 1:<br>输入: [“5”,”2”,”C”,”D”,”+”]<br>输出: 30<br>解释:<br>第1轮：你可以得到5分。总和是：5。<br>第2轮：你可以得到2分。总和是：7。<br>操作1：第2轮的数据无效。总和是：5。<br>第3轮：你可以得到10分（第2轮的数据已被删除）。总数是：15。<br>第4轮：你可以得到5 + 10 = 15分。总数是：30。</p>
<p>示例 2:<br>输入: [“5”,”-2”,”4”,”C”,”D”,”9”,”+”,”+”]<br>输出: 27<br>解释:<br>第1轮：你可以得到5分。总和是：5。<br>第2轮：你可以得到-2分。总数是：3。<br>第3轮：你可以得到4分。总和是：7。<br>操作1：第3轮的数据无效。总数是：3。<br>第4轮：你可以得到-4分（第三轮的数据已被删除）。总和是：-1。<br>第5轮：你可以得到9分。总数是：8。<br>第6轮：你可以得到-4 + 9 = 5分。总数是13。<br>第7轮：你可以得到9 + 5 = 14分。总数是27。<br>注意：<br>输入列表的大小将介于1和1000之间。<br>列表中的每个整数都将介于-30000和30000之间。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sToi</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'-'</span>){</span><br><span class="line">            flag=<span class="number">-1</span>;</span><br><span class="line">            str=str.substr(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++) ans=ans*<span class="number">10</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">return</span> ans*flag;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ops)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; st;<span class="comment">//栈</span></span><br><span class="line">        <span class="keyword">int</span> n=ops.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(ops[i]==<span class="string">"C"</span>){</span><br><span class="line">                st.pop_back();</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(ops[i]==<span class="string">"D"</span>){</span><br><span class="line">                st.push_back(st.back()*<span class="number">2</span>);</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(ops[i]==<span class="string">"+"</span>){</span><br><span class="line">                <span class="keyword">int</span> len=st.size();</span><br><span class="line">                st.push_back(st[len<span class="number">-1</span>]+st[len<span class="number">-2</span>]);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                st.push_back(sToi(ops[i]));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> res=accumulate(st.begin(), st.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="696-计数二进制子串"><a href="#696-计数二进制子串" class="headerlink" title="696. 计数二进制子串"></a>696. 计数二进制子串</h2><p><strong>Description</strong><br>给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。<br>重复出现的子串要计算它们出现的次数。<br><strong>Example</strong><br>示例 1 :<br>输入: “00110011”<br>输出: 6<br>解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。<br>请注意，一些重复出现的子串要计算它们出现的次数。</p>
<p>另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。</p>
<p>示例 2 :<br>输入: “10101”<br>输出: 4<br>解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。<br>注意：<br>s.length 在1到50,000之间。<br>s 只包含“0”或“1”字符。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; counts;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> pre=<span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){ <span class="comment">//统计连续0或1的个数，counts数组相邻元素肯定是不同的0和1的统计量</span></span><br><span class="line">            <span class="keyword">if</span>(pre==<span class="string">'#'</span>){</span><br><span class="line">                pre=s[i];</span><br><span class="line">                ans++;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==pre) ans++;</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                counts.push_back(ans);</span><br><span class="line">                ans=<span class="number">1</span>;</span><br><span class="line">                pre=s[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        counts.push_back(ans);<span class="comment">//最后一段</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;counts.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(i&lt;counts.size()<span class="number">-1</span>){</span><br><span class="line">                res+=min(counts[i], counts[i+<span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="735-行星碰撞"><a href="#735-行星碰撞" class="headerlink" title="735. 行星碰撞"></a>735. 行星碰撞</h2><p><strong>Description</strong><br>给定一个整数数组 asteroids，表示在同一行的行星。<br>对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。<br>找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。<br><strong>Example</strong><br>示例 1:<br>输入:<br>asteroids = [5, 10, -5]<br>输出: [5, 10]<br>解释:<br>10 和 -5 碰撞后只剩下 10。 5 和 10 永远不会发生碰撞。</p>
<p>示例 2:<br>输入:<br>asteroids = [8, -8]<br>输出: []<br>解释:<br>8 和 -8 碰撞后，两者都发生爆炸。</p>
<p>示例 3:<br>输入:<br>asteroids = [10, 2, -5]<br>输出: [10]<br>解释:<br>2 和 -5 发生碰撞后剩下 -5。10 和 -5 发生碰撞后剩下 10。</p>
<p>示例 4:<br>输入:<br>asteroids = [-2, -1, 1, 2]<br>输出: [-2, -1, 1, 2]<br>解释:<br>-2 和 -1 向左移动，而 1 和 2 向右移动。<br>由于移动方向相同的行星不会发生碰撞，所以最终没有行星发生碰撞。<br>说明:</p>
<p>数组 asteroids 的长度不超过 10000。<br>每一颗行星的大小都是非零整数，范围是 [-1000, 1000] 。<br><strong>Program</strong><br><strong>思路</strong><br>栈：这里只有左边的球向右移动，右边的球向左移动才会发生碰撞，反之不会发生碰撞。<br>时间复杂度：$O(n)$，for循环是$O(n)$的，while里在for的整个过程中是$O(n)$的，因为每个元素最多入栈出栈一次。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; asteroidCollision(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; asteroids) {</span><br><span class="line">        <span class="keyword">int</span> n=asteroids.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> x=asteroids[i];</span><br><span class="line">            <span class="keyword">bool</span> isPush=<span class="literal">true</span>; <span class="comment">//是否入栈</span></span><br><span class="line">            <span class="keyword">while</span>(!st.empty()&amp;&amp;(x&lt;<span class="number">0</span>&amp;&amp;st.back()&gt;<span class="number">0</span>)){ <span class="comment">//只有左边的球向右移动和右边的球向左移动才会碰撞</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(st.back())&lt;<span class="built_in">abs</span>(x)) st.pop_back();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(st.back())==<span class="built_in">abs</span>(x)) {st.pop_back();isPush=<span class="literal">false</span>;<span class="keyword">break</span>;}</span><br><span class="line">                <span class="keyword">else</span> {isPush=<span class="literal">false</span>;<span class="keyword">break</span>;}</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(isPush) st.push_back(x);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> st;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h2><p><strong>Description</strong><br>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。<br><strong>Example</strong><br>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。<br>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dailyTemperatures(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T) {</span><br><span class="line">        <span class="keyword">int</span> n=T.size();</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">while</span>(!st.empty()&amp;&amp;T[st.top()]&lt;=T[i]) st.pop();</span><br><span class="line">            res[i]=st.empty()?<span class="number">0</span>:st.top()-i;</span><br><span class="line">            st.push(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844. 比较含退格的字符串"></a>844. 比较含退格的字符串</h2><p><strong>Description</strong><br>给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。<br>注意：如果对空文本输入退格字符，文本继续为空。<br><strong>Example</strong><br>示例 1：<br>输入：S = “ab#c”, T = “ad#c”<br>输出：true<br>解释：S 和 T 都会变成 “ac”。</p>
<p>示例 2：<br>输入：S = “ab##”, T = “c#d#”<br>输出：true<br>解释：S 和 T 都会变成 “”。</p>
<p>示例 3：<br>输入：S = “a##c”, T = “#a#c”<br>输出：true<br>解释：S 和 T 都会变成 “c”。</p>
<p>示例 4：<br>输入：S = “a#c”, T = “b”<br>输出：false<br>解释：S 会变成 “c”，但 T 仍然是 “b”。</p>
<p>提示：<br>1 &lt;= S.length &lt;= 200<br>1 &lt;= T.length &lt;= 200<br>S 和 T 只含有小写字母以及字符 ‘#’。</p>
<p>进阶：<br>你可以用 O(N) 的时间复杂度和 O(1) 的空间复杂度解决该问题吗？<br><strong>Program</strong><br><strong>思路</strong><br>从后往前遍历，遇到’#’则计数，遇到普通字符则判断计数是否为0，否则跳过；<br>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m=S.length(), n=T.length();</span><br><span class="line">        <span class="keyword">int</span> i=m<span class="number">-1</span>, j=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> skipS=<span class="number">0</span>, skipT=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span>){ <span class="comment">//从后往前遍历</span></span><br><span class="line">            <span class="keyword">while</span>(i&gt;=<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(S[i]==<span class="string">'#'</span>){skipS++;i--;}</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(skipS&gt;<span class="number">0</span>){skipS--;i--;}</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>; <span class="comment">//保留</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(T[j]==<span class="string">'#'</span>){skipT++;j--;}</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(skipT&gt;<span class="number">0</span>){skipT--;j--;}</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>; <span class="comment">//保留</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>&amp;&amp;S[i]!=T[j]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//当前保留字符不相等</span></span><br><span class="line">            <span class="keyword">if</span>((i&gt;=<span class="number">0</span>&amp;&amp;j&lt;<span class="number">0</span>)||(i&lt;<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="856-括号的分数"><a href="#856-括号的分数" class="headerlink" title="856. 括号的分数"></a>856. 括号的分数</h2><p><strong>Description</strong><br>给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：</p>
<ul>
<li>() 得 1 分。</li>
<li>AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。</li>
<li>(A) 得 2 * A 分，其中 A 是平衡括号字符串。</li>
</ul>
<p><strong>Example</strong><br>示例 1：<br>输入： “()”<br>输出： 1</p>
<p>示例 2：<br>输入： “(())”<br>输出： 2</p>
<p>示例 3：<br>输入： “()()”<br>输出： 2</p>
<p>示例 4：<br>输入： “(()(()))”<br>输出： 6</p>
<p>提示：<br>S 是平衡括号字符串，且只含有 ( 和 ) 。<br>2 &lt;= S.length &lt;= 50<br><strong>Program</strong><br><strong>栈</strong><br>维护一个栈，栈内元素表示以该对括号内的分数：<br>（1）遇到左括号，入栈，初试化括号内的分数为0；<br>（2）遇到右括号，出栈，出栈前的栈顶元素值为当前一对括号包含的所有子括号的分数，判断该score是否为0：</p>
<ul>
<li>score==0,表示当前括号内没有嵌套，应当向上将包含该括号的上一级括号的分数st.top()+1——如果栈为空，则直接最终结果ans+=1;</li>
<li>score&gt;0,表示当前括号内有嵌套的分数为score，更新栈顶元素（包含当前括号的上一级括号分数）st.top()+2<em>score —— 如果栈为空，则直接最终结果ans+=2</em>score；<br>时间复杂度：$O(n)$<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">scoreOfParentheses</span><span class="params">(<span class="built_in">string</span> S)</span> </span>{</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.length();i++){</span><br><span class="line">            <span class="keyword">if</span>(S[i]==<span class="string">'('</span>){</span><br><span class="line">                st.push(<span class="number">0</span>);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">int</span> score=st.top();st.pop();</span><br><span class="line">                <span class="keyword">if</span>(score==<span class="number">0</span>){</span><br><span class="line">                    <span class="keyword">if</span>(st.empty()) ans+=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> st.top()+=<span class="number">1</span>;</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    <span class="keyword">if</span>(st.empty()) ans+=<span class="number">2</span>*score;</span><br><span class="line">                    <span class="keyword">else</span> st.top()+=<span class="number">2</span>*score;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="880-索引处的解码字符串"><a href="#880-索引处的解码字符串" class="headerlink" title="880. 索引处的解码字符串"></a>880. 索引处的解码字符串</h2></li>
</ul>
<p><strong>Description</strong><br>给定一个编码字符串 S。请你找出 解码字符串 并将其写入磁带。解码时，从编码字符串中 每次读取一个字符 ，并采取以下步骤：</p>
<ul>
<li>如果所读的字符是字母，则将该字母写在磁带上。</li>
<li>如果所读的字符是数字（例如 d），则整个当前磁带总共会被重复写 d-1 次。</li>
<li>现在，对于给定的编码字符串 S 和索引 K，查找并返回解码字符串中的第 K 个字母。</li>
</ul>
<p><strong>Example</strong><br>示例 1：<br>输入：S = “leet2code3”, K = 10<br>输出：”o”<br>解释：<br>解码后的字符串为 “leetleetcodeleetleetcodeleetleetcode”。<br>字符串中的第 10 个字母是 “o”。</p>
<p>示例 2：<br>输入：S = “ha22”, K = 5<br>输出：”h”<br>解释：<br>解码后的字符串为 “hahahaha”。第 5 个字母是 “h”。</p>
<p>示例 3：<br>输入：S = “a2345678999999999999999”, K = 1<br>输出：”a”<br>解释：<br>解码后的字符串为 “a” 重复 8301530446056247680 次。第 1 个字母是 “a”。</p>
<p>提示：<br>2 &lt;= S.length &lt;= 100<br>S 只包含小写字母与数字 2 到 9 。<br>S 以字母开头。<br>1 &lt;= K &lt;= 10^9<br>题目保证 K 小于或等于解码字符串的长度。<br>解码后的字符串保证少于 2^63 个字母。<br><strong>Program</strong><br><strong>暴力</strong><br>超内存！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeAtIndex</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">int</span> K)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=S.length();</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(S[i]&gt;=<span class="string">'a'</span>&amp;&amp;S[i]&lt;=<span class="string">'z'</span>) str+=S[i];</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">int</span> j=S[i]-<span class="string">'0'</span><span class="number">-1</span>;</span><br><span class="line">                <span class="built_in">string</span> tmp=str;</span><br><span class="line">                <span class="keyword">while</span>(j--){</span><br><span class="line">                    str+=tmp;</span><br><span class="line">                    <span class="keyword">if</span>(str.length()&gt;=K) <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(str.length()&gt;=K) <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        res+=str[K<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>规律处理</strong><br>（1）如果我们有一个像 appleappleappleappleappleapple 这样的解码字符串和一个像 K=24 这样的索引，那么如果 K=4，答案是相同的。<br>（2）一般来说，当解码的字符串等于某个长度为 size 的单词重复某些次数（例如 apple 与 size=5 组合重复6次）时，索引 K 的答案与索引 K % size 的答案相同。<br>（3）首先计算解码后字符串长度为size，然后从后往前遍历，遇到数字就size/=S[i]-‘0’,否则遇到字母size–，然后K%size，判断K==0且S[i]为字母，则说明找到解。<br>例如样例1：”leet2code3”<br>size=36,k=10<br>i=9,size=36/3=12,k=10 mod 12=10;<br>i=8,size=11,k=10<br>i=7,size=10,k=0<br>i=6,return;</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeAtIndex</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">int</span> K)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=S.length();</span><br><span class="line">        <span class="keyword">long</span> size=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(S[i]&gt;=<span class="string">'a'</span>&amp;&amp;S[i]&lt;=<span class="string">'z'</span>) size++;</span><br><span class="line">            <span class="keyword">else</span> size*=S[i]-<span class="string">'0'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            K%=size;</span><br><span class="line">            <span class="keyword">if</span>(K==<span class="number">0</span>&amp;&amp;S[i]&gt;=<span class="string">'a'</span>&amp;&amp;S[i]&lt;=<span class="string">'z'</span>) <span class="keyword">return</span> res+S[i];</span><br><span class="line">            <span class="keyword">if</span>(S[i]&gt;=<span class="string">'2'</span>&amp;&amp;S[i]&lt;=<span class="string">'9'</span>) size/=S[i]-<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">else</span> size--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="901-股票价格跨度"><a href="#901-股票价格跨度" class="headerlink" title="901. 股票价格跨度"></a>901. 股票价格跨度</h2><p><strong>Description</strong><br>编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。<br>今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。<br>例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。<br><strong>Example</strong><br>示例：<br>输入：[“StockSpanner”,”next”,”next”,”next”,”next”,”next”,”next”,”next”], [[],[100],[80],[60],[70],[60],[75],[85]]<br>输出：[null,1,1,1,2,1,4,6]<br>解释：<br>首先，初始化 S = StockSpanner()，然后：<br>S.next(100) 被调用并返回 1，<br>S.next(80) 被调用并返回 1，<br>S.next(60) 被调用并返回 1，<br>S.next(70) 被调用并返回 2，<br>S.next(60) 被调用并返回 1，<br>S.next(75) 被调用并返回 4，<br>S.next(85) 被调用并返回 6。</p>
<p>注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格<br>(包括今天的价格 75) 小于或等于今天的价格。</p>
<p>提示：<br>调用 StockSpanner.next(int price) 时，将有 1 &lt;= price &lt;= 10^5。<br>每个测试用例最多可以调用  10000 次 StockSpanner.next。<br>在所有测试用例中，最多调用 150000 次 StockSpanner.next。<br>此问题的总时间限制减少了 50%。<br><strong>Program</strong><br><strong>单调栈</strong><br>乍一看还以为是树状数组题，然后看到<strong>最大连续日数</strong>。这题还是比较有意思的，没有直接说求左边第一个比当前大的元素！这个转变很关键啊！<br>这么一看就是求当前到左边比当前大的天数的索引差值！Next Greater Element变成了Pre Greater Element，正向遍历，单调递减栈！时间复杂度：$O(n)$，n为next调用的次数</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> idx;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> _val, <span class="keyword">int</span> _idx):val(_val),idx(_idx){}</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">stack</span>&lt;Node&gt; st;<span class="comment">//单调递减栈</span></span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    StockSpanner() {</span><br><span class="line">        idx=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> price)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span>(!st.empty()&amp;&amp;st.top().val&lt;=price) st.pop(); <span class="comment">//找出左边第一个比当前大的元素下标</span></span><br><span class="line">        <span class="keyword">int</span> res=st.empty()?idx+<span class="number">1</span>:idx-st.top().idx;</span><br><span class="line">        st.push(Node(price, idx++));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StockSpanner object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * StockSpanner* obj = new StockSpanner();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;next(price);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="907-子数组的最小值之和"><a href="#907-子数组的最小值之和" class="headerlink" title="907. 子数组的最小值之和"></a>907. 子数组的最小值之和</h2><p><strong>Description</strong><br>给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。<br>由于答案可能很大，因此返回答案模 10^9 + 7。<br><strong>Example</strong><br>示例：<br>输入：[3,1,2,4]<br>输出：17<br>解释：<br>子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。<br>最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。</p>
<p>提示：<br>1 &lt;= A &lt;= 30000<br>1 &lt;= A[i] &lt;= 30000<br><strong>Program</strong><br><strong>单调栈</strong><br>以A[i]为最小值，左右最大辐射范围<br>left[i]记录左边第一个小于A[i]的下标；<br>right[i]记录右边第一个小于A[i]的下标；<br>以A[i]为最小值的区间个数为：$(i-left[i]) * (right[i] - i)$<br>由于存在重复元素，所以需要左右两边其中一个取小于等于。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumSubarrayMins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n, <span class="number">0</span>), right(n, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">while</span>(!st.empty()&amp;&amp;A[st.top()]&gt;=A[i]) st.pop();</span><br><span class="line">            left[i]=st.empty()?<span class="number">-1</span>:st.top();</span><br><span class="line">            st.push(i);</span><br><span class="line">        }</span><br><span class="line">        st=<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">while</span>(!st.empty()&amp;&amp;A[st.top()]&gt;A[i]) st.pop();</span><br><span class="line">            right[i]=st.empty()?n:st.top();</span><br><span class="line">            st.push(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            ans+=(i-left[i])*(right[i]-i)%MOD*A[i]%MOD;</span><br><span class="line">            ans%=MOD;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumSubarrayMins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; st; <span class="comment">//单调递增栈，{val,count}表示以A[j]为右端点且为最小值的区间长度count</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">            <span class="keyword">int</span> c=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(!st.empty()&amp;&amp;st.top().first&gt;=A[j]) {</span><br><span class="line">                c+=st.top().second;</span><br><span class="line">                tmp-=st.top().first*st.top().second;</span><br><span class="line">                st.pop();</span><br><span class="line">            }</span><br><span class="line">            st.push({A[j], c});</span><br><span class="line">            tmp+=A[j]*c;</span><br><span class="line">            ans+=tmp;</span><br><span class="line">            ans%=MOD;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="946-验证栈序列"><a href="#946-验证栈序列" class="headerlink" title="946. 验证栈序列"></a>946. 验证栈序列</h2><p><strong>Description</strong><br>给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。<br><strong>Example</strong><br>示例 1：<br>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]<br>输出：true<br>解释：我们可以按以下顺序执行：<br>push(1), push(2), push(3), push(4), pop() -&gt; 4,<br>push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</p>
<p>示例 2：<br>输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]<br>输出：false<br>解释：1 不能在 2 之前弹出。</p>
<p>提示：<br>0 &lt;= pushed.length == popped.length &lt;= 1000<br>0 &lt;= pushed[i], popped[i] &lt; 1000<br>pushed 是 popped 的排列。<br><strong>Program</strong><br>直接判断栈顶元素是否等于出栈元素，是则继续出栈，否则进栈元素进栈。<br>时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=pushed.size();</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        i=j=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n&amp;&amp;j&lt;n){</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty()&amp;&amp;stk.top()==popped[j]){</span><br><span class="line">                stk.pop();</span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">            stk.push(pushed[i++]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n&amp;&amp;!stk.empty()&amp;&amp;stk.top()==popped[j]){</span><br><span class="line">            stk.pop();</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> j==n&amp;&amp;stk.empty();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=pushed.size();</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        i=j=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:pushed){</span><br><span class="line">            stk.push(x);</span><br><span class="line">            <span class="keyword">while</span>(j&lt;n&amp;&amp;!stk.empty()&amp;&amp;stk.top()==popped[j]){</span><br><span class="line">                stk.pop();j++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> j==n&amp;&amp;stk.empty();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1002-查找常用字符"><a href="#1002-查找常用字符" class="headerlink" title="1002. 查找常用字符"></a>1002. 查找常用字符</h2><p><strong>Description</strong><br>给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。<br>你可以按任意顺序返回答案。<br><strong>Example</strong><br>示例 1：<br>输入：[“bella”,”label”,”roller”]<br>输出：[“e”,”l”,”l”]</p>
<p>示例 2：<br>输入：[“cool”,”lock”,”cook”]<br>输出：[“c”,”o”]</p>
<p>提示：<br>1 &lt;= A.length &lt;= 100<br>1 &lt;= A[i].length &lt;= 100<br>A[i][j] 是小写字母<br><strong>Program</strong><br><strong>思路</strong><br>（1）对每个字符串的26个字母进行计数；<br>（2）最终结果仅保留各个字符串中对应字母最小的值；</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; commonChars(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minChs(<span class="number">26</span>, inf);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nowChs(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> str:A){</span><br><span class="line">            fill(nowChs.begin(), nowChs.end(), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> ch:str){</span><br><span class="line">                nowChs[ch-<span class="string">'a'</span>]++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++){</span><br><span class="line">                minChs[i]=min(minChs[i], nowChs[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++){</span><br><span class="line">            <span class="keyword">while</span>(minChs[i]&gt;<span class="number">0</span>){</span><br><span class="line">                <span class="built_in">string</span> str;</span><br><span class="line">                str+=i+<span class="string">'a'</span>;</span><br><span class="line">                res.push_back(str);</span><br><span class="line">                minChs[i]--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1003-检查替换后的词是否有效"><a href="#1003-检查替换后的词是否有效" class="headerlink" title="1003. 检查替换后的词是否有效"></a>1003. 检查替换后的词是否有效</h2><p><strong>Description</strong><br>给定有效字符串 “abc”。<br>对于任何有效的字符串 V，我们可以将 V 分成两个部分 X 和 Y，使得 X + Y（X 与 Y 连接）等于 V。（X 或 Y 可以为空。）那么，X + “abc” + Y 也同样是有效的。<br>例如，如果 S = “abc”，则有效字符串的示例是：”abc”，”aabcbc”，”abcabc”，”abcabcababcc”。无效字符串的示例是：”abccba”，”ab”，”cababc”，”bac”。<br>如果给定字符串 S 有效，则返回 true；否则，返回 false。<br><strong>Example</strong><br>示例 1：<br>输入：”aabcbc”<br>输出：true<br>解释：<br>从有效字符串 “abc” 开始。<br>然后我们可以在 “a” 和 “bc” 之间插入另一个 “abc”，产生 “a” + “abc” + “bc”，即 “aabcbc”。</p>
<p>示例 2：<br>输入：”abcabcababcc”<br>输出：true<br>解释：<br>“abcabcabc” 是有效的，它可以视作在原串后连续插入 “abc”。<br>然后我们可以在最后一个字母之前插入 “abc”，产生 “abcabcab” + “abc” + “c”，即 “abcabcababcc”。</p>
<p>示例 3：<br>输入：”abccba”<br>输出：false</p>
<p>示例 4：<br>输入：”cababc”<br>输出：false</p>
<p>提示：<br>1 &lt;= S.length &lt;= 20000<br>S[i] 为 ‘a’、’b’、或 ‘c’<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> S)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=S.length();</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">        <span class="built_in">string</span> tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(S[i]!=<span class="string">'c'</span>) stk.push(S[i]);</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">if</span>(stk.size()&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                tmp=<span class="string">"c"</span>;</span><br><span class="line">                tmp=stk.top()+tmp;stk.pop();</span><br><span class="line">                tmp=stk.top()+tmp;stk.pop();</span><br><span class="line">                <span class="keyword">if</span>(tmp!=<span class="string">"abc"</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> tmp=<span class="string">""</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> stk.empty();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1019-链表中的下一个更大节点"><a href="#1019-链表中的下一个更大节点" class="headerlink" title="1019. 链表中的下一个更大节点"></a>1019. 链表中的下一个更大节点</h2><p><strong>Description</strong><br>给出一个以头节点 head 作为第一个节点的链表。链表中的节点分别编号为：node_1, node_2, node_3, … 。<br>每个节点都可能有下一个更大值（next larger value）：对于 node_i，如果其 next_larger(node_i) 是 node_j.val，那么就有 j &gt; i 且  node_j.val &gt; node_i.val，而 j 是可能的选项中最小的那个。如果不存在这样的 j，那么下一个更大值为 0 。<br>返回整数答案数组 answer，其中 answer[i] = next_larger(node_{i+1}) 。<br>注意：在下面的示例中，诸如 [2,1,5] 这样的输入（不是输出）是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。<br><strong>Example</strong><br>示例 1：<br>输入：[2,1,5]<br>输出：[5,5,0]</p>
<p>示例 2：<br>输入：[2,7,4,3,5]<br>输出：[7,0,5,5,0]</p>
<p>示例 3：<br>输入：[1,7,5,1,9,2,5,1]<br>输出：[7,9,9,9,0,5,0,0]</p>
<p>提示：<br>对于链表中的每个节点，1 &lt;= node.val &lt;= 10^9<br>给定列表的长度在 [0, 10000] 范围内<br><strong>Program</strong><br><strong>单调栈</strong><br>时间复杂度：$O(n)$<br>空间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextLargerNodes(ListNode* head) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>){</span><br><span class="line">            vec.push_back(head-&gt;val);</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> n=vec.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk; <span class="comment">//单调栈</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){ <span class="comment">//从右往左遍历</span></span><br><span class="line">            <span class="keyword">while</span>(!stk.empty()&amp;&amp;stk.top()&lt;=vec[i]) stk.pop(); <span class="comment">//i的右边，栈内小于等于vec[i]的元素全部出栈</span></span><br><span class="line">            res[i]=stk.empty()?<span class="number">0</span>:stk.top();</span><br><span class="line">            stk.push(vec[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1021-删除最外层的括号"><a href="#1021-删除最外层的括号" class="headerlink" title="1021. 删除最外层的括号"></a>1021. 删除最外层的括号</h2><p><strong>Description</strong><br>有效括号字符串为空 (“”)、”(“ + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。<br>如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。<br>给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。<br>对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。<br><strong>Example</strong><br>示例 1：<br>输入：”(()())(())”<br>输出：”()()()”<br>解释：<br>输入字符串为 “(()())(())”，原语化分解得到 “(()())” + “(())”，<br>删除每个部分中的最外层括号后得到 “()()” + “()” = “()()()”。</p>
<p>示例 2：<br>输入：”(()())(())(()(()))”<br>输出：”()()()()(())”<br>解释：<br>输入字符串为 “(()())(())(()(()))”，原语化分解得到 “(()())” + “(())” + “(()(()))”，<br>删除每个部分中的最外层括号后得到 “()()” + “()” + “()(())” = “()()()()(())”。</p>
<p>示例 3：<br>输入：”()()”<br>输出：””<br>解释：<br>输入字符串为 “()()”，原语化分解得到 “()” + “()”，<br>删除每个部分中的最外层括号后得到 “” + “” = “”。</p>
<p>提示：<br>S.length &lt;= 10000<br>S[i] 为 “(“ 或 “)”<br>S 是一个有效括号字符串<br><strong>Program</strong><br><strong>思路</strong><br>关键在于拆分原语，可以发现左括号与右括号数量相等的时候是一个原语！！<br>时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeOuterParentheses</span><span class="params">(<span class="built_in">string</span> S)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=S.length();</span><br><span class="line">        <span class="keyword">int</span> lb=<span class="number">0</span>, rb=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">int</span> prePos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(S[i]==<span class="string">'('</span>) lb++;</span><br><span class="line">            <span class="keyword">else</span> rb++;</span><br><span class="line">            <span class="keyword">if</span>(lb==rb){</span><br><span class="line">                vec.push_back(prePos);</span><br><span class="line">                vec.push_back(i);</span><br><span class="line">                prePos=i+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i==vec[idx]){</span><br><span class="line">                idx++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            res+=S[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1023-驼峰式匹配"><a href="#1023-驼峰式匹配" class="headerlink" title="1023. 驼峰式匹配"></a>1023. 驼峰式匹配</h2><p><strong>Description</strong><br>如果我们可以将小写字母插入模式串 pattern 得到待查询项 query，那么待查询项与给定模式串匹配。（我们可以在任何位置插入每个字符，也可以插入 0 个字符。）<br>给定待查询列表 queries，和模式串 pattern，返回由布尔值组成的答案列表 answer。只有在待查项 queries[i] 与模式串 pattern 匹配时， answer[i] 才为 true，否则为 false。<br><strong>Example</strong><br>示例 1：<br>输入：queries = [“FooBar”,”FooBarTest”,”FootBall”,”FrameBuffer”,”ForceFeedBack”], pattern = “FB”<br>输出：[true,false,true,true,false]<br>示例：<br>“FooBar” 可以这样生成：”F” + “oo” + “B” + “ar”。<br>“FootBall” 可以这样生成：”F” + “oot” + “B” + “all”.<br>“FrameBuffer” 可以这样生成：”F” + “rame” + “B” + “uffer”.</p>
<p>示例 2：<br>输入：queries = [“FooBar”,”FooBarTest”,”FootBall”,”FrameBuffer”,”ForceFeedBack”], pattern = “FoBa”<br>输出：[true,false,true,false,false]<br>解释：<br>“FooBar” 可以这样生成：”Fo” + “o” + “Ba” + “r”.<br>“FootBall” 可以这样生成：”Fo” + “ot” + “Ba” + “ll”.</p>
<p>示例 3：<br>输出：queries = [“FooBar”,”FooBarTest”,”FootBall”,”FrameBuffer”,”ForceFeedBack”], pattern = “FoBaT”<br>输入：[false,true,false,false,false]<br>解释：<br>“FooBarTest” 可以这样生成：”Fo” + “o” + “Ba” + “r” + “T” + “est”.</p>
<p>提示：<br>1 &lt;= queries.length &lt;= 100<br>1 &lt;= queries[i].length &lt;= 100<br>1 &lt;= pattern.length &lt;= 100<br>所有字符串都仅由大写和小写英文字母组成。<br><strong>Program</strong><br><strong>双指针</strong><br>如果str[i]与pattern[j]匹配，同时后移；<br>否则，如果str[i]为大写字母，直接返回false:<br>否则，i后移；<br>判断pattern是否匹配完，没匹配完，直接返回false;<br>最后判断str剩余部分是否存在大写字母，如果有直接返回false；<br>如果没有，则匹配成功，返回true;</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="built_in">string</span> str, <span class="built_in">string</span> pattern)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> m=str.length(), n=pattern.length();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m&amp;&amp;j&lt;n){</span><br><span class="line">            <span class="keyword">if</span>(str[i]==pattern[j]){</span><br><span class="line">                i++;j++;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(str[i]&gt;=<span class="string">'A'</span>&amp;&amp;str[i]&lt;=<span class="string">'Z'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(j&lt;n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m){</span><br><span class="line">            <span class="keyword">if</span>(str[i]&gt;=<span class="string">'A'</span>&amp;&amp;str[i]&lt;=<span class="string">'Z'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; camelMatch(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; queries, <span class="built_in">string</span> pattern) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;queries.size();i++){</span><br><span class="line">            res.push_back(match(queries[i], pattern));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a>1047. 删除字符串中的所有相邻重复项</h2><p><strong>Description</strong><br>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。<br>在 S 上反复执行重复项删除操作，直到无法继续删除。<br>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。<br><strong>Example</strong><br>示例：<br>输入：”abbaca”<br>输出：”ca”<br>解释：<br>例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。<br>提示：<br>1 &lt;= S.length &lt;= 20000<br>S 仅由小写英文字母组成。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> S)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=S.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(!stk.empty()&amp;&amp;stk.back()==S[i]){</span><br><span class="line">                stk.pop_back();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            stk.push_back(S[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:stk) res+=ch;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1081-不同字符的最小子序列"><a href="#1081-不同字符的最小子序列" class="headerlink" title="1081. 不同字符的最小子序列"></a>1081. 不同字符的最小子序列</h2><p><strong>Description</strong><br>返回字符串 text 中按字典序排列最小的子序列，该子序列包含 text 中所有不同字符一次。<br><strong>Example</strong><br>示例 1：<br>输入：”cdadabcc”<br>输出：”adbc”</p>
<p>示例 2：<br>输入：”abcd”<br>输出：”abcd”</p>
<p>示例 3：<br>输入：”ecbacba”<br>输出：”eacb”</p>
<p>示例 4：<br>输入：”leetcode”<br>输出：”letcod”</p>
<p>提示：<br>1 &lt;= text.length &lt;= 1000<br>text 由小写英文字母组成<br><strong>Program</strong><br><strong>思路</strong><br>子序列且要求每个字符仅出现一次，子序列要求相对位置不变，可以考虑单调栈，遇到与当前字符大的字符，检查是否可以出栈；<br>出栈条件：①比当前字符大；②并且该字符在字符串后面还存在</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestSubsequence</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">26</span>];  <span class="comment">//字符在s中的个数</span></span><br><span class="line">        <span class="keyword">bool</span> vis[<span class="number">26</span>]; <span class="comment">//是否入栈</span></span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cnt[s[i]-<span class="string">'a'</span>]++; <span class="comment">//计数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> pos=s[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">while</span>(!vis[pos]&amp;&amp;!stk.empty()&amp;&amp;stk.top()&gt;s[i]&amp;&amp;cnt[stk.top()-<span class="string">'a'</span>]&gt;<span class="number">0</span>){ <span class="comment">//没入栈（保证只入栈一次），判断是否可以出栈</span></span><br><span class="line">                vis[stk.top()-<span class="string">'a'</span>]=<span class="literal">false</span>;</span><br><span class="line">                stk.pop();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(!vis[pos]){ <span class="comment">//入栈</span></span><br><span class="line">                stk.push(s[i]);</span><br><span class="line">                vis[pos]=<span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            cnt[pos]--; <span class="comment">//每次都减少个数，表示i后对应字符的个数</span></span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty()){</span><br><span class="line">            res+=stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">        }</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1124-表现良好的最长时间段"><a href="#1124-表现良好的最长时间段" class="headerlink" title="1124. 表现良好的最长时间段"></a>1124. 表现良好的最长时间段</h2><p><strong>Description</strong><br>给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。<br>我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。<br>所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。<br>请你返回「表现良好时间段」的最大长度。<br><strong>Example</strong><br>示例 1：<br>输入：hours = [9,9,6,0,6,6,9]<br>输出：3<br>解释：最长的表现良好时间段是 [9,9,6]。</p>
<p>提示：<br>1 &lt;= hours.length &lt;= 10000<br>0 &lt;= hours[i] &lt;= 16<br><strong>Program</strong><br><strong>暴力</strong><br>首先将hours数组转成1，-1的形式，方便统计，然后计算前缀和，题目要求的就是说要使得[i,j]的和大于0的最长长度。一个直接的思路是暴力枚举，时间复杂度：$O(n^2)$<br>超时</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestWPI</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; hours)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=hours.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            hours[i]=hours[i]&gt;<span class="number">8</span>?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preSum(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            preSum[i]+=preSum[i<span class="number">-1</span>]+hours[i<span class="number">-1</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line">                <span class="keyword">if</span>(preSum[j]&gt;preSum[i]) res=max(res, j-i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>单调栈</strong><br>从暴力的双循环看：<br>（1）内循环，$i&lt;j_1&lt;j_2$，如果preSum[j_2]&gt;preSum[i]，那么$j_1$无意义，所以从后往前遍历j；<br>（2）外循环：$i&lt;i_1&lt;j$，如果preSum[i_1]&gt;preSum[i]，那么$i_1$无意义；<br><a href="https://leetcode-cn.com/problems/longest-well-performing-interval/solution/can-kao-liao-ji-ge-da-shen-de-ti-jie-zhi-hou-zong-/" target="_blank" rel="noopener">详解</a></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestWPI</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; hours)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=hours.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            hours[i]=hours[i]&gt;<span class="number">8</span>?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preSum(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            preSum[i]+=preSum[i<span class="number">-1</span>]+hours[i<span class="number">-1</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++){</span><br><span class="line">            <span class="keyword">if</span>(stk.empty()||preSum[stk.top()]&gt;preSum[i]) stk.push(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;=<span class="number">0</span>;j--){</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty()&amp;&amp;preSum[j]&gt;preSum[stk.top()]){</span><br><span class="line">                res=max(j-stk.top(), res);</span><br><span class="line">                stk.pop();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1190-反转每对括号间的子串"><a href="#1190-反转每对括号间的子串" class="headerlink" title="1190. 反转每对括号间的子串"></a>1190. 反转每对括号间的子串</h2><p><strong>Description</strong><br>给出一个字符串 s（仅含有小写英文字母和括号）。<br>请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。<br>注意，您的结果中 不应 包含任何括号。<br><strong>Example</strong><br>示例 1：<br>输入：s = “(abcd)”<br>输出：”dcba”</p>
<p>示例 2：<br>输入：s = “(u(love)i)”<br>输出：”iloveu”</p>
<p>示例 3：<br>输入：s = “(ed(et(oc))el)”<br>输出：”leetcode”</p>
<p>示例 4：<br>输入：s = “a(bcdefghijkl(mno)p)q”<br>输出：”apmnolkjihgfedcbq”</p>
<p>提示：<br>0 &lt;= s.length &lt;= 2000<br>s 中只有小写英文字母和括号<br>我们确保所有括号都是成对出现的<br><strong>Program</strong><br><strong>暴力</strong><br>时间复杂度：$O(n^2)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; stk;<span class="comment">//栈</span></span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=<span class="string">')'</span>) stk.push_back(s[i]);</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">                <span class="keyword">while</span>(!stk.empty()&amp;&amp;stk.back()!=<span class="string">'('</span>){</span><br><span class="line">                    tmp.push_back(stk.back());</span><br><span class="line">                    stk.pop_back();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(!stk.empty()) stk.pop_back();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> ch:tmp) stk.push_back(ch);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:stk) str+=ch;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>虫洞法</strong><br><img src="/assets/img/algorithm/1190_example_01.gif" alt="image"><br>时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){ <span class="comment">//匹配一对括号</span></span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'('</span>) stk.push(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">')'</span>){</span><br><span class="line">                <span class="keyword">int</span> j=stk.top();stk.pop();</span><br><span class="line">                m[j]=i;</span><br><span class="line">                m[i]=j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> d=<span class="number">1</span>; <span class="comment">//方向</span></span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=d){</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'('</span>||s[i]==<span class="string">')'</span>){ <span class="comment">//遇到括号就跳到另一边，并且换方向</span></span><br><span class="line">                i=m[i];</span><br><span class="line">                d=-d; <span class="comment">//换方向</span></span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                res+=s[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1209-删除字符串中的所有相邻重复项-II"><a href="#1209-删除字符串中的所有相邻重复项-II" class="headerlink" title="1209. 删除字符串中的所有相邻重复项 II"></a>1209. 删除字符串中的所有相邻重复项 II</h2><p><strong>Description</strong><br>给你一个字符串 s，「k 倍重复项删除操作」将会从 s 中选择 k 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。<br>你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。<br>在执行完所有删除操作后，返回最终得到的字符串。<br>本题答案保证唯一。<br><strong>Example</strong><br>示例 1：<br>输入：s = “abcd”, k = 2<br>输出：”abcd”<br>解释：没有要删除的内容。</p>
<p>示例 2：<br>输入：s = “deeedbbcccbdaa”, k = 3<br>输出：”aa”<br>解释：<br>先删除 “eee” 和 “ccc”，得到 “ddbbbdaa”<br>再删除 “bbb”，得到 “dddaa”<br>最后删除 “ddd”，得到 “aa”</p>
<p>示例 3：<br>输入：s = “pbbcggttciiippooaais”, k = 2<br>输出：”ps”</p>
<p>提示：<br>1 &lt;= s.length &lt;= 10^5<br>2 &lt;= k &lt;= 10^4<br>s 中只含有小写英文字母。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(stk.empty()||stk.back().second&lt;k){</span><br><span class="line">                <span class="keyword">if</span>(!stk.empty()&amp;&amp;stk.back().first==s[i]){</span><br><span class="line">                    stk.back().second++;</span><br><span class="line">                    <span class="keyword">if</span>(stk.back().second==k) stk.pop_back();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> stk.push_back({s[i], <span class="number">1</span>});</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">if</span>(stk.back().second==k) stk.pop_back();</span><br><span class="line">                <span class="keyword">else</span> stk.back().second-=k;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">for</span>(pair&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; p:stk){</span><br><span class="line">            <span class="keyword">char</span> ch=p.first;</span><br><span class="line">            <span class="keyword">int</span> count=p.second;</span><br><span class="line">            <span class="keyword">while</span>(count--) str+=ch;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1249-移除无效的括号"><a href="#1249-移除无效的括号" class="headerlink" title="1249. 移除无效的括号"></a>1249. 移除无效的括号</h2><p><strong>Description</strong><br>给你一个由 ‘(‘、’)’ 和小写字母组成的字符串 s。<br>你需要从字符串中删除最少数目的 ‘(‘ 或者 ‘)’ （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。<br>请返回任意一个合法字符串。<br>有效「括号字符串」应当符合以下 任意一条 要求：</p>
<ul>
<li>空字符串或只包含小写字母的字符串</li>
<li>可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」</li>
<li>可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」</li>
</ul>
<p><strong>Example</strong><br>示例 1：<br>输入：s = “lee(t(c)o)de)”<br>输出：”lee(t(c)o)de”<br>解释：”lee(t(co)de)” , “lee(t(c)ode)” 也是一个可行答案。</p>
<p>示例 2：<br>输入：s = “a)b(c)d”<br>输出：”ab(c)d”</p>
<p>示例 3：<br>输入：s = “))((“<br>输出：””<br>解释：空字符串也是有效的</p>
<p>示例 4：<br>输入：s = “(a(b(c)d)”<br>输出：”a(b(c)d)”</p>
<p>提示：<br>1 &lt;= s.length &lt;= 10^5<br>s[i] 可能是 ‘(‘、’)’ 或英文小写字母<br><strong>Program</strong><br>时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minRemoveToMakeValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rms; <span class="comment">//待移出的括号下标</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'('</span>){</span><br><span class="line">                stk.push_back(i);</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">')'</span>){</span><br><span class="line">                <span class="keyword">if</span>(stk.empty()) rms.push_back(i); <span class="comment">//需要移出</span></span><br><span class="line">                <span class="keyword">else</span> stk.pop_back();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:stk) rms.push_back(i);</span><br><span class="line">        <span class="comment">// sort(rms.begin(), rms.end());</span></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>, m=rms.size();</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(j&lt;m&amp;&amp;i==rms[j]){</span><br><span class="line">                j++;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                str+=s[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1370-上升下降字符串"><a href="#1370-上升下降字符串" class="headerlink" title="1370. 上升下降字符串"></a>1370. 上升下降字符串</h2><p><strong>Description</strong><br>给你一个字符串 s ，请你根据下面的算法重新构造字符串：</p>
<p>从 s 中选出 最小 的字符，将它 接在 结果字符串的后面。<br>从 s 剩余字符中选出 最小 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。<br>重复步骤 2 ，直到你没法从 s 中选择字符。<br>从 s 中选出 最大 的字符，将它 接在 结果字符串的后面。<br>从 s 剩余字符中选出 最大 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。<br>重复步骤 5 ，直到你没法从 s 中选择字符。<br>重复步骤 1 到 6 ，直到 s 中所有字符都已经被选过。<br>在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。</p>
<p>请你返回将 s 中字符重新排序后的 结果字符串 。<br><strong>Example</strong><br>示例 1：<br>输入：s = “aaaabbbbcccc”<br>输出：”abccbaabccba”<br>解释：第一轮的步骤 1，2，3 后，结果字符串为 result = “abc”<br>第一轮的步骤 4，5，6 后，结果字符串为 result = “abccba”<br>第一轮结束，现在 s = “aabbcc” ，我们再次回到步骤 1<br>第二轮的步骤 1，2，3 后，结果字符串为 result = “abccbaabc”<br>第二轮的步骤 4，5，6 后，结果字符串为 result = “abccbaabccba”</p>
<p>示例 2：<br>输入：s = “rat”<br>输出：”art”<br>解释：单词 “rat” 在上述算法重排序以后变成 “art”</p>
<p>示例 3：<br>输入：s = “leetcode”<br>输出：”cdelotee”</p>
<p>示例 4：<br>输入：s = “ggggggg”<br>输出：”ggggggg”</p>
<p>示例 5：<br>输入：s = “spo”<br>输出：”ops”</p>
<p>提示：<br>1 &lt;= s.length &lt;= 500<br>s 只包含小写英文字母。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> chs[<span class="number">26</span>];</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> nCount;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++){</span><br><span class="line">            <span class="keyword">if</span>(chs[i]&gt;<span class="number">0</span>){</span><br><span class="line">                chs[i]--;</span><br><span class="line">                str+=i+<span class="string">'a'</span>;</span><br><span class="line">                nCount--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(nCount==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">25</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">if</span>(chs[i]&gt;<span class="number">0</span>){</span><br><span class="line">                chs[i]--;</span><br><span class="line">                str+=i+<span class="string">'a'</span>;</span><br><span class="line">                nCount--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">sortString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        n=s.length();</span><br><span class="line">        nCount=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(chs, <span class="number">0</span>, <span class="keyword">sizeof</span>(chs));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:s){</span><br><span class="line">            chs[ch-<span class="string">'a'</span>]++;</span><br><span class="line">            nCount++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(nCount&gt;<span class="number">0</span>){</span><br><span class="line">            handle();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1381-设计一个支持增量操作的栈"><a href="#1381-设计一个支持增量操作的栈" class="headerlink" title="1381. 设计一个支持增量操作的栈"></a>1381. 设计一个支持增量操作的栈</h2><p><strong>Description</strong><br>请你设计一个支持下述操作的栈。</p>
<p>实现自定义栈类 CustomStack ：<br>CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。<br>void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。<br>int pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。<br>void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。<br><strong>Example</strong><br>示例：<br>输入：<br>[“CustomStack”,”push”,”push”,”pop”,”push”,”push”,”push”,”increment”,”increment”,”pop”,”pop”,”pop”,”pop”]<br>[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]<br>输出：<br>[null,null,null,2,null,null,null,null,null,103,202,201,-1]<br>解释：<br>CustomStack customStack = new CustomStack(3); // 栈是空的 []<br>customStack.push(1);                          // 栈变为 [1]<br>customStack.push(2);                          // 栈变为 [1, 2]<br>customStack.pop();                            // 返回 2 –&gt; 返回栈顶值 2，栈变为 [1]<br>customStack.push(2);                          // 栈变为 [1, 2]<br>customStack.push(3);                          // 栈变为 [1, 2, 3]<br>customStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4<br>customStack.increment(5, 100);                // 栈变为 [101, 102, 103]<br>customStack.increment(2, 100);                // 栈变为 [201, 202, 103]<br>customStack.pop();                            // 返回 103 –&gt; 返回栈顶值 103，栈变为 [201, 202]<br>customStack.pop();                            // 返回 202 –&gt; 返回栈顶值 202，栈变为 [201]<br>customStack.pop();                            // 返回 201 –&gt; 返回栈顶值 201，栈变为 []<br>customStack.pop();                            // 返回 -1 –&gt; 栈为空，返回 -1</p>
<p>提示：<br>1 &lt;= maxSize &lt;= 1000<br>1 &lt;= x &lt;= 1000<br>1 &lt;= k &lt;= 1000<br>0 &lt;= val &lt;= 100<br>每种方法 increment，push 以及 pop 分别最多调用 1000 次<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomStack</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    CustomStack(<span class="keyword">int</span> maxSize) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;maxSize = maxSize;</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(size&lt;maxSize){</span><br><span class="line">            stk.push_back(x);</span><br><span class="line">            size++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(size&gt;<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">int</span> val=stk.back();</span><br><span class="line">            stk.pop_back();</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;min(size, k);i++){</span><br><span class="line">            stk[i]+=val;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CustomStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CustomStack* obj = new CustomStack(maxSize);</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * obj-&gt;increment(k,val);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="1410-HTML-实体解析器"><a href="#1410-HTML-实体解析器" class="headerlink" title="1410. HTML 实体解析器"></a>1410. HTML 实体解析器</h2><p><strong>Description</strong><br>「HTML 实体解析器」 是一种特殊的解析器，它将 HTML 代码作为输入，并用字符本身替换掉所有这些特殊的字符实体。</p>
<p>HTML 里这些特殊字符和它们对应的字符实体包括：<br>双引号：字符实体为 " ，对应的字符是 “ 。<br>单引号：字符实体为 ' ，对应的字符是 ‘ 。<br>与符号：字符实体为 &amp; ，对应对的字符是 &amp; 。<br>大于号：字符实体为 &gt; ，对应的字符是 &gt; 。<br>小于号：字符实体为 &lt; ，对应的字符是 &lt; 。<br>斜线号：字符实体为 ⁄ ，对应的字符是 / 。<br>给你输入字符串 text ，请你实现一个 HTML 实体解析器，返回解析器解析后的结果。</p>
<p><strong>Example</strong><br>示例 1：<br>输入：text = “&amp; is an HTML entity but &amp;ambassador; is not.”<br>输出：”&amp; is an HTML entity but &amp;ambassador; is not.”<br>解释：解析器把字符实体 &amp; 用 &amp; 替换</p>
<p>示例 2：<br>输入：text = “and I quote: "…"”<br>输出：”and I quote: "…"“</p>
<p>示例 3：<br>输入：text = “Stay home! Practice on Leetcode :)”<br>输出：”Stay home! Practice on Leetcode :)”</p>
<p>示例 4：<br>输入：text = “x &gt; y &amp;&amp; x &lt; y is always false”<br>输出：”x &gt; y &amp;&amp; x &lt; y is always false”</p>
<p>示例 5：<br>输入：text = “leetcode.com⁄problemset⁄all”<br>输出：”leetcode.com/problemset/all”</p>
<p>提示：<br>1 &lt;= text.length &lt;= 10^5<br>字符串可能包含 256 个ASCII 字符中的任意字符。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; m;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">entityParser</span><span class="params">(<span class="built_in">string</span> text)</span> </span>{</span><br><span class="line">        m[<span class="string">"&amp;quot;"</span>] = <span class="string">"\""</span>;</span><br><span class="line">        m[<span class="string">"&amp;apos;"</span>] = <span class="string">"\'"</span>;</span><br><span class="line">        m[<span class="string">"&amp;amp;"</span>] = <span class="string">"&amp;"</span>;</span><br><span class="line">        m[<span class="string">"&amp;gt;"</span>] = <span class="string">"&gt;"</span>;</span><br><span class="line">        m[<span class="string">"&amp;lt;"</span>] = <span class="string">"&lt;"</span>;</span><br><span class="line">        m[<span class="string">"&amp;frasl;"</span>] = <span class="string">"/"</span>;</span><br><span class="line">        <span class="keyword">int</span> n=text.length();</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(text[i]==<span class="string">'&amp;'</span>){</span><br><span class="line">                <span class="keyword">int</span> pos=text.find_first_of(<span class="string">';'</span>, i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(pos!=<span class="built_in">string</span>::npos){</span><br><span class="line">                    <span class="built_in">string</span> s=text.substr(i, pos-i+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(m.find(s)!=m.end()){</span><br><span class="line">                        str+=m[s];</span><br><span class="line">                        i=pos;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            str+=text[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1441-用栈操作构建数组"><a href="#1441-用栈操作构建数组" class="headerlink" title="1441. 用栈操作构建数组"></a>1441. 用栈操作构建数组</h2><p><strong>Description</strong><br>给你一个目标数组 target 和一个整数 n。每次迭代，需要从  list = {1,2,3…, n} 中依序读取一个数字。</p>
<p>请使用下述操作来构建目标数组 target ：</p>
<ul>
<li>Push：从 list 中读取一个新元素， 并将其推入数组中。</li>
<li>Pop：删除数组中的最后一个元素。</li>
<li>如果目标数组构建完成，就停止读取更多元素。<br>题目数据保证目标数组严格递增，并且只包含 1 到 n 之间的数字。</li>
</ul>
<p>请返回构建目标数组所用的操作序列。<br>题目数据保证答案是唯一的。<br><strong>Example</strong><br>示例 1：<br>输入：target = [1,3], n = 3<br>输出：[“Push”,”Push”,”Pop”,”Push”]<br>解释：<br>读取 1 并自动推入数组 -&gt; [1]<br>读取 2 并自动推入数组，然后删除它 -&gt; [1]<br>读取 3 并自动推入数组 -&gt; [1,3]</p>
<p>示例 2：<br>输入：target = [1,2,3], n = 3<br>输出：[“Push”,”Push”,”Push”]</p>
<p>示例 3：<br>输入：target = [1,2], n = 4<br>输出：[“Push”,”Push”]<br>解释：只需要读取前 2 个数字就可以停止。</p>
<p>示例 4：<br>输入：target = [2,3,4], n = 4<br>输出：[“Push”,”Pop”,”Push”,”Push”,”Push”]</p>
<p>提示：<br>1 &lt;= target.length &lt;= 100<br>1 &lt;= target[i] &lt;= 100<br>1 &lt;= n &lt;= 100<br>target 是严格递增的<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; buildArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target, <span class="keyword">int</span> n) {</span><br><span class="line">        <span class="keyword">int</span> len=target.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="keyword">if</span>(target[j]==i){</span><br><span class="line">                stk.push_back(<span class="string">"Push"</span>);</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span>(j==len) <span class="keyword">break</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                stk.push_back(<span class="string">"Push"</span>);</span><br><span class="line">                stk.push_back(<span class="string">"Pop"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> stk;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1544-整理字符串"><a href="#1544-整理字符串" class="headerlink" title="1544. 整理字符串"></a>1544. 整理字符串</h2><p><strong>Description</strong><br>给你一个由大小写英文字母组成的字符串 s 。<br>一个整理好的字符串中，两个相邻字符 s[i] 和 s[i + 1] 不会同时满足下述条件：<br>0 &lt;= i &lt;= s.length - 2<br>s[i] 是小写字符，但 s[i + 1] 是相同的大写字符；反之亦然 。<br>请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的 两个相邻 字符并删除，直到字符串整理好为止。<br>请返回整理好的 字符串 。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。<br>注意：空字符串也属于整理好的字符串，尽管其中没有任何字符。<br><strong>Example</strong><br>示例 1：<br>输入：s = “leEeetcode”<br>输出：”leetcode”<br>解释：无论你第一次选的是 i = 1 还是 i = 2，都会使 “leEeetcode” 缩减为 “leetcode” 。</p>
<p>示例 2：<br>输入：s = “abBAcC”<br>输出：””<br>解释：存在多种不同情况，但所有的情况都会导致相同的结果。例如：<br>“abBAcC” –&gt; “aAcC” –&gt; “cC” –&gt; “”<br>“abBAcC” –&gt; “abBA” –&gt; “aA” –&gt; “”</p>
<p>示例 3：<br>输入：s = “s”<br>输出：”s”</p>
<p>提示：<br>1 &lt;= s.length &lt;= 100<br>s 只包含小写和大写英文字母<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">makeGood</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; stk; <span class="comment">//栈</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(!stk.empty()&amp;&amp;(stk.back()+<span class="number">32</span>==s[i]||stk.back()==s[i]+<span class="number">32</span>)) stk.pop_back();</span><br><span class="line">            <span class="keyword">else</span> stk.push_back(s[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(stk.begin(), stk.end());</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a>剑指 Offer 30. 包含min函数的栈</h2><p><strong>Description</strong><br>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。<br><strong>Example</strong><br>示例:<br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.min();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.min();   –&gt; 返回 -2.</p>
<p>提示：<br>各函数的调用总次数不超过 20000 次<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; minStk; <span class="comment">//单调递减栈</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    MinStack() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        stk.push(x);</span><br><span class="line">        <span class="keyword">if</span>(!minStk.empty()&amp;&amp;x&lt;=minStk.top()) minStk.push(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(minStk.empty()) minStk.push(x);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(stk.empty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(minStk.top()==stk.top()) minStk.pop();</span><br><span class="line">        stk.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> stk.top();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> minStk.top();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="面试题-03-02-栈的最小值"><a href="#面试题-03-02-栈的最小值" class="headerlink" title="面试题 03.02. 栈的最小值"></a>面试题 03.02. 栈的最小值</h2><p><strong>Description</strong><br>请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。<br><strong>Example</strong><br>示例：<br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; minStk;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    MinStack() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(minStk.empty()||minStk.top()&gt;=x) minStk.push(x);</span><br><span class="line">        stk.push(x);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(stk.empty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(stk.top()==minStk.top()) minStk.pop();</span><br><span class="line">        stk.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> stk.top();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> minStk.top();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="面试题-03-04-化栈为队"><a href="#面试题-03-04-化栈为队" class="headerlink" title="面试题 03.04. 化栈为队"></a>面试题 03.04. 化栈为队</h2><p><strong>Description</strong><br>实现一个MyQueue类，该类用两个栈来实现一个队列。<br><strong>Example</strong><br>示例：<br>MyQueue queue = new MyQueue();<br>queue.push(1);<br>queue.push(2);<br>queue.peek();  // 返回 1<br>queue.pop();   // 返回 1<br>queue.empty(); // 返回 false</p>
<p>说明：<br>你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。<br>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; inStk, ouStk;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyQueue() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        inStk.push(x);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(ouStk.empty()){</span><br><span class="line">            <span class="keyword">while</span>(!inStk.empty()){</span><br><span class="line">                ouStk.push(inStk.top());</span><br><span class="line">                inStk.pop();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> res=ouStk.top(); ouStk.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(ouStk.empty()){</span><br><span class="line">            <span class="keyword">while</span>(!inStk.empty()){</span><br><span class="line">                ouStk.push(inStk.top());</span><br><span class="line">                inStk.pop();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ouStk.top();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> inStk.empty()&amp;&amp;ouStk.empty();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="面试题-17-17-多次搜索"><a href="#面试题-17-17-多次搜索" class="headerlink" title="面试题 17.17. 多次搜索"></a>面试题 17.17. 多次搜索</h2><p><strong>Description</strong><br>给定一个较长字符串big和一个包含较短字符串的数组smalls，设计一个方法，根据smalls中的每一个较短字符串，对big进行搜索。输出smalls中的字符串在big里出现的所有位置positions，其中positions[i]为smalls[i]出现的所有位置。<br><strong>Example</strong><br>示例：<br>输入：<br>big = “mississippi”<br>smalls = [“is”,”ppi”,”hi”,”sis”,”i”,”ssippi”]<br>输出： [[1,4],[8],[],[3],[1,4,7,10],[5]]</p>
<p>提示：<br>0 &lt;= len(big) &lt;= 1000<br>0 &lt;= len(smalls[i]) &lt;= 1000<br>smalls的总字符数不会超过 100000。<br>你可以认为smalls中没有重复字符串。<br>所有出现的字符均为英文小写字母。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">**<span class="number">1</span>、KMP**</span><br><span class="line">KMP多次匹配问题</span><br><span class="line">时间复杂度：$O(m*l+\sum_{i=<span class="number">1</span>}^{l}{(n_i)})$，其中$l$为smalls数组长度，$n_i$为smalls数组第i个元素的长度；</span><br><span class="line">空间复杂度：$O(\sum_{i=<span class="number">1</span>}^{l}{(n_i)})$</span><br><span class="line">```cpp</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getNext(<span class="built_in">string</span> pattern){</span><br><span class="line">        <span class="keyword">int</span> n=pattern.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(n, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;pattern[i]!=pattern[j+<span class="number">1</span>]){</span><br><span class="line">                j=next[j];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(pattern[i]==pattern[j+<span class="number">1</span>]) j++;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; multiMatch(<span class="built_in">string</span> text, <span class="built_in">string</span> pattern){</span><br><span class="line">        <span class="keyword">int</span> m=text.length(), n=pattern.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next=getNext(pattern);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;text[i]!=pattern[j+<span class="number">1</span>]){</span><br><span class="line">                j=next[j];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(text[i]==pattern[j+<span class="number">1</span>]) j++;</span><br><span class="line">            <span class="keyword">if</span>(j==n<span class="number">-1</span>){</span><br><span class="line">                res.push_back(i-n+<span class="number">1</span>);</span><br><span class="line">                j=next[j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; multiSearch(<span class="built_in">string</span> big, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; smalls) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n=smalls.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(smalls[i]==<span class="string">""</span>){</span><br><span class="line">                res.push_back({});</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            res.push_back(multiMatch(big, smalls[i]));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>2、AC自动机</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>{</span></span><br><span class="line">        <span class="keyword">int</span> cnt;</span><br><span class="line">        Trie* fail;</span><br><span class="line">        Trie* next[<span class="number">26</span>];</span><br><span class="line">        Trie(){</span><br><span class="line">            cnt=<span class="number">0</span>;</span><br><span class="line">            fail=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) next[i]=<span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    Trie* root=<span class="keyword">new</span> Trie();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> i)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> n=str.length();</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        Trie* cur=root;</span><br><span class="line">        <span class="keyword">while</span>(idx&lt;n){</span><br><span class="line">            <span class="keyword">int</span> pos=str[idx]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next[pos]==<span class="literal">NULL</span>) cur-&gt;next[pos]=<span class="keyword">new</span> Trie();</span><br><span class="line">            cur=cur-&gt;next[pos];</span><br><span class="line">            idx++;</span><br><span class="line">        }</span><br><span class="line">        cur-&gt;cnt=i+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createFailPointer</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="built_in">queue</span>&lt;Trie*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            Trie* cur=q.front();q.pop();</span><br><span class="line">            Trie* fail=cur-&gt;fail;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++){</span><br><span class="line">                Trie* son=cur-&gt;next[i];</span><br><span class="line">                <span class="keyword">if</span>(son==<span class="literal">NULL</span>) {cur-&gt;next[i]=(fail==<span class="literal">NULL</span>?cur:fail-&gt;next[i]);<span class="keyword">continue</span>;} <span class="comment">//孩子为空，调整指向</span></span><br><span class="line">                son-&gt;fail=(fail==<span class="literal">NULL</span>?cur:fail-&gt;next[i]);</span><br><span class="line">                q.push(son);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="built_in">string</span> text, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; smalls)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> n=text.length();</span><br><span class="line">        Trie* cur=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> pos=text[i]-<span class="string">'a'</span>;</span><br><span class="line">            Trie* son=cur-&gt;next[pos];</span><br><span class="line">            <span class="keyword">while</span>(son!=root){</span><br><span class="line">                <span class="keyword">if</span>(son-&gt;cnt&gt;<span class="number">0</span>){</span><br><span class="line">                    <span class="keyword">int</span> idx=son-&gt;cnt<span class="number">-1</span>;</span><br><span class="line">                    res[idx].push_back(i-smalls[idx].length()+<span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">                son=son-&gt;fail; <span class="comment">//继续跳，因为fail也是son的后缀</span></span><br><span class="line">            }</span><br><span class="line">            cur=cur-&gt;next[pos];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; multiSearch(<span class="built_in">string</span> big, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; smalls) {</span><br><span class="line">        <span class="keyword">int</span> n=smalls.size();</span><br><span class="line">        res.resize(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) insert(smalls[i], i);</span><br><span class="line">        createFailPointer();</span><br><span class="line">        query(big, smalls);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1></blockquote>
<h2 id="树的序列化"><a href="#树的序列化" class="headerlink" title="树的序列化"></a>树的序列化</h2><h3 id="652-寻找重复的子树"><a href="#652-寻找重复的子树" class="headerlink" title="652. 寻找重复的子树"></a>652. 寻找重复的子树</h3><p><strong>Description</strong><br>给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。<br>两棵树重复是指它们具有相同的结构以及相同的结点值。<br><strong>Example</strong><br>示例 1：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> /   / \</span><br><span class="line">4   2   4</span><br><span class="line">   /</span><br><span class="line">  4</span><br></pre></td></tr></tbody></table></figure>
<p>下面是两个重复的子树：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">4</span><br></pre></td></tr></tbody></table></figure>
<p>和<br>    4<br>因此，你需要以列表的形式返回上述重复子树的根结点。<br><strong>Program</strong><br><strong>思路</strong><br>将每个子树序列化后，用哈希表判断是否重复，如果重复，加入结果即可，注意分隔符，否则将不能准确区分不同子树的情况</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root) {</span><br><span class="line">        serialize(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> str=to_string(root-&gt;val) + <span class="string">"#"</span> + serialize(root-&gt;left) + <span class="string">"#"</span> + serialize(root-&gt;right); <span class="comment">//注意分隔符</span></span><br><span class="line">        m[str]++;</span><br><span class="line">        <span class="keyword">if</span>(m[str]==<span class="number">2</span>) res.push_back(root);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="树的操作"><a href="#树的操作" class="headerlink" title="树的操作"></a>树的操作</h2><h3 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a>114. 二叉树展开为链表</h3><p><strong>Description</strong><br>给定一个二叉树，原地将它展开为链表。<br><strong>Example</strong><br>例如，给定二叉树</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \   \</span><br><span class="line">3   4   6</span><br></pre></td></tr></tbody></table></figure>
<p>将其展开为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong><br>前序遍历，自顶而下</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        TreeNode* r=root-&gt;right;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>){</span><br><span class="line">            flatten(root-&gt;left);</span><br><span class="line">            TreeNode* lR=root-&gt;left;</span><br><span class="line">            <span class="keyword">while</span>(lR-&gt;right!=<span class="literal">NULL</span>) lR=lR-&gt;right;</span><br><span class="line">            root-&gt;right=root-&gt;left;</span><br><span class="line">            root-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">            flatten(r);</span><br><span class="line">            lR-&gt;right=r;</span><br><span class="line">        }<span class="keyword">else</span> flatten(root-&gt;right);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>后序遍历，自底而上</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        flatten(root-&gt;left);</span><br><span class="line">        flatten(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>){</span><br><span class="line">            TreeNode* lR=root-&gt;left;</span><br><span class="line">            <span class="keyword">while</span>(lR-&gt;right!=<span class="literal">NULL</span>) lR=lR-&gt;right;</span><br><span class="line">            TreeNode* right=root-&gt;right;</span><br><span class="line">            root-&gt;right=root-&gt;left;</span><br><span class="line">            lR-&gt;right=right;</span><br><span class="line">            root-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>前两种时间复杂度$O(n)$,空间复杂度：$O(n)$,栈相关！<br>现在使用前驱的方法，使得空间复杂度降为$O(1)$.<br>其中每个节点最多额外访问一次，所以时间复杂度还是$O(n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        TreeNode* cur=root;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>){</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">NULL</span>){</span><br><span class="line">                TreeNode* next=cur-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(next-&gt;right!=<span class="literal">NULL</span>) next=next-&gt;right; <span class="comment">//找到前驱节点</span></span><br><span class="line">                next-&gt;right=cur-&gt;right;</span><br><span class="line">                cur-&gt;right=cur-&gt;left;</span><br><span class="line">                cur-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">            }</span><br><span class="line">            cur=cur-&gt;right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99. 恢复二叉搜索树"></a>99. 恢复二叉搜索树</h3><p><strong>Description</strong><br>二叉搜索树中的两个节点被错误地交换。<br>请在不改变其结构的情况下，恢复这棵树。<br><strong>Example</strong><br>示例 1:<br>输入: [1,3,null,null,2]</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&nbsp;  1</span><br><span class="line">&nbsp; /</span><br><span class="line">&nbsp;3</span><br><span class="line">&nbsp; \</span><br><span class="line">&nbsp;  2</span><br><span class="line"></span><br><span class="line">输出: [3,1,null,null,2]</span><br></pre></td></tr></tbody></table></figure>
<p>   3<br>  /<br> 1<br>  <br>   2</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例&nbsp;2:</span><br><span class="line">输入: [3,1,4,null,null,2]</span><br></pre></td></tr></tbody></table></figure>
<p>  3<br> / <br>1   4<br>   /<br>  2</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出: [2,1,4,null,null,3]</span><br></pre></td></tr></tbody></table></figure>
<p>  2<br> / <br>1   4<br>   /<br>  3</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">进阶:</span><br><span class="line">使用 O(n) 空间复杂度的解法很容易实现。</span><br><span class="line">你能想出一个只使用常数空间的解决方案吗？</span><br><span class="line">**Program**</span><br><span class="line">**中序遍历**</span><br><span class="line">中序遍历的时候记录pre-&gt;val&gt;root-&gt;val：</span><br><span class="line">- 如果第一次则node1=pre,node2=root，</span><br><span class="line">  防止node2为空，即第二个样例的情况</span><br><span class="line">- 如果第二次则node2=root即可；</span><br><span class="line">  因为交换了两个节点值，那么原本递增的中序会出现两个异常点，一个更大，一个更小。</span><br><span class="line">```cpp</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode {</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span><br><span class="line"> * };</span><br><span class="line"> */</span><br><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line">    TreeNode* pre;</span><br><span class="line">    bool isFirst;</span><br><span class="line">    TreeNode *node1, *node2;</span><br><span class="line">    void inOrderTravel(TreeNode* root){</span><br><span class="line">        if(root==NULL) return;</span><br><span class="line">        inOrderTravel(root-&gt;left);</span><br><span class="line">        if(isFirst){</span><br><span class="line">            pre=root;</span><br><span class="line">            isFirst=false;</span><br><span class="line">        }else{</span><br><span class="line">            if(pre-&gt;val&gt;root-&gt;val){</span><br><span class="line">                if(node1==NULL) {</span><br><span class="line">                    node1=pre;</span><br><span class="line">                    node2=root;</span><br><span class="line">                }else node2=root;</span><br><span class="line"></span><br><span class="line">                //isFirst=true;</span><br><span class="line">            }</span><br><span class="line">            pre=root;</span><br><span class="line">        }</span><br><span class="line">        inOrderTravel(root-&gt;right);</span><br><span class="line">    }</span><br><span class="line">    void recoverTree(TreeNode* root) {</span><br><span class="line">        isFirst=true;</span><br><span class="line">        pre=node1=node2=NULL;</span><br><span class="line">        inOrderTravel(root);</span><br><span class="line">        int tmp=node1-&gt;val;</span><br><span class="line">        node1-&gt;val=node2-&gt;val;</span><br><span class="line">        node2-&gt;val=tmp;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Mirros遍历</strong><br>先找到左子树前驱，如果前驱右孩子为空则，置为root，否则置为空，其他与上一个一致</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode {</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span><br><span class="line"> * };</span><br><span class="line"> */</span><br><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line">    TreeNode* pre;</span><br><span class="line">    bool isFirst;</span><br><span class="line">    TreeNode *node1, *node2;</span><br><span class="line">    void recoverTree(TreeNode* root) {</span><br><span class="line">        //初始化</span><br><span class="line">        isFirst=true;</span><br><span class="line">        pre=node1=node2=NULL;</span><br><span class="line"></span><br><span class="line">        while(root!=NULL){</span><br><span class="line">            if(root-&gt;left!=NULL){</span><br><span class="line">                TreeNode* predecessor=root-&gt;left;</span><br><span class="line">                while(predecessor-&gt;right!=NULL&amp;&amp;predecessor-&gt;right!=root){</span><br><span class="line">                    predecessor=predecessor-&gt;right;</span><br><span class="line">                }</span><br><span class="line">                if(predecessor-&gt;right==NULL){</span><br><span class="line">                    predecessor-&gt;right=root;</span><br><span class="line">                    root=root-&gt;left;</span><br><span class="line">                }else{</span><br><span class="line">                    predecessor-&gt;right=NULL;</span><br><span class="line">                    if(pre!=NULL&amp;&amp;pre-&gt;val&gt;root-&gt;val){</span><br><span class="line">                        if(node1==NULL){</span><br><span class="line">                            node1=pre;</span><br><span class="line">                            node2=root;</span><br><span class="line">                        }else node2=root;</span><br><span class="line">                    }</span><br><span class="line">                    pre=root;</span><br><span class="line">                    root=root-&gt;right;</span><br><span class="line">                }</span><br><span class="line">            }else{</span><br><span class="line">                if(pre!=NULL&amp;&amp;pre-&gt;val&gt;root-&gt;val){</span><br><span class="line">                    if(node1==NULL){</span><br><span class="line">                        node1=pre;</span><br><span class="line">                        node2=root;</span><br><span class="line">                    }else node2=root;</span><br><span class="line">                }</span><br><span class="line">                pre=root;</span><br><span class="line">                root=root-&gt;right;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        //交换</span><br><span class="line">        int tmp=node1-&gt;val;</span><br><span class="line">        node1-&gt;val=node2-&gt;val;</span><br><span class="line">        node2-&gt;val=tmp;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode {</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span><br><span class="line"> * };</span><br><span class="line"> */</span><br><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line">    TreeNode* pre;</span><br><span class="line">    bool isFirst;</span><br><span class="line">    TreeNode *node1, *node2;</span><br><span class="line">    void recoverTree(TreeNode* root) {</span><br><span class="line">        //初始化</span><br><span class="line">        isFirst=true;</span><br><span class="line">        pre=node1=node2=NULL;</span><br><span class="line"></span><br><span class="line">        while(root!=NULL){</span><br><span class="line">            if(root-&gt;left!=NULL){ //左子树不为空</span><br><span class="line">                TreeNode* predecessor=root-&gt;left;</span><br><span class="line">                while(predecessor-&gt;right!=NULL&amp;&amp;predecessor-&gt;right!=root){</span><br><span class="line">                    predecessor=predecessor-&gt;right;</span><br><span class="line">                }</span><br><span class="line">                if(predecessor-&gt;right==NULL){ //前驱右孩子为空</span><br><span class="line">                    predecessor-&gt;right=root;</span><br><span class="line">                    root=root-&gt;left; //遍历左子树</span><br><span class="line">                }else{</span><br><span class="line">                    predecessor-&gt;right=NULL;</span><br><span class="line">                    if(pre!=NULL&amp;&amp;pre-&gt;val&gt;root-&gt;val){</span><br><span class="line">                        if(node1==NULL){</span><br><span class="line">                            node1=pre;</span><br><span class="line">                            node2=root;</span><br><span class="line">                        }else node2=root;</span><br><span class="line">                    }</span><br><span class="line">                    pre=root;</span><br><span class="line">                    root=root-&gt;right;</span><br><span class="line">                }</span><br><span class="line">            }else{</span><br><span class="line">                if(pre!=NULL&amp;&amp;pre-&gt;val&gt;root-&gt;val){</span><br><span class="line">                    if(node1==NULL){</span><br><span class="line">                        node1=pre;</span><br><span class="line">                        node2=root;</span><br><span class="line">                    }else node2=root;</span><br><span class="line">                }</span><br><span class="line">                pre=root;</span><br><span class="line">                root=root-&gt;right;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        //交换</span><br><span class="line">        int tmp=node1-&gt;val;</span><br><span class="line">        node1-&gt;val=node2-&gt;val;</span><br><span class="line">        node2-&gt;val=tmp;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a>98. 验证二叉搜索树</h3><p><strong>Description</strong><br>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<p>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。<br><strong>Example</strong><br>示例 1:<br>输入:<br>    2<br>   / <br>  1   3<br>输出: true</p>
<p>示例 2:<br>输入:<br>    5<br>   / <br>  1   4<br>     / <br>    3   6<br>输出: false<br>解释: 输入为: [5,1,4,null,null,3,6]。<br>     根节点的值为 5 ，但是其右子节点值为 4 。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        DFS(root);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;vec.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(vec[i<span class="number">-1</span>]&gt;=vec[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode* root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        DFS(root-&gt;left);</span><br><span class="line">        vec.push_back(root-&gt;val);</span><br><span class="line">        DFS(root-&gt;right);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h3><p><strong>Description</strong><br>根据一棵树的前序遍历与中序遍历构造二叉树。<br>注意:<br>你可以假设树中没有重复的元素。<br><strong>Example</strong><br>例如，给出<br>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]<br>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> create(preorder, inorder, <span class="number">0</span>, preorder.size()<span class="number">-1</span>, <span class="number">0</span>, inorder.size()<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function">TreeNode* <span class="title">create</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preOrder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inOrder, <span class="keyword">int</span> pL,<span class="keyword">int</span> pR, <span class="keyword">int</span> iL,<span class="keyword">int</span> iR)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(pL&gt;pR||iL&gt;iR) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(preOrder[pL]);</span><br><span class="line">        <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=iL;i&lt;=iR;i++){</span><br><span class="line">            <span class="keyword">if</span>(inOrder[i]==preOrder[pL]){</span><br><span class="line">                pos=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> numLeft=pos-iL;</span><br><span class="line">        root-&gt;left=create(preOrder, inOrder, pL+<span class="number">1</span>,pL+numLeft, iL, pos<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right=create(preOrder, inOrder, pL+numLeft+<span class="number">1</span>, pR, pos+<span class="number">1</span>, iR);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a>106. 从中序与后序遍历序列构造二叉树</h3><p><strong>Description</strong><br>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。<br><strong>Example</strong><br>例如，给出<br>中序遍历 inorder = [9,3,15,20,7]<br>后序遍历 postorder = [9,15,7,20,3]<br>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> create(inorder, postorder, <span class="number">0</span>, inorder.size()<span class="number">-1</span>, <span class="number">0</span>, postorder.size()<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function">TreeNode* <span class="title">create</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inOrder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postOrder, <span class="keyword">int</span> iL,<span class="keyword">int</span> iR, <span class="keyword">int</span> pL,<span class="keyword">int</span> pR)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(iL&gt;iR||pL&gt;pR) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(postOrder[pR]);</span><br><span class="line">        <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=iL;i&lt;=iR;i++){</span><br><span class="line">            <span class="keyword">if</span>(inOrder[i]==postOrder[pR]){</span><br><span class="line">                pos=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> numLeft=pos-iL;</span><br><span class="line">        root-&gt;left=create(inOrder, postOrder, iL, pos<span class="number">-1</span>, pL, pL+numLeft<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right=create(inOrder, postOrder, pos+<span class="number">1</span>, iR, pL+numLeft, pR<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a>109. 有序链表转换二叉搜索树</h3><p><strong>Description</strong><br>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。<br>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。<br><strong>Example</strong><br>示例:<br>给定的有序链表： [-10, -3, 0, 5, 9],<br>一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     0</span><br><span class="line">    / \</span><br><span class="line">  -3   9</span><br><span class="line">  /   /</span><br><span class="line">-10  5</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>){</span><br><span class="line">            vec.push_back(head-&gt;val);</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> create(<span class="number">0</span>, vec.size()<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function">TreeNode* <span class="title">create</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        TreeNode* root= <span class="keyword">new</span> TreeNode(vec[mid]);</span><br><span class="line">        root-&gt;left=create(l, mid<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right=create(mid+<span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a>113. 路径总和 II</h3><p><strong>Description</strong><br>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。<br>说明: 叶子节点是指没有子节点的节点。<br><strong>Example</strong><br>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \    / \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></tbody></table></figure>
<p>返回:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">int</span> total;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) {</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        total=sum;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        findPath(root, vec, sum);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findPath</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec, <span class="keyword">int</span> sum)</span></span>{</span><br><span class="line">        sum+=root-&gt;val;</span><br><span class="line">        vec.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>&amp;&amp;sum==total){</span><br><span class="line">            result.push_back(vec);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>) findPath(root-&gt;left, vec, sum);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">NULL</span>) findPath(root-&gt;right, vec, sum);</span><br><span class="line">        vec.pop_back();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a>116. 填充每个节点的下一个右侧节点指针</h3><p><strong>Description</strong><br>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node {</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>初始状态下，所有 next 指针都被设置为 NULL。<br><strong>Example</strong><br><img src="/assets/img/algorithm/116_sample.png" alt="图示"></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：{"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":null,"right":null,"val":4},"next":null,"right":{"$id":"4","left":null,"next":null,"right":null,"val":5},"val":2},"next":null,"right":{"$id":"5","left":{"$id":"6","left":null,"next":null,"right":null,"val":6},"next":null,"right":{"$id":"7","left":null,"next":null,"right":null,"val":7},"val":3},"val":1}</span><br><span class="line"></span><br><span class="line">输出：{"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":{"$id":"4","left":null,"next":{"$id":"5","left":null,"next":{"$id":"6","left":null,"next":null,"right":null,"val":7},"right":null,"val":6},"right":null,"val":5},"right":null,"val":4},"next":{"$id":"7","left":{"$ref":"5"},"next":null,"right":{"$ref":"6"},"val":3},"right":{"$ref":"4"},"val":2},"next":null,"right":{"$ref":"7"},"val":1}</span><br><span class="line"></span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) {}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) {}</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        Node* levelNode=root;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            Node* top=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(top!=levelNode){</span><br><span class="line">                top-&gt;next=q.front();</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                levelNode=levelNode-&gt;right;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(top-&gt;left!=<span class="literal">NULL</span>) q.push(top-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(top-&gt;right!=<span class="literal">NULL</span>) q.push(top-&gt;right);</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a>117. 填充每个节点的下一个右侧节点指针 II</h3><p><strong>Description</strong><br>给定一个二叉树</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node {</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p>进阶：<br>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。<br><strong>Example</strong><br>示例：<br><img src="/assets/img/algorithm/117_sample.png" alt="图示"><br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) {}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) {}</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        Node* levelNode=root;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        Node* tmpLevel=levelNode;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            Node* top=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(top-&gt;left!=<span class="literal">NULL</span>){</span><br><span class="line">                q.push(top-&gt;left);</span><br><span class="line">                tmpLevel=top-&gt;left;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(top-&gt;right!=<span class="literal">NULL</span>){</span><br><span class="line">                q.push(top-&gt;right);</span><br><span class="line">                tmpLevel=top-&gt;right;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(top!=levelNode){</span><br><span class="line">                top-&gt;next=q.front();</span><br><span class="line">            }<span class="keyword">else</span> levelNode=tmpLevel;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="129-求根到叶子节点数字之和"><a href="#129-求根到叶子节点数字之和" class="headerlink" title="129. 求根到叶子节点数字之和"></a>129. 求根到叶子节点数字之和</h3><p><strong>Description</strong><br>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。<br>例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。<br>计算从根到叶子节点生成的所有数字之和。<br>说明: 叶子节点是指没有子节点的节点。<br><strong>Example</strong><br>示例 1:<br>输入: [1,2,3]</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br></pre></td></tr></tbody></table></figure>
<p>输出: 25<br>解释:<br>从根到叶子节点路径 1-&gt;2 代表数字 12.<br>从根到叶子节点路径 1-&gt;3 代表数字 13.<br>因此，数字总和 = 12 + 13 = 25.<br>示例 2:<br>输入: [4,9,0,5,1]</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  9   0</span><br><span class="line">&nbsp;/ \</span><br><span class="line">5   1</span><br></pre></td></tr></tbody></table></figure>
<p>输出: 1026<br>解释:<br>从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.<br>从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.<br>从根到叶子节点路径 4-&gt;0 代表数字 40.<br>因此，数字总和 = 495 + 491 + 40 = 1026.<br><strong>Progam</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        sumNodes(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sumNodes</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        sum=sum*<span class="number">10</span>+root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>) result+=sum;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>) sumNodes(root-&gt;left, sum);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">NULL</span>) sumNodes(root-&gt;right, sum);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="133-克隆图"><a href="#133-克隆图" class="headerlink" title="133. 克隆图"></a>133. 克隆图</h3><p><strong>Description</strong><br>给定无向连通图中一个节点的引用，返回该图的深拷贝（克隆）。图中的每个节点都包含它的值 val（Int） 和其邻居的列表（list[Node]）。<br><strong>Example</strong><br>示例：<br><img src="/assets/img/algorithm/113_sample.png" alt="图示"></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">{"$id":"1","neighbors":[{"$id":"2","neighbors":[{"$ref":"1"},{"$id":"3","neighbors":[{"$ref":"2"},{"$id":"4","neighbors":[{"$ref":"3"},{"$ref":"1"}],"val":4}],"val":3}],"val":2},{"$ref":"4"}],"val":1}</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">节点 1 的值是 1，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 2 的值是 2，它有两个邻居：节点 1 和 3 。</span><br><span class="line">节点 3 的值是 3，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</span><br></pre></td></tr></tbody></table></figure>

<p>提示：<br>节点数介于 1 到 100 之间。<br>无向图是一个简单图，这意味着图中没有重复的边，也没有自环。<br>由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。<br>必须将给定节点的拷贝作为对克隆图的引用返回。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; neighbors;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">        <span class="built_in">map</span>&lt;Node*, Node*&gt; m;</span><br><span class="line">        q.push(node);</span><br><span class="line">        Node* root=<span class="keyword">new</span> Node(node-&gt;val);</span><br><span class="line">        m[node]=root;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            Node* top=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;top-&gt;neighbors.size();i++){</span><br><span class="line">                Node* tmp=top-&gt;neighbors[i];</span><br><span class="line">                <span class="keyword">if</span>(m.find(tmp)==m.end()){</span><br><span class="line">                    Node* newNode=<span class="keyword">new</span> Node(tmp-&gt;val);</span><br><span class="line">                    m[tmp]=newNode;</span><br><span class="line">                    q.push(tmp);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">map</span>&lt;Node*, Node*&gt;::iterator it=m.begin();it!=m.end();it++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;it-&gt;first-&gt;neighbors.size();i++){</span><br><span class="line">                it-&gt;second-&gt;neighbors.push_back(m[it-&gt;first-&gt;neighbors[i]]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a>199. 二叉树的右视图</h3><p><strong>Description</strong><br>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。<br><strong>Example</strong><br>示例:<br>输入: [1,2,3,null,5,null,4]<br>输出: [1, 3, 4]<br>解释:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   1            &lt;---</span><br><span class="line"> /   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rightSideView(TreeNode* root) {</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        TreeNode* levelNode=root;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        q.push(root);</span><br><span class="line">        TreeNode* tmpLevel;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            TreeNode* top=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(top-&gt;left!=<span class="literal">NULL</span>){</span><br><span class="line">                q.push(top-&gt;left);</span><br><span class="line">                tmpLevel=top-&gt;left;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(top-&gt;right!=<span class="literal">NULL</span>){</span><br><span class="line">                q.push(top-&gt;right);</span><br><span class="line">                tmpLevel=top-&gt;right;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(top==levelNode){</span><br><span class="line">                result.push_back(levelNode-&gt;val);</span><br><span class="line">                levelNode=tmpLevel;   </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h3><p><strong>Description</strong><br>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]<br><strong>Example</strong><br>示例 1:<br>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。</p>
<p>示例 2:<br>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p>
<p>说明:<br>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉搜索树中。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">NULL</span>){</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val&gt;p-&gt;val&amp;&amp;root-&gt;val&gt;q-&gt;val){</span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val&lt;p-&gt;val&amp;&amp;root-&gt;val&lt;q-&gt;val){</span><br><span class="line">                root=root-&gt;right;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h3><p><strong>Description</strong><br>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]<br><strong>Example</strong><br>示例 1:<br>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出: 3<br>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p>
<p>示例 2:<br>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>输出: 5<br>解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</p>
<p>说明:<br>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉树中。<br><strong>Program</strong><br><strong>思路</strong><br>root为p,q的最近公共祖先：<br>1.p,q分别在root的左右子树上；<br>2.root=p,q在root的子树上；<br>3.root=q,p在root的子树上；<br>后序遍历：<br>先判断左右子树是否包含p或q，不分别包含p和q的话，比较2,3即可。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* res;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> leftSon=dfs(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">bool</span> rightSon=dfs(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span>((leftSon&amp;&amp;rightSon)||((root-&gt;val==p-&gt;val||root-&gt;val==q-&gt;val)&amp;&amp;(leftSon||rightSon))) res=root;</span><br><span class="line">        <span class="keyword">return</span> leftSon||rightSon||(root-&gt;val==p-&gt;val||root-&gt;val==q-&gt;val);</span><br><span class="line">    }</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{</span><br><span class="line">        dfs(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h3><p><strong>Description</strong><br>给定一个二叉树，返回所有从根节点到叶子节点的路径。<br>说明: 叶子节点是指没有子节点的节点。<br><strong>Example</strong><br>示例:<br>输入:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   1</span><br><span class="line"> /   \</span><br><span class="line">2     3</span><br><span class="line"> \</span><br><span class="line">  5</span><br></pre></td></tr></tbody></table></figure>
<p>输出: [“1-&gt;2-&gt;5”, “1-&gt;3”]<br>解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; paths;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; binaryTreePaths(TreeNode* root) {</span><br><span class="line">        DFS(root, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">converStr</span><span class="params">(<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">if</span>(val&lt;<span class="number">0</span>){</span><br><span class="line">            str+=<span class="string">'-'</span>;</span><br><span class="line">            val=-val;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">while</span>(val!=<span class="number">0</span>){</span><br><span class="line">            vec.push_back(val%<span class="number">10</span>);</span><br><span class="line">            val/=<span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator rit=vec.rbegin();rit!=vec.rend();rit++){</span><br><span class="line">            str+=*rit+<span class="string">'0'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode* root, <span class="built_in">string</span> s)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">string</span> str=s+<span class="string">"-&gt;"</span>;</span><br><span class="line">        str+=converStr(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>){</span><br><span class="line">            paths.push_back(str.substr(<span class="number">2</span>,str.length()<span class="number">-2</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>) DFS(root-&gt;left, str);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">NULL</span>) DFS(root-&gt;right, str);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a>437. 路径总和 III</h3><p><strong>Description</strong><br>给定一个二叉树，它的每个结点都存放着一个整数值。<br>找出路径和等于给定数值的路径总数。<br>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。<br>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。<br><strong>Example</strong><br>示例：<br>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      10</span><br><span class="line">     /  \</span><br><span class="line">    5   -3</span><br><span class="line">   / \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> / \   \</span><br><span class="line">3  -2   1</span><br></pre></td></tr></tbody></table></figure>
<p>返回 3。和等于 8 的路径有:</p>
<ol>
<li>5 -&gt; 3</li>
<li>5 -&gt; 2 -&gt; 1</li>
<li>-3 -&gt; 11</li>
</ol>
<p><strong>Program</strong><br><strong>思路</strong><br>（1）pathSum(root, sum)是以root为根的二叉树路径和为sum的个数，则：<br>pathSum(root, sum)=pathSum(root-&gt;left, sum)+pathSum(root-&gt;right, sum)？<br>还漏了一种情况，因为pathSum仅仅以root为根，而路径不一定以root为起点，所以这里漏了以root为起点的路径的情况：<br>pathSum(root, sum)=pathSum(root-&gt;left, sum)+pathSum(root-&gt;right, sum)+calPath(root, sum);<br>其中calPath(root, sum)为以root为起点的路径和为sum的路径数！<br>（2）所以有两个递归过程，一个是以root作为根的递归，一个是以root作为路径起点的递归；<br>（3）calPath(root,sum)中找到和为sum时，ans+1，还需要继续向下递归，因为可以类似于[1,2,-1,4],sum=3这种情况，以1位起点可以有两条路径。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calPaths</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span></span>{ <span class="comment">//以root为起点的路径数</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sum-=root-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> ans=sum==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans+calPaths(root-&gt;left, sum)+calPaths(root-&gt;right, sum);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>{ <span class="comment">//以root为根的路径数！与上不同，路径可以不以root开头</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=calPaths(root, sum);</span><br><span class="line">        ans+=pathSum(root-&gt;left, sum);</span><br><span class="line">        ans+=pathSum(root-&gt;right, sum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="508-出现次数最多的子树元素和"><a href="#508-出现次数最多的子树元素和" class="headerlink" title="508. 出现次数最多的子树元素和"></a>508. 出现次数最多的子树元素和</h3><p><strong>Description</strong><br>给你一个二叉树的根结点，请你找出出现次数最多的子树元素和。一个结点的「子树元素和」定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。<br>你需要返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。<br><strong>Example</strong><br>示例 1：<br>输入:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  5</span><br><span class="line"> /  \</span><br><span class="line">2   -3</span><br></pre></td></tr></tbody></table></figure>
<p>返回 [2, -3, 4]，所有的值均只出现一次，以任意顺序返回所有值。</p>
<p>示例 2：<br>输入：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  5</span><br><span class="line"> /  \</span><br><span class="line">2   -5</span><br></pre></td></tr></tbody></table></figure>
<p>返回 [2]，只有 2 出现两次，-5 只出现 1 次。<br>提示： 假设任意子树元素和均可以用 32 位有符号整数表示。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">postOrder</span><span class="params">(TreeNode* root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=root-&gt;val;</span><br><span class="line">        sum+=postOrder(root-&gt;left);</span><br><span class="line">        sum+=postOrder(root-&gt;right);</span><br><span class="line">        m[sum]++;</span><br><span class="line">        ans=max(ans, m[sum]);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findFrequentTreeSum(TreeNode* root) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        postOrder(root);</span><br><span class="line">        <span class="keyword">for</span>(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p:m){</span><br><span class="line">            <span class="keyword">if</span>(p.second==ans){</span><br><span class="line">                res.push_back(p.first);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="572. 另一个树的子树"></a>572. 另一个树的子树</h3><p><strong>Description</strong><br>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。<br><strong>Example</strong><br>示例 1:<br>给定的树 s:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br><span class="line"> / \</span><br><span class="line">1   2</span><br></pre></td></tr></tbody></table></figure>
<p>给定的树 t：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  4</span><br><span class="line"> / \</span><br><span class="line">1   2</span><br></pre></td></tr></tbody></table></figure>
<p>返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</p>
<p>示例 2:<br>给定的树 s：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br><span class="line"> / \</span><br><span class="line">1   2</span><br><span class="line">   /</span><br><span class="line">  0</span><br></pre></td></tr></tbody></table></figure>
<p>给定的树 t：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  4</span><br><span class="line"> / \</span><br><span class="line">1   2</span><br></pre></td></tr></tbody></table></figure>
<p>返回 false。<br><strong>Program</strong><br><strong>思路</strong><br>（1）比较当前root是否一致，一致则判断各自左右子树是否相等；<br>（2）即isSubtree(s, t) || isSubtree(s-&gt;left, t) ||isSubtree(s-&gt;right, t)<br>这里有问题，即每次第一个isSubtree(s, t)不相等的时候，后面都会进行左右子树比较，存在大量重复，解决方法是比较当前root为根的子树与t是否一致，与左右子树比较分开。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* root;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSub</span><span class="params">(TreeNode* s, TreeNode* t)</span></span>{ <span class="comment">//有重复, 因为当前状态与后续递归结果有关，那么前面的节点在后面返回为false的时候都会进行一次以其节点为根，t为根的完整子树比对，这个会与if(!isPass)中产生大量重复计算！</span></span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">NULL</span>&amp;&amp;t==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">NULL</span>||t==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> isPass=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s-&gt;val==t-&gt;val){</span><br><span class="line">            isPass = isSub(s-&gt;left, t-&gt;left) &amp;&amp; isSub(s-&gt;right, t-&gt;right);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(!isPass){</span><br><span class="line">            isPass = isSub(s-&gt;left, root) || isSub(s-&gt;right, root);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> isPass;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>{</span><br><span class="line">        root=t;</span><br><span class="line">        <span class="keyword">return</span> isSub(s, t);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* root;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(TreeNode* s, TreeNode* t)</span></span>{ <span class="comment">//有重复</span></span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">NULL</span>&amp;&amp;t==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">NULL</span>||t==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;val==t-&gt;val &amp;&amp; isSame(s-&gt;left, t-&gt;left) &amp;&amp; isSame(s-&gt;right, t-&gt;right);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">NULL</span>&amp;&amp;t==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">NULL</span>||t==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSame(s, t) || isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t); <span class="comment">//这样做就可以避免前面重复的问题！</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a>530. 二叉搜索树的最小绝对差</h3><p><strong>Description</strong><br>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。<br><strong>Example</strong><br>示例：<br>输入：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  3</span><br><span class="line"> /</span><br><span class="line">2</span><br></pre></td></tr></tbody></table></figure>
<p>输出：<br>1<br>解释：<br>最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。</p>
<p>提示：<br>树中至少有 2 个节点。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans=INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> pre=<span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="number">-1</span>) ans=min(ans,<span class="built_in">abs</span>(pre-root-&gt;val));</span><br><span class="line">        pre=root-&gt;val;</span><br><span class="line">        inOrder(root-&gt;right);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a>538. 把二叉搜索树转换为累加树</h3><p><strong>Description</strong><br>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。<br><strong>Example</strong><br>例如：<br>输入: 原始二叉搜索树:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   5</span><br><span class="line"> /   \</span><br><span class="line">2     13</span><br></pre></td></tr></tbody></table></figure>
<p>输出: 转换为累加树:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   18</span><br><span class="line">  /   \</span><br><span class="line">20     13</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addRightTree</span><span class="params">(TreeNode* root)</span></span>{ <span class="comment">//一次遍历，累加右子树和</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftSum=addRightTree(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightSum=addRightTree(root-&gt;right);</span><br><span class="line">        root-&gt;val+=rightSum; <span class="comment">//当前节点累加右子树和</span></span><br><span class="line">        <span class="keyword">return</span> root-&gt;val+leftSum; <span class="comment">//当前节点返回的为以当前节点为根的所有节点的和！</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addLeftTree</span><span class="params">(TreeNode* root, <span class="keyword">int</span> preSum)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        root-&gt;val+=preSum;                   <span class="comment">//累加父节点值</span></span><br><span class="line">        addLeftTree(root-&gt;left, root-&gt;val);  <span class="comment">//将当前节点值累加到其左孩子</span></span><br><span class="line">        addLeftTree(root-&gt;right, preSum);    <span class="comment">//右孩子累加当前节点父节点的值</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> sum=addRightTree(root);</span><br><span class="line">        addLeftTree(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a>543. 二叉树的直径</h3><p><strong>Description</strong><br>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。<br><strong>Example</strong><br>示例 :<br>给定二叉树</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \     </span><br><span class="line">4   5</span><br></pre></td></tr></tbody></table></figure>
<p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
<p>注意：两结点之间的路径长度是以它们之间边的数目表示。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calHeight</span><span class="params">(TreeNode* root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftH=calHeight(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightH=calHeight(root-&gt;right);</span><br><span class="line">        ans=max(ans, leftH+rightH);</span><br><span class="line">        <span class="keyword">return</span> max(leftH, rightH)+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        calHeight(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="563-二叉树的坡度"><a href="#563-二叉树的坡度" class="headerlink" title="563. 二叉树的坡度"></a>563. 二叉树的坡度</h3><p><strong>Description</strong><br>给定一个二叉树，计算整个树的坡度。<br>一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。<br>整个树的坡度就是其所有节点的坡度之和。<br><strong>Example</strong><br>示例：<br>输入：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   1</span><br><span class="line"> /   \</span><br><span class="line">2     3</span><br></pre></td></tr></tbody></table></figure>
<p>输出：1<br>解释：<br>结点 2 的坡度: 0<br>结点 3 的坡度: 0<br>结点 1 的坡度: |2-3| = 1<br>树的坡度 : 0 + 0 + 1 = 1</p>
<p>提示：<br>任何子树的结点的和不会超过 32 位整数的范围。<br>坡度的值不会超过 32 位整数的范围。</p>
<p><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">postOrder</span><span class="params">(TreeNode* root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftSum=postOrder(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightSum=postOrder(root-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> slope=<span class="built_in">abs</span>(leftSum-rightSum);</span><br><span class="line">        ans+=slope;</span><br><span class="line">        <span class="keyword">return</span> leftSum+rightSum+root-&gt;val;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTilt</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        postOrder(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a>617. 合并二叉树</h3><p><strong>Description</strong><br>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。<br><strong>Example</strong><br>示例 1:<br>输入:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         / \                       / \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       /                           \   \                      </span><br><span class="line">      5                             4   7     </span><br><span class="line">```             </span><br><span class="line">输出:</span><br><span class="line">合并后的树:</span><br></pre></td></tr></tbody></table></figure>
<pre><code>    3
   / \
  4   5
 / \   \
5   4   7</code></pre><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">注意:&nbsp;合并必须从两个树的根节点开始。</span><br><span class="line">**Program**</span><br><span class="line">```cpp</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode {</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span><br><span class="line"> * };</span><br><span class="line"> */</span><br><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line">    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {</span><br><span class="line">        if(t1==NULL&amp;&amp;t2==NULL) return NULL;</span><br><span class="line">        TreeNode* root=new TreeNode(0);</span><br><span class="line">        if(t1!=NULL) root-&gt;val+=t1-&gt;val;</span><br><span class="line">        if(t2!=NULL) root-&gt;val+=t2-&gt;val;</span><br><span class="line">        root-&gt;left =mergeTrees((t1!=NULL)?t1-&gt;left:NULL, (t2!=NULL)?t2-&gt;left:NULL); //注意空节点判断</span><br><span class="line">        root-&gt;right=mergeTrees((t1!=NULL)?t1-&gt;right:NULL, (t2!=NULL)?t2-&gt;right:NULL);</span><br><span class="line">        return root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="655-输出二叉树"><a href="#655-输出二叉树" class="headerlink" title="655. 输出二叉树"></a>655. 输出二叉树</h3><p><strong>Description</strong><br>在一个 m<em>n 的二维字符串数组中输出二叉树，并遵守以下规则：<br>行数 m 应当等于给定二叉树的高度。<br>列数 n 应当总是奇数。<br>根节点的值（以字符串格式给出）应当放在可放置的第一行正中间。根节点所在的行与列会将剩余空间划分为两部分（左下部分和右下部分）。你应该将左子树输出在左下部分，右子树输出在右下部分。左下和右下部分应当有相同的大小。即使一个子树为空而另一个非空，你不需要为空的子树输出任何东西，但仍需要为另一个子树留出足够的空间。然而，如果两个子树都为空则不需要为它们留出任何空间。<br>每个未使用的空间应包含一个空的字符串””。<br>使用相同的规则输出子树。<br>*</em>Example**<br>示例 1:<br>输入:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> /</span><br><span class="line">2</span><br></pre></td></tr></tbody></table></figure>
<p>输出:<br>[[“”, “1”, “”],<br> [“2”, “”, “”]]<br>示例 2:</p>
<p>输入:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line"> \</span><br><span class="line">  4</span><br></pre></td></tr></tbody></table></figure>
<p>输出:<br>[[“”, “”, “”, “1”, “”, “”, “”],<br> [“”, “2”, “”, “”, “”, “3”, “”],<br> [“”, “”, “4”, “”, “”, “”, “”]]<br>示例 3:</p>
<p>输入:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    2   5</span><br><span class="line">   /</span><br><span class="line">  3</span><br><span class="line"> /</span><br><span class="line">4</span><br></pre></td></tr></tbody></table></figure>
<p>输出:<br>[[“”,  “”,  “”, “”,  “”, “”, “”, “1”, “”,  “”,  “”,  “”,  “”, “”, “”]<br> [“”,  “”,  “”, “2”, “”, “”, “”, “”,  “”,  “”,  “”,  “5”, “”, “”, “”]<br> [“”,  “3”, “”, “”,  “”, “”, “”, “”,  “”,  “”,  “”,  “”,  “”, “”, “”]<br> [“4”, “”,  “”, “”,  “”, “”, “”, “”,  “”,  “”,  “”,  “”,  “”, “”, “”]]<br>注意: 二叉树的高度在范围 [1, 10] 中。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> rows=<span class="number">0</span>, cols=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calRowCol</span><span class="params">(TreeNode* root, <span class="keyword">int</span> h)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>){</span><br><span class="line">            rows=max(rows, h);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> leftCols=calRowCol(root-&gt;left, h+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> rightCols=calRowCol(root-&gt;right, h+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max(leftCols, rightCols)*<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(TreeNode* root, <span class="keyword">int</span> row, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> col=(left+right)/<span class="number">2</span>;</span><br><span class="line">        res[row][col]=to_string(root-&gt;val);</span><br><span class="line">        setValue(root-&gt;left, row+<span class="number">1</span>, left, col<span class="number">-1</span>);</span><br><span class="line">        setValue(root-&gt;right, row+<span class="number">1</span>, col+<span class="number">1</span>, right);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; printTree(TreeNode* root) {</span><br><span class="line">        cols=calRowCol(root, <span class="number">0</span>);</span><br><span class="line">        res.resize(rows, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(cols, <span class="string">""</span>));</span><br><span class="line">        setValue(root, <span class="number">0</span>, <span class="number">0</span>, cols<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="662-二叉树最大宽度"><a href="#662-二叉树最大宽度" class="headerlink" title="662. 二叉树最大宽度"></a>662. 二叉树最大宽度</h3><p><strong>Description</strong><br>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。<br>每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。<br><strong>Example</strong><br>示例 1:<br>输入:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   /   \</span><br><span class="line">  3     2</span><br><span class="line"> / \     \  </span><br><span class="line">5   3     9</span><br></pre></td></tr></tbody></table></figure>
<p>输出: 4<br>解释: 最大值出现在树的第 3 层，宽度为 4 (5,3,null,9)。</p>
<p>示例 2:<br>输入:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   /  </span><br><span class="line">  3    </span><br><span class="line"> / \       </span><br><span class="line">5   3</span><br></pre></td></tr></tbody></table></figure>
<p>输出: 2<br>解释: 最大值出现在树的第 3 层，宽度为 2 (5,3)。</p>
<p>示例 3:<br>输入:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  3   2</span><br><span class="line"> /        </span><br><span class="line">5</span><br></pre></td></tr></tbody></table></figure>
<p>输出: 2<br>解释: 最大值出现在树的第 2 层，宽度为 2 (3,2)。</p>
<p>示例 4:<br>输入:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    3   2</span><br><span class="line">   /     \  </span><br><span class="line">  5       9</span><br><span class="line"> /         \</span><br><span class="line">6           7</span><br></pre></td></tr></tbody></table></figure>
<p>输出: 8<br>解释: 最大值出现在树的第 4 层，宽度为 8 (6,null,null,null,null,null,null,7)。<br>注意: 答案在32位有符号整数的表示范围内。<br><strong>Program</strong><br><strong>思路</strong><br>（1）通过满二叉树的性质，子节点索引分别为$idx_{father}<em>2+1,idx_{father}}</em>2+2$，来对非空节点进行编码；<br>（2）由于二叉树的层数阅读，编码为2的指数倍，容易越界，故可以考虑同一层同时减去本层最小的索引来进行编码数值的压缩，而不会影响宽度（索引差值）的结果！<br>时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        TreeNode* node;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> idx;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(TreeNode* _node, <span class="keyword">long</span> <span class="keyword">long</span> _idx){</span><br><span class="line">            node=_node;</span><br><span class="line">            idx=_idx; <span class="comment">//按满二叉树编码</span></span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">widthOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">        q.push(Node(root, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> preMin=<span class="number">0</span>; <span class="comment">//编码压缩，因为存在指数级增长，那么可以考虑同层的索引减去同层最小值！而宽度的计算相对结果不变！</span></span><br><span class="line">        <span class="keyword">int</span> maxWidth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            <span class="keyword">int</span> size=q.size();</span><br><span class="line">            <span class="keyword">int</span> start, end;</span><br><span class="line">            <span class="keyword">int</span> nowMin=INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++){</span><br><span class="line">                Node cur=q.front();q.pop();</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) start=cur.idx; <span class="comment">//记录同层头尾两个节点的索引值</span></span><br><span class="line">                <span class="keyword">if</span>(i==size<span class="number">-1</span>) end=cur.idx;</span><br><span class="line">                <span class="keyword">if</span>(cur.node-&gt;left!=<span class="literal">NULL</span>){</span><br><span class="line">                    <span class="keyword">int</span> nowIdx=(cur.idx-preMin)*<span class="number">2</span>+<span class="number">1</span>; <span class="comment">//压缩</span></span><br><span class="line">                    nowMin=min(nowMin, nowIdx);</span><br><span class="line">                    q.push(Node(cur.node-&gt;left, nowIdx));</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(cur.node-&gt;right!=<span class="literal">NULL</span>){</span><br><span class="line">                    <span class="keyword">int</span> nowIdx=(cur.idx-preMin)*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">                    nowMin=min(nowMin, nowIdx);</span><br><span class="line">                    q.push(Node(cur.node-&gt;right, nowIdx));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">int</span> width=end-start+<span class="number">1</span>;</span><br><span class="line">            maxWidth=maxWidth&lt;width?width:maxWidth;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> maxWidth;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="894-所有可能的满二叉树"><a href="#894-所有可能的满二叉树" class="headerlink" title="894. 所有可能的满二叉树"></a>894. 所有可能的满二叉树</h3><p><strong>Description</strong><br>满二叉树是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。<br>返回包含 N 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。<br>答案中每个树的每个结点都必须有 node.val=0。<br>你可以按任何顺序返回树的最终列表。<br><strong>Example</strong><br>示例：<br>输入：7<br>输出：[[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]<br>解释：<br><img src="/assets/img/algorithm/fivetrees.png" alt="image"><br>提示：<br>1 &lt;= N &lt;= 20<br><strong>Program</strong><br><strong>递归</strong><br>根结点1<br>左子树节点数为0, 1, 3, 5, i<br>右子树节点数为N-1-i, 1, 0</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; allPossibleFBT(<span class="keyword">int</span> N) {</span><br><span class="line">        <span class="keyword">if</span>(N%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">1</span>) <span class="keyword">return</span> {<span class="keyword">new</span> TreeNode(<span class="number">0</span>)};</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N<span class="number">-1</span>;i+=<span class="number">2</span>){</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; leftTree=allPossibleFBT(i);</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; rightTree=allPossibleFBT(N<span class="number">-1</span>-i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;leftTree.size();j++){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;rightTree.size();k++){</span><br><span class="line">                    TreeNode* root=<span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                    root-&gt;left=leftTree[j];</span><br><span class="line">                    root-&gt;right=rightTree[k];</span><br><span class="line">                    res.push_back(root);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="919-完全二叉树插入器"><a href="#919-完全二叉树插入器" class="headerlink" title="919. 完全二叉树插入器"></a>919. 完全二叉树插入器</h3><p><strong>Description</strong><br>完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。<br>设计一个用完全二叉树初始化的数据结构 CBTInserter，它支持以下几种操作：</p>
<ul>
<li>CBTInserter(TreeNode root) 使用头节点为 root 的给定树初始化该数据结构；</li>
<li>CBTInserter.insert(int v)  向树中插入一个新节点，节点类型为 TreeNode，值为 v 。使树保持完全二叉树的状态，并返回插入的新节点的父节点的值；</li>
<li>CBTInserter.get_root() 将返回树的头节点。</li>
</ul>
<p><strong>Example</strong><br>示例 1：<br>输入：inputs = [“CBTInserter”,”insert”,”get_root”], inputs = [[[1]],[2],[]]<br>输出：[null,1,[1,2]]</p>
<p>示例 2：<br>输入：inputs = [“CBTInserter”,”insert”,”insert”,”get_root”], inputs = [[[1,2,3,4,5,6]],[7],[8],[]]<br>输出：[null,3,4,[1,2,3,4,5,6,7,8]]</p>
<p>提示：<br>最初给定的树是完全二叉树，且包含 1 到 1000 个节点。<br>每个测试用例最多调用 CBTInserter.insert  操作 10000 次。<br>给定节点或插入节点的每个值都在 0 到 5000 之间。<br><strong>Program</strong><br><strong>思路</strong><br>维护一个双端队列，保存孩子为0或1的节点，插入时，插入队列头结点即可，如果头结点孩子满了，出队，同时注意插入的节点孩子为0，也需要入队。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBTInserter</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* root;</span><br><span class="line">    <span class="built_in">deque</span>&lt;TreeNode*&gt; dq;<span class="comment">//保留0或1个孩子的节点</span></span><br><span class="line">    CBTInserter(TreeNode* root) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;root = root;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            TreeNode* node=q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left==<span class="literal">NULL</span>||node-&gt;right==<span class="literal">NULL</span>) dq.push_back(node);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left!=<span class="literal">NULL</span>) q.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right!=<span class="literal">NULL</span>) q.push(node-&gt;right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v)</span> </span>{</span><br><span class="line">        TreeNode* node=dq.front();</span><br><span class="line">        <span class="keyword">int</span> value=node-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left==<span class="literal">NULL</span>) {node-&gt;left=<span class="keyword">new</span> TreeNode(v);dq.push_back(node-&gt;left);}</span><br><span class="line">        <span class="keyword">else</span> {node-&gt;right=<span class="keyword">new</span> TreeNode(v);dq.push_back(node-&gt;right);}</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right!=<span class="literal">NULL</span>) dq.pop_front();</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">get_root</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CBTInserter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CBTInserter* obj = new CBTInserter(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;insert(v);</span></span><br><span class="line"><span class="comment"> * TreeNode* param_2 = obj-&gt;get_root();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968. 监控二叉树"></a>968. 监控二叉树</h3><p><strong>Description</strong><br>给定一个二叉树，我们在树的节点上安装摄像头。<br>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。<br>计算监控树的所有节点所需的最小摄像头数量。<br><strong>Example</strong><br>示例 1：<br><img src="/assets/img/algorithm/bst_cameras_01.png" alt="image"><br>输入：[0,0,null,0,0]<br>输出：1<br>解释：如图所示，一台摄像头足以监控所有节点。</p>
<p>示例 2：<br><img src="/assets/img/algorithm/bst_cameras_02.png" alt="image"><br>输入：[0,0,null,0,null,0,null,null,0]<br>输出：2<br>解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</p>
<p>提示：<br>给定树的节点数的范围是 [1, 1000]。<br>每个节点的值都是 0。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(dfs(root)==<span class="number">0</span>){</span><br><span class="line">            res++;<span class="comment">//根节点未覆盖</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    0 -- 未覆盖</span></span><br><span class="line"><span class="comment">    1 -- 已覆盖</span></span><br><span class="line"><span class="comment">    2 -- 需设置摄像头</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//已覆盖</span></span><br><span class="line">        <span class="keyword">int</span> left=dfs(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right=dfs(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">0</span>||right==<span class="number">0</span>){ <span class="comment">//左右孩子有一个未覆盖</span></span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">//需要设置摄像头</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">1</span>&amp;&amp;right==<span class="number">1</span>){ <span class="comment">//左右孩子均已覆盖，本节点未覆盖</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left+right&gt;=<span class="number">3</span>){ <span class="comment">//孩子有设置摄像头</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//已经处理完所有情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//随便返回</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="979-在二叉树中分配硬币"><a href="#979-在二叉树中分配硬币" class="headerlink" title="979. 在二叉树中分配硬币"></a>979. 在二叉树中分配硬币</h3><p><strong>Description</strong><br>给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。<br>在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。<br>返回使每个结点上只有一枚硬币所需的移动次数。<br><strong>Example</strong><br>示例 1：<br><img src="/assets/img/algorithm/tree1.png" alt="image"><br>输入：[3,0,0]<br>输出：2<br>解释：从树的根结点开始，我们将一枚硬币移到它的左子结点上，一枚硬币移到它的右子结点上。</p>
<p>示例 2：<br><img src="/assets/img/algorithm/tree2.png" alt="image"><br>输入：[0,3,0]<br>输出：3<br>解释：从根结点的左子结点开始，我们将两枚硬币移到根结点上 [移动两次]。然后，我们把一枚硬币从根结点移到右子结点上。</p>
<p>示例 3：<br><img src="/assets/img/algorithm/tree3.png" alt="image"><br>输入：[1,0,2]<br>输出：2</p>
<p>示例 4：<br><img src="/assets/img/algorithm/tree4.png" alt="image"><br>输入：[1,0,0,null,3]<br>输出：4</p>
<p>提示：<br>1&lt;= N &lt;= 100<br>0 &lt;= node.val &lt;= N<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distributeCoins</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        dfs(root); <span class="comment">//因为总共有N个硬币N个节点所以整棵树的过载量一定是0</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l=dfs(root-&gt;left); <span class="comment">//左子树过载量</span></span><br><span class="line">        <span class="keyword">int</span> r=dfs(root-&gt;right); <span class="comment">//右子树过载量</span></span><br><span class="line">        <span class="comment">//使得左右子树满足条件的移动次数</span></span><br><span class="line">        <span class="comment">//这里只需考虑从父节点移动到两个子树的移动次数即可，不管父节点金币数！少就欠着，多了不管！</span></span><br><span class="line">        <span class="comment">//之后子树的计算以该节点为根的树的过载量会覆盖子树过载量</span></span><br><span class="line">        <span class="comment">//比如例2，左子树过载量为2，右子树过载量为-1，那么从根节点移动到两个子树的移动次数为abs(2)+abs(-1)=3</span></span><br><span class="line">        <span class="comment">//而此时根节点的过载量为0+2-1-1=0刚好抵消</span></span><br><span class="line">        <span class="comment">//也就是说我们只需要考虑拿出的数量（可正可负可为零）</span></span><br><span class="line">        ans+=<span class="built_in">abs</span>(l)+<span class="built_in">abs</span>(r);</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val+l+r<span class="number">-1</span>; <span class="comment">//当前节点的过载量=该节点金币数+左子树过载量+右子树过载量-1</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="987-二叉树的垂序遍历"><a href="#987-二叉树的垂序遍历" class="headerlink" title="987. 二叉树的垂序遍历"></a>987. 二叉树的垂序遍历</h3><p><strong>Description</strong><br>给定二叉树，按垂序遍历返回其结点值。<br>对位于 (X, Y) 的每个结点而言，其左右子结点分别位于 (X-1, Y-1) 和 (X+1, Y-1)。<br>把一条垂线从 X = -infinity 移动到 X = +infinity ，每当该垂线与结点接触时，我们按从上到下的顺序报告结点的值（ Y 坐标递减）。<br>如果两个结点位置相同，则首先报告的结点值较小。<br>按 X 坐标顺序返回非空报告的列表。每个报告都有一个结点值列表。<br><strong>Example</strong><br>示例 1：<br><img src="/assets/img/algorithm/1236_example_1.png" alt="image"><br>输入：[3,9,20,null,null,15,7]<br>输出：[[9],[3,15],[20],[7]]<br>解释：<br>在不丧失其普遍性的情况下，我们可以假设根结点位于 (0, 0)：<br>然后，值为 9 的结点出现在 (-1, -1)；<br>值为 3 和 15 的两个结点分别出现在 (0, 0) 和 (0, -2)；<br>值为 20 的结点出现在 (1, -1)；<br>值为 7 的结点出现在 (2, -2)。</p>
<p>示例 2：<br><img src="/assets/img/algorithm/1236_example_2.png" alt="image"><br>输入：[1,2,3,4,5,6,7]<br>输出：[[4],[2],[1,5,6],[3],[7]]<br>解释：<br>根据给定的方案，值为 5 和 6 的两个结点出现在同一位置。<br>然而，在报告 “[1,5,6]” 中，结点值 5 排在前面，因为 5 小于 6。</p>
<p>提示：<br>树的结点数介于 1 和 1000 之间。<br>每个结点值介于 0 和 1000 之间。<br><strong>Program</strong><br><strong>思路</strong><br>（1）给每个节点坐标化；<br>（2）先按照x增序排列，在根据y轴降序排列，最后根据val升序排列；</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> x, y, val;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y, <span class="keyword">int</span> _val):x(_x),y(_y),val(_val){}</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; other) <span class="keyword">const</span>{</span><br><span class="line">            <span class="keyword">return</span> x!=other.x?x&lt;other.x:(y!=other.y?y&gt;other.y:val&lt;other.val); <span class="comment">//先按照x,y排序，然后按照val排序</span></span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; vec;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* root, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        vec.push_back(Node(x, y, root-&gt;val));</span><br><span class="line">        preOrder(root-&gt;left, x<span class="number">-1</span>, y<span class="number">-1</span>);</span><br><span class="line">        preOrder(root-&gt;right, x+<span class="number">1</span>, y<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; verticalTraversal(TreeNode* root) {</span><br><span class="line">        preOrder(root, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        sort(vec.begin(), vec.end());</span><br><span class="line">        <span class="keyword">int</span> preX=vec[<span class="number">0</span>].x;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(preX==vec[i].x) tmp.push_back(vec[i].val);</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">                tmp.clear();</span><br><span class="line">                preX=vec[i].x;</span><br><span class="line">                tmp.push_back(vec[i].val);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(!tmp.empty()) res.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1008-前序遍历构造二叉搜索树"><a href="#1008-前序遍历构造二叉搜索树" class="headerlink" title="1008. 前序遍历构造二叉搜索树"></a>1008. 前序遍历构造二叉搜索树</h3><p><strong>Description</strong><br>返回与给定前序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。<br>(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 &lt; node.val，而 node.right 的任何后代，值总 &gt; node.val。此外，前序遍历首先显示节点 node 的值，然后遍历 node.left，接着遍历 node.right。）<br>题目保证，对于给定的测试用例，总能找到满足要求的二叉搜索树。<br><strong>Example</strong><br>示例：<br>输入：[8,5,1,7,10,12]<br>输出：[8,5,10,1,7,null,12]</p>
<p>提示：<br>1 &lt;= preorder.length &lt;= 100<br>1 &lt;= preorder[i] &lt;= 10^8<br>preorder 中的值互不相同<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">createTree</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preOrder, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inOrder, <span class="keyword">int</span> pL, <span class="keyword">int</span> pR, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(pL&gt;pR||inL&gt;inR) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(preOrder[pL]);</span><br><span class="line">        <span class="keyword">int</span> pos;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=inL;i&lt;=inR;i++){</span><br><span class="line">            <span class="keyword">if</span>(inOrder[i]==preOrder[pL]){</span><br><span class="line">                pos=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> leftNum=pos-inL;</span><br><span class="line">        root-&gt;left=createTree(preOrder, inOrder, pL+<span class="number">1</span>, pL+leftNum, inL, pos<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right=createTree(preOrder, inOrder, pL+leftNum+<span class="number">1</span>, pR, pos+<span class="number">1</span>, inR);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">TreeNode* <span class="title">bstFromPreorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=preorder.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inOrder(preorder.begin(), preorder.end());</span><br><span class="line">        sort(inOrder.begin(), inOrder.end());</span><br><span class="line">        <span class="keyword">return</span> createTree(preorder, inOrder, <span class="number">0</span>, n<span class="number">-1</span>, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1104-二叉树寻路"><a href="#1104-二叉树寻路" class="headerlink" title="1104. 二叉树寻路"></a>1104. 二叉树寻路</h3><p><strong>Description</strong><br>在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。<br>如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；<br>而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。<br>给你树上某一个节点的标号 label，请你返回从根节点到该标号为 label 节点的路径，该路径是由途经的节点标号所组成的。<br><img src="/assets/img/algorithm/tree_1104.png" alt="image"><br><strong>Example</strong><br>示例 1：<br>输入：label = 14<br>输出：[1,3,4,14]</p>
<p>示例 2：<br>输入：label = 26<br>输出：[1,2,6,10,26]</p>
<p>提示：<br>$1 &lt;= label &lt;= 10^6$<br><strong>Program</strong><br><strong>思路</strong><br>（1）正常顺序下的父节点编码为子节点编码$\frac{label}{2}$；<br>（2）可以发现规律每层头尾节点的值$left+right=father_label + label/2$<br>即$father_label = left+right-label/2=2^{h-1}+2^{h}-1-label/2=3 * 2^{h-1}-1-label/2$；</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getH</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(<span class="built_in">log</span>(x) / <span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pathInZigZagTree(<span class="keyword">int</span> label) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> h=getH(label);</span><br><span class="line">        <span class="keyword">while</span>(h&gt;=<span class="number">1</span>){</span><br><span class="line">            res.push_back(label);</span><br><span class="line">            label = (<span class="keyword">int</span>)(<span class="number">3</span> * <span class="built_in">pow</span>(<span class="number">2</span>, --h) - label/<span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        res.push_back(label);</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1261-在受污染的二叉树中查找元素"><a href="#1261-在受污染的二叉树中查找元素" class="headerlink" title="1261. 在受污染的二叉树中查找元素"></a>1261. 在受污染的二叉树中查找元素</h3><p><strong>Description</strong><br>给出一个满足下述规则的二叉树：<br>root.val == 0<br>如果 treeNode.val == x 且 treeNode.left != null，那么 treeNode.left.val == 2 * x + 1<br>如果 treeNode.val == x 且 treeNode.right != null，那么 treeNode.right.val == 2 * x + 2<br>现在这个二叉树受到「污染」，所有的 treeNode.val 都变成了 -1。<br>请你先还原二叉树，然后实现 FindElements 类：<br>FindElements(TreeNode* root) 用受污染的二叉树初始化对象，你需要先把它还原。<br>bool find(int target) 判断目标值 target 是否存在于还原后的二叉树中并返回结果。<br><strong>Example</strong><br>示例 1：<br>输入：<br>[“FindElements”,”find”,”find”]<br>[[[-1,null,-1]],[1],[2]]<br>输出：<br>[null,false,true]<br>解释：<br>FindElements findElements = new FindElements([-1,null,-1]);<br>findElements.find(1); // return False<br>findElements.find(2); // return True</p>
<p>示例 2：<br>输入：<br>[“FindElements”,”find”,”find”,”find”]<br>[[[-1,-1,-1,-1,-1]],[1],[3],[5]]<br>输出：<br>[null,true,true,false]<br>解释：<br>FindElements findElements = new FindElements([-1,-1,-1,-1,-1]);<br>findElements.find(1); // return True<br>findElements.find(3); // return True<br>findElements.find(5); // return False</p>
<p>示例 3：<br>输入：<br>[“FindElements”,”find”,”find”,”find”,”find”]<br>[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]<br>输出：<br>[null,true,false,false,true]<br>解释：<br>FindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);<br>findElements.find(2); // return True<br>findElements.find(3); // return False<br>findElements.find(4); // return False<br>findElements.find(5); // return True</p>
<p>提示：<br>TreeNode.val == -1<br>二叉树的高度不超过 20<br>节点的总数在 $[1, 10^4]$ 之间<br>调用 find() 的总次数在 $[1, 10^4]$ 之间<br>$0 &lt;= target &lt;= 10^6$<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindElements</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; val;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* root, <span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        val.push_back(<span class="literal">true</span>);</span><br><span class="line">        m[x]=idx++;</span><br><span class="line">        preOrder(root-&gt;left, x*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        preOrder(root-&gt;right, x*<span class="number">2</span>+<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    FindElements(TreeNode* root) {</span><br><span class="line">        preOrder(root, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> m.find(target)!=m.end() &amp;&amp; val[m[target]];</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FindElements object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FindElements* obj = new FindElements(root);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;find(target);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindElements</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* root;</span><br><span class="line">    FindElements(TreeNode* root) {</span><br><span class="line">        rebuild(root);</span><br><span class="line">        <span class="keyword">this</span>-&gt;root=root;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">(TreeNode* root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==<span class="number">-1</span>) root-&gt;val=<span class="number">0</span>;</span><br><span class="line">        postOrder(root);</span><br><span class="line">        preOrder(root);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode* root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        postOrder(root-&gt;left);</span><br><span class="line">        postOrder(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>&amp;&amp;root-&gt;left-&gt;val!=<span class="number">-1</span>) root-&gt;val=(root-&gt;left-&gt;val<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right!=<span class="literal">NULL</span>&amp;&amp;root-&gt;right-&gt;val!=<span class="number">-1</span>) root-&gt;val=(root-&gt;right-&gt;val<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val!=<span class="number">-1</span>){</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>) root-&gt;left-&gt;val=root-&gt;val*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right!=<span class="literal">NULL</span>) root-&gt;right-&gt;val=root-&gt;val*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">        preOrder(root-&gt;left);</span><br><span class="line">        preOrder(root-&gt;right);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> findTarget(root, target);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode* root, <span class="keyword">int</span> target)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> findTarget(root-&gt;left, target) || findTarget(root-&gt;right, target);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FindElements object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FindElements* obj = new FindElements(root);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;find(target);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="1530-好叶子节点对的数量"><a href="#1530-好叶子节点对的数量" class="headerlink" title="1530. 好叶子节点对的数量"></a>1530. 好叶子节点对的数量</h3><p><strong>Description</strong><br>给你二叉树的根节点 root 和一个整数 distance 。<br>如果二叉树中两个 叶 节点之间的 最短路径长度 小于或者等于 distance ，那它们就可以构成一组 好叶子节点对 。<br>返回树中 好叶子节点对的数量 。<br><strong>Example</strong><br>示例 1：<br>输入：root = [1,2,3,null,4], distance = 3<br>输出：1<br>解释：树的叶节点是 3 和 4 ，它们之间的最短路径的长度是 3 。这是唯一的好叶子节点对。</p>
<p>示例 2：<br>输入：root = [1,2,3,4,5,6,7], distance = 3<br>输出：2<br>解释：好叶子节点对为 [4,5] 和 [6,7] ，最短路径长度都是 2 。但是叶子节点对 [4,6] 不满足要求，因为它们之间的最短路径长度为 4 。</p>
<p>示例 3：<br>输入：root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3<br>输出：1<br>解释：唯一的好叶子节点对是 [2,5] 。</p>
<p>示例 4：<br>输入：root = [100], distance = 1<br>输出：0</p>
<p>示例 5：<br>输入：root = [1,1,1], distance = 2<br>输出：1</p>
<p>提示：<br>tree 的节点数在 [1, 2^10] 范围内。<br>每个节点的值都在 [1, 100] 之间。<br>1 &lt;= distance &lt;= 10<br><strong>Program</strong><br><strong>思路</strong><br>详见官方题解<br>（1）一个自然的思路是需要记录叶子结点到以每个节点为根的距离，这里可以简化，因为题目只需要小于等于distance的好节点，所以对于每个节点为根来说，只需要记录距离小于等于distance的叶子结点个数即可，即$dist[i],0&lt;=i&lt;=distance$；<br>（2）其次，对于以每个节点为根的好节点个数来说，由两部分组成：<br>一个是leftDist[i]*rightDist[j]，其中i+j+2&lt;=distance;<br>另一个则是leftCount+rightCount；(leftCount, rightCount分别为以左右孩子为根的好节点对个数)<br>可以知道这个以节点为根的好节点对个数，即以该节点为最近公共祖先！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//返回值：</span></span><br><span class="line">    <span class="comment">//1)叶子节点到root的距离为i的个数，只需记录小于等于distance的个数！</span></span><br><span class="line">    <span class="comment">//2)以root为根的好节点对个数</span></span><br><span class="line">    pair&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; postOrder(TreeNode* root, <span class="keyword">const</span> <span class="keyword">int</span>&amp; distance){</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dist(distance+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">bool</span> isLeaf=(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(isLeaf){</span><br><span class="line">            dist[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> make_pair(dist, <span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; leftDist=<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(distance+<span class="number">1</span>, <span class="number">0</span>), rightDist=<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(distance+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> leftCount=<span class="number">0</span>, rightCount=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>) tie(leftDist, leftCount)=postOrder(root-&gt;left, distance);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">NULL</span>) tie(rightDist, rightCount)=postOrder(root-&gt;right, distance);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新当前dist数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;distance;i++)  dist[i+<span class="number">1</span>]+=leftDist[i]+rightDist[i];</span><br><span class="line">        <span class="comment">//计算以root为根节点的好节点对个数</span></span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=distance;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j+i+<span class="number">2</span>&lt;=distance;j++){</span><br><span class="line">                cnt+=(leftDist[i]*rightDist[j]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> make_pair(dist, cnt+leftCount+rightCount);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> distance)</span> </span>{</span><br><span class="line">        pair&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; p=postOrder(root, distance);</span><br><span class="line">        <span class="keyword">return</span> p.second;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先"></a>剑指 Offer 68 - II. 二叉树的最近公共祖先</h3><p><strong>Description</strong><br>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]<br><strong>Example</strong><br>示例 1:<br>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出: 3<br>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p>
<p>示例 2:<br>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>输出: 5<br>解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</p>
<p>说明:<br>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉树中。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* res;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">postOrder</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>{ <span class="comment">//判断一root为根的子树是否包含p或q</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> leftSon = postOrder(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">bool</span> rightSon = postOrder(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span>((leftSon&amp;&amp;rightSon)||((leftSon||rightSon)&amp;&amp;(root-&gt;val==p-&gt;val||root-&gt;val==q-&gt;val))) res=root;</span><br><span class="line">        <span class="keyword">return</span> leftSon || rightSon || root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{</span><br><span class="line">        postOrder(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="树遍历"><a href="#树遍历" class="headerlink" title="树遍历"></a>树遍历</h2><h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h3><p><strong>Description</strong><br>给定一个二叉树，返回它的中序 遍历。<br><strong>Example</strong><br>示例:<br>输入: [1,null,2,3]</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure>
<p>输出: [1,3,2]<br>进阶: 递归算法很简单，你可以通过迭代算法完成吗？<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) {</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur=root;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>||!st.empty()){  </span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>){</span><br><span class="line">                st.push(cur);</span><br><span class="line">                cur=cur-&gt;left;</span><br><span class="line">            }</span><br><span class="line">            cur=st.top();st.pop();</span><br><span class="line">            res.push_back(cur-&gt;val);</span><br><span class="line">            cur=cur-&gt;right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a>144. 二叉树的前序遍历</h3><p><strong>Description</strong><br>给定一个二叉树，返回它的 前序 遍历。<br><strong>Example</strong><br>示例:<br>输入: [1,null,2,3]  </p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure>
<p>输出: [1,2,3]<br>进阶: 递归算法很简单，你可以通过迭代算法完成吗？<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) {</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur=root;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>||!st.empty()){</span><br><span class="line">            <span class="keyword">if</span>(cur!=<span class="literal">NULL</span>){</span><br><span class="line">                res.push_back(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right!=<span class="literal">NULL</span>) st.push(cur-&gt;right);</span><br><span class="line">                cur=cur-&gt;left;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                cur=st.top();st.pop();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) {</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur=root;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>||!st.empty()){</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>){</span><br><span class="line">                res.push_back(cur-&gt;val);</span><br><span class="line">                st.push(cur);</span><br><span class="line">                cur=cur-&gt;left;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(!st.empty()){</span><br><span class="line">                cur=st.top();st.pop();</span><br><span class="line">                cur=cur-&gt;right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a>145. 二叉树的后序遍历</h3><p><strong>Description</strong><br>给定一个二叉树，返回它的 后序 遍历。<br><strong>Example</strong><br>示例:<br>输入: [1,null,2,3]</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure>
<p>输出: [3,2,1]<br>进阶: 递归算法很简单，你可以通过迭代算法完成吗？<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) {</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode *cur=root, *pre=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>||!st.empty()){</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>){</span><br><span class="line">                st.push(cur);</span><br><span class="line">                cur=cur-&gt;left;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(!st.empty()){</span><br><span class="line">                cur=st.top();</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right==<span class="literal">NULL</span>||pre==cur-&gt;right){ <span class="comment">//右边为空或者已经访问</span></span><br><span class="line">                    res.push_back(cur-&gt;val);</span><br><span class="line">                    pre=cur;</span><br><span class="line">                    cur=<span class="literal">NULL</span>; <span class="comment">//以该节点为根的树全部访问完成</span></span><br><span class="line">                    st.pop();</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    cur=cur-&gt;right;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a>222. 完全二叉树的节点个数</h3><p><strong>Description</strong><br>给出一个完全二叉树，求出该树的节点个数。</p>
<p>说明：<br>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。<br><strong>Example</strong><br>示例:<br>输入:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \  /</span><br><span class="line">4  5 6</span><br></pre></td></tr></tbody></table></figure>
<p>输出: 6<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> countNodes(root-&gt;left)+countNodes(root-&gt;right)+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a>501. 二叉搜索树中的众数</h2><p><strong>Description</strong><br>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p>
<p>假定 BST 有如下定义：<br>结点左子树中所含结点的值小于等于当前结点的值<br>结点右子树中所含结点的值大于等于当前结点的值<br>左子树和右子树都是二叉搜索树<br><strong>Example</strong><br>例如：<br>给定 BST [1,null,2,2],</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">2</span><br></pre></td></tr></tbody></table></figure>
<p>返回[2].</p>
<p>提示：如果众数超过1个，不需考虑输出顺序<br>进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base, count ,maxCount;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(x==base){</span><br><span class="line">            count++;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            base=x;</span><br><span class="line">            count=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(count==maxCount){</span><br><span class="line">            res.push_back(base);</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(count&gt;maxCount){</span><br><span class="line">            res.clear();</span><br><span class="line">            maxCount=count;</span><br><span class="line">            res.push_back(base);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findMode(TreeNode* root) {</span><br><span class="line">        TreeNode* cur=root, *pre=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>){ <span class="comment">//Morris中序遍历，构造树的前驱</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left==<span class="literal">NULL</span>){ <span class="comment">//左节点为空没有前驱</span></span><br><span class="line">                update(cur-&gt;val);</span><br><span class="line">                cur=cur-&gt;right;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//左子树不为空，寻找前驱</span></span><br><span class="line">            pre=cur-&gt;left;</span><br><span class="line">            <span class="keyword">while</span>(pre-&gt;right!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;right!=cur){</span><br><span class="line">                pre=pre-&gt;right;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(pre-&gt;right==<span class="literal">NULL</span>){ <span class="comment">//前驱右节点指向cur</span></span><br><span class="line">                pre-&gt;right=cur;</span><br><span class="line">                cur=cur-&gt;left;</span><br><span class="line">            }<span class="keyword">else</span>{  <span class="comment">//恢复原树结构，前驱右指针置空</span></span><br><span class="line">                pre-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">                update(cur-&gt;val);</span><br><span class="line">                cur=cur-&gt;right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a>637. 二叉树的层平均值</h2><p><strong>Description</strong><br>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。<br><strong>Example</strong><br>示例 1：<br>输入：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></tbody></table></figure>
<p>输出：[3, 14.5, 11]<br>解释：<br>第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。</p>
<p>提示：<br>节点值的范围在32位有符号整数范围内。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; averageOfLevels(TreeNode* root) {</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            <span class="keyword">int</span> size=q.size();</span><br><span class="line">            <span class="keyword">double</span> avg=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++){</span><br><span class="line">                TreeNode* now=q.front();q.pop();</span><br><span class="line">                avg+=now-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(now-&gt;left!=<span class="literal">NULL</span>) q.push(now-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(now-&gt;right!=<span class="literal">NULL</span>) q.push(now-&gt;right);</span><br><span class="line">            }</span><br><span class="line">            avg/=size;</span><br><span class="line">            res.push_back(avg);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1022-从根到叶的二进制数之和"><a href="#1022-从根到叶的二进制数之和" class="headerlink" title="1022. 从根到叶的二进制数之和"></a>1022. 从根到叶的二进制数之和</h3><p><strong>Description</strong><br>给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1，那么它表示二进制数 01101，也就是 13 。<br>对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。<br>返回这些数字之和。题目数据保证答案是一个 32 位 整数。<br><strong>Example</strong><br>示例 1：<br>输入：root = [1,0,1,0,1,0,1]<br>输出：22<br>解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22</p>
<p>示例 2：<br>输入：root = [0]<br>输出：0</p>
<p>示例 3：<br>输入：root = [1]<br>输出：1</p>
<p>示例 4：<br>输入：root = [1,1]<br>输出：3</p>
<p>提示：<br>树中的结点数介于 1 和 1000 之间。<br>Node.val 为 0 或 1 。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* root, <span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        x&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        x|=root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>){</span><br><span class="line">            ans+=x;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        preOrder(root-&gt;left, x);</span><br><span class="line">        preOrder(root-&gt;right, x);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRootToLeaf</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        preOrder(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="树计数"><a href="#树计数" class="headerlink" title="树计数"></a>树计数</h2><h3 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a>230. 二叉搜索树中第K小的元素</h3><p><strong>Description</strong><br>给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。</p>
<p>说明：<br>你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。<br><strong>Example</strong><br>示例 1:<br>输入: root = [3,1,4,null,2], k = 1</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line"> \</span><br><span class="line">&nbsp;  2</span><br></pre></td></tr></tbody></table></figure>
<p>输出: 1</p>
<p>示例 2:<br>输入: root = [5,3,6,2,4,null,null,1], k = 3</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">   / \</span><br><span class="line">  2   4</span><br><span class="line"> /</span><br><span class="line">1</span><br></pre></td></tr></tbody></table></figure>
<p>输出: 3<br>进阶：<br>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？<br><strong>Program</strong><br><strong>栈遍历</strong><br>时间复杂度：$O(H+K)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        st.push(root);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty()&amp;&amp;ans&lt;k){</span><br><span class="line">            TreeNode* node=st.top();</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left!=<span class="literal">NULL</span>&amp;&amp;s.find(node-&gt;left)==s.end()) st.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                st.pop();ans++; s.insert(node);</span><br><span class="line">                <span class="keyword">if</span>(ans==k) {</span><br><span class="line">                    res=node-&gt;val;<span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right!=<span class="literal">NULL</span>) st.push(node-&gt;right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a>404. 左叶子之和</h3><p><strong>Description</strong><br>计算给定二叉树的所有左叶子之和。<br><strong>Example</strong><br>示例：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></tbody></table></figure>
<p>在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leftLeavesSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> isLeft)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>){</span><br><span class="line">            <span class="keyword">if</span>(isLeft) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>){</span><br><span class="line">            <span class="keyword">return</span> leftLeavesSum(root-&gt;right, <span class="literal">false</span>);</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right==<span class="literal">NULL</span>){</span><br><span class="line">            <span class="keyword">return</span> leftLeavesSum(root-&gt;left, <span class="literal">true</span>);</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">return</span> leftLeavesSum(root-&gt;left, <span class="literal">true</span>) + leftLeavesSum(root-&gt;right, <span class="literal">false</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> leftLeavesSum(root, <span class="literal">false</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1></blockquote>
<h2 id="线性二分"><a href="#线性二分" class="headerlink" title="线性二分"></a>线性二分</h2><h3 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h3><p><strong>Description</strong><br>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。<br>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。<br>你可以假设数组中不存在重复的元素。<br>你的算法时间复杂度必须是 O(log n) 级别。<br><strong>Example</strong><br>示例 1:<br>输入: nums = [4,5,6,7,0,1,2], target = 0<br>输出: 4</p>
<p>示例 2:<br>输入: nums = [4,5,6,7,0,1,2], target = 3<br>输出: -1<br><strong>Program</strong><br><strong>思路</strong><br>首先，题目要求时间复杂度必须是$O(\log{n})$，则肯定要用二分查找，但是一般二分查找需要有序，那么现在这种不分有序可以吗？可以！<br>设left,mid,right分别为当前搜索左、中、右索引：<br>按照一般二分思路：<br>（1）如果nums[mid]==target，则返回mid，找到元素；<br>（2）如果[left,mid-1]有序：<br>①如果target在此范围内，则在左半部分查找；<br>②如果target不在此范围内，则在右半部分查找，此时有可能变成原问题(与递归很像)；<br>（3）如果[mid+1,right]有序:<br>①如果target在此范围内，则在右半部分查找；<br>②否则，在左半部分查找，此时有可能原问题</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;left&lt;&lt;" "&lt;&lt;mid&lt;&lt;" "&lt;&lt;right&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]&lt;=nums[mid]){ <span class="comment">//左半部分有序，注意不要比较nums[mid-1]，下同，因为mid-1可能小于left</span></span><br><span class="line">                <span class="keyword">if</span>(target&gt;=nums[left]&amp;&amp;target&lt;nums[mid]) right=mid<span class="number">-1</span>; <span class="comment">//往左半部分搜索</span></span><br><span class="line">                <span class="keyword">else</span> left=mid+<span class="number">1</span>; <span class="comment">//往右半部分搜索，又可能成了原问题</span></span><br><span class="line"></span><br><span class="line">            }<span class="keyword">else</span>{  <span class="comment">//右半部分有序</span></span><br><span class="line">                <span class="keyword">if</span>(target&gt;nums[mid]&amp;&amp;target&lt;=nums[right]) left=mid+<span class="number">1</span>; <span class="comment">//往右半部分搜索</span></span><br><span class="line">                <span class="keyword">else</span> right=mid<span class="number">-1</span>; <span class="comment">//往左半部分搜索，有可能成了原问题</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h3><p><strong>Description</strong><br>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。<br>你的算法时间复杂度必须是 O(log n) 级别。<br>如果数组中不存在目标值，返回 [-1, -1]。<br><strong>Example</strong><br>示例 1:<br>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: [3,4]</p>
<p>示例 2:<br>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: [-1,-1]<br><strong>Program</strong><br><strong>思路</strong><br>题目就是找比target小的第一个位置，以及比target大的第一个位置<br>注意边界！！！！搞死人！<br>时间复杂度：$O(\log{n})$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) {</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> {<span class="number">-1</span>, <span class="number">-1</span>};</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){ <span class="comment">//找第一个比target大的位置</span></span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target) right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//求得第一个比target大的位置left</span></span><br><span class="line">        <span class="comment">//注意如果target在数组内，那么在left或left-1位置上必然为target</span></span><br><span class="line">        <span class="comment">//因为left此时最大为n-1，即target&gt;=nums[n-1]</span></span><br><span class="line">        <span class="keyword">int</span> r=nums[left]==target?left:(left<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;nums[left<span class="number">-1</span>]==target)?left<span class="number">-1</span>:<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(r==<span class="number">-1</span>) <span class="keyword">return</span> {<span class="number">-1</span>, <span class="number">-1</span>};</span><br><span class="line">        left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){ <span class="comment">//找第一个比target小的位置</span></span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target) left=mid;</span><br><span class="line">            <span class="keyword">else</span> right=mid<span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//求得第一个比target小的位置left</span></span><br><span class="line">        <span class="comment">//注意如果target在数组内，那么在left或left+1位置上必然为target</span></span><br><span class="line">        <span class="comment">//因为left此时最小为0，即target&lt;=nums[0]</span></span><br><span class="line">        <span class="keyword">int</span> l=nums[left]==target?left:(left+<span class="number">1</span>&lt;n&amp;&amp;nums[left+<span class="number">1</span>]==target)?left+<span class="number">1</span>:<span class="number">-1</span>; <span class="comment">//记录</span></span><br><span class="line">        <span class="keyword">if</span>(l==<span class="number">-1</span>) <span class="keyword">return</span> {<span class="number">-1</span>, <span class="number">-1</span>};</span><br><span class="line">        <span class="keyword">return</span> {l, r}; <span class="comment">//注意两端的元素！比如10，l=4,r=5</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h3><p><strong>Description</strong><br>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>你可以假设数组中无重复元素。<br><strong>Example</strong><br>示例 1:<br>输入: [1,3,5,6], 5<br>输出: 2</p>
<p>示例 2:<br>输入: [1,3,5,6], 2<br>输出: 1</p>
<p>示例 3:<br>输入: [1,3,5,6], 7<br>输出: 4</p>
<p>示例 4:<br>输入: [1,3,5,6], 0<br>输出: 0<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target) right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(right==nums.size()<span class="number">-1</span>&amp;&amp;nums[right]&lt;target) right++;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根"></a>69. x 的平方根</h3><p><strong>Description</strong><br>实现 int sqrt(int x) 函数。<br>计算并返回 x 的平方根，其中 x 是非负整数。<br>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。<br><strong>Example</strong><br>示例 1:<br>输入: 4<br>输出: 2</p>
<p>示例 2:<br>输入: 8<br>输出: 2<br>说明: 8 的平方根是 2.82842…,<br>     由于返回类型是整数，小数部分将被舍去。<br><strong>Program</strong><br>注意二分法，left+right+1防止死循环</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> left=<span class="number">0</span>, right=x;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="comment">//加1防止死循环</span></span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> mid=(left+right+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid*mid&lt;=(<span class="keyword">long</span> <span class="keyword">long</span>)x) left=mid;</span><br><span class="line">            <span class="keyword">else</span> right=mid<span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a>81. 搜索旋转排序数组 II</h3><p><strong>Description</strong><br>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。<br>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。<br><strong>Example</strong><br>示例 1:<br>输入: nums = [2,5,6,0,0,1,2], target = 0<br>输出: true</p>
<p>示例 2:<br>输入: nums = [2,5,6,0,0,1,2], target = 3<br>输出: false<br>进阶:<br>这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。<br>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？<br><strong>Program</strong><br>由于无法根据nums[left]&lt;=nums[mid]判断哪边直接有序，因为譬如[1,0,0,1,1,1,1],target=0，但是如果nums[left]==nums[mid]，只要target!=nums[mid]，直接left++，相当于化为子问题[0,0,1,1,1]进行查找。<br>最差时间复杂度：$O(n)$，例如[1,1,1,1,0]，target=0</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]==nums[mid]){ <span class="comment">//有重复元素时，不方便判断左右不分是否有序，但是这时left对应肯定不是所求，跳过即可</span></span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(nums[left]&lt;nums[mid]){ <span class="comment">//左半部分有序</span></span><br><span class="line">                <span class="keyword">if</span>(target&gt;=nums[left]&amp;&amp;target&lt;nums[mid]) right=mid<span class="number">-1</span>; <span class="comment">//往左半部分搜索</span></span><br><span class="line">                <span class="keyword">else</span> left=mid+<span class="number">1</span>; <span class="comment">//往右半部分搜索，又可能成了原问题</span></span><br><span class="line"></span><br><span class="line">            }<span class="keyword">else</span>{  <span class="comment">//右半部分有序</span></span><br><span class="line">                <span class="keyword">if</span>(target&gt;nums[mid]&amp;&amp;target&lt;=nums[right]) left=mid+<span class="number">1</span>; <span class="comment">//往右半部分搜索</span></span><br><span class="line">                <span class="keyword">else</span> right=mid<span class="number">-1</span>; <span class="comment">//往左半部分搜索，有可能成了原问题</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a>153. 寻找旋转排序数组中的最小值</h3><p><strong>Description</strong><br>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。<br>请找出其中最小的元素。<br>你可以假设数组中不存在重复元素。<br><strong>Example</strong><br>示例 1:<br>输入: [3,4,5,1,2]<br>输出: 1</p>
<p>示例 2:<br>输入: [4,5,6,7,0,1,2]<br>输出: 0<br><strong>Program</strong><br><strong>思路</strong><br>还是之前旋转排序树组的思路，不同的是，这里需要记录minValue，<br>（1）当左半部分有序，minValue肯定在nums[left]或右半部分产生，left=mid+1；<br>（2）当右半部分有序，minvalue肯定在nums[mid]或左半部分产生，right=mid-1；<br>（3）判断left&lt;=right，又回到了子问题！<br>时间复杂度：$O(\log{n})$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> minValue=INT_MAX;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]&lt;=nums[mid]){</span><br><span class="line">                minValue=min(minValue, nums[left]);</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                minValue=min(minValue, nums[mid]);</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> minValue;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162. 寻找峰值"></a>162. 寻找峰值</h3><p><strong>Description</strong><br>峰值元素是指其值大于左右相邻值的元素。<br>给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。<br>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。<br>你可以假设 nums[-1] = nums[n] = -∞。<br><strong>Example</strong><br>示例 1:<br>输入: nums = [1,2,3,1]<br>输出: 2<br>解释: 3 是峰值元素，你的函数应该返回其索引 2。</p>
<p>示例 2:<br>输入: nums = [1,2,1,3,5,6,4]<br>输出: 1 或 5<br>解释: 你的函数可以返回索引 1，其峰值元素为 2；<br>     或者返回索引 5， 其峰值元素为 6。<br>说明:<br>你的解法应该是 $O(\log{N})$ 时间复杂度的。<br><strong>Program</strong><br><strong>递归二分查找</strong><br>也可以说是分治。<br>设left,right分别是数组左右端点下标，mid=(left+right)/2：<br>（1）判断mid是否满足峰值，如果是直接返回；<br>（2）否则，判断子问题(left,mid)以及(mid,right)是否有满足题意的峰值，或运算；<br>（3）边界：</p>
<ul>
<li>left==right，即数组只有一个元素，先判断是否满足峰值，若满足，返回true，否则返回false！</li>
<li>right-left=1，即数组只有两个元素，由于mid=(left+right)/2，所以mid一定是奇数时的中点位置或者偶数时中间偏左的位置：<strong>若mid满足，则返回true；否则判断子问题(left,mid)以及(mid+1,right)——不能判断(mid,right)因为会死循环！</strong><br>当然，找到峰值时，当然要记录峰值位置了，找到一个即可，或运算的前者如果为true，后面就不会计算了~<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findPeak</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>((mid<span class="number">-1</span>&lt;<span class="number">0</span>||nums[mid]&gt;nums[mid<span class="number">-1</span>])&amp;&amp;(mid+<span class="number">1</span>&gt;=n||nums[mid]&gt;nums[mid+<span class="number">1</span>])){</span><br><span class="line">            res=mid;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(left==right) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//只有一个元素的时候，先检查</span></span><br><span class="line">        <span class="keyword">if</span>(right-left==<span class="number">1</span>) <span class="keyword">return</span> findPeak(nums, left, mid) || findPeak(nums, mid+<span class="number">1</span>, right); <span class="comment">//只有两个元素的时候</span></span><br><span class="line">        <span class="keyword">return</span> findPeak(nums, left, mid) || findPeak(nums, mid, right);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        n=nums.size();</span><br><span class="line">        findPeak(nums, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="270-最接近的二叉搜索树值"><a href="#270-最接近的二叉搜索树值" class="headerlink" title="270. 最接近的二叉搜索树值"></a>270. 最接近的二叉搜索树值</h3></li>
</ul>
<p><strong>Description</strong><br>给定一个不为空的二叉搜索树和一个目标值 target，请在该二叉搜索树中找到最接近目标值 target 的数值。<br>注意：<br>给定的目标值 target 是一个浮点数<br>题目保证在该二叉搜索树中只会存在一个最接近目标值的数<br><strong>Example</strong><br>示例：<br>输入: root = [4,2,5,1,3]，目标值 target = 3.714286</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></tbody></table></figure>
<p>输出: 4<br><strong>Program</strong><br><strong>遍历</strong><br>时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">long</span> inf=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">long</span> res;</span><br><span class="line">    <span class="keyword">double</span> t;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(root-&gt;val-t)&lt;<span class="built_in">abs</span>(res - t)) res=root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>) dfs(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">NULL</span>) dfs(root-&gt;right);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode* root, <span class="keyword">double</span> target)</span> </span>{</span><br><span class="line">        res=inf;</span><br><span class="line">        t=target;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>二分</strong><br>时间复杂度：$O(H)$<br>根据root-&gt;Val与target的比较选择左右子树。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> minDis=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode* root, <span class="keyword">double</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">double</span> dis=<span class="built_in">abs</span>(root-&gt;val-target);</span><br><span class="line">        <span class="keyword">if</span>(dis&lt;minDis){</span><br><span class="line">            minDis=dis;</span><br><span class="line">            res=root-&gt;val;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;target) res=closestValue(root-&gt;right, target);</span><br><span class="line">        <span class="keyword">else</span> res=closestValue(root-&gt;left, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="274-H-指数"><a href="#274-H-指数" class="headerlink" title="274. H 指数"></a>274. H 指数</h3><p><strong>Description</strong><br>给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。<br>h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数 不超过 h 次。）<br>例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。<br><strong>Example</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; citations)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=citations.size();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        sort(citations.begin(), citations.end());</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(citations[mid]&gt;=n-mid){</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">                res=max(res, n-mid);</span><br><span class="line">            }<span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>示例：<br>输入：citations = [3,0,6,1,5]<br>输出：3<br>解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。<br>     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。</p>
<p>提示：如果 h 有多种可能的值，h 指数是其中最大的那个。</p>
<h3 id="275-H指数-II"><a href="#275-H指数-II" class="headerlink" title="275. H指数 II"></a>275. H指数 II</h3><p><strong>Description</strong><br>给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照升序排列。编写一个方法，计算出研究者的 h 指数。<br>h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）”<br><strong>Example</strong><br>示例:<br>输入: citations = [0,1,3,5,6]<br>输出: 3<br>解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。<br>     由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。</p>
<p>说明:<br>如果 h 有多有种可能的值 ，h 指数是其中最大的那个。</p>
<p>进阶：<br>这是 H指数 的延伸题目，本题中的 citations 数组是保证有序的。<br>你可以优化你的算法到对数时间复杂度吗？<br><strong>Program</strong><br><strong>二分查找</strong><br>如果citations[mid]&gt;=n-mid，则H=n-mid是一个可能的解，这里需要H尽可能大，所以mid要尽可能靠左。<br>时间复杂度：$O(\log{n})$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; citations)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(citations.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=citations.size();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(citations[mid]&gt;=n-mid) right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(citations[left]&lt;n-left) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> n-left;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278. 第一个错误的版本"></a>278. 第一个错误的版本</h3><p><strong>Description</strong><br>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。<br>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。<br>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。<br><strong>Example</strong><br>示例:<br>给定 n = 5，并且 version = 4 是第一个错误的版本。<br>调用 isBadVersion(3) -&gt; false<br>调用 isBadVersion(5) -&gt; true<br>调用 isBadVersion(4) -&gt; true<br>所以，4 是第一个错误的版本。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The API isBadVersion is defined for you.</span></span><br><span class="line"><span class="comment">// bool isBadVersion(int version);</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>, right=n;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid)) right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a>287. 寻找重复数</h3><p><strong>Description</strong><br>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。<br><strong>Example</strong><br>示例 1:<br>输入: [1,3,4,2,2]<br>输出: 2</p>
<p>示例 2:<br>输入: [3,1,3,4,2]<br>输出: 3<br>说明：<br>不能更改原数组（假设数组是只读的）。<br>只能使用额外的 $O(1)$ 的空间。<br>时间复杂度小于 $O(n^2)$ 。<br>数组中只有一个重复的数字，但它可能不止重复出现一次。<br><strong>Program</strong><br>从[1,n]进行二分判断那个数为重复数，left=1,right=n，计算数组中小于等于mid的个数cnt：</p>
<ul>
<li>如果cnt小于等于mid，则[1,mid]范围内不存在重复数；</li>
<li>如果cnt严格大于mid，则[1,mid]必定存在重复数；</li>
</ul>
<p><strong>因为n+1个元素的数组，其中只有一个数target重复至少一次，那么对于数组中原本大于等于target的数x，数组中小于等于x的个数一定大于x。因为如果不存在重复小于等于x的数的个数严格小于等于x</strong><br>时间复杂度：$O(n\log{n})$<br>空间复杂度：$O(1)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x: nums) cnt+=(x&lt;=mid)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;mid) right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="374-猜数字大小"><a href="#374-猜数字大小" class="headerlink" title="374. 猜数字大小"></a>374. 猜数字大小</h3><p><strong>Description</strong><br>我们正在玩一个猜数字游戏。 游戏规则如下：<br>我从 1 到 n 选择一个数字。 你需要猜我选择了哪个数字。<br>每次你猜错了，我会告诉你这个数字是大了还是小了。<br>你调用一个预先定义好的接口 guess(int num)，它会返回 3 个可能的结果（-1，1 或 0）：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-1 : 我的数字比较小</span><br><span class="line"> 1 : 我的数字比较大</span><br><span class="line"> 0 : 恭喜！你猜对了！</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Example</strong><br>示例 :<br>输入: n = 10, pick = 6<br>输出: 6<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Forward declaration of guess API.</span></span><br><span class="line"><span class="comment"> * @param  num   your guess</span></span><br><span class="line"><span class="comment"> * @return 	     -1 if num is lower than the guess number</span></span><br><span class="line"><span class="comment"> *			      1 if num is higher than the guess number</span></span><br><span class="line"><span class="comment"> *               otherwise return 0</span></span><br><span class="line"><span class="comment"> * int guess(int num);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>, right=n;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(guess(mid)==<span class="number">0</span>) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(guess(mid)==<span class="number">1</span>) left=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right=mid<span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="436-寻找右区间"><a href="#436-寻找右区间" class="headerlink" title="436. 寻找右区间"></a>436. 寻找右区间</h3><p><strong>Description</strong><br>给定一组区间，对于每一个区间 i，检查是否存在一个区间 j，它的起始点大于或等于区间 i 的终点，这可以称为 j 在 i 的“右侧”。</p>
<p>对于任何区间，你需要存储的满足条件的区间 j 的最小索引，这意味着区间 j 有最小的起始点可以使其成为“右侧”区间。如果区间 j 不存在，则将区间 i 存储为 -1。最后，你需要输出一个值为存储的区间值的数组。</p>
<p>注意:</p>
<ul>
<li>你可以假设区间的终点总是大于它的起始点。</li>
<li>你可以假定这些区间都不具有相同的起始点</li>
</ul>
<p><strong>Example</strong><br>示例 1:<br>输入: [ [1,2] ]<br>输出: [-1]</p>
<p>解释:集合中只有一个区间，所以输出-1。</p>
<p>示例 2:<br>输入: [ [3,4], [2,3], [1,2] ]<br>输出: [-1, 0, 1]</p>
<p>解释:对于[3,4]，没有满足条件的“右侧”区间。<br>对于[2,3]，区间[3,4]具有最小的“右”起点;<br>对于[1,2]，区间[2,3]具有最小的“右”起点。</p>
<p>示例 3:<br>输入: [ [1,4], [2,3], [3,4] ]<br>输出: [-1, 2, -1]</p>
<p>解释:对于区间[1,4]和[3,4]，没有满足条件的“右侧”区间。<br>对于[2,3]，区间[3,4]有最小的“右”起点。<br><strong>Program</strong><br>吐槽题干，最小索引个屁！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos;</span><br><span class="line">        <span class="keyword">int</span> idx;</span><br><span class="line">        Node(){};</span><br><span class="line">        Node(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _pos, <span class="keyword">int</span> _idx):pos(_pos),idx(_idx){}</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findRightInterval(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) {</span><br><span class="line">        <span class="keyword">int</span> n=intervals.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; vec;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) vec.push_back(Node(intervals[i], i));</span><br><span class="line">        sort(vec.begin(), vec.end(), [](<span class="keyword">const</span> Node&amp; a, <span class="keyword">const</span> Node&amp; b){<span class="keyword">return</span> a.pos[<span class="number">0</span>]&lt;b.pos[<span class="number">0</span>];});</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v:intervals){</span><br><span class="line">            <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">                <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(vec[mid].pos[<span class="number">0</span>]&gt;=v[<span class="number">1</span>]) right=mid;</span><br><span class="line">                <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(vec[left].pos[<span class="number">0</span>]&lt;v[<span class="number">1</span>]) res.push_back(<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span> res.push_back(vec[left].idx);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="475-供暖器"><a href="#475-供暖器" class="headerlink" title="475. 供暖器"></a>475. 供暖器</h3><p><strong>Description</strong><br>冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。<br>现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。<br>所以，你的输入将会是房屋和供暖器的位置。你将输出供暖器的最小加热半径。</p>
<p>说明:</p>
<ul>
<li>给出的房屋和供暖器的数目是非负数且不会超过 25000。</li>
<li>给出的房屋和供暖器的位置均是非负数且不会超过10^9。</li>
<li>只要房屋位于供暖器的半径内(包括在边缘上)，它就可以得到供暖。</li>
<li>所有供暖器都遵循你的半径标准，加热的半径也一样。</li>
</ul>
<p><strong>Example</strong><br>示例 1:<br>输入: [1,2,3],[2]<br>输出: 1<br>解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。</p>
<p>示例 2:<br>输入: [1,2,3,4],[1,4]<br>输出: 1<br>解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。<br><strong>Program</strong><br>利用二分寻找每个hosue最近的两个热水器位置，取其最小距离作为其最小半径，而所有house的最小半径的最大值即为所求！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRadius</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; houses, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heaters)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=heaters.size();</span><br><span class="line">        sort(heaters.begin(), heaters.end());</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> house:houses){</span><br><span class="line">            <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">                <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(heaters[mid]&gt;=house) right=mid;</span><br><span class="line">                <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">int</span> disLeft=(heaters[left]&lt;house)?<span class="built_in">abs</span>(house-heaters[left]):(left<span class="number">-1</span>&gt;=<span class="number">0</span>)?<span class="built_in">abs</span>(house-heaters[left<span class="number">-1</span>]):INT_MAX; <span class="comment">//注意边界</span></span><br><span class="line">            <span class="keyword">int</span> disRight=(heaters[left]&gt;=house)?<span class="built_in">abs</span>(house-heaters[left]):INT_MAX;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;disLeft&lt;&lt;" "&lt;&lt;disRight&lt;&lt;endl;</span></span><br><span class="line">            res=max(res, min(disLeft, disRight));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="528-按权重随机选择"><a href="#528-按权重随机选择" class="headerlink" title="528. 按权重随机选择"></a>528. 按权重随机选择</h3><p><strong>Description</strong><br>给定一个正整数数组 w ，其中 w[i] 代表位置 i 的权重，请写一个函数 pickIndex ，它可以随机地获取位置 i，选取位置 i 的概率与 w[i] 成正比。<br>例如，给定一个值 [1，9] 的输入列表，当我们从中选择一个数字时，很有可能 10 次中有 9 次应该选择数字 9 作为答案。<br><strong>Example</strong><br>示例 1：<br>输入：<br>[“Solution”,”pickIndex”]<br>[[[1]],[]]<br>输出：[null,0]<br>示例 2：</p>
<p>输入：<br>[“Solution”,”pickIndex”,”pickIndex”,”pickIndex”,”pickIndex”,”pickIndex”]<br>[[[1,3]],[],[],[],[],[]]<br>输出：[null,0,1,1,1,0]</p>
<p>输入语法说明：<br>输入是两个列表：调用成员函数名和调用的参数。Solution 的构造函数有一个参数，即数组 w。pickIndex 没有参数。输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。</p>
<p>提示：<br>1 &lt;= w.length &lt;= 10000<br>1 &lt;= w[i] &lt;= 10^5<br>pickIndex 将被调用不超过 10000 次<br><strong>Program</strong><br>思路，由于选择位置i的概率与权重w[i]成正比，所以设基础概率为p，可知$p\sum_{i=0}^{n-1}W[i]=1}，所以$p_i=w[i]/\sum_{j=0}^{n-1}w[j]$。<br>一般使用均匀分布，那么类似画条线，根据权重落在一段区间内表示选择位置i，例如[1,2,3]，则在[1,6]范围内，[1],[2,3],[4,5,6]分别为三个位置的概率区间，根据二分查找找到去第几个区间即可。<br>时间复杂度：$O(n)$,pickIndex的复杂度$O(\log{n})$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    mt19937 rng{random_device{}()};</span><br><span class="line">    uniform_int_distribution&lt;<span class="keyword">int</span>&gt; ui;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preSum;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; w) {</span><br><span class="line">        n=w.size();</span><br><span class="line">        <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:w){</span><br><span class="line">            s+=x;</span><br><span class="line">            preSum.push_back(s);</span><br><span class="line">        }</span><br><span class="line">        ui=uniform_int_distribution&lt;<span class="keyword">int</span>&gt;{<span class="number">1</span>, s};</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> target=ui(rng);</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(preSum[mid]&gt;=target) right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(w);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;pickIndex();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="658-找到-K-个最接近的元素"><a href="#658-找到-K-个最接近的元素" class="headerlink" title="658. 找到 K 个最接近的元素"></a>658. 找到 K 个最接近的元素</h3><p><strong>Description</strong><br>给定一个排序好的数组，两个整数 k 和 x，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。如果有两个数与 x 的差值一样，优先选择数值较小的那个数。<br><strong>Example</strong><br>示例 1:<br>输入: [1,2,3,4,5], k=4, x=3<br>输出: [1,2,3,4]</p>
<p>示例 2:<br>输入: [1,2,3,4,5], k=4, x=-1<br>输出: [1,2,3,4]</p>
<p>说明:<br>k 的值为正数，且总是小于给定排序数组的长度。<br>数组不为空，且长度不超过 104<br>数组里的每个元素与 x 的绝对值不超过 104<br><strong>Program</strong><br><strong>一般思路</strong><br>对每个元素与x求绝对值，对绝对值排序，选出前k个数就是答案，时间复杂度：$O(n\log{n})$<br><strong>二分查找</strong><br>（1）先找到数组中与目标值绝对值最小的元素，这里使用二分查找第一个不小于目标值的元素，当然有可能找的值偏大，需要与其左边一个数比较（如果存在）；<br>（2）然后从绝对值最小的元素位置开始向两边扩展！<br>时间复杂度：$(\log{n} + k)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findClosestElements(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k, <span class="keyword">int</span> x) {</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//找到绝对值最小的数</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid]&gt;=x) right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(left&gt;<span class="number">0</span>) right=left=(<span class="built_in">abs</span>(arr[left]-x)&lt;<span class="built_in">abs</span>(arr[left<span class="number">-1</span>]-x))?left:left<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//找到绝对值最小的k个数</span></span><br><span class="line">        <span class="keyword">while</span>(right-left+<span class="number">1</span>&lt;k){</span><br><span class="line">            <span class="keyword">if</span>(left<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;right+<span class="number">1</span>&lt;=n<span class="number">-1</span>){</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(arr[left<span class="number">-1</span>]-x)&lt;=<span class="built_in">abs</span>(arr[right+<span class="number">1</span>]-x)) left--;</span><br><span class="line">                <span class="keyword">else</span> right++;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(left<span class="number">-1</span>&gt;=<span class="number">0</span>) left--;</span><br><span class="line">            <span class="keyword">else</span> right++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(arr.begin()+left, arr.begin()+left+k);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h3><p><strong>Description</strong><br>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。<br><strong>Example</strong><br>示例 1:<br>输入: nums = [-1,0,3,5,9,12], target = 9<br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4</p>
<p>示例 2:<br>输入: nums = [-1,0,3,5,9,12], target = 2<br>输出: -1<br>解释: 2 不存在 nums 中因此返回 -1</p>
<p>提示：<br>你可以假设 nums 中的所有元素是不重复的。<br>n 将在 [1, 10000]之间。<br>nums 的每个元素都将在 [-9999, 9999]之间。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target) left=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right=mid<span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="744-寻找比目标字母大的最小字母"><a href="#744-寻找比目标字母大的最小字母" class="headerlink" title="744. 寻找比目标字母大的最小字母"></a>744. 寻找比目标字母大的最小字母</h3><p><strong>Description</strong><br>给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。<br>在比较时，字母是依序循环出现的。举个例子：<br>如果目标字母 target = ‘z’ 并且字符列表为 letters = [‘a’, ‘b’]，则答案返回 ‘a’<br><strong>Example</strong><br>示例：<br>输入:<br>letters = [“c”, “f”, “j”]<br>target = “a”<br>输出: “c”</p>
<p>输入:<br>letters = [“c”, “f”, “j”]<br>target = “c”<br>输出: “f”</p>
<p>输入:<br>letters = [“c”, “f”, “j”]<br>target = “d”<br>输出: “f”</p>
<p>输入:<br>letters = [“c”, “f”, “j”]<br>target = “g”<br>输出: “j”</p>
<p>输入:<br>letters = [“c”, “f”, “j”]<br>target = “j”<br>输出: “c”</p>
<p>输入:<br>letters = [“c”, “f”, “j”]<br>target = “k”<br>输出: “c”</p>
<p>提示：<br>letters长度范围在[2, 10000]区间内。<br>letters 仅由小写字母组成，最少包含两个不同的字母。<br>目标字母target 是一个小写字母。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">nextGreatestLetter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; letters, <span class="keyword">char</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=letters.size();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(letters[mid]&gt;target) right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(target&gt;=letters[left]) left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> letters[left];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="826-安排工作以达到最大收益"><a href="#826-安排工作以达到最大收益" class="headerlink" title="826. 安排工作以达到最大收益"></a>826. 安排工作以达到最大收益</h3><p><strong>Description</strong><br>有一些工作：difficulty[i] 表示第 i 个工作的难度，profit[i] 表示第 i 个工作的收益。<br>现在我们有一些工人。worker[i] 是第 i 个工人的能力，即该工人只能完成难度小于等于 worker[i] 的工作。<br>每一个工人都最多只能安排一个工作，但是一个工作可以完成多次。<br>举个例子，如果 3 个工人都尝试完成一份报酬为 1 的同样工作，那么总收益为 $3。如果一个工人不能完成任何工作，他的收益为 $0 。<br>我们能得到的最大收益是多少？<br><strong>Example</strong><br>示例：<br>输入: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]<br>输出: 100<br>解释: 工人被分配的工作难度是 [4,4,6,6] ，分别获得 [20,20,30,30] 的收益。</p>
<p>提示:<br>$1 &lt;= difficulty.length = profit.length &lt;= 10000$<br>$1 &lt;= worker.length &lt;= 10000$<br>$difficulty[i], profit[i], worker[i]$  的范围是 $[1, 10^5]$<br><strong>Program</strong><br><strong>排序+二分</strong><br>（1）首先，按照任务难度升序；<br>（2）二分找到可胜任的尽可能大的难度的任务；<br>（3）而（2）中找到的未必是利润最大的任务，因为有可能难度小的任务利润更大，那么需要预处理，即找到前缀最大利润，即[0,j]这j+1个任务中的最大利润best[j]；<br>时间复杂度：$O(n\log{n})$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> dft;</span><br><span class="line">        <span class="keyword">int</span> prof;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> _dft, <span class="keyword">int</span> _prof):dft(_dft), prof(_prof){}</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; other) <span class="keyword">const</span>{</span><br><span class="line">            <span class="keyword">return</span> dft &lt; other.dft; <span class="comment">//按照难度升序</span></span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfitAssignment</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; difficulty, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; profit, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; worker)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; vec;</span><br><span class="line">        <span class="keyword">int</span> n=difficulty.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            vec.push_back(Node(difficulty[i], profit[i]));</span><br><span class="line">        }</span><br><span class="line">        sort(vec.begin(), vec.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; best(n, <span class="number">0</span>); <span class="comment">//前缀最大收益</span></span><br><span class="line">        <span class="keyword">int</span> best_prof=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){  <span class="comment">//预处理，计算前缀最大收益，因为后面需要二分确定选择可胜任的尽可能大的难度的任务，有可能不是最大收益，即更小的难度下可能是最大收益</span></span><br><span class="line">            best_prof=max(best_prof, vec[i].prof);</span><br><span class="line">            best[i]=best_prof;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;worker.size();i++){</span><br><span class="line">            <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">                <span class="keyword">int</span> mid=left+(right-left+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(vec[mid].dft&lt;=worker[i]) left=mid;</span><br><span class="line">                <span class="keyword">else</span> right=mid<span class="number">-1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(vec[left].dft&lt;=worker[i]) ans+=best[right]; <span class="comment">//条件不成立表示工人不足以完成任何任务，反之能够胜任至少一个任务</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="852-山脉数组的峰顶索引"><a href="#852-山脉数组的峰顶索引" class="headerlink" title="852. 山脉数组的峰顶索引"></a>852. 山脉数组的峰顶索引</h3><p><strong>Description</strong><br>我们把符合下列属性的数组 A 称作山脉：<br>$A.length &gt;= 3$<br>存在 $0 &lt; i &lt; A.length - 1$ 使得$A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]$<br>给定一个确定为山脉的数组，返回任何满足 $A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]$ 的 $i$ 的值。<br><strong>Example</strong><br>示例 1：<br>输入：[0,1,0]<br>输出：1</p>
<p>示例 2：<br>输入：[0,2,1,0]<br>输出：1</p>
<p>提示：<br>3 &lt;= A.length &lt;= 10000<br>0 &lt;= A[i] &lt;= 10^6<br>A 是如上定义的山脉<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid+<span class="number">1</span>&lt;=right&amp;&amp;A[mid]&gt;A[mid+<span class="number">1</span>]) right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="875-爱吃香蕉的珂珂"><a href="#875-爱吃香蕉的珂珂" class="headerlink" title="875. 爱吃香蕉的珂珂"></a>875. 爱吃香蕉的珂珂</h3><p><strong>Description</strong><br>珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。<br>珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。<br>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。<br>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。<br><strong>Example</strong><br>示例 1：<br>输入: piles = [3,6,7,11], H = 8<br>输出: 4</p>
<p>示例 2：<br>输入: piles = [30,11,23,4,20], H = 5<br>输出: 30</p>
<p>示例 3：<br>输入: piles = [30,11,23,4,20], H = 6<br>输出: 23</p>
<p>提示：<br>1 &lt;= piles.length &lt;= 10^4<br>piles.length &lt;= H &lt;= 10^9<br>1 &lt;= piles[i] &lt;= 10^9<br><strong>Program</strong><br>对K进行二分，时间复杂度：$O(n\log(K))$ 其中n为piles最大长度，K为piles[i]最大值</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calH</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> k)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> h=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=piles.size();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n){</span><br><span class="line">            <span class="keyword">int</span> x=piles[i];</span><br><span class="line">            h+=x/k;</span><br><span class="line">            h+=(x%k&gt;<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> H)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=piles.size();</span><br><span class="line">        <span class="comment">//sort(piles.begin(), piles.end()); //不用排序</span></span><br><span class="line">        <span class="comment">//if(H==n) return piles[n-1]; //提前结束</span></span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>, right=<span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(calH(piles, mid)&lt;=H) right=mid; <span class="comment">//保留可能的上界</span></span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="911-在线选举"><a href="#911-在线选举" class="headerlink" title="911. 在线选举"></a>911. 在线选举</h3><p><strong>Description</strong><br>在选举中，第 i 张票是在时间为 times[i] 时投给 persons[i] 的。<br>现在，我们想要实现下面的查询函数： TopVotedCandidate.q(int t) 将返回在 t 时刻主导选举的候选人的编号。<br>在 t 时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。<br><strong>Example</strong><br>示例：<br>输入：[“TopVotedCandidate”,”q”,”q”,”q”,”q”,”q”,”q”], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]]<br>输出：[null,0,1,1,0,0,1]<br>解释：<br>时间为 3，票数分布情况是 [0]，编号为 0 的候选人领先。<br>时间为 12，票数分布情况是 [0,1,1]，编号为 1 的候选人领先。<br>时间为 25，票数分布情况是 [0,1,1,0,0,1]，编号为 1 的候选人领先（因为最近的投票结果是平局）。<br>在时间 15、24 和 8 处继续执行 3 个查询。</p>
<p>提示：<br>1 &lt;= persons.length = times.length &lt;= 5000<br>0 &lt;= persons[i] &lt;= persons.length<br>times 是严格递增的数组，所有元素都在 [0, 10^9] 范围中。<br>每个测试用例最多调用 10000 次 TopVotedCandidate.q。<br>TopVotedCandidate.q(int t) 被调用时总是满足 t &gt;= times[0]。<br><strong>Program</strong><br><strong>思路</strong><br>（1）预处理：先计算每个时刻对应索引下的领先候选人<br>（2）二分查找：查找times序列下不大于t的最大索引！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopVotedCandidate</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curTop; <span class="comment">//当前时刻领先候选人</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; times; <span class="comment">//时间转索引</span></span><br><span class="line">    TopVotedCandidate(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; persons, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; times) {</span><br><span class="line">        <span class="keyword">int</span> n=persons.size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;times=times;</span><br><span class="line">        curTop.resize(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curCount(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> curMax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmpTop=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            curCount[persons[i]]++;</span><br><span class="line">            <span class="keyword">if</span>(curCount[persons[i]]&gt;curMax){</span><br><span class="line">                curMax=curCount[persons[i]];</span><br><span class="line">                curTop[i]=persons[i];</span><br><span class="line">                tmpTop=persons[i];</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(curCount[persons[i]]==curMax){ <span class="comment">//当前时刻投票的候选人票数领先</span></span><br><span class="line">                curTop[i]=persons[i];</span><br><span class="line">                tmpTop=persons[i];</span><br><span class="line">            }<span class="keyword">else</span> curTop[i]=tmpTop; <span class="comment">//当前时刻投票的候选人票数没有领先！</span></span><br><span class="line">            <span class="comment">//cout&lt;&lt;curTop[i]&lt;&lt;" ";</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">q</span><span class="params">(<span class="keyword">int</span> t)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=times.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">int</span> mid=(left+right+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(times[mid]&gt;t) right=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> left=mid;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;left&lt;&lt;" "&lt;&lt;right&lt;&lt;endl;</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//cout&lt;&lt;left&lt;&lt;" ";</span></span><br><span class="line">        <span class="keyword">return</span> curTop[left];</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TopVotedCandidate object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TopVotedCandidate* obj = new TopVotedCandidate(persons, times);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;q(t);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="1011-在-D-天内送达包裹的能力"><a href="#1011-在-D-天内送达包裹的能力" class="headerlink" title="1011. 在 D 天内送达包裹的能力"></a>1011. 在 D 天内送达包裹的能力</h3><p><strong>Description</strong><br>传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。<br>传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。<br>返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。<br><strong>Example</strong><br>示例 1：<br>输入：weights = [1,2,3,4,5,6,7,8,9,10], D = 5<br>输出：15<br>解释：<br>船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：<br>第 1 天：1, 2, 3, 4, 5<br>第 2 天：6, 7<br>第 3 天：8<br>第 4 天：9<br>第 5 天：10</p>
<p>请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。</p>
<p>示例 2：<br>输入：weights = [3,2,2,4,1,4], D = 3<br>输出：6<br>解释：<br>船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：<br>第 1 天：3, 2<br>第 2 天：2, 4<br>第 3 天：1, 4</p>
<p>示例 3：<br>输入：weights = [1,2,3,1,1], D = 4<br>输出：3<br>解释：<br>第 1 天：1<br>第 2 天：2<br>第 3 天：3<br>第 4 天：1, 1</p>
<p>提示：<br>1 &lt;= D &lt;= weights.length &lt;= 50000<br>1 &lt;= weights[i] &lt;= 500<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calD</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; weights, <span class="keyword">int</span> w)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> d=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=weights.size();</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n){</span><br><span class="line">            <span class="keyword">int</span> c=w;</span><br><span class="line">            <span class="keyword">if</span>(w&lt;weights[i]) <span class="keyword">return</span> inf; <span class="comment">//如果最低运载能力比任何一个weight[i]小，则不可达</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;n&amp;&amp;c-weights[i]&gt;=<span class="number">0</span>){</span><br><span class="line">                c-=weights[i];</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            d++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; weights, <span class="keyword">int</span> D)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>, right=<span class="number">500</span>*<span class="number">50000</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(calD(weights, mid)&lt;=D) right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1150-检查一个数是否在数组中占绝大多数"><a href="#1150-检查一个数是否在数组中占绝大多数" class="headerlink" title="1150. 检查一个数是否在数组中占绝大多数"></a>1150. 检查一个数是否在数组中占绝大多数</h3><p><strong>Description</strong><br>给出一个按 非递减 顺序排列的数组 nums，和一个目标数值 target。假如数组 nums 中绝大多数元素的数值都等于 target，则返回 True，否则请返回 False。<br>所谓占绝大多数，是指在长度为 N 的数组中出现必须 超过 N/2 次。<br><strong>Example</strong><br>示例 1：<br>输入：nums = [2,4,5,5,5,5,5,6,6], target = 5<br>输出：true<br>解释：<br>数字 5 出现了 5 次，而数组的长度为 9。<br>所以，5 在数组中占绝大多数，因为 5 次 &gt; 9/2。</p>
<p>示例 2：<br>输入：nums = [10,100,101,101], target = 101<br>输出：false<br>解释：<br>数字 101 出现了 2 次，而数组的长度是 4。<br>所以，101 不是 数组占绝大多数的元素，因为 2 次 = 4/2。</p>
<p>提示：<br>1 &lt;= nums.length &lt;= 1000<br>1 &lt;= nums[i] &lt;= 10^9<br>1 &lt;= target &lt;= 10^9<br><strong>Program</strong><br><strong>二分</strong><br>由于本题有序，而不是无序，无序的做法是计数加减，不再赘述，时间复杂度$O(n)$，<br>而有序，则可以用二分找第一个target的位置以及题目要求超过N/2次，故第一个位置到此之后的N/2次如果都为target肯定true，否则false，注意边界以及target不存在即可。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMajorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target) right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(nums[left]!=target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left+n/<span class="number">2</span>&gt;=n||nums[left+n/<span class="number">2</span>]!=target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1064-不动点"><a href="#1064-不动点" class="headerlink" title="1064. 不动点"></a>1064. 不动点</h3><p><strong>Description</strong><br>给定已经按升序排列、由不同整数组成的数组 A，返回满足 A[i] == i 的最小索引 i。如果不存在这样的 i，返回 -1。<br><strong>Example</strong><br>示例 1：<br>输入：[-10,-5,0,3,7]<br>输出：3<br>解释：<br>对于给定的数组，A[0] = -10，A[1] = -5，A[2] = 0，A[3] = 3，因此输出为 3 。</p>
<p>示例 2：<br>输入：[0,2,5,8,17]<br>输出：0<br>示例：<br>A[0] = 0，因此输出为 0 。</p>
<p>示例 3：<br>输入：[-10,-5,3,4,7,9]<br>输出：-1<br>解释：<br>不存在这样的 i 满足 A[i] = i，因此输出为 -1 。</p>
<p>提示：<br>1 &lt;= A.length &lt; 10^4<br>-10^9 &lt;= A[i] &lt;= 10^9<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fixedPoint</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[mid]&lt;<span class="number">0</span>){left=mid+<span class="number">1</span>;<span class="keyword">continue</span>;}</span><br><span class="line">            <span class="keyword">if</span>(A[mid]==mid) right=mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(A[mid]&lt;mid) left=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right=mid<span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(A[left]!=left) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1283-使结果不超过阈值的最小除数"><a href="#1283-使结果不超过阈值的最小除数" class="headerlink" title="1283. 使结果不超过阈值的最小除数"></a>1283. 使结果不超过阈值的最小除数</h3><p><strong>Description</strong><br>给你一个整数数组 nums 和一个正整数 threshold  ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。<br>请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。<br>每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。<br>题目保证一定有解。<br><strong>Example</strong><br>示例 1：<br>输入：nums = [1,2,5,9], threshold = 6<br>输出：5<br>解释：如果除数为 1 ，我们可以得到和为 17 （1+2+5+9）。<br>如果除数为 4 ，我们可以得到和为 7 (1+1+2+3) 。如果除数为 5 ，和为 5 (1+1+1+2)。</p>
<p>示例 2：<br>输入：nums = [2,3,5,7,11], threshold = 11<br>输出：3</p>
<p>示例 3：<br>输入：nums = [19], threshold = 5<br>输出：4</p>
<p>提示：<br>1 &lt;= nums.length &lt;= 5 * 10^4<br>1 &lt;= nums[i] &lt;= 10^6<br>nums.length &lt;= threshold &lt;= 10^6<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">double</span> k)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums){</span><br><span class="line">            sum+=(<span class="keyword">int</span>)<span class="built_in">ceil</span>(x/k);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">smallestDivisor</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> threshold)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>, right=INT_MAX;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(cal(nums, mid)&lt;=threshold) right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1300-转变数组后最接近目标值的数组和"><a href="#1300-转变数组后最接近目标值的数组和" class="headerlink" title="1300. 转变数组后最接近目标值的数组和"></a>1300. 转变数组后最接近目标值的数组和</h3><p><strong>Description</strong><br>给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数 value ，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近  target （最接近表示两者之差的绝对值最小）。<br>如果有多种使得和最接近 target 的方案，请你返回这些整数中的最小值。<br>请注意，答案不一定是 arr 中的数字。<br><strong>Example</strong><br>示例 1：<br>输入：arr = [4,9,3], target = 10<br>输出：3<br>解释：当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。</p>
<p>示例 2：<br>输入：arr = [2,3,5], target = 10<br>输出：5</p>
<p>示例 3：<br>输入：arr = [60864,25176,27249,21296,20204], target = 56803<br>输出：11361</p>
<p>提示：<br>1 &lt;= arr.length &lt;= 10^4<br>1 &lt;= arr[i], target &lt;= 10^5<br><strong>Program</strong><br><strong>排序+前缀和+二分</strong><br>时间复杂度：$O((N+C)\log{N})$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> minDis=inf;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){ <span class="comment">//找第一个大于target的位置</span></span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid]&gt;target) right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(arr[left]&lt;target) <span class="keyword">return</span> n; <span class="comment">//target比所有元素都大</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBestValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        sort(arr.begin(), arr.end());</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        <span class="keyword">int</span> preSum[n];</span><br><span class="line">        <span class="built_in">memset</span>(preSum, <span class="number">0</span>, <span class="keyword">sizeof</span>(preSum));</span><br><span class="line">        <span class="keyword">int</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            preSum[i]+=arr[i];</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>) preSum[i]+=preSum[i<span class="number">-1</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=arr[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++){</span><br><span class="line">            <span class="keyword">int</span> pos=binarySearch(arr, i);</span><br><span class="line">            <span class="keyword">int</span> sum=(pos&gt;<span class="number">0</span>?preSum[pos<span class="number">-1</span>]:<span class="number">0</span>)+i*(n-pos);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(sum-target)&lt;minDis){</span><br><span class="line">                minDis=<span class="built_in">abs</span>(sum-target);</span><br><span class="line">                res=i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>排序+前缀和+双重二分</strong><br>时间复杂度：$O(C\log{N})$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){ <span class="comment">//找第一个大于target的位置</span></span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid]&gt;target) right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(arr[left]&lt;target) <span class="keyword">return</span> n; <span class="comment">//target比所有元素都大</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBestValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        sort(arr.begin(), arr.end());</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        <span class="keyword">int</span> preSum[n];</span><br><span class="line">        <span class="built_in">memset</span>(preSum, <span class="number">0</span>, <span class="keyword">sizeof</span>(preSum));</span><br><span class="line">        <span class="keyword">int</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            preSum[i]+=arr[i];</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>) preSum[i]+=preSum[i<span class="number">-1</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=arr[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        <span class="keyword">int</span> minDis=inf;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> pos=binarySearch(arr, mid);</span><br><span class="line">            <span class="keyword">int</span> sum=(pos&gt;<span class="number">0</span>?preSum[pos<span class="number">-1</span>]:<span class="number">0</span>)+mid*(n-pos);</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;target) right=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(sum-target)&lt;minDis){</span><br><span class="line">                minDis=<span class="built_in">abs</span>(sum-target);</span><br><span class="line">                res=mid;</span><br><span class="line">                <span class="keyword">if</span>(minDis==<span class="number">0</span>) <span class="keyword">break</span>;   </span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(sum-target)==minDis){</span><br><span class="line">                res=min(res, mid);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1351-统计有序矩阵中的负数"><a href="#1351-统计有序矩阵中的负数" class="headerlink" title="1351. 统计有序矩阵中的负数"></a>1351. 统计有序矩阵中的负数</h3><p><strong>Description</strong><br>给你一个 m * n 的矩阵 grid，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。<br>请你统计并返回 grid 中 负数 的数目。<br><strong>Example</strong><br>示例 1：<br>输入：grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]<br>输出：8<br>解释：矩阵中共有 8 个负数。</p>
<p>示例 2：<br>输入：grid = [[3,2],[1,0]]<br>输出：0</p>
<p>示例 3：<br>输入：grid = [[1,-1],[-1,-1]]<br>输出：3</p>
<p>示例 4：<br>输入：grid = [[-1]]<br>输出：1</p>
<p>提示：<br>m == grid.length<br>n == grid[i].length<br>1 &lt;= m, n &lt;= 100<br>-100 &lt;= grid[i][j] &lt;= 100<br><strong>Program</strong><br>时间复杂度：$O(n\log{n})$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calEachRow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){ <span class="comment">//找最小的非负数位置</span></span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=<span class="number">0</span>) left=mid;</span><br><span class="line">            <span class="keyword">else</span> right=mid<span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(nums[left]&lt;<span class="number">0</span>) left--;</span><br><span class="line">        <span class="keyword">return</span> nums.size()<span class="number">-1</span>-left;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNegatives</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m=grid.size(), n=grid[<span class="number">0</span>].size();  </span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            ans+=calEachRow(grid[i], <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1482-制作-m-束花所需的最少天数"><a href="#1482-制作-m-束花所需的最少天数" class="headerlink" title="1482. 制作 m 束花所需的最少天数"></a>1482. 制作 m 束花所需的最少天数</h3><p><strong>Description</strong><br>给你一个整数数组 bloomDay，以及两个整数 m 和 k 。<br>现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花 。<br>花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。<br>请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。<br><strong>Example</strong><br>示例 1：<br>输入：bloomDay = [1,10,3,10,2], m = 3, k = 1<br>输出：3<br>解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。<br>现在需要制作 3 束花，每束只需要 1 朵。<br>1 天后：[x, _, _, _, _]   // 只能制作 1 束花<br>2 天后：[x, _, _, _, x]   // 只能制作 2 束花<br>3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3</p>
<p>示例 2：<br>输入：bloomDay = [1,10,3,10,2], m = 3, k = 2<br>输出：-1<br>解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。</p>
<p>示例 3：<br>输入：bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3<br>输出：12<br>解释：要制作 2 束花，每束需要 3 朵。<br>花园在 7 天后和 12 天后的情况如下：<br>7 天后：[x, x, x, x, _, x, x]<br>可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。<br>12 天后：[x, x, x, x, x, x, x]<br>显然，我们可以用不同的方式制作两束花。</p>
<p>示例 4：<br>输入：bloomDay = [1000000000,1000000000], m = 1, k = 1<br>输出：1000000000<br>解释：需要等 1000000000 天才能采到花来制作花束</p>
<p>示例 5：<br>输入：bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2<br>输出：9</p>
<p>提示：<br>bloomDay.length == n<br>1 &lt;= n &lt;= 10^5<br>1 &lt;= bloomDay[i] &lt;= 10^9<br>1 &lt;= m &lt;= 10^6<br>1 &lt;= k &lt;= n<br><strong>Program</strong><br><strong>二分查找</strong><br>对最终天数进行二分即可，isPass判断mid天内是否能够组成m个花束！<br>时间复杂度：$O(n\log{C})$，$n$为数组长度，$C$为天数的范围</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPass</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bloomDay, <span class="keyword">int</span> m, <span class="keyword">int</span> day, <span class="keyword">int</span> k)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=bloomDay.size();</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(bloomDay[i]&lt;=day){</span><br><span class="line">                tmp++;</span><br><span class="line">                <span class="keyword">if</span>(tmp==k){</span><br><span class="line">                    ans++;</span><br><span class="line">                    tmp=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(ans==m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }<span class="keyword">else</span> tmp=<span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bloomDay, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=bloomDay.size();</span><br><span class="line">        <span class="keyword">if</span>(n/k&lt;m) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>, right=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            right=max(right, bloomDay[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isPass(bloomDay, m, mid, k)) right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5643-将数组分成三个子数组的方案数"><a href="#5643-将数组分成三个子数组的方案数" class="headerlink" title="5643. 将数组分成三个子数组的方案数"></a>5643. 将数组分成三个子数组的方案数</h3><p><strong>Description</strong><br>我们称一个分割整数数组的方案是 好的 ，当它满足：<br>数组被分成三个 非空 连续子数组，从左至右分别命名为 left ， mid ， right 。<br>left 中元素和小于等于 mid 中元素和，mid 中元素和小于等于 right 中元素和。<br>给你一个 非负 整数数组 nums ，请你返回 好的 分割 nums 方案数目。由于答案可能会很大，请你将结果对 109 + 7 取余后返回。<br><strong>Example</strong><br>示例 1：<br>输入：nums = [1,1,1]<br>输出：1<br>解释：唯一一种好的分割方案是将 nums 分成 [1] [1] [1] 。</p>
<p>示例 2：<br>输入：nums = [1,2,2,2,5,0]<br>输出：3<br>解释：nums 总共有 3 种好的分割方案：<br>[1] [2] [2,2,5,0]<br>[1] [2,2] [2,5,0]<br>[1,2] [2,2] [5,0]</p>
<p>示例 3：<br>输入：nums = [3,2,1]<br>输出：0<br>解释：没有好的分割方案。</p>
<p>提示：<br>3 &lt;= nums.length &lt;= 105<br>0 &lt;= nums[i] &lt;= 104<br><strong>program</strong><br><strong>思路</strong><br>（1）控制mid数组的左边界j；<br>（2）二分查找mid数组的右边界i的范围！注意边界~<br>时间复杂度：$O(n\log{n})$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToSplit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> preSum[n];</span><br><span class="line">        <span class="built_in">memset</span>(preSum, <span class="number">0</span>, <span class="keyword">sizeof</span>(preSum));</span><br><span class="line">        <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            s+=nums[i];</span><br><span class="line">            preSum[i]=s;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n<span class="number">-2</span>;j++){</span><br><span class="line">            <span class="keyword">int</span> left=j, right=n<span class="number">-2</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right){ <span class="comment">//找左边界</span></span><br><span class="line">                <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(preSum[j<span class="number">-1</span>]&lt;=preSum[mid]-preSum[j<span class="number">-1</span>]) right=mid;</span><br><span class="line">                <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(preSum[j<span class="number">-1</span>]&gt;preSum[left]-preSum[j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> min_i=left;</span><br><span class="line">            left=j, right=n<span class="number">-2</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right){ <span class="comment">//右边界</span></span><br><span class="line">                <span class="keyword">int</span> mid=left+(right-left+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(preSum[n<span class="number">-1</span>]-preSum[mid]&gt;=preSum[mid]-preSum[j<span class="number">-1</span>]) left=mid;</span><br><span class="line">                <span class="keyword">else</span> right=mid<span class="number">-1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(preSum[n<span class="number">-1</span>]-preSum[left]&lt;preSum[left]-preSum[j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> max_i=left;</span><br><span class="line">            <span class="keyword">if</span>(max_i&lt;min_i) <span class="keyword">continue</span>;</span><br><span class="line">            ans=(ans%MOD+(max_i-min_i+<span class="number">1</span>)%MOD)%MOD;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5644-得到子序列的最少操作次数"><a href="#5644-得到子序列的最少操作次数" class="headerlink" title="5644. 得到子序列的最少操作次数"></a>5644. 得到子序列的最少操作次数</h3><p><strong>Description</strong><br>给你一个数组 target ，包含若干 互不相同 的整数，以及另一个整数数组 arr ，arr 可能 包含重复元素。<br>每一次操作中，你可以在 arr 的任意位置插入任一整数。比方说，如果 arr = [1,4,1,2] ，那么你可以在中间添加 3 得到 [1,4,3,1,2] 。你可以在数组最开始或最后面添加整数。<br>请你返回 最少 操作次数，使得 target 成为 arr 的一个子序列。<br>一个数组的 子序列 指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的子序列（加粗元素），但 [2,4,2] 不是子序列。<br><strong>Example</strong><br>示例 1：<br>输入：target = [5,1,3], arr = [9,4,2,3,4]<br>输出：2<br>解释：你可以添加 5 和 1 ，使得 arr 变为 [5,9,4,1,2,3,4] ，target 为 arr 的子序列。</p>
<p>示例 2：<br>输入：target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1]<br>输出：3</p>
<p>提示：<br>$1 &lt;= target.length, arr.length &lt;= 10^5$<br>$1 &lt;= target[i], arr[i] &lt;= 10^9$<br>target 不包含任何重复元素。<br><strong>Program</strong><br><strong>方法：最长上升子序列</strong><br>设target的长度为 N。<br>回顾题意，假设我们需要添加 xx 个整数，那么就需要 arr 中提供额外的 N-xN−x 个整数，且这 N-xN−x 个整数在 arr 中出现的顺序应该与 target 中的顺序相同。<br>为了使得 xx 最小，我们需要让 N-xN−x 尽可能大，也就是找出 rr 中，满足「顺序相同」性质的最长子序列。<br>那么怎么构造出「顺序相同」的最长子序列呢？<br>显然，如果把arr 中所有的整数，按照其在 target 中的位置「重新标号」，那么一个「顺序相同」的子序列，就等于「重新标号」后的一个上升子序列。而「顺序相同」的最长子序列，就等于「重新标号」后的最长上升子序列。</p>
<p>到此，解法已经呼之欲出了，只剩下最后一个细节：对于那些不在 target 中的数要怎么「标号」呢？实际上，这部分数字对于结果没有任何影响，因此在「标号」的过程中，直接剔除它们即可。<br>时间复杂度：$O(\log{n})$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LCS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> n=vec.size();</span><br><span class="line">        <span class="keyword">int</span> tail[n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(tail, <span class="number">0</span>, <span class="keyword">sizeof</span>(tail));</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:vec){</span><br><span class="line">            <span class="keyword">int</span> left=<span class="number">0</span>, right=len;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">                <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(tail[mid]&gt;=x) right=mid;</span><br><span class="line">                <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            tail[left]=x;</span><br><span class="line">            <span class="keyword">if</span>(left==len) len++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=target.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) m[target[i]]=i;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:arr){</span><br><span class="line">            <span class="keyword">if</span>(m.find(x)!=m.end()){</span><br><span class="line">                vec.emplace_back(m[x]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> size=LCS(vec);</span><br><span class="line">        <span class="keyword">return</span> n-size;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="面试题-10-03-搜索旋转数组"><a href="#面试题-10-03-搜索旋转数组" class="headerlink" title="面试题 10.03. 搜索旋转数组"></a>面试题 10.03. 搜索旋转数组</h3><p><strong>Description</strong><br>搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。<br><strong>Example</strong><br>示例1:<br> 输入: arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 5<br> 输出: 8（元素5在该数组中的索引）</p>
<p>示例2:<br> 输入：arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 11<br> 输出：-1 （没有找到）<br>提示:<br>arr 长度范围在[1, 1000000]之间<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res=INT_MAX;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid]==target) res=min(res, mid);</span><br><span class="line">            <span class="keyword">if</span>(arr[left]==target) res=min(res, left);</span><br><span class="line">            <span class="keyword">if</span>(arr[right]==target) res=min(res, right);</span><br><span class="line">            <span class="keyword">if</span>(arr[left]==arr[mid]){</span><br><span class="line">                <span class="keyword">if</span>(arr[mid]==target) res=min(res, left);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(arr[left]&lt;arr[mid]){</span><br><span class="line">                <span class="keyword">if</span>(target&lt;=arr[mid]&amp;&amp;target&gt;=arr[left]) right=mid;</span><br><span class="line">                <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">if</span>(target&lt;=arr[right]&amp;&amp;target&gt;=arr[mid]) left=mid;</span><br><span class="line">                <span class="keyword">else</span> right=mid<span class="number">-1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res==INT_MAX?<span class="number">-1</span>:res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a>剑指 Offer 11. 旋转数组的最小数字</h3><p><strong>Description</strong><br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。<br><strong>Example</strong><br>示例 1：<br>输入：[3,4,5,1,2]<br>输出：1</p>
<p>示例 2：<br>输入：[2,2,2,0,1]<br>输出：0<br><strong>Program</strong><br><strong>二分查找</strong><br>与搜索旋转排序数组 II类似，即存在重复元素，那么如果number[left]==number[mid]，无法判断应当从哪个位置开始二分，这个时候left++,即重新成为原问题！<br>平均时间复杂度：$O(\log{n})$，最差时间复杂度：$O(n)$，即所有元素相等</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=numbers.size();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> minValue=INT_MAX;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[left]==numbers[mid]){</span><br><span class="line">                minValue=min(minValue, numbers[left]);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(numbers[left]&lt;numbers[mid]){</span><br><span class="line">                minValue=min(minValue, numbers[left]);</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                minValue=min(minValue, numbers[mid]);</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> minValue;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a>剑指 Offer 53 - I. 在排序数组中查找数字 I</h3><p><strong>Description</strong><br>统计一个数字在排序数组中出现的次数。<br><strong>Example</strong><br>示例 1:<br>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: 2</p>
<p>示例 2:<br>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: 0</p>
<p>限制：<br>0 &lt;= 数组长度 &lt;= 50000<br><strong>Progam</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){ <span class="comment">//找大于等于target的最小元素下标</span></span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target) right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(nums[left]!=target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l=left;</span><br><span class="line">        left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){ <span class="comment">//找大于target的最小元素下标</span></span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target) right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> r=(nums[left]&gt;target)?left:left+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;l&lt;&lt;" "&lt;&lt;r&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span> r-l;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字"></a>剑指 Offer 53 - II. 0～n-1中缺失的数字</h3><p><strong>Description</strong><br>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。<br><strong>Example</strong><br>示例 1:<br>输入: [0,1,3]<br>输出: 2</p>
<p>示例 2:<br>输入: [0,1,2,3,4,5,6,7,9]<br>输出: 8</p>
<p>限制：<br>1 &lt;= 数组长度 &lt;= 10000<br><strong>Program</strong><br><strong>二分</strong><br>话不多说上二分找到下标与元素对应的最右端的元素即可，注意边界！时间复杂度$O(n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==mid) left=mid;</span><br><span class="line">            <span class="keyword">else</span> right=mid<span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(nums[left]!=left) <span class="keyword">return</span> left;<span class="comment">//恰好第一个0</span></span><br><span class="line">        <span class="keyword">return</span> left+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>位运算</strong><br>位运算的话时间复杂度$O(n)$，思路就是先遍历0~n所有数异或，然后遍历数组元素进行异或，利用两个相同的数异或为0的性质，本题某个数不存在，最后就会被异或剩下，就是结果。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> bit=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++){</span><br><span class="line">            bit^=i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums){</span><br><span class="line">            bit^=x;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> bit;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="面试题-10-05-稀疏数组搜索"><a href="#面试题-10-05-稀疏数组搜索" class="headerlink" title="面试题 10.05. 稀疏数组搜索"></a>面试题 10.05. 稀疏数组搜索</h3><p><strong>Description</strong><br>稀疏数组搜索。有个排好序的字符串数组，其中散布着一些空字符串，编写一种方法，找出给定字符串的位置。<br><strong>Example</strong><br>示例1:<br> 输入: words = [“at”, “”, “”, “”, “ball”, “”, “”, “car”, “”, “”,”dad”, “”, “”], s = “ta”<br> 输出：-1<br> 说明: 不存在返回-1。</p>
<p>示例2:<br> 输入：words = [“at”, “”, “”, “”, “ball”, “”, “”, “car”, “”, “”,”dad”, “”, “”], s = “ball”<br> 输出：4<br>提示:<br>words的长度在[1, 1000000]之间<br><strong>Program</strong><br><strong>二分分治</strong><br>最差时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">string</span> s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(words[mid]==s) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">int</span> lPos=binary_search(words, s, left, mid<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(lPos!=<span class="number">-1</span>) <span class="keyword">return</span> lPos;</span><br><span class="line">        <span class="keyword">int</span> rPos=binary_search(words, s, mid+<span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> rPos;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=words.size();</span><br><span class="line">        <span class="keyword">return</span> binary_search(words, s, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>二分查找</strong><br>问题在于mid为空字符串的情况需要特殊处理。<br>平均时间复杂度：$O(\log{n})$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=words.size();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> tmpMid=mid;</span><br><span class="line">            <span class="keyword">while</span>(tmpMid&lt;=right&amp;&amp;words[tmpMid]==<span class="string">""</span>) tmpMid++;</span><br><span class="line">            <span class="keyword">if</span>(tmpMid==right+<span class="number">1</span>){</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(words[tmpMid]==s) <span class="keyword">return</span> tmpMid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(words[tmpMid]&gt;s) right=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="矩阵二分"><a href="#矩阵二分" class="headerlink" title="矩阵二分"></a>矩阵二分</h2><h3 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74. 搜索二维矩阵"></a>74. 搜索二维矩阵</h3><p><strong>Description</strong><br>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<ul>
<li>每行中的整数从左到右按升序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ul>
<p><strong>Example</strong><br>示例 1:<br>输入:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target = 3</span><br></pre></td></tr></tbody></table></figure>
<p>输出: true</p>
<p>示例 2:<br>输入:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target = 13</span><br></pre></td></tr></tbody></table></figure>
<p>输出: false<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m=matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> row=<span class="number">0</span>, col=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row&lt;m&amp;&amp;col&gt;=<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col]==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col]&lt;target) row++;</span><br><span class="line">            <span class="keyword">else</span> col--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a>240. 搜索二维矩阵 II</h3><p><strong>Description</strong><br>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<p><strong>Example</strong><br>示例:<br>现有矩阵 matrix 如下：<br>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。<br>给定 target = 20，返回 false。<br><strong>Program</strong><br>根据严格单调的特性：<br>令x=1,y=1000，<br>若f(x,y)&lt;z，则计算f(x+1,,y)<br>若f(x,y)&gt;z，则计算f(x,y-1)<br>若f(x,y)==z，则计算f(x+1,y-1)<br>时间复杂度：$O(m+n)$</p>
<p>确实巧妙，想了下这个算法的关键是找到合适的遍历起点，这个点肯定具有某种特殊性，这个二维矩阵，四个角就是四个特殊点，但他们的特点不同，左上和右下分别是矩阵的最小和最大值，左下和右上具有两面性，如果是所在行最大值那么就是所在列的最小值，反过来也一样。左上和右下与目标值比较不相等时，下一步既可以遍历行也可以遍历列是不确定的，而左下和右上是可以确定的，因为自身值的特点可以排除一个方向的路径，只有一个遍历路径。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m=matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m&amp;&amp;j&gt;=<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">int</span> tmp=matrix[i][j];</span><br><span class="line">            <span class="keyword">if</span>(tmp==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp&gt;target) j--;</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="378-有序矩阵中第K小的元素"><a href="#378-有序矩阵中第K小的元素" class="headerlink" title="378. 有序矩阵中第K小的元素"></a>378. 有序矩阵中第K小的元素</h3><p><strong>Description</strong><br>给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。<br>请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。<br><strong>Example</strong><br>示例：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">   [ 1,  5,  9],</span><br><span class="line">   [10, 11, 13],</span><br><span class="line">   [12, 13, 15]</span><br><span class="line">],</span><br><span class="line">k = 8,</span><br></pre></td></tr></tbody></table></figure>
<p>返回 13。</p>
<p>提示：<br>你可以假设 k 的值永远是有效的，1 ≤ k ≤ n2 。<br><strong>Program</strong><br>相似题目，用到同一性质的题：<br>240. 搜索二维矩阵 II<br>1237. 找出给定方程的正整数解<br>性质：</p>
<ul>
<li>f(x, y) &lt; f(x + 1, y)</li>
<li>f(x, y) &lt; f(x, y + 1)<br>如果暴力排序，时间复杂度：$O(n^2 \log{n})$</li>
</ul>
<p><strong>思路</strong><br>（1）矩阵最小值为matrix[0][0],最大值为matrix[n-1][n-1]，分别记为left,right；<br>（2）记任意mid，使得left&lt;=mid&lt;=right，那么不大于mid所有元素肯定在矩阵左上方，<br>盗张图：<img src="/assets/img/algorithm/378_example_01.png" alt="image"><br>如图，mid=8，折线左上部分为不小于8的所有数<br>（3）那么从右上角或左下角开始，由性质可以发现可以单调移动，以右上角为例：<br>①若f(x,y)&lt;=mid，计数ans+=y+1，x++(因为第x行y列左边所有数都不小于mid，而要比较下一行f(x+1,y))；<br>②若f(x,y)&gt;mid，y–;<br>（4）二分查找mid即可。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLess</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> mid, <span class="keyword">int</span> k)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> n=matrix.size();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=n<span class="number">-1</span>&amp;&amp;j&gt;=<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j]&lt;=mid){</span><br><span class="line">                ans+=j+<span class="number">1</span>;</span><br><span class="line">                i++;</span><br><span class="line">            }<span class="keyword">else</span> j--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans&gt;=k;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=matrix.size();</span><br><span class="line">        <span class="keyword">int</span> left=matrix[<span class="number">0</span>][<span class="number">0</span>], right=matrix[n<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isLess(matrix, mid, k)) right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1292-元素和小于等于阈值的正方形的最大边长"><a href="#1292-元素和小于等于阈值的正方形的最大边长" class="headerlink" title="1292. 元素和小于等于阈值的正方形的最大边长"></a>1292. 元素和小于等于阈值的正方形的最大边长</h3><p>给你一个大小为 m x n 的矩阵 mat 和一个整数阈值 threshold。<br>请你返回元素总和小于或等于阈值的正方形区域的最大边长；如果没有这样的正方形区域，则返回 0 。<br><strong>Example</strong><br>示例 1：<br>输入：mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4<br>输出：2<br>解释：总和小于 4 的正方形的最大边长为 2，如图所示。</p>
<p>示例 2：<br>输入：mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1<br>输出：0</p>
<p>示例 3：<br>输入：mat = [[1,1,1,1],[1,0,0,0],[1,0,0,0],[1,0,0,0]], threshold = 6<br>输出：3</p>
<p>示例 4：<br>输入：mat = [[18,70],[61,1],[25,85],[14,40],[11,96],[97,96],[63,45]], threshold = 40184<br>输出：2</p>
<p>提示：<br>1 &lt;= m, n &lt;= 300<br>m == mat.length<br>n == mat[i].length<br>0 &lt;= mat[i][j] &lt;= 10000<br>0 &lt;= threshold &lt;= 10^5<br><strong>Program</strong><br><strong>前缀和+二分</strong><br>先求出矩阵前缀和，然后对边长进行二分查找。<br>时间复杂度：$O(mn\log{min(m,n)}$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLess</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; DP, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> radius, <span class="keyword">int</span> threshold)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=radius<span class="number">-1</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=radius<span class="number">-1</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">int</span> ans=DP[i][j];</span><br><span class="line">                ans-=i-radius&gt;=<span class="number">0</span>?DP[i-radius][j]:<span class="number">0</span>;</span><br><span class="line">                ans-=j-radius&gt;=<span class="number">0</span>?DP[i][j-radius]:<span class="number">0</span>;</span><br><span class="line">                ans+=(i-radius&gt;=<span class="number">0</span>&amp;&amp;j-radius&gt;=<span class="number">0</span>)?DP[i-radius][j-radius]:<span class="number">0</span>;</span><br><span class="line">                <span class="comment">// ans=DP[i][j]-D[i-radius][j]-DP[i][j-radius]+DP[i-radius][j-radius];</span></span><br><span class="line">                <span class="keyword">if</span>(ans&lt;=threshold) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSideLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat, <span class="keyword">int</span> threshold)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m=mat.size(), n=mat[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; DP(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                DP[i][j]=mat[i][j];</span><br><span class="line">                DP[i][j]+=(j<span class="number">-1</span>&gt;=<span class="number">0</span>)?DP[i][j<span class="number">-1</span>]:<span class="number">0</span>;</span><br><span class="line">                DP[i][j]+=(i<span class="number">-1</span>&gt;=<span class="number">0</span>)?DP[i<span class="number">-1</span>][j]:<span class="number">0</span>;</span><br><span class="line">                DP[i][j]-=(i<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;j<span class="number">-1</span>&gt;=<span class="number">0</span>)?DP[i<span class="number">-1</span>][j<span class="number">-1</span>]:<span class="number">0</span>;</span><br><span class="line">                <span class="comment">//DP[i][j]=DP[i][j-1]+DP[i-1][j]-DP[i-1][j-1]+mat[i][j];</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=min(m, n);</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isLess(DP, m, n, mid, threshold)) left=mid;</span><br><span class="line">            <span class="keyword">else</span> right=mid<span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="面试题-10-09-排序矩阵查找"><a href="#面试题-10-09-排序矩阵查找" class="headerlink" title="面试题 10.09. 排序矩阵查找"></a>面试题 10.09. 排序矩阵查找</h3><p><strong>Description</strong><br>给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。<br><strong>Example</strong><br>示例:<br>现有矩阵 matrix 如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<p>给定 target = 5，返回 true。<br>给定 target = 20，返回 false。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m=matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> row=<span class="number">0</span>, col=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row&lt;m&amp;&amp;col&gt;=<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col]==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col]&gt;target) col--;</span><br><span class="line">            <span class="keyword">else</span> row++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="二分思想"><a href="#二分思想" class="headerlink" title="二分思想"></a>二分思想</h2><h3 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a>454. 四数相加 II</h3><p><strong>Description</strong><br>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。<br>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。<br><strong>Example</strong><br>例如:<br>输入:<br>A = [ 1, 2]<br>B = [-2,-1]<br>C = [-1, 2]<br>D = [ 0, 2]</p>
<p>输出:<br>2</p>
<p>解释:<br>两个元组如下:</p>
<ol>
<li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</li>
<li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</li>
</ol>
<p><strong>Program</strong><br><strong>二分</strong><br>先求出两个数组的和，然后求另两个数组的和，在HashMap中查找即可。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; D)</span> </span>{</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; sumAB;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;B.size();j++){</span><br><span class="line">                sumAB[A[i]+B[j]]++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;C.size();i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;D.size();j++){</span><br><span class="line">                <span class="keyword">if</span>(sumAB.find(-C[i]-D[j])!=sumAB.end()) ans+=sumAB[-C[i]-D[j]];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="面试题-08-03-魔术索引"><a href="#面试题-08-03-魔术索引" class="headerlink" title="面试题 08.03. 魔术索引"></a>面试题 08.03. 魔术索引</h3><p><strong>Description</strong><br>魔术索引。 在数组A[0…n-1]中，有所谓的魔术索引，满足条件A[i] = i。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。<br><strong>Example</strong><br>示例1:<br> 输入：nums = [0, 2, 3, 4, 5]<br> 输出：0<br> 说明: 0下标的元素为0</p>
<p>示例2:<br> 输入：nums = [1, 1, 1]<br> 输出：1<br>提示:<br>nums长度在[1, 1000000]之间<br><strong>Program</strong><br><strong>线性搜索</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMagicIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==i) <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>二分</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMagicIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">return</span> dfs(nums, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> leftPos=dfs(nums, left, mid<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(leftPos!=<span class="number">-1</span>) <span class="keyword">return</span> leftPos;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==mid) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums, mid+<span class="number">1</span>, right);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1></blockquote>
<h2 id="经典分治"><a href="#经典分治" class="headerlink" title="经典分治"></a>经典分治</h2><h3 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h3><p><strong>Description</strong><br>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。<br>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。<br>你可以假设 nums1 和 nums2 不会同时为空。<br><strong>Example</strong><br>示例 1:<br>nums1 = [1, 3]<br>nums2 = [2]</p>
<p>则中位数是 2.0</p>
<p>示例 2:<br>nums1 = [1, 2]<br>nums2 = [3, 4]<br>则中位数是 (2 + 3)/2 = 2.5<br><strong>Program</strong><br><strong>暴力</strong><br>时间复杂度：$O((m+n)/2)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m=nums1.size(), n=nums2.size();</span><br><span class="line">        <span class="keyword">int</span> left1=<span class="number">0</span>, left2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pre, now;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> res=<span class="number">-1.0</span>;</span><br><span class="line">        <span class="keyword">bool</span> isPass=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(left1&lt;m&amp;&amp;left2&lt;n){</span><br><span class="line">            <span class="keyword">if</span>(nums1[left1]&lt;nums2[left2]) now=nums1[left1++];</span><br><span class="line">            <span class="keyword">else</span> now=nums2[left2++];</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">if</span>((m+n)%<span class="number">2</span>==<span class="number">1</span>&amp;&amp;ans==n+(m-n)/<span class="number">2</span>+<span class="number">1</span>){res=(<span class="keyword">double</span>)now;isPass=<span class="literal">true</span>;<span class="keyword">break</span>;}</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ans==n+(m-n)/<span class="number">2</span>+<span class="number">1</span>){res=((<span class="keyword">double</span>)pre+now)/<span class="number">2</span>;isPass=<span class="literal">true</span>;<span class="keyword">break</span>;}</span><br><span class="line">            pre=now;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(isPass) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">while</span>(left1&lt;m){</span><br><span class="line">            now=nums1[left1++];</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">if</span>((m+n)%<span class="number">2</span>==<span class="number">1</span>&amp;&amp;ans==n+(m-n)/<span class="number">2</span>+<span class="number">1</span>){res=(<span class="keyword">double</span>)now;isPass=<span class="literal">true</span>;<span class="keyword">break</span>;}</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ans==n+(m-n)/<span class="number">2</span>+<span class="number">1</span>){res=((<span class="keyword">double</span>)pre+now)/<span class="number">2</span>;isPass=<span class="literal">true</span>;<span class="keyword">break</span>;}</span><br><span class="line">            pre=now;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(isPass) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">while</span>(left2&lt;n){</span><br><span class="line">            now=nums2[left2++];</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">if</span>((m+n)%<span class="number">2</span>==<span class="number">1</span>&amp;&amp;ans==n+(m-n)/<span class="number">2</span>+<span class="number">1</span>){res=(<span class="keyword">double</span>)now;isPass=<span class="literal">true</span>;<span class="keyword">break</span>;}</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ans==n+(m-n)/<span class="number">2</span>+<span class="number">1</span>){res=((<span class="keyword">double</span>)pre+now)/<span class="number">2</span>;isPass=<span class="literal">true</span>;<span class="keyword">break</span>;}</span><br><span class="line">            pre=now;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="23-合并K个排序链表"><a href="#23-合并K个排序链表" class="headerlink" title="23. 合并K个排序链表"></a>23. 合并K个排序链表</h3><p><strong>Description</strong><br>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。<br><strong>Example</strong><br>示例:<br>输入:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&nbsp; 1-&gt;4-&gt;5,</span><br><span class="line">&nbsp; 1-&gt;3-&gt;4,</span><br><span class="line">&nbsp; 2-&gt;6</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<p>输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<br><strong>Program</strong><br><strong>非递归归并</strong><br>首先，此题与归并排序很像，只不过是链表合并，那么根据非递归归并可以这样做：<br>（1）len=2,4,8,…，这里需要注意n不是2的幂次的时候，len最大为比n大的最小2次幂——因为需要合并最终剩余的两个单链；<br>（2）对于每len个链进行归并，l,r分表表示左右端点，只需要合并l与(l+r+1)/2两个单链，结果存储在lists[l]中即可：<br>例如lists：[0,1,2,3,4,5,6]<br>len=2:[0,1]合并存储在lists[0]中，[2,3]合并存储在lists[2]中,…<br>len=4:[0,1,2,3]合并0,2存储在lists[0]中，[4,5,6]合并4,6存储在lists[4]…<br>len=8:[0,1,2,3,4,5,6]合并0,4存储在lists[0]中；<br>…<br>以此类推，所以最终结果存储在lists[0]中。<br>时间复杂度：$O(n\log(n))$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;ListNode*&gt; vec;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l, ListNode* r)</span></span>{</span><br><span class="line">        ListNode* root=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* p=root;</span><br><span class="line">        <span class="keyword">while</span>(l!=<span class="literal">NULL</span>&amp;&amp;r!=<span class="literal">NULL</span>){</span><br><span class="line">            <span class="keyword">if</span>(l-&gt;val&lt;=r-&gt;val) {p-&gt;next=<span class="keyword">new</span> ListNode(l-&gt;val);l=l-&gt;next;}</span><br><span class="line">            <span class="keyword">else</span> {p-&gt;next=<span class="keyword">new</span> ListNode(r-&gt;val);r=r-&gt;next;}</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(l!=<span class="literal">NULL</span>){</span><br><span class="line">            p-&gt;next=<span class="keyword">new</span> ListNode(l-&gt;val);</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            l=l-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(r!=<span class="literal">NULL</span>){</span><br><span class="line">            p-&gt;next=<span class="keyword">new</span> ListNode(r-&gt;val);</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            r=r-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(lists.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> n=lists.size();</span><br><span class="line">        <span class="keyword">bool</span> isFirst=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n||isFirst;len*=<span class="number">2</span>){</span><br><span class="line">            <span class="keyword">if</span>(len&gt;=n) isFirst=<span class="literal">false</span>; <span class="comment">//当n不是2的幂次的时候，需要遍历整个数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len){</span><br><span class="line">                <span class="keyword">int</span> l=i;</span><br><span class="line">                <span class="keyword">int</span> r=i+len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">int</span> mid=l+(r-l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(mid&gt;=n) <span class="keyword">break</span>; <span class="comment">//单链不需要合并</span></span><br><span class="line">                <span class="comment">//cout&lt;&lt;l&lt;&lt;" "&lt;&lt;mid&lt;&lt;" "&lt;&lt;r&lt;&lt;";;;";</span></span><br><span class="line">                lists[l]=merge(lists[l], lists[mid]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// lists[0]=merge(lists[0], lists[1]);</span></span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="218-天际线问题"><a href="#218-天际线问题" class="headerlink" title="218. 天际线问题"></a>218. 天际线问题</h3><p><strong>Description</strong><br>城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。现在，假设您获得了城市风光照片（图A）上显示的所有建筑物的位置和高度，请编写一个程序以输出由这些建筑物形成的天际线（图B）。<br><img src="/assets/img/algorithm/218_example_01.png" alt="image"><br>每个建筑物的几何信息用三元组 [Li，Ri，Hi] 表示，其中 Li 和 Ri 分别是第 i 座建筑物左右边缘的 x 坐标，Hi 是其高度。可以保证 0 ≤ Li, Ri ≤ INT_MAX, 0 &lt; Hi ≤ INT_MAX 和 Ri - Li &gt; 0。您可以假设所有建筑物都是在绝对平坦且高度为 0 的表面上的完美矩形。</p>
<p>例如，图A中所有建筑物的尺寸记录为：[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] 。</p>
<p>输出是以 [ [x1,y1], [x2, y2], [x3, y3], … ] 格式的“关键点”（图B中的红点）的列表，它们唯一地定义了天际线。关键点是水平线段的左端点。请注意，最右侧建筑物的最后一个关键点仅用于标记天际线的终点，并始终为零高度。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p>
<p>例如，图B中的天际线应该表示为：[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]。</p>
<p>说明:<br>任何输入列表中的建筑物数量保证在 [0, 10000] 范围内。<br>输入列表已经按左 x 坐标 Li  进行升序排列。<br>输出列表必须按 x 位排序。<br>输出天际线中不得有连续的相同高度的水平线。例如 […[2 3], [4 5], [7 5], [11 5], [12 7]…] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[…[2 3], [4 5], [12 7], …]<br><strong>Program</strong><br><strong>扫描法</strong><br>使用扫描线，从左至右扫过。如果遇到左端点，将高度入堆，如果遇到右端点，则将高度从堆中删除。使用 last 变量记录上一个转折点。<br>可以参考下面的图，扫描线下方的方格就是堆。<br><img src="/assets/img/algorithm/218_example_02.gif" alt="image"></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; getSkyline(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; buildings) {</span><br><span class="line">        <span class="built_in">multiset</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; all_buildings;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="comment">//按x坐标顺序排列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec:buildings){</span><br><span class="line">            all_buildings.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(vec[<span class="number">0</span>], -vec[<span class="number">2</span>])); <span class="comment">//左端点</span></span><br><span class="line">            all_buildings.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(vec[<span class="number">1</span>], vec[<span class="number">2</span>])); <span class="comment">//右端点</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; heights({<span class="number">0</span>});<span class="comment">//初试高度0</span></span><br><span class="line">        <span class="keyword">int</span> pre=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p:all_buildings){</span><br><span class="line">            <span class="keyword">if</span>(p.second&lt;<span class="number">0</span>) heights.insert(-p.second); <span class="comment">//左端点插入</span></span><br><span class="line">            <span class="keyword">else</span> heights.erase(heights.find(p.second)); <span class="comment">//右端点剔除</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> maxHeight=*heights.rbegin();<span class="comment">//当前最大高度</span></span><br><span class="line">            <span class="keyword">if</span>(pre!=maxHeight){</span><br><span class="line">                pre=maxHeight;</span><br><span class="line">                res.push_back({p.first, maxHeight});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="241-为运算表达式设计优先级"><a href="#241-为运算表达式设计优先级" class="headerlink" title="241. 为运算表达式设计优先级"></a>241. 为运算表达式设计优先级</h3><p><strong>Description</strong><br>给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。<br><strong>Example</strong><br>示例 1:<br>输入: “2-1-1”<br>输出: [0, 2]<br>解释:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((2-1)-1) = 0</span><br><span class="line">(2-(1-1)) = 2</span><br></pre></td></tr></tbody></table></figure>

<p>示例 2:<br>输入: “2<em>3-4</em>5”<br>输出: [-34, -14, -10, -10, 10]<br>解释:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(2*(3-(4*5))) = -34</span><br><span class="line">((2*3)-(4*5)) = -14</span><br><span class="line">((2*(3-4))*5) = -10</span><br><span class="line">(2*((3-4)*5)) = -10</span><br><span class="line">(((2*3)-4)*5) = 10</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong><br><strong>分治</strong><br>以操作符划分为两部分，分别求两部分的结果，最后对应求值。<br>可以发现可以分成两个子问题。<br>边界：纯数字<br>记得记忆化搜索，因为存在重复计算。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; diffWaysToCompute(<span class="built_in">string</span> input) {</span><br><span class="line">        <span class="keyword">int</span> n=input.length();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="keyword">if</span>(m.find(input)!=m.end()) <span class="keyword">return</span> m[input];</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> isDig=<span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(isOperator(input[i])){</span><br><span class="line">                isDig=<span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; leftVec=diffWaysToCompute(input.substr(<span class="number">0</span>, i));</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rightVec=diffWaysToCompute(input.substr(i+<span class="number">1</span>, n-i<span class="number">-1</span>));</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp=calExpression(leftVec, rightVec, input[i]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;tmp.size();j++) res.push_back(tmp[j]);</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(isDig){</span><br><span class="line">                num=num*<span class="number">10</span>+input[i]-<span class="string">'0'</span>; <span class="comment">//全部是数字</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(isDig){</span><br><span class="line">            <span class="keyword">return</span> {num};</span><br><span class="line">        }</span><br><span class="line">        sort(res.begin(), res.end());</span><br><span class="line">        m[input]=res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOperator</span><span class="params">(<span class="keyword">char</span> ch)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> ch==<span class="string">'+'</span>||ch==<span class="string">'-'</span>||ch==<span class="string">'*'</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; calExpression(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; left, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; right, <span class="keyword">char</span> op){</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;left.size();i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;right.size();j++){</span><br><span class="line">                res.push_back(cal(left[i],right[j], op));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">char</span> op)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span>(op){</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:res=a+b;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:res=a-b;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:res=a*b;<span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//cout&lt;&lt;res&lt;&lt;" ";</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="493-翻转对"><a href="#493-翻转对" class="headerlink" title="493. 翻转对"></a>493. 翻转对</h3><p><strong>Description</strong><br>给定一个数组 nums ，如果 $i &lt; j 且 nums[i] &gt; 2 * nums[j]$ 我们就将 (i, j) 称作一个重要翻转对。<br>你需要返回给定数组中的重要翻转对的数量。<br><strong>Example</strong><br>示例 1:<br>输入: [1,3,2,3,1]<br>输出: 2</p>
<p>示例 2:<br>输入: [2,4,3,5,1]<br>输出: 3<br>注意:<br>给定数组的长度不会超过50000。<br>输入数组中的所有数字都在32位整数的表示范围内。<br><strong>Program</strong><br><strong>思路</strong><br>求逆序对的思路，即求第i个元素左边比它大两倍的元素个数！树状数组求解：<br>（1）元素范围[-INT_MIN,INT_MAX]，太大，树状数组C内存超限，需要离散化；<br>（2）对元素离散化后，<strong>需要找到在已排序初始数组nums中小于等于当前nums[i]的两倍的<del>最大元素</del>对应于离散化后的值！</strong>，显然二分查找：</p>
<ul>
<li>为什么要找小于等于$target=nums[i] * 2$的最大元素对应离散值呢？——因为对于每个nums[i]，需要数组左边[0,i-1]中求比$target$大的元素的个数，通过树状数组$getSum(n)-getSum(lessValue)$，其中lessValue是小于等于$target$最大元素的离散值！<br>（3）注意边界：</li>
<li>有可能整个数组都比$target$小，那么二分查找到的<strong>对应元素</strong>离散值lessValue恰好为最大元素的离散值n，应当累加getSum(n)-getSum(lessValue)=getSum(n)-getSum(n)=0;</li>
<li>有可能整个数组都比$target$大，那么二分查找返回-1，此时应当累加getSum(n)-getSum(0)=getSum(n)；</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> idx;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> _val, <span class="keyword">int</span> _idx):val(_val),idx(_idx){}</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; tmp) <span class="keyword">const</span>{</span><br><span class="line">            <span class="keyword">return</span> val&lt;tmp.val;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; vec;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=n;i+=lowbit(i)) C[i]+=v;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;=<span class="number">1</span>;i-=lowbit(i)) sum+=C[i];</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> target)</span></span>{ <span class="comment">//找第一个小于等于target的数的下标，未找到则返回-1，表示所有元素都比target大</span></span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(vec[mid].val&lt;=target) left=mid;</span><br><span class="line">            <span class="keyword">else</span> right=mid<span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(vec[left].val&gt;target) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        n=nums.size();</span><br><span class="line">        C.resize(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        A.resize(n, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//离散化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) vec.push_back(Node(nums[i], i));</span><br><span class="line">        sort(vec.begin(), vec.end());</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; iTov;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;vec[i].val==vec[i<span class="number">-1</span>].val) A[vec[i].idx]=A[vec[i<span class="number">-1</span>].idx];</span><br><span class="line">            <span class="keyword">else</span> A[vec[i].idx]=i+<span class="number">1</span>;</span><br><span class="line">            iTov[A[vec[i].idx]]=vec[i].val;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> nowValue = A[i]; <span class="comment">//当前元素对应离散化后的值</span></span><br><span class="line">            <span class="keyword">int</span> nowSortedIdx = binarySearch((<span class="keyword">long</span> <span class="keyword">long</span>)iTov[nowValue] * <span class="number">2</span>);<span class="comment">//当前元素的两倍值对应排序后数组的坐标</span></span><br><span class="line">            <span class="keyword">if</span>(nowSortedIdx==<span class="number">-1</span>) ans+=getSum(n);</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">int</span> lessValue=A[vec[nowSortedIdx].idx]; <span class="comment">//nowSortedIdx对应离散化后的值</span></span><br><span class="line">                <span class="comment">//cout&lt;&lt;nowValue&lt;&lt;" "&lt;&lt;lessValue&lt;&lt;endl;</span></span><br><span class="line">                ans+=getSum(n)-getSum(lessValue);</span><br><span class="line">            }  </span><br><span class="line">            update(nowValue, <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="932-漂亮数组"><a href="#932-漂亮数组" class="headerlink" title="932. 漂亮数组"></a>932. 漂亮数组</h3><p><strong>Description</strong><br>对于某些固定的 N，如果数组 A 是整数 1, 2, …, N 组成的排列，使得：<br>对于每个 $i &lt; j$，都不存在 k 满足 $i &lt; k &lt; j$ 使得 $A[k] * 2 = A[i] + A[j]$。<br>那么数组 A 是漂亮数组。<br>给定 N，返回任意漂亮数组 A（保证存在一个）。<br><strong>Example</strong><br>示例 1：<br>输入：4<br>输出：[2,1,4,3]</p>
<p>示例 2：<br>输入：5<br>输出：[3,1,2,5,4]</p>
<p>提示：<br>1 &lt;= N &lt;= 1000<br><strong>Program</strong><br><strong>分治</strong><br>性质：<br>（1）A是一个漂亮数组，如果对A中所有元素乘k+一个常数，那么Ａ还是一个漂亮数组<br>（2）A是一个奇数漂亮数组，B是一个偶数漂亮数组，那么A+B也是漂亮数组：</p>
<ul>
<li>因为$x[k] * 2=x[i] + x[j], i&lt;k&lt;j$对A，B都成立；</li>
<li>对于A+B，如果i,j都属于A或B，不用谈，<strong>那么如果i属于A，j属于B，方程左边为偶数，右边为奇数，所以方程也一定不成立</strong>，得证！</li>
</ul>
<p>那么根据性质2，如果能够将所有奇数放在左边，所有偶数放在右边，各自成为一个漂亮数组，那么就找到结果了。<br>奇数有$(N+1)/2$个，偶数有$N/2$个。</p>
<p><strong>进行子问题划分：</strong><br>设$f(N)$为以$[1,N]$为某排列的漂亮数组，求$f((N+1)/2)，f(N/2)$，可以发现：</p>
<ul>
<li>$f((N+1)/2)$的每个元素$x$，$x * 2-1 \in [1, N]$ 且 $(x * 2-1)&amp;1=1$，即$x * 2-1$为奇数，且恰好为$[1,N]$的所有奇数。</li>
<li>$f(N/2)$的每个元素$y$，$y * 2 \in [1, N]$ 且 $(y * 2)&amp;1=0$，即$y * 2$为偶数，且恰好为$[1,N]$的所有偶数。</li>
</ul>
<p>根据性质1、2，$[f((N+1)/2) * 2-1]+[f(N/2) * 2]$即为答案！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; beautifulArray(<span class="keyword">int</span> N) {</span><br><span class="line">        <span class="keyword">if</span>(m.find(N)!=m.end()) <span class="keyword">return</span> m[N];</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">1</span>){</span><br><span class="line">            m[<span class="number">1</span>]={<span class="number">1</span>};</span><br><span class="line">            <span class="keyword">return</span> m[<span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; odds=beautifulArray((N+<span class="number">1</span>)/<span class="number">2</span>); <span class="comment">//奇数</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; evens=beautifulArray(N/<span class="number">2</span>); <span class="comment">//偶数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>&amp; x:odds) res.push_back(x*<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>&amp; x:evens) res.push_back(x*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="973-最接近原点的-K-个点"><a href="#973-最接近原点的-K-个点" class="headerlink" title="973. 最接近原点的 K 个点"></a>973. 最接近原点的 K 个点</h3><p><strong>Description</strong><br>我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。<br>（这里，平面上两点之间的距离是欧几里德距离。）<br>你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。<br><strong>Example</strong><br>示例 1：<br>输入：points = [[1,3],[-2,2]], K = 1<br>输出：[[-2,2]]<br>解释：<br>(1, 3) 和原点之间的距离为 sqrt(10)，<br>(-2, 2) 和原点之间的距离为 sqrt(8)，<br>由于 sqrt(8) &lt; sqrt(10)，(-2, 2) 离原点更近。<br>我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。</p>
<p>示例 2：<br>输入：points = [[3,3],[5,-1],[-2,4]], K = 2<br>输出：[[3,3],[-2,4]]<br>（答案 [[-2,4],[3,3]] 也会被接受。）</p>
<p>提示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= K &lt;= points.length &lt;= 10000</span><br><span class="line">-10000 &lt; points[i][0] &lt; 10000</span><br><span class="line">-10000 &lt; points[i][1] &lt; 10000</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong><br><strong>堆排序</strong><br>优先队列实现，时间复杂度：$O(n\log{n})$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Cmp</span>{</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span><span class="keyword">const</span></span>{</span><br><span class="line">            <span class="keyword">return</span> (a[<span class="number">0</span>]*a[<span class="number">0</span>]+a[<span class="number">1</span>]*a[<span class="number">1</span>])&gt;(b[<span class="number">0</span>]*b[<span class="number">0</span>]+b[<span class="number">1</span>]*b[<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; kClosest(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> K) {</span><br><span class="line">        priority_queue&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;, Cmp&gt; pq(points.begin(), points.end());</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty()&amp;&amp;k&lt;K){</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; now=pq.top();pq.pop();</span><br><span class="line">            res.push_back(now);</span><br><span class="line">            k++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>快排</strong><br>题目要的是前k个距离最小的元素，根据快排的性质，每次快排都能将元素分成左右两部分。<br>平均时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; kClosest(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> K) {</span><br><span class="line">        <span class="keyword">if</span>(points.size()==K) <span class="keyword">return</span> points;</span><br><span class="line">        quickSort(points, <span class="number">0</span>, points.size()<span class="number">-1</span>, K);</span><br><span class="line">        points.resize(K); <span class="comment">//剔除后面不要的元素</span></span><br><span class="line">        <span class="keyword">return</span> points;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> K)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">int</span> pos=partition(points, left, right);</span><br><span class="line">            <span class="keyword">if</span>(pos-left+<span class="number">1</span>==K) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pos-left+<span class="number">1</span>&gt;K) quickSort(points, left, pos, K);</span><br><span class="line">            <span class="keyword">else</span> quickSort(points, pos+<span class="number">1</span>, right, K-(pos-left+<span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; x)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> x[<span class="number">0</span>]*x[<span class="number">0</span>]+x[<span class="number">1</span>]*x[<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp=points[left];</span><br><span class="line">        <span class="keyword">int</span> tmpDis=dis(temp);</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;dis(points[right])&gt;=tmpDis) right--;</span><br><span class="line">            points[left]=points[right];</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;dis(points[left])&lt;=tmpDis) left++;</span><br><span class="line">            points[right]=points[left];</span><br><span class="line">        }</span><br><span class="line">        points[left]=temp;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a>剑指 Offer 25. 合并两个排序的链表</h3><p><strong>Description</strong><br>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。<br><strong>Example</strong><br>示例1：<br>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br>限制：<br>0 &lt;= 链表长度 &lt;= 1000<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>{</span><br><span class="line">        ListNode* root=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* tp=root;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span>&amp;&amp;l2!=<span class="literal">NULL</span>){</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val&lt;=l2-&gt;val){</span><br><span class="line">                tp-&gt;next=<span class="keyword">new</span> ListNode(l1-&gt;val);</span><br><span class="line">                tp=tp-&gt;next;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                tp-&gt;next=<span class="keyword">new</span> ListNode(l2-&gt;val);</span><br><span class="line">                tp=tp-&gt;next;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span>){</span><br><span class="line">            tp-&gt;next=<span class="keyword">new</span> ListNode(l1-&gt;val);</span><br><span class="line">            tp=tp-&gt;next;</span><br><span class="line">            l1=l1-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(l2!=<span class="literal">NULL</span>){</span><br><span class="line">            tp-&gt;next=<span class="keyword">new</span> ListNode(l2-&gt;val);</span><br><span class="line">            tp=tp-&gt;next;</span><br><span class="line">            l2=l2-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root-&gt;next;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a>剑指 Offer 40. 最小的k个数</h3><p><strong>Description</strong><br>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。<br><strong>Example</strong><br>示例 1：<br>输入：arr = [3,2,1], k = 2<br>输出：[1,2] 或者 [2,1]</p>
<p>示例 2：<br>输入：arr = [0,1,2,1], k = 1<br>输出：[0]</p>
<p>限制：<br>0 &lt;= k &lt;= arr.length &lt;= 10000<br>0 &lt;= arr[i] &lt;= 10000<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> temp=arr[left];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;arr[right]&gt;=temp) right--;</span><br><span class="line">            arr[left]=arr[right];</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;arr[left]&lt;=temp) left++;</span><br><span class="line">            arr[right]=arr[left];</span><br><span class="line">        }</span><br><span class="line">        arr[left]=temp;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">int</span> pos=partition(arr, left, right);</span><br><span class="line">            <span class="keyword">if</span>(pos-left+<span class="number">1</span>==k) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(pos-left+<span class="number">1</span>&lt;k) quickSort(arr, pos+<span class="number">1</span>, right, k-(pos-left+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span> quickSort(arr, left, pos<span class="number">-1</span>, k);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getLeastNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="keyword">if</span>(k==arr.size()) <span class="keyword">return</span> arr;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.size()<span class="number">-1</span>, k);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(arr.begin(), arr.begin()+k);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="面试题-17-14-最小K个数"><a href="#面试题-17-14-最小K个数" class="headerlink" title="面试题 17.14. 最小K个数"></a>面试题 17.14. 最小K个数</h3><p><strong>Description</strong><br>设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。<br><strong>Example</strong><br>示例：<br>输入： arr = [1,3,5,7,2,4,6,8], k = 4<br>输出： [1,2,3,4]<br>提示：<br>0 &lt;= len(arr) &lt;= 100000<br>0 &lt;= k &lt;= min(100000, len(arr))<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> temp=arr[left];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;arr[right]&gt;=temp) right--;</span><br><span class="line">            arr[left]=arr[right];</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;arr[left]&lt;=temp) left++;</span><br><span class="line">            arr[right]=arr[left];</span><br><span class="line">        }</span><br><span class="line">        arr[left]=temp;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">int</span> pos=partition(arr, left, right);</span><br><span class="line">            <span class="keyword">if</span>(pos-left+<span class="number">1</span>==k) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(pos-left+<span class="number">1</span>&lt;k) quickSort(arr, pos+<span class="number">1</span>, right, k-(pos-left+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span> quickSort(arr, left, pos<span class="number">-1</span>, k);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; smallestK(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="keyword">if</span>(k==arr.size()) <span class="keyword">return</span> arr;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.size()<span class="number">-1</span>, k);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(arr.begin(), arr.begin()+k);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1></blockquote>
<h2 id="常规位运算"><a href="#常规位运算" class="headerlink" title="常规位运算"></a>常规位运算</h2><h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h3><p><strong>Description</strong><br>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>说明：解集不能包含重复的子集。<br><strong>Example</strong><br>示例:<br>输入: nums = [1,2,3]<br>输出:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">&nbsp; [1],</span><br><span class="line">&nbsp; [2],</span><br><span class="line">&nbsp; [1,2,3],</span><br><span class="line">&nbsp; [1,3],</span><br><span class="line">&nbsp; [2,3],</span><br><span class="line">&nbsp; [1,2],</span><br><span class="line">&nbsp; []</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; subset(<span class="keyword">int</span> x, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums){</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>==<span class="number">1</span>){</span><br><span class="line">                vec.push_back(nums[i]);</span><br><span class="line">            }</span><br><span class="line">        }  </span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++){</span><br><span class="line">            result.push_back(subset(i, n, nums));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1356-根据数字二进制下-1-的数目排序"><a href="#1356-根据数字二进制下-1-的数目排序" class="headerlink" title="1356. 根据数字二进制下 1 的数目排序"></a>1356. 根据数字二进制下 1 的数目排序</h3><p><strong>Description</strong><br>给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。<br>如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。<br>请你返回排序后的数组。<br><strong>Example</strong><br>示例 1：<br>输入：arr = [0,1,2,3,4,5,6,7,8]<br>输出：[0,1,2,4,8,3,5,6,7]<br>解释：[0] 是唯一一个有 0 个 1 的数。<br>[1,2,4,8] 都有 1 个 1 。<br>[3,5,6] 有 2 个 1 。<br>[7] 有 3 个 1 。<br>按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]</p>
<p>示例 2：<br>输入：arr = [1024,512,256,128,64,32,16,8,4,2,1]<br>输出：[1,2,4,8,16,32,64,128,256,512,1024]<br>解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。</p>
<p>示例 3：<br>输入：arr = [10000,10000]<br>输出：[10000,10000]</p>
<p>示例 4：<br>输入：arr = [2,3,5,7,11,13,17,19]<br>输出：[2,3,5,17,7,11,13,19]</p>
<p>示例 5：<br>输入：arr = [10,100,1000,10000]<br>输出：[10,100,10000,1000]</p>
<p>提示：<br>1 &lt;= arr.length &lt;= 500<br>0 &lt;= arr[i] &lt;= 10^4<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortByBits(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr) {</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">10001</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10000</span>;i++){</span><br><span class="line">            dp[i]=dp[i&gt;&gt;<span class="number">1</span>]+(i&amp;<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        sort(arr.begin(), arr.end(), [&amp;](<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b){</span><br><span class="line">            <span class="keyword">return</span> dp[a]==dp[b]?a&lt;b:dp[a]&lt;dp[b];</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="去重位运算"><a href="#去重位运算" class="headerlink" title="去重位运算"></a>去重位运算</h2><h3 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a>136. 只出现一次的数字</h3><p><strong>Description</strong><br>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。<br>说明：<br>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？<br><strong>Example</strong><br>示例 1:<br>输入: [2,2,1]<br>输出: 1</p>
<p>示例 2:<br>输入: [4,1,2,1,2]<br>输出: 4<br><strong>Program</strong><br><strong>①常规思路</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i+=<span class="number">2</span>){</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&lt;nums.size()&amp;&amp;nums[i]!=nums[i+<span class="number">1</span>]){</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nums[nums.size()<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>位运算’与’去重</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++){</span><br><span class="line">            num^=nums[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a>剑指 Offer 39. 数组中出现次数超过一半的数字</h3><p><strong>Description</strong><br>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br><strong>Example</strong><br>示例 1:<br>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br>输出: 2</p>
<p>限制：<br>1 &lt;= 数组长度 &lt;= 50000<br><strong>Program</strong><br><strong>思路</strong><br>投票：由于众数过半，所以正负抵消，最终剩余的一定是众数。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> nCount=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=pre) nCount--;</span><br><span class="line">            <span class="keyword">else</span> nCount++;</span><br><span class="line">            <span class="keyword">if</span>(nCount==<span class="number">0</span>){</span><br><span class="line">                nCount=<span class="number">1</span>;</span><br><span class="line">                pre=nums[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="137-只出现一次的数字-II"><a href="#137-只出现一次的数字-II" class="headerlink" title="137. 只出现一次的数字 II"></a>137. 只出现一次的数字 II</h3><p><strong>Description</strong><br>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。<br>说明：<br>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？<br><strong>Example</strong><br>示例 1:<br>输入: [2,2,3,2]<br>输出: 3</p>
<p>示例 2:<br>输入: [0,1,0,1,0,1,99]<br>输出: 99<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> one,two,three;</span><br><span class="line">        one=two=three=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x: nums){</span><br><span class="line">            two |= one &amp; x;</span><br><span class="line">            one ^=x;</span><br><span class="line">            three = one &amp; two;</span><br><span class="line">            one &amp;= ~three;</span><br><span class="line">            two &amp;= ~three;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="268-缺失数字"><a href="#268-缺失数字" class="headerlink" title="268. 缺失数字"></a>268. 缺失数字</h3><p><strong>Description</strong><br>给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。<br><strong>Example</strong><br>示例 1:<br>输入: [3,0,1]<br>输出: 2</p>
<p>示例 2:<br>输入: [9,6,4,2,3,5,7,0,1]<br>输出: 8<br><strong>Program</strong><br>位运算，$O(n)$，[0…n]异或，而数组缺少其中一个，故整体两次异或编程0，单独一次异或的就是缺失的了</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> result=nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++){</span><br><span class="line">            result^=i;</span><br><span class="line">            result^=nums[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1></blockquote>
<h2 id="区间贪心"><a href="#区间贪心" class="headerlink" title="区间贪心"></a>区间贪心</h2><h3 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h3><p><strong>Description</strong><br>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个位置。<br><strong>Example</strong><br>示例 1:<br>输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p>
<p>示例 2:<br>输入: [3,2,1,0,4]<br>输出: false<br>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。<br><strong>Program</strong></p>
<ul>
<li>如果某一个作为 起跳点 的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为 起跳点。</li>
<li>可以对每一个能作为 起跳点 的格子都尝试跳一次，把 能跳到最远的距离 不断更新。</li>
<li>如果可以一直跳到最后，就成功了。<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(i&gt;k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            k=max(k, i+nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(k&gt;=nums.size()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a>135. 分发糖果</h3></li>
</ul>
<p><strong>Description</strong><br>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。<br>你需要按照以下要求，帮助老师给这些孩子分发糖果：<br>每个孩子至少分配到 1 个糖果。<br>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。<br>那么这样下来，老师至少需要准备多少颗糖果呢？<br><strong>Example</strong><br>示例 1：<br>输入：[1,0,2]<br>输出：5<br>解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。</p>
<p>示例 2：<br>输入：[1,2,2]<br>输出：4<br>解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。<br>     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=ratings.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; candies(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(ratings[i]&gt;ratings[i<span class="number">-1</span>]) candies[i]=candies[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">if</span>(ratings[i]&gt;ratings[i+<span class="number">1</span>]){</span><br><span class="line">                <span class="keyword">if</span>(candies[i]&lt;=candies[i+<span class="number">1</span>]) candies[i]=candies[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) ans+=candies[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="605-种花问题"><a href="#605-种花问题" class="headerlink" title="605. 种花问题"></a>605. 种花问题</h3><p><strong>Description</strong><br>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。<br>给你一个整数数组  flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。<br><strong>Example</strong><br>示例 1：<br>输入：flowerbed = [1,0,0,0,1], n = 1<br>输出：true</p>
<p>示例 2：<br>输入：flowerbed = [1,0,0,0,1], n = 2<br>输出：false</p>
<p>提示：<br>1 &lt;= flowerbed.length &lt;= 2 * 10^4<br>flowerbed[i] 为 0 或 1<br>flowerbed 中不存在相邻的两朵花<br>0 &lt;= n &lt;= flowerbed.length<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; flowerbed, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m=flowerbed.size();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m){</span><br><span class="line">            <span class="keyword">if</span>(flowerbed[i]==<span class="number">1</span>) i+=<span class="number">2</span>; <span class="comment">//跳两步</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((i+<span class="number">1</span>&lt;m&amp;&amp;flowerbed[i+<span class="number">1</span>]==<span class="number">0</span>)||i==m<span class="number">-1</span>){ <span class="comment">//当前0，前一位肯定0，判断后一位即可</span></span><br><span class="line">                ans++;</span><br><span class="line">                i+=<span class="number">2</span>;</span><br><span class="line">            }<span class="keyword">else</span> i+=<span class="number">3</span>; <span class="comment">//后一位为1，不可放置，跳三步</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans&gt;=n;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="632-最小区间"><a href="#632-最小区间" class="headerlink" title="632. 最小区间"></a>632. 最小区间</h3><p><strong>Description</strong><br>你有 k 个升序排列的整数数组。找到一个最小区间，使得 k 个列表中的每个列表至少有一个数包含在其中。<br>我们定义如果 b-a &lt; d-c 或者在 b-a == d-c 时 a &lt; c，则区间 [a,b] 比 [c,d] 小。<br><strong>Example</strong><br>示例 1:<br>输入:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]<br>输出: [20,24]<br>解释:<br>列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。<br>列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。<br>列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。<br>注意:<br>给定的列表可能包含重复元素，所以在这里升序表示 &gt;= 。<br>1 &lt;= k &lt;= 3500<br>-10^5 &lt;= 元素的值 &lt;= 10^5<br>对于使用Java的用户，请注意传入类型已修改为List&lt;List<integer>&gt;。重置代码模板后可以看到这项改动。<br><strong>Program</strong><br><strong>思路</strong><br>首先，我们想一下这样一个问题：题目要求是寻找最小区间，最小区间满足下面两点：</integer></p>
<ul>
<li>长度最小(首要)</li>
<li>长度相同时起点最小<br>长度最小的区间必然是需要我们在计算中找到的，但是起点最小的区间我们是可以知道的。就是从每个区间中找最小的元素，组成的新的区间，我们称其为起始区间。如果之后没有长度比起始区间长度更短的，那么起始区间就是我们所求的最小区间，因为起始区间的起点是最小的。</li>
</ul>
<p>那么我们所需要做的就是搜索是否有比起始区间还要短的区间了。那么该如何搜索呢？<br>答案是 <strong>每次都将当前区间中最小的元素丢弃，换成其原始数组中的下一个元素(为了保证区间至少包含每个数组一个元素)</strong>。就是说，如果当前我们从每个区间中选取的元素分别是a1_1,a2_1,a3_1…ak_1(前面的数字代表来自第几个数组，后面的数字表示该数是该数组的第几个元素),若此时最小的元素是ai_1,最大元素是aj_1,那么区间就为[ai_1, aj_1],区间中最小元素是ai_1,那么我们就将ai_1丢弃,将ai_2拿出来放进去。</p>
<p><strong>原因</strong>：如果不换ai_1,那么区间的起点就一直是ai_1,而且区间长度不可能缩小，区间长度取决于起点和终点，而终点是不可能变小的。因为我们是从小到大进行元素的选取，我们每次丢弃一个元素，就要选择它在原数组中的下一位，而原数组是升序排列的。故终点不可能减小。<br>那么，我们只能够通过让起点增大来是区间缩小，即每次丢弃最小的元素，换成它原数组的下一个元素。然后再计算当前所选区间的长度，如果小于之前的区间长度就更新即可。</p>
<p><strong>结束条件</strong>：当当前最小元素是其原来整数数组的最后一个元素时，就是结束的时候。因为之后的操作不可能更改起点了，只会让终点变大，即区间变长。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> _val, <span class="keyword">int</span> _id):val(_val),id(_id){}</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; tmp) <span class="keyword">const</span>{</span><br><span class="line">            <span class="keyword">return</span> val&gt;tmp.val;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; smallestRange(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums) {</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">1</span>) <span class="keyword">return</span> {nums[<span class="number">0</span>][<span class="number">0</span>], nums[<span class="number">0</span>][<span class="number">0</span>]};</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nIdx(n, <span class="number">0</span>);</span><br><span class="line">        priority_queue&lt;Node&gt; pq;</span><br><span class="line">        <span class="keyword">int</span> start=INT_MAX, end=INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            start=min(start, nums[i][nIdx[i]]);</span><br><span class="line">            end=max(end, nums[i][nIdx[i]]);</span><br><span class="line">            pq.push(Node(nums[i][nIdx[i]++], i));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">bool</span> isPass=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> s=start, e=end; <span class="comment">//记录当前队列中的最值，由于数组有序，s,e只会增大</span></span><br><span class="line">        <span class="keyword">while</span>(isPass){</span><br><span class="line">            Node node=pq.top();pq.pop();</span><br><span class="line">            <span class="keyword">if</span>(nIdx[node.id]==nums[node.id].size()){</span><br><span class="line">                isPass=<span class="literal">false</span>;<span class="comment">//到达数组尾部</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">int</span> val=nums[node.id][nIdx[node.id]++];</span><br><span class="line">            pq.push(Node(val, node.id));</span><br><span class="line">            s=pq.top().val;</span><br><span class="line">            e=max(e, val);</span><br><span class="line">            <span class="keyword">if</span>(e-s&lt;end-start){</span><br><span class="line">                start=s;</span><br><span class="line">                end=e;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> {start, end};</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1024-视频拼接"><a href="#1024-视频拼接" class="headerlink" title="1024. 视频拼接"></a>1024. 视频拼接</h3><p><strong>Description</strong><br>你将会获得一系列视频片段，这些片段来自于一项持续时长为 T 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。<br>视频片段 clips[i] 都用区间进行表示：开始于 clips[i][0] 并于 clips[i][1] 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 [0, 7] 可以剪切成 [0, 1] + [1, 3] + [3, 7] 三部分。<br>我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, T]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。<br><strong>Example</strong><br>示例 1：<br>输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10<br>输出：3<br>解释：<br>我们选中 [0,2], [8,10], [1,9] 这三个片段。<br>然后，按下面的方案重制比赛片段：<br>将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。<br>现在我们手上有 [0,2] + [2,8] + [8,10]，而这些涵盖了整场比赛 [0, 10]。</p>
<p>示例 2：<br>输入：clips = [[0,1],[1,2]], T = 5<br>输出：-1<br>解释：<br>我们无法只用 [0,1] 和 [0,2] 覆盖 [0,5] 的整个过程。</p>
<p>示例 3：<br>输入：clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9<br>输出：3<br>解释：<br>我们选取片段 [0,4], [4,7] 和 [6,9] 。</p>
<p>示例 4：<br>输入：clips = [[0,4],[2,8]], T = 5<br>输出：2<br>解释：<br>注意，你可能录制超过比赛结束时间的视频。</p>
<p>提示：<br>1 &lt;= clips.length &lt;= 100<br>0 &lt;= clips[i][0] &lt;= clips[i][1] &lt;= 100<br>0 &lt;= T &lt;= 100<br><strong>Program</strong><br><strong>动态规划</strong><br>设DP[i]是以i为结束的最小数目：<br>（1）以HashMap记录以i为结尾的所有区间的起始点，这里需要将区间[s,e]中每个以s开头，j(j=s,…e)为结尾的区间都算进去；<br>（2）递推方程：DP[i]=min(DP[i],1+DP[m[i][j])，其中j为以i结尾的区间的索引，0表示该区间起始。<br>边界：</p>
<ul>
<li>如果m[0].size()==0，表示没有以0开头的区间，如果m[T].size()==0，表示没有以T为结尾的区间，所以直接返回false；</li>
<li>否则DP[0]=0<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">videoStitching</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; clips, <span class="keyword">int</span> T)</span> </span>{</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; m;<span class="comment">//记录以i为结尾的区间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec:clips){</span><br><span class="line">            <span class="keyword">int</span> s=vec[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> e=vec[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=s;i&lt;=e;i++){ <span class="comment">//拆分区间</span></span><br><span class="line">                m[i].push_back(s);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> DP[T+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, inf, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">if</span>(m[T].size()==<span class="number">0</span>||m[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        DP[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=T;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m[i].size();j++){</span><br><span class="line">                <span class="keyword">int</span> s=m[i][j];</span><br><span class="line">                DP[i]=min(DP[i], <span class="number">1</span>+DP[s]);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//cout&lt;&lt;DP[i]&lt;&lt;endl;</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[T]==inf?<span class="number">-1</span>:DP[T]; <span class="comment">//未找到连通区间</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p><strong>贪心</strong><br>此题与<strong>跳跃游戏</strong>类似，可以说是其的变型。<br>DP[i]记录以i为起点的最远可达距离。<br>按起点i进行遍历，记录过程中最远可达距离，</p>
<ul>
<li>如果i==mx(当前最大可达)，说明不连续可达后面的点；</li>
<li>如果i==pre(上一次的最远可达)，记录区间数<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">videoStitching</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; clips, <span class="keyword">int</span> T)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">101</span>] ={<span class="number">0</span>};</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>, ans = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; clip : clips) {</span><br><span class="line">            dp[clip[<span class="number">0</span>]] = max(dp[clip[<span class="number">0</span>]], clip[<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) {</span><br><span class="line">            mx = max(mx, dp[i]);</span><br><span class="line">            <span class="keyword">if</span> (i == pre) { <span class="comment">//已到达上一区间所能到达的最远距离</span></span><br><span class="line">                ans++;  </span><br><span class="line">                pre = mx;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (i == mx) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//不可达</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5641-卡车上的最大单元数"><a href="#5641-卡车上的最大单元数" class="headerlink" title="5641. 卡车上的最大单元数"></a>5641. 卡车上的最大单元数</h3></li>
</ul>
<p><strong>Description</strong><br>请你将一些箱子装在 一辆卡车 上。给你一个二维数组 boxTypes ，其中 boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi] ：<br>numberOfBoxesi 是类型 i 的箱子的数量。<br>numberOfUnitsPerBoxi 是类型 i 每个箱子可以装载的单元数量。<br>整数 truckSize 表示卡车上可以装载 箱子 的 最大数量 。只要箱子数量不超过 truckSize ，你就可以选择任意箱子装到卡车上。<br>返回卡车可以装载 单元 的 最大 总数。<br><strong>Example</strong><br>示例 1：<br>输入：boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4<br>输出：8<br>解释：箱子的情况如下：</p>
<ul>
<li>1 个第一类的箱子，里面含 3 个单元。</li>
<li>2 个第二类的箱子，每个里面含 2 个单元。</li>
<li>3 个第三类的箱子，每个里面含 1 个单元。<br>可以选择第一类和第二类的所有箱子，以及第三类的一个箱子。<br>单元总数 = (1 * 3) + (2 * 2) + (1 * 1) = 8</li>
</ul>
<p>示例 2：<br>输入：boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10<br>输出：91</p>
<p>提示：<br>$1 &lt;= boxTypes.length &lt;= 1000$<br>$1 &lt;= numberOfBoxesi, numberOfUnitsPerBoxi &lt;= 1000$<br>$1 &lt;= truckSize &lt;= 10^6$<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumUnits</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; boxTypes, <span class="keyword">int</span> truckSize)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=boxTypes.size();</span><br><span class="line">        sort(boxTypes.begin(), boxTypes.end(), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b){</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">1</span>]!=b[<span class="number">1</span>]) <span class="keyword">return</span> a[<span class="number">1</span>]&gt;b[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>]&gt;b[<span class="number">0</span>];</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">int</span> cntBox=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cntUnit=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cntBox&lt;truckSize&amp;&amp;i&lt;n){</span><br><span class="line">            <span class="keyword">int</span> bSize=boxTypes[i][<span class="number">0</span>], uSize=boxTypes[i][<span class="number">1</span>];i++;</span><br><span class="line">            <span class="keyword">if</span>(cntBox+bSize&lt;=truckSize){</span><br><span class="line">                cntUnit+=uSize*bSize;</span><br><span class="line">                cntBox+=bSize;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                cntUnit+=uSize*(truckSize-cntBox);</span><br><span class="line">                cntBox=truckSize;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cntUnit;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5642-大餐计数"><a href="#5642-大餐计数" class="headerlink" title="5642. 大餐计数"></a>5642. 大餐计数</h3><p><strong>Description</strong><br>大餐 是指 恰好包含两道不同餐品 的一餐，其美味程度之和等于 2 的幂。<br>你可以搭配 任意 两道餐品做一顿大餐。<br>给你一个整数数组 deliciousness ，其中 deliciousness[i] 是第 i​​​​​​​​​​​​​​ 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 大餐 的数量。结果需要对 109 + 7 取余。<br>注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。<br><strong>Example</strong><br>示例 1：<br>输入：deliciousness = [1,3,5,7,9]<br>输出：4<br>解释：大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。<br>它们各自的美味程度之和分别为 4 、8 、8 和 16 ，都是 2 的幂。</p>
<p>示例 2：<br>输入：deliciousness = [1,1,1,3,3,3,7]<br>输出：15<br>解释：大餐的美味程度组合为 3 种 (1,1) ，9 种 (1,3) ，和 3 种 (1,7) 。</p>
<p>提示：<br>$1 &lt;= deliciousness.length &lt;= 10^5$<br>$0 &lt;= deliciousness[i] &lt;= 2^20$<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1E9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; deliciousness)</span> </span>{</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:deliciousness) m[x]++;</span><br><span class="line">        sort(deliciousness.begin(), deliciousness.end());</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:deliciousness){</span><br><span class="line">            <span class="keyword">if</span>(st.find(x)!=st.end()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> tmp=(<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>, i);</span><br><span class="line">            <span class="keyword">while</span>(i&lt;=<span class="number">21</span>){</span><br><span class="line">                <span class="keyword">if</span>(tmp&gt;=x){</span><br><span class="line">                    <span class="comment">// cout&lt;&lt;tmp&lt;&lt;" ";</span></span><br><span class="line">                    <span class="keyword">if</span>(m.find(tmp-x)!=m.end()&amp;&amp;tmp-x&gt;=x){</span><br><span class="line">                        <span class="keyword">if</span>(x==tmp-x) ans=(ans+((m[x]%MOD)*((m[x]<span class="number">-1</span>)%MOD)/<span class="number">2</span>)%MOD)%MOD;</span><br><span class="line">                        <span class="keyword">else</span> ans=(ans+((m[x]%MOD)*(m[tmp-x]%MOD))%MOD)%MOD;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                i++;</span><br><span class="line">                tmp=(<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>, i);</span><br><span class="line">            }</span><br><span class="line">            st.insert(x);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="树形分治"><a href="#树形分治" class="headerlink" title="树形分治"></a>树形分治</h2><h3 id="剑指-Offer-36-二叉搜索树与双向链表"><a href="#剑指-Offer-36-二叉搜索树与双向链表" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表"></a>剑指 Offer 36. 二叉搜索树与双向链表</h3><p><strong>Description</strong><br>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。<br>为了让您更好地理解问题，以下面的二叉搜索树为例：<br><img src="/assets/img/algorithm/bstdlloriginalbst.png" alt="image"><br>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。<br>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。<br><img src="/assets/img/algorithm/bstdllreturndll.png" alt="image"><br>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。<br><strong>Program</strong><br><strong>分治</strong><br>先吐槽下自己，早就写出来了，然后dfs里面调用dfs的地方，忘记将treeToDoublyList()改成dfs()，然后找了半天bug…<br>（1）当前根结点为中间节点，左右子树当然就成为了两个分治子问题，分别求各自的递增循环队列<br>（2）合并循环队列。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() {}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = NULL;</span></span><br><span class="line"><span class="comment">        right = NULL;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">dfs</span><span class="params">(Node* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        Node* head;</span><br><span class="line">        Node* leftHead=dfs(root-&gt;left);</span><br><span class="line">        Node* rightHead=dfs(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(leftHead!=<span class="literal">NULL</span>&amp;&amp;rightHead!=<span class="literal">NULL</span>){</span><br><span class="line">            leftHead-&gt;left-&gt;right=root; <span class="comment">//更新左链最后一个节点的右指针指向</span></span><br><span class="line">            root-&gt;right=rightHead; <span class="comment">//更新中间节点右指针指向</span></span><br><span class="line">            rightHead-&gt;left-&gt;right=leftHead; <span class="comment">//更新右链最后一个节点右指针指向</span></span><br><span class="line">            root-&gt;left=leftHead-&gt;left; <span class="comment">//更新中间节点左指针指向</span></span><br><span class="line">            leftHead-&gt;left=rightHead-&gt;left; <span class="comment">//更新左链第一个节点的左指针指向</span></span><br><span class="line">            rightHead-&gt;left=root; <span class="comment">//更新右链最后一个节点左指针指向</span></span><br><span class="line">            head=leftHead;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(leftHead!=<span class="literal">NULL</span>&amp;&amp;rightHead==<span class="literal">NULL</span>){</span><br><span class="line">            leftHead-&gt;left-&gt;right=root; <span class="comment">//更新左链最后一个节点的右指针指向</span></span><br><span class="line">            root-&gt;left=leftHead-&gt;left;</span><br><span class="line">            root-&gt;right=leftHead;</span><br><span class="line">            leftHead-&gt;left=root;</span><br><span class="line">            head=leftHead;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(leftHead==<span class="literal">NULL</span>&amp;&amp;rightHead!=<span class="literal">NULL</span>){</span><br><span class="line">            root-&gt;right=rightHead;</span><br><span class="line">            root-&gt;left=rightHead-&gt;left;</span><br><span class="line">            rightHead-&gt;left-&gt;right=root;</span><br><span class="line">            rightHead-&gt;left=root;</span><br><span class="line">            head=root;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(leftHead==<span class="literal">NULL</span>&amp;&amp;rightHead==<span class="literal">NULL</span>){</span><br><span class="line">            root-&gt;left=root;</span><br><span class="line">            root-&gt;right=root;</span><br><span class="line">            head=root;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1></blockquote>
<h2 id="常规数学"><a href="#常规数学" class="headerlink" title="常规数学"></a>常规数学</h2><h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h3><p><strong>Description</strong><br>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。<br>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。<br>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。<br><strong>Example</strong><br>示例：<br>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> carray = <span class="number">0</span>;</span><br><span class="line">        ListNode* root = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* p = root;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">NULL</span>&amp;&amp;l2 != <span class="literal">NULL</span>){</span><br><span class="line">            p-&gt;val = (l1-&gt;val + l2-&gt;val + carray)%<span class="number">10</span>;</span><br><span class="line">            carray = (l1-&gt;val + l2-&gt;val + carray)/<span class="number">10</span>;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="literal">NULL</span>||l2!=<span class="literal">NULL</span>||carray!=<span class="number">0</span>) p-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span>){</span><br><span class="line">            p-&gt;val = (l1-&gt;val + carray)%<span class="number">10</span>;</span><br><span class="line">            carray = (l1-&gt;val + carray)/<span class="number">10</span>;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="literal">NULL</span>||carray!=<span class="number">0</span>) p-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(l2!=<span class="literal">NULL</span>){</span><br><span class="line">            p-&gt;val = (l2-&gt;val + carray)%<span class="number">10</span>;</span><br><span class="line">            carray = (l2-&gt;val + carray)/<span class="number">10</span>;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2!=<span class="literal">NULL</span>||carray!=<span class="number">0</span>) p-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(carray!=<span class="number">0</span>) p-&gt;val=carray;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7.整数反转"></a>7.整数反转</h3><p><strong>Description</strong><br>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<br><strong>Example</strong><br>示例 1:<br>输入: 123<br>输出: 321<br>示例 2:<br>输入: -123<br>输出: -321<br>示例 3:<br>输入: 120<br>输出: 21<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>){</span><br><span class="line">            result = result*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(result&lt;INT_MIN||result&gt;INT_MAX) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a>8. 字符串转换整数 (atoi)</h3><p><strong>Description</strong><br>请你来实现一个 atoi 函数，使其能将字符串转换成整数。<br>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p>
<ul>
<li>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。</li>
<li>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。</li>
<li>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。<br>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</li>
</ul>
<p>提示：<br>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 $[−2^31,  2^31 − 1]$。如果数值超过这个范围，请返回  INT_MAX $(2^31 − 1)$ 或 INT_MIN $(−2^31)$ 。<br><strong>Example</strong><br>示例 1:<br>输入: “42”<br>输出: 42</p>
<p>示例 2:<br>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p>
<p>示例 3:<br>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p>
<p>示例 4:<br>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。</p>
<p>示例 5:<br>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN $(−2^31)$ 。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">-1</span>, end=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[<span class="number">0</span>]==<span class="string">' '</span>) str.erase(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">//去掉前缀空格</span></span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">0</span>||!(str[<span class="number">0</span>]==<span class="string">'+'</span>||str[<span class="number">0</span>]==<span class="string">'-'</span>||(str[<span class="number">0</span>]&gt;=<span class="string">'0'</span>&amp;&amp;str[<span class="number">0</span>]&lt;=<span class="string">'9'</span>))) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'+'</span>) str.erase(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'-'</span>){flag=<span class="number">-1</span>;str.erase(<span class="number">0</span>, <span class="number">1</span>);}</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[idx]&gt;=<span class="string">'0'</span>&amp;&amp;str[idx]&lt;=<span class="string">'9'</span>){</span><br><span class="line">            <span class="keyword">if</span>(start==<span class="number">-1</span>){</span><br><span class="line">                start=idx;</span><br><span class="line">                end=idx;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                end++;</span><br><span class="line">            }</span><br><span class="line">            idx++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(start==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        str = str.substr(start, end-start+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++){</span><br><span class="line">            ans=ans*<span class="number">10</span>+flag*(str[i]-<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span>(ans&lt;INT_MIN) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            <span class="keyword">if</span>(ans&gt;INT_MAX) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h3><p><strong>Description</strong><br>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br><strong>Example</strong><br>示例 1:<br>输入: 121<br>输出: true<br>示例 2:<br>输入: -121<br>输出: false<br>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br>示例 3:<br>输入: 10<br>输出: false<br>解释: 从右向左读, 为 01 。因此它不是一个回文数。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>){</span><br><span class="line">            str+=(x%<span class="number">10</span>)+<span class="string">'0'</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=str.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">if</span>(str[left]!=str[right]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12. 整数转罗马数字"></a>12. 整数转罗马数字</h3><p><strong>Description</strong><br>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></tbody></table></figure>
<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>
<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li>
<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</li>
</ul>
<p><strong>Example</strong><br>示例 1:<br>输入: 3<br>输出: “III”</p>
<p>示例 2:<br>输入: 4<br>输出: “IV”</p>
<p>示例 3:<br>输入: 9<br>输出: “IX”</p>
<p>示例 4:<br>输入: 58<br>输出: “LVIII”<br>解释: L = 50, V = 5, III = 3.</p>
<p>示例 5:<br>输入: 1994<br>输出: “MCMXCIV”<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>{</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m={</span><br><span class="line">            {<span class="number">1</span>, <span class="string">"I"</span>},</span><br><span class="line">            {<span class="number">4</span>, <span class="string">"IV"</span>},</span><br><span class="line">            {<span class="number">9</span>, <span class="string">"IX"</span>},</span><br><span class="line">            {<span class="number">5</span>, <span class="string">"V"</span>},</span><br><span class="line">            {<span class="number">10</span>, <span class="string">"X"</span>},</span><br><span class="line">            {<span class="number">40</span>, <span class="string">"XL"</span>},</span><br><span class="line">            {<span class="number">90</span>, <span class="string">"XC"</span>},</span><br><span class="line">            {<span class="number">50</span>, <span class="string">"L"</span>},</span><br><span class="line">            {<span class="number">100</span>, <span class="string">"C"</span>},</span><br><span class="line">            {<span class="number">400</span>, <span class="string">"CD"</span>},</span><br><span class="line">            {<span class="number">900</span>, <span class="string">"CM"</span>},</span><br><span class="line">            {<span class="number">500</span>, <span class="string">"D"</span>},</span><br><span class="line">            {<span class="number">1000</span>, <span class="string">"M"</span>}</span><br><span class="line">        };</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec={<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">40</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">400</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">1000</span>};</span><br><span class="line">        sort(vec.begin(), vec.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="built_in">string</span> str=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size();){</span><br><span class="line">            <span class="keyword">if</span>(num&gt;=vec[i]){</span><br><span class="line">                num-=vec[i];</span><br><span class="line">                str+=m[vec[i]];</span><br><span class="line">            }<span class="keyword">else</span> i++;</span><br><span class="line">            <span class="keyword">if</span>(num==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="29-两数相除"><a href="#29-两数相除" class="headerlink" title="29. 两数相除"></a>29. 两数相除</h3><p><strong>Description</strong><br>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。<br>返回被除数 dividend 除以除数 divisor 得到的商。<br>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2<br><strong>Example</strong><br>示例 1:<br>输入: dividend = 10, divisor = 3<br>输出: 3<br>解释: 10/3 = truncate(3.33333..) = truncate(3) = 3</p>
<p>示例 2:<br>输入: dividend = 7, divisor = -3<br>输出: -2<br>解释: 7/-3 = truncate(-2.33333..) = -2</p>
<p>提示：<br>被除数和除数均为 32 位有符号整数。<br>除数不为 0。<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 $[−2^{31},  2^{31} − 1]$。本题中，如果除法结果溢出，则返回 $2^{31} − 1$。<br><strong>Program</strong><br>例如:11/2,题目要求不用乘法、除法和mod运算符，那么只能用加减法，11一直减2太慢<br>11-2-4-…更快，那么需要判断是否越过了11.<br>一般情况a/b:<br>(1)a=INT_MIN且b=-1，越上界，结果应为INT_MAX；<br>(2)记录最终结果符号，如果a，b都转成正数，INT_MIN会越上界，所以都转为负数计算，详见代码<br>当然笔试啥的可能就直接转long了，避免麻烦。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(dividend==INT_MIN&amp;&amp;divisor==<span class="number">-1</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> sign=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>((dividend&gt;<span class="number">0</span>&amp;&amp;divisor&lt;<span class="number">0</span>)||(dividend&lt;<span class="number">0</span>&amp;&amp;divisor&gt;<span class="number">0</span>)) sign=<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//全部用负数表示，防止溢出，比如-INT_MAX如果表示成正数就会溢出</span></span><br><span class="line">        dividend=dividend&gt;<span class="number">0</span>?-dividend:dividend;  </span><br><span class="line">        divisor=divisor&gt;<span class="number">0</span>?-divisor:divisor;</span><br><span class="line">        <span class="keyword">int</span> res=div(dividend, divisor); <span class="comment">//res已经不会溢出上界了，最多刚好为INT_MIN</span></span><br><span class="line">        <span class="keyword">return</span> sign==<span class="number">1</span>?-res:res;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">-1</span>;  <span class="comment">//INT_MIN,-1的话会出现结果为INT_MAX+1溢出，转成负数就不会溢出了</span></span><br><span class="line">        <span class="keyword">int</span> tb=b;</span><br><span class="line">        <span class="keyword">while</span>((<span class="keyword">long</span>)tb+tb&gt;a&amp;&amp;(<span class="keyword">long</span>)tb+tb&lt;<span class="number">0</span>){ <span class="comment">//防止越过下界变成正值</span></span><br><span class="line">            tb+=tb;   <span class="comment">//倍数增长</span></span><br><span class="line">            ans+=ans;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans+div(a-tb, b);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a>50. Pow(x, n)</h3><p><strong>Description</strong><br>实现 $pow(x, n)$ ，即计算 $x$ 的 $n$ 次幂函数。<br><strong>Example</strong><br>示例 1:<br>输入: 2.00000, 10<br>输出: 1024.00000</p>
<p>示例 2:<br>输入: 2.10000, 3<br>输出: 9.26100</p>
<p>示例 3:<br>输入: 2.00000, -2<br>输出: 0.25000<br>解释: 2-2 = 1/22 = 1/4 = 0.25<br>说明:<br>$-100.0 &lt; x &lt; 100.0$<br>$n$ 是 32 位有符号整数，其数值范围是 $[−231, 231 − 1]$ 。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>){x=<span class="number">1</span>/x;n=-n;}</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">double</span> ans=myPow(x, n/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> ans*ans;</span><br><span class="line">        <span class="keyword">return</span> ans*ans*x;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// double myPow(double x, int n){</span></span><br><span class="line">    <span class="comment">//     return dfs(x, n);</span></span><br><span class="line">    <span class="comment">// }</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="223-矩形面积"><a href="#223-矩形面积" class="headerlink" title="223. 矩形面积"></a>223. 矩形面积</h3><p><strong>Description</strong><br>在二维平面上计算出两个由直线构成的矩形重叠后形成的总面积。<br>每个矩形由其左下顶点和右上顶点坐标表示，如图所示。<br><img src="/assets/img/algorithm/rectangle_area.png" alt="image"><br><strong>Example</strong><br>示例:<br>输入: -3, 0, 3, 4, 0, -1, 9, 2<br>输出: 45<br>说明: 假设矩形面积不会超出 int 的范围。<br><strong>Program</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">思路：先对两个矩形按照左下角横坐标排序，较小的在左边，即rectA, rectB</span><br><span class="line">①rectA与rectB不重叠(自己可以在图上画一下)：</span><br><span class="line">- rectA.rightUp_x&lt;=rectB.leftDown_x      //rectA的右边界与rectB的左边界不相交</span><br><span class="line">- rectA.rightUp_y&lt;=rectB.leftDown_y      //rectA的上边界与rectB的下边界不相交</span><br><span class="line">- rectA.leftDown_y&gt;=rectB.rightUp_y      //rectA的下边界与rectB的上边界不相交</span><br><span class="line"></span><br><span class="line">②rectA与rectB重叠，计算重叠矩形rectU坐标：uLx,uLy,uRx,uRy，可以发现以下关系：</span><br><span class="line">- uLx=max(rectA.leftDown_x, rectB.leftDown_x);    //rectU的左边界坐标为rectA与rectB左边界的最小值</span><br><span class="line">- uLy=max(rectA.leftDown_y, rectB.leftDown_y);    //rectU的下边界为rectA与rectB下边界的最小值</span><br><span class="line">- uRx=min(rectA.rightUp_x,rectB.rightUp_x);       //rectU的右边界为rectA与rectB右边界最小值</span><br><span class="line">- uRy=min(rectA.rightUp_y, rectB.rightUp_y);      //rectU的上边界为rectA与rectB上边界的最小值</span><br><span class="line"></span><br><span class="line">③计算最终面积</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Rect</span>{</span></span><br><span class="line">        <span class="keyword">int</span> leftDown_x,leftDown_y;</span><br><span class="line">        <span class="keyword">int</span> rightUp_x, rightUp_y;</span><br><span class="line">        Rect(){}</span><br><span class="line">        Rect(<span class="keyword">int</span> lx, <span class="keyword">int</span> ly, <span class="keyword">int</span> rx, <span class="keyword">int</span> ry):leftDown_x(lx), leftDown_y(ly),rightUp_x(rx),rightUp_y(ry){}</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">calArea</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">return</span> (rightUp_y-leftDown_y) * (rightUp_x-leftDown_x);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">computeArea</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C, <span class="keyword">int</span> D, <span class="keyword">int</span> E, <span class="keyword">int</span> F, <span class="keyword">int</span> G, <span class="keyword">int</span> H)</span> </span>{</span><br><span class="line">        <span class="function">Rect <span class="title">rectA</span><span class="params">(A,B,C,D)</span></span>;</span><br><span class="line">        <span class="function">Rect <span class="title">rectB</span><span class="params">(E,F,G,H)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(rectA.leftDown_x&gt;rectB.leftDown_x) swap(rectA, rectB);</span><br><span class="line">        <span class="keyword">if</span>(rectA.rightUp_x&lt;=rectB.leftDown_x</span><br><span class="line">            ||rectA.rightUp_y&lt;=rectB.leftDown_y</span><br><span class="line">            ||rectA.leftDown_y&gt;=rectB.rightUp_y) <span class="keyword">return</span> rectA.calArea()+rectB.calArea();</span><br><span class="line">        <span class="keyword">int</span> uLx=max(rectA.leftDown_x, rectB.leftDown_x);</span><br><span class="line">        <span class="keyword">int</span> uLy=max(rectA.leftDown_y, rectB.leftDown_y);</span><br><span class="line">        <span class="keyword">int</span> uRx=min(rectA.rightUp_x,rectB.rightUp_x);</span><br><span class="line">        <span class="keyword">int</span> uRy=min(rectA.rightUp_y, rectB.rightUp_y);</span><br><span class="line">        <span class="function">Rect <span class="title">rectU</span><span class="params">(uLx, uLy, uRx, uRy)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> rectA.calArea()+ (rectB.calArea() - rectU.calArea()); <span class="comment">//防止溢出</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="367-有效的完全平方数"><a href="#367-有效的完全平方数" class="headerlink" title="367. 有效的完全平方数"></a>367. 有效的完全平方数</h3><p><strong>Description</strong><br>给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。<br>说明：不要使用任何内置的库函数，如  sqrt。<br><strong>Example</strong><br>示例 1：<br>输入：16<br>输出：True</p>
<p>示例 2：<br>输入：14<br>输出：False<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=num;i++){</span><br><span class="line">            <span class="keyword">if</span>(i*i==num) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i*i&gt;num) <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1093-大样本统计"><a href="#1093-大样本统计" class="headerlink" title="1093. 大样本统计"></a>1093. 大样本统计</h3><p><strong>Description</strong><br>我们对 0 到 255 之间的整数进行采样，并将结果存储在数组 count 中：count[k] 就是整数 k 的采样个数。<br>我们以 浮点数 数组的形式，分别返回样本的最小值、最大值、平均值、中位数和众数。其中，众数是保证唯一的。<br>我们先来回顾一下中位数的知识：<br>如果样本中的元素有序，并且元素数量为奇数时，中位数为最中间的那个元素；<br>如果样本中的元素有序，并且元素数量为偶数时，中位数为中间的两个元素的平均值。<br><strong>Example</strong><br>示例 1：<br>输入：count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]<br>输出：[1.00000,3.00000,2.37500,2.50000,3.00000]</p>
<p>示例 2：<br>输入：count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]<br>输出：[1.00000,4.00000,2.18182,2.00000,1.00000]</p>
<p>提示：<br>count.length == 256<br>1 &lt;= sum(count) &lt;= 10^9<br>计数表示的众数是唯一的<br>答案与真实值误差在 10^-5 以内就会被视为正确答案<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; sampleStats(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; count) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res(<span class="number">5</span>, <span class="number">0.0</span>);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mxCount=<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">0</span>]=(<span class="keyword">double</span>)<span class="number">256</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++){</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(count[i]&gt;<span class="number">0</span>){</span><br><span class="line">                res[<span class="number">0</span>]=min((<span class="keyword">double</span>)i, res[<span class="number">0</span>]);</span><br><span class="line">                res[<span class="number">1</span>]=max((<span class="keyword">double</span>)i, res[<span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            res[<span class="number">2</span>]+=count[i]*i;</span><br><span class="line">            ans+=count[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(count[i]&gt;mxCount){</span><br><span class="line">                res[<span class="number">4</span>]=(<span class="keyword">double</span>)i;</span><br><span class="line">                mxCount=count[i];</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        res[<span class="number">2</span>]/=ans;</span><br><span class="line">        <span class="keyword">if</span>(ans%<span class="number">2</span>==<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">double</span> a=<span class="number">-1.0</span>, b=<span class="number">-1.0</span>;</span><br><span class="line">            <span class="keyword">int</span> nCount=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++){</span><br><span class="line">                nCount+=count[i];</span><br><span class="line">                <span class="keyword">if</span>(nCount==ans/<span class="number">2</span>){</span><br><span class="line">                    a=(<span class="keyword">double</span>)i;</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span>(nCount&gt;ans/<span class="number">2</span>){</span><br><span class="line">                    <span class="keyword">if</span>(a==<span class="number">-1.0</span>) a=b=(<span class="keyword">double</span>) i;</span><br><span class="line">                    <span class="keyword">else</span> b=(<span class="keyword">double</span>)i;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(b!=<span class="number">-1.0</span>) <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            res[<span class="number">3</span>]=(a+b)/<span class="number">2</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            ans=(ans+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> nCount=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++){</span><br><span class="line">                nCount+=count[i];</span><br><span class="line">                <span class="keyword">if</span>(nCount&gt;=ans){</span><br><span class="line">                    res[<span class="number">3</span>]=(<span class="keyword">double</span>)i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }  </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="规划数学"><a href="#规划数学" class="headerlink" title="规划数学"></a>规划数学</h2><h3 id="面试题-16-11-跳水板"><a href="#面试题-16-11-跳水板" class="headerlink" title="面试题 16.11. 跳水板"></a>面试题 16.11. 跳水板</h3><p><strong>Description</strong><br>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。<br>返回的长度需要从小到大排列。<br><strong>Example</strong><br>示例：<br>输入：<br>shorter = 1<br>longer = 2<br>k = 3<br>输出： {3,4,5,6}<br>提示：<br>$0 &lt; shorter &lt;= longer$<br>$0 &lt;= k &lt;= 100000$<br><strong>Program</strong><br><strong>①记忆搜索</strong><br>超时</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">    <span class="keyword">int</span> K;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> sum, <span class="keyword">int</span> k, <span class="keyword">int</span> shorter, <span class="keyword">int</span> longer)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(k==K){</span><br><span class="line">            res.insert(sum);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(st.find(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(sum, k))!=st.end()) <span class="keyword">return</span>;</span><br><span class="line">        st.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(sum,k));</span><br><span class="line">        dfs(sum+shorter, k+<span class="number">1</span>, shorter, longer);</span><br><span class="line">        dfs(sum+longer, k+<span class="number">1</span>,shorter, longer);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; divingBoard(<span class="keyword">int</span> shorter, <span class="keyword">int</span> longer, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> {};</span><br><span class="line">        K=k;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, shorter, longer);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(res.begin(), res.end());</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>②数学</strong><br>题目k的范围限制了不能使用递归。<br>那么如何考虑呢？<br>（1）首先，有$k+1$种组合，每种组合下的长度不相同，证明如下：</p>
<ul>
<li>不失一般性，设i，j分别为短板数目，且$0&lt;=i&lt;j&lt;=k$，长度分别为：</li>
<li>$shorter * i+longer * (k-i), shorter * j+longer * (k-j)$</li>
<li>二者之差：$shorter * i+longer * (k-i)-shorter * j-longer * (k-j)=(longer-shorter) * (j-i)!=0$<br>（2）两个边界，$k==0$和$shorter==longer$可以直接得出答案。<br>（3）一般情况求解，$shorter * i+longer * (k-i), k&gt;=i&gt;=0$，其中$i$递减遍历即可得到长度递增的答案，因为$i$递减的过程中，最终长度相当于每次用一根长板替换一根短板，所以长度在变长！<br>时间复杂度：$O(k)$<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; divingBoard(<span class="keyword">int</span> shorter, <span class="keyword">int</span> longer, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="keyword">if</span>(longer==shorter) <span class="keyword">return</span> {k*shorter};</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(k+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            res[k-i]=shorter*i+longer*(k-i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="模拟数学"><a href="#模拟数学" class="headerlink" title="模拟数学"></a>模拟数学</h2><h3 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a>67. 二进制求和</h3></li>
</ul>
<p><strong>Description</strong><br>给定两个二进制字符串，返回他们的和（用二进制表示）。<br>输入为非空字符串且只包含数字 1 和 0。<br><strong>Example</strong><br>示例 1:<br>输入: a = “11”, b = “1”<br>输出: “100”</p>
<p>示例 2:<br>输入: a = “1010”, b = “1011”<br>输出: “10101”<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> carry_bit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a.length()&lt;b.length()) swap(a, b);</span><br><span class="line">        reverse(a.begin(),a.end());</span><br><span class="line">        reverse(b.begin(),b.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.length();i++){</span><br><span class="line">            <span class="keyword">int</span> tmp=a[i]-<span class="string">'0'</span>+b[i]-<span class="string">'0'</span>+carry_bit;</span><br><span class="line">            a[i]=tmp%<span class="number">2</span>+<span class="string">'0'</span>;</span><br><span class="line">            carry_bit=tmp/<span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> idx=b.length();</span><br><span class="line">        <span class="keyword">while</span>(carry_bit!=<span class="number">0</span>&amp;&amp;idx&lt;a.length()){</span><br><span class="line">            <span class="keyword">int</span> tmp=a[idx]-<span class="string">'0'</span>+carry_bit;</span><br><span class="line">            a[idx]=tmp%<span class="number">2</span>+<span class="string">'0'</span>;</span><br><span class="line">            carry_bit=tmp/<span class="number">2</span>;</span><br><span class="line">            idx++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(carry_bit!=<span class="number">0</span>) a+=carry_bit+<span class="string">'0'</span>;</span><br><span class="line">        reverse(a.begin(),a.end());</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="数学规律"><a href="#数学规律" class="headerlink" title="数学规律"></a>数学规律</h2><h3 id="168-Excel表列名称"><a href="#168-Excel表列名称" class="headerlink" title="168. Excel表列名称"></a>168. Excel表列名称</h3><p><strong>Description</strong><br>给定一个正整数，返回它在 Excel 表中相对应的列名称。<br>例如，</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; A</span><br><span class="line">2 -&gt; B</span><br><span class="line">3 -&gt; C</span><br><span class="line">...</span><br><span class="line">26 -&gt; Z</span><br><span class="line">27 -&gt; AA</span><br><span class="line">28 -&gt; AB</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Example</strong><br>示例 1:<br>输入: 1<br>输出: “A”</p>
<p>示例 2:<br>输入: 28<br>输出: “AB”</p>
<p>示例 3:<br>输入: 701<br>输出: “ZY”<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="built_in">string</span> result;</span><br><span class="line">        <span class="keyword">do</span>{</span><br><span class="line">            n--;</span><br><span class="line">            result+=<span class="string">'A'</span>+n%<span class="number">26</span>;</span><br><span class="line">            n/=<span class="number">26</span>;</span><br><span class="line">        }<span class="keyword">while</span>(n!=<span class="number">0</span>);</span><br><span class="line">        reverse(result.begin(), result.end());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="166-分数到小数"><a href="#166-分数到小数" class="headerlink" title="166. 分数到小数"></a>166. 分数到小数</h3><p><strong>Description</strong><br>给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。<br>如果小数部分为循环小数，则将循环的部分括在括号内。<br><strong>Example</strong><br>示例 1:<br>输入: numerator = 1, denominator = 2<br>输出: “0.5”</p>
<p>示例 2:<br>输入: numerator = 2, denominator = 1<br>输出: “2”</p>
<p>示例 3:<br>输入: numerator = 2, denominator = 3<br>输出: “0.(6)”<br><strong>Program</strong><br><strong>模拟</strong><br>模拟除法，特别要注意-INT_MAX,INT_MAX，与1，-1组合，特判。<br>（1）首先要注意混循环小数，例如2/15=0.1333…,1/6=0.1666…这种非纯循环小数(0.333…,0.1111..)情况；<br>（2）再看看模拟除法过程中何时会出现循环小数，以num表示分子，den表示分母：<br>①如果num&lt;den，当前商为0，num<em>=10；<br>②如果num&gt;=den,当前商为num/den (除了整数部分，商一定为个位数1~9)，num=num%den</em>10;<br>那么循环小数出现的条件就是num重复出现！用Hash记录已出现的num即可。<br>（3）记录小数点的位置以及括号的位置。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>((numerator&gt;<span class="number">0</span>&amp;&amp;denominator&gt;<span class="number">0</span>)||(numerator&lt;<span class="number">0</span>&amp;&amp;denominator&lt;<span class="number">0</span>)) flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>((numerator&gt;<span class="number">0</span>&amp;&amp;denominator&lt;<span class="number">0</span>)||(numerator&lt;<span class="number">0</span>&amp;&amp;denominator&gt;<span class="number">0</span>)) flag=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">long</span> num=<span class="built_in">abs</span>(numerator);</span><br><span class="line">        <span class="keyword">long</span> den=<span class="built_in">abs</span>(denominator);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">if</span>(den==<span class="number">1</span>) <span class="keyword">return</span> to_string(flag*num);</span><br><span class="line">        <span class="keyword">if</span>(num%den==<span class="number">0</span>) <span class="keyword">return</span> to_string(flag*num/den);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> str=<span class="string">""</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; idx;<span class="comment">//记录出现循环分子的位置</span></span><br><span class="line">        idx[num]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dotIdx=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>){ <span class="comment">//模拟除法</span></span><br><span class="line">            str+=to_string(num/den);</span><br><span class="line">            <span class="keyword">if</span>(dotIdx==<span class="number">-1</span>) { <span class="comment">//整数部分位数</span></span><br><span class="line">                dotIdx=str.length();</span><br><span class="line">                i=str.length()<span class="number">-1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(num&gt;den) num=num%den;</span><br><span class="line">            num*=<span class="number">10</span>;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(idx.find(num)!=idx.end()) <span class="keyword">break</span>; <span class="comment">//出现循环数</span></span><br><span class="line">            <span class="keyword">else</span> idx[num]=i;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(num!=<span class="number">0</span>){ <span class="comment">//存在循环小数</span></span><br><span class="line">            str.insert(str.begin()+idx[num], <span class="string">'('</span>);</span><br><span class="line">            str+=<span class="string">')'</span>;</span><br><span class="line">        }</span><br><span class="line">        str.insert(str.begin()+dotIdx, <span class="string">'.'</span>); <span class="comment">//加小数点</span></span><br><span class="line">        <span class="keyword">return</span> flag==<span class="number">1</span>?str:<span class="string">"-"</span>+str;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="171-Excel表列序号"><a href="#171-Excel表列序号" class="headerlink" title="171. Excel表列序号"></a>171. Excel表列序号</h3><p><strong>Description</strong><br>给定一个Excel表格中的列名称，返回其相应的列序号。<br>例如，</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Example</strong><br>示例 1:<br>输入: “A”<br>输出: 1</p>
<p>示例 2:<br>输入: “AB”<br>输出: 28</p>
<p>示例 3:<br>输入: “ZY”<br>输出: 701<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++){</span><br><span class="line">            result=result*<span class="number">26</span>+s[i]-<span class="string">'A'</span>+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172. 阶乘后的零"></a>172. 阶乘后的零</h3><p><strong>Description</strong><br>给定一个整数 n，返回 n! 结果尾数中零的数量。<br><strong>Example</strong><br>示例 1:<br>输入: 3<br>输出: 0<br>解释: 3! = 6, 尾数中没有零。</p>
<p>示例 2:<br>输入: 5<br>输出: 1<br>解释: 5! = 120, 尾数中有 1 个零.<br><strong>Program</strong><br>0的数量与10有关，10与因子2和5有关，2的个数一定比5多。<br>5出现次数为每5个出现一次，每25出现两次，每125出现三次….</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>){</span><br><span class="line">            result+=n/<span class="number">5</span>;</span><br><span class="line">            n/=<span class="number">5</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h3><p><strong>Description</strong><br>编写一个算法来判断一个数是不是“快乐数”。<br>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。<br><strong>Example</strong><br>示例:<br>输入: 19<br>输出: true<br>解释:<br>1^2 + 9^2 = 82<br>8^2 + 2^2 = 68<br>6^2 + 8^2 = 100<br>1^2 + 0^2 + 0^2 = 1<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">int</span> bit =x%<span class="number">10</span>;</span><br><span class="line">            sum+=bit*bit;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> low=n, fast=n;</span><br><span class="line">        <span class="keyword">do</span>{</span><br><span class="line">            low=calSum(low);</span><br><span class="line">            fast=calSum(fast);</span><br><span class="line">            fast=calSum(fast);</span><br><span class="line">        }<span class="keyword">while</span>(fast!=low);</span><br><span class="line">        <span class="keyword">return</span> low == <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="231-2的幂"><a href="#231-2的幂" class="headerlink" title="231. 2的幂"></a>231. 2的幂</h3><p><strong>Description</strong><br>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。<br><strong>Example</strong><br>示例 1:<br>输入: 1<br>输出: true<br>解释: 20 = 1</p>
<p>示例 2:<br>输入: 16<br>输出: true<br>解释: 24 = 16</p>
<p>示例 3:<br>输入: 218<br>输出: false<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmp&lt;=n){</span><br><span class="line">            <span class="keyword">if</span>(tmp==n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            tmp*=<span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (n&gt;<span class="number">0</span> &amp;&amp; (n&amp;(n<span class="number">-1</span>))==<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="258-各位相加"><a href="#258-各位相加" class="headerlink" title="258. 各位相加"></a>258. 各位相加</h3><p><strong>Description</strong><br>给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。<br><strong>Example</strong><br>示例:<br>输入: 38<br>输出: 2<br>解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。<br>进阶:<br>你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？<br><strong>Program</strong><br>（1）令$X=x_{n} * 10^{n-1} + x_{n-1} * 10^{n-2}…+x_1$，则：<br>$$X=x_{n} * (10^{n-1}-1+1) + x_{n-1} * (10^{n-2}-1+1)…+x_1 \\<br>=x_{n} * (10^{n-1}-1) + x_{n-1} * (10^{n-2}-1)…+(x_n+…x_1)$$<br>其中$n&gt;=1$，所以$n-i&gt;1时,10^{n-i} \pmod 9==0$<br>设$Y=(x_n+…x_1)$：</p>
<ul>
<li>当$0&lt;=Y&lt;9$，就是所求答案，$Answer=X \pmod 9=(X-1) \pmod 9$；</li>
<li>当$Y==9$，也是答案，$Answer=(X-1) \pmod 9+1$——因为直接模9为0；</li>
<li>当$Y&gt;9$，也就是$Y$的位数多于一位，那么又回到了原问题$X$，所以还是最终一定会到个位数，即$Answer=(X-1) \pmod 9+1$。<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (num - <span class="number">1</span>) % <span class="number">9</span> + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h2><h3 id="1201-丑数-III"><a href="#1201-丑数-III" class="headerlink" title="1201. 丑数 III"></a>1201. 丑数 III</h3></li>
</ul>
<p><strong>Description</strong><br>请你帮忙设计一个程序，用来找出第 n 个丑数。<br>丑数是可以被 a 或 b 或 c 整除的 正整数。<br><strong>Example</strong><br>示例 1：<br>输入：n = 3, a = 2, b = 3, c = 5<br>输出：4<br>解释：丑数序列为 2, 3, 4, 5, 6, 8, 9, 10… 其中第 3 个是 4。</p>
<p>示例 2：<br>输入：n = 4, a = 2, b = 3, c = 4<br>输出：6<br>解释：丑数序列为 2, 3, 4, 6, 8, 9, 12… 其中第 4 个是 6。</p>
<p>示例 3：<br>输入：n = 5, a = 2, b = 11, c = 13<br>输出：10<br>解释：丑数序列为 2, 4, 6, 8, 10, 11, 12, 13… 其中第 5 个是 10。</p>
<p>示例 4：<br>输入：n = 1000000000, a = 2, b = 217983653, c = 336916467<br>输出：1999999984</p>
<p>提示：<br>1 &lt;= n, a, b, c &lt;= 10^9<br>1 &lt;= a * b * c &lt;= 10^18<br>本题结果在 [1, 2 * 10^9] 的范围内<br><strong>Program</strong><br>1，对于一个数，有多少个丑数小于等于该数是可以快速计算出来的<br>2，因此可以用二分搜索定位该数</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> y==<span class="number">0</span>?x:gcd(y,x%y);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">cal</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> a*(b/gcd(a,b));</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> ab=cal(a,b);</span><br><span class="line">        <span class="keyword">long</span> ac=cal(a,c);</span><br><span class="line">        <span class="keyword">long</span> bc=cal(b,c);</span><br><span class="line">        <span class="keyword">long</span> abc=cal(ab,c);</span><br><span class="line">        <span class="keyword">int</span> l=min(a,min(b,c));</span><br><span class="line">        <span class="keyword">int</span> r=<span class="number">2e9</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r){</span><br><span class="line">            <span class="keyword">int</span> mid=l+(r-l)/<span class="number">2</span>; <span class="comment">//mid不一定是最后结果！比如n=1,a=b=2,3/2=2/2=1但2才是结果而不是3</span></span><br><span class="line">            <span class="keyword">int</span> count=mid/a+mid/b+mid/c-mid/ab-mid/ac-mid/bc+mid/abc; <span class="comment">//容斥原理</span></span><br><span class="line">            <span class="keyword">if</span>(count&lt;n) l=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r=mid; <span class="comment">//mid有可能是最后结果，所以r=mid，之后会进一步逼近到正确结果</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="素数筛选"><a href="#素数筛选" class="headerlink" title="素数筛选"></a>素数筛选</h2><h3 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a>204. 计数质数</h3><p><strong>Description</strong><br>统计所有小于非负整数 n 的质数的数量。<br><strong>Example</strong><br>示例:<br>输入: 10<br>输出: 4<br>解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; bMarked;</span><br><span class="line">        bMarked.resize(n);</span><br><span class="line">        prime.resize(n);</span><br><span class="line">        fill(bMarked.begin(), bMarked.end(), <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(!bMarked[i]){</span><br><span class="line">                bMarked[i]=<span class="literal">true</span>;</span><br><span class="line">                prime[count++]=i;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;count&amp;&amp;i*prime[j]&lt;n;j++){</span><br><span class="line">                bMarked[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="有限状态自动机"><a href="#有限状态自动机" class="headerlink" title="有限状态自动机"></a>有限状态自动机</h1></blockquote>
<h2 id="确定性有限状态自动机"><a href="#确定性有限状态自动机" class="headerlink" title="确定性有限状态自动机"></a>确定性有限状态自动机</h2><h3 id="65-有效数字"><a href="#65-有效数字" class="headerlink" title="65. 有效数字"></a>65. 有效数字</h3><p><strong>Description</strong><br>验证给定的字符串是否可以解释为十进制数字。<br><strong>Example</strong><br>例如:<br>“0” =&gt; true<br>“ 0.1 “ =&gt; true<br>“abc” =&gt; false<br>“1 a” =&gt; false<br>“2e10” =&gt; true<br>“ -90e3   “ =&gt; true<br>“ 1e” =&gt; false<br>“e3” =&gt; false<br>“ 6e-1” =&gt; true<br>“ 99e2.5 “ =&gt; false<br>“53.5e93” =&gt; true<br>“ –6 “ =&gt; false<br>“-+3” =&gt; false<br>“95a54e53” =&gt; false</p>
<p>说明: 我们有意将问题陈述地比较模糊。在实现代码之前，你应当事先思考所有可能的情况。这里给出一份可能存在于有效十进制数字中的字符列表：</p>
<p>数字 0-9<br>指数 - “e”<br>正/负号 - “+”/“-“<br>小数点 - “.”<br>当然，在输入中，这些字符的上下文也很重要。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;&gt; states;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; legalStates;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line">        states.resize(<span class="number">9</span>);</span><br><span class="line">        states[<span class="number">0</span>][<span class="string">' '</span>]=<span class="number">0</span>; states[<span class="number">0</span>][<span class="string">'d'</span>]=<span class="number">2</span>;states[<span class="number">0</span>][<span class="string">'s'</span>]=<span class="number">1</span>;states[<span class="number">0</span>][<span class="string">'.'</span>]=<span class="number">8</span>;</span><br><span class="line">        states[<span class="number">1</span>][<span class="string">'.'</span>]=<span class="number">8</span>;states[<span class="number">1</span>][<span class="string">'d'</span>]=<span class="number">2</span>;</span><br><span class="line">        states[<span class="number">2</span>][<span class="string">'d'</span>]=<span class="number">2</span>;states[<span class="number">2</span>][<span class="string">'.'</span>]=<span class="number">3</span>;states[<span class="number">2</span>][<span class="string">'e'</span>]=<span class="number">4</span>;states[<span class="number">2</span>][<span class="string">' '</span>]=<span class="number">7</span>;</span><br><span class="line">        states[<span class="number">3</span>][<span class="string">'d'</span>]=<span class="number">3</span>;states[<span class="number">3</span>][<span class="string">'e'</span>]=<span class="number">4</span>;states[<span class="number">3</span>][<span class="string">' '</span>]=<span class="number">7</span>;</span><br><span class="line">        states[<span class="number">4</span>][<span class="string">'s'</span>]=<span class="number">5</span>;states[<span class="number">4</span>][<span class="string">'d'</span>]=<span class="number">6</span>;</span><br><span class="line">        states[<span class="number">5</span>][<span class="string">'d'</span>]=<span class="number">6</span>;</span><br><span class="line">        states[<span class="number">6</span>][<span class="string">'d'</span>]=<span class="number">6</span>;states[<span class="number">6</span>][<span class="string">' '</span>]=<span class="number">7</span>;</span><br><span class="line">        states[<span class="number">7</span>][<span class="string">' '</span>]=<span class="number">7</span>;</span><br><span class="line">        states[<span class="number">8</span>][<span class="string">'d'</span>]=<span class="number">3</span>;</span><br><span class="line">        legalStates.insert(<span class="number">2</span>);</span><br><span class="line">        legalStates.insert(<span class="number">3</span>);</span><br><span class="line">        legalStates.insert(<span class="number">6</span>);</span><br><span class="line">        legalStates.insert(<span class="number">7</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">0</span>; <span class="comment">//当前状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:s){</span><br><span class="line">            <span class="keyword">if</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>) ch=<span class="string">'d'</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">'+'</span>||ch==<span class="string">'-'</span>) ch=<span class="string">'s'</span>;</span><br><span class="line">            <span class="comment">// else ch=ch; //空格、dot、e以及其他非法字符</span></span><br><span class="line">            <span class="keyword">if</span>(states[p].find(ch)==states[p].end()) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//出现非法字符</span></span><br><span class="line">            p = states[p][ch];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> (legalStates.find(p)!=legalStates.end());</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1></blockquote>
<h2 id="经典滑窗"><a href="#经典滑窗" class="headerlink" title="经典滑窗"></a>经典滑窗</h2><h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h3><p><strong>Description</strong><br>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。<br><strong>Example</strong><br>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<p>示例 2:<br>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
<p>示例 3:<br>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。<br><strong>Program</strong><br><strong>滑动窗口</strong><br>设s,e分别为不重复子串的起止位置，可以发现如果str[s:e]为无重复子串，那么[s+1,e]也为无重复子串！<br>遍历s从头到尾：<br>（1）剔除前一个位置的字符；<br>（2）以s为开头，只要满足无重复就不断后移e；</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; vis;</span><br><span class="line">        <span class="keyword">int</span> e=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>){</span><br><span class="line">                vis.erase(s[i<span class="number">-1</span>]);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span>(e+<span class="number">1</span>&lt;n&amp;&amp;vis.find(s[e+<span class="number">1</span>])==vis.end()){</span><br><span class="line">                vis.insert(s[e+<span class="number">1</span>]);</span><br><span class="line">                e++;</span><br><span class="line">            }</span><br><span class="line">            ans=(ans&gt;vis.size())?ans:vis.size();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h3><p><strong>Description</strong><br>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。<br><strong>Example</strong><br>示例：<br>输入：s = 7, nums = [2,3,1,2,4,3]<br>输出：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p>
<p>进阶：<br>如果你已经完成了$O(n)$时间复杂度的解法, 请尝试$O(n log n)$时间复杂度的解法。<br><strong>Program</strong><br><strong>滑窗</strong><br>时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> e=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> tmpSum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> vis[n];</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(vis[i<span class="number">-1</span>]){</span><br><span class="line">                    vis[i<span class="number">-1</span>]=<span class="literal">false</span>;</span><br><span class="line">                    tmpSum-=nums[i<span class="number">-1</span>];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span>(e+<span class="number">1</span>&lt;n&amp;&amp;tmpSum&lt;s){</span><br><span class="line">                tmpSum+=nums[e+<span class="number">1</span>];</span><br><span class="line">                vis[e+<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">                e++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(tmpSum&gt;=s) ans=min(ans, e-i+<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans==INT_MAX?<span class="number">0</span>:ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="424-替换后的最长重复字符"><a href="#424-替换后的最长重复字符" class="headerlink" title="424. 替换后的最长重复字符"></a>424. 替换后的最长重复字符</h3><p><strong>Description</strong><br>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。<br>注意:<br>字符串长度 和 k 不会超过 104。<br><strong>Example</strong><br>示例 1:<br>输入:<br>s = “ABAB”, k = 2<br>输出:<br>4<br>解释:<br>用两个’A’替换为两个’B’,反之亦然。</p>
<p>示例 2:<br>输入:<br>s = “AABABBA”, k = 1<br>输出:<br>4</p>
<p>解释:<br>将中间的一个’A’替换为’B’,字符串变为 “AABBBBA”。<br>子串 “BBBB” 有最长重复字母, 答案为 4。<br><strong>Program</strong><br><strong>滑动窗口</strong><br>这题与’1004 最大连续1的个数 III’类似，不同的是1004题知道所求连续1个数，而这里未知，可以是任意字符组成的最大长度。<br>问题的关键<strong>仿佛</strong>在于是哪个字符组成了最大长度？！<br>然而，这么想的话不好分析，可以是任意字符。<br>那么一个简单的想法就是记录<strong>当前窗口中字符出现个数的最大值maxCount</strong>：<br>（1）如果maxCount+k小于窗口长度则继续在增长窗口，窗口右终点右移;<br>（2）否则，窗口缩减，窗口左起点右移；<br>这里的思想还是滑动窗口的思想，即窗口[s,e]满足条件，那么[s+1…,e]肯定也是满足条件的窗口，最后结果取过程中窗口长度最大值即可。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">int</span> e=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxCount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m[<span class="number">26</span>];</span><br><span class="line">        <span class="built_in">memset</span>(m, <span class="number">0</span>, <span class="keyword">sizeof</span>(m));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>){</span><br><span class="line">                m[s[i<span class="number">-1</span>]-<span class="string">'A'</span>]--; <span class="comment">//前一个字符出窗口，计数减1</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span>(e+<span class="number">1</span>&lt;n&amp;&amp;max(maxCount,m[s[e+<span class="number">1</span>]-<span class="string">'A'</span>]+<span class="number">1</span>)+k&gt;=e+<span class="number">1</span>-i+<span class="number">1</span>){ <span class="comment">//尝试增长窗口</span></span><br><span class="line">                m[s[e+<span class="number">1</span>]-<span class="string">'A'</span>]++;</span><br><span class="line">                maxCount=max(maxCount, m[s[e+<span class="number">1</span>]-<span class="string">'A'</span>]); <span class="comment">//记录当前窗口字符最大值</span></span><br><span class="line">                e++;</span><br><span class="line">            }</span><br><span class="line">            ans=max(ans, e-i+<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a>567. 字符串的排列</h3><p><strong>Description</strong><br>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。<br>换句话说，第一个字符串的排列之一是第二个字符串的子串。<br><strong>Example</strong><br>示例1:<br>输入: s1 = “ab” s2 = “eidbaooo”<br>输出: True<br>解释: s2 包含 s1 的排列之一 (“ba”).</p>
<p>示例2:<br>输入: s1= “ab” s2 = “eidboaoo”<br>输出: False</p>
<p>注意：<br>输入的字符串只包含小写字母<br>两个字符串的长度都在 [1, 10,000] 之间<br><strong>Program</strong><br><strong>滑动窗口</strong><br>很明显滑动窗口题，关键在于如何在s1长度窗口内匹配所有s1的字母，先上滑窗模板：<br>（1）窗口起始i前一个位置i-1如果有s1的字母出现，m[s2[i-1]]++，同时由于窗口后移一位，窗口长度k++；<br>（2）while中滑动窗口计算，如果发现s1的字母出现m[s2[e+1]]–，不过这里会<strong>有问题：可能窗口内匹配的某种字母比s1对应字母的个数要多！</strong><br>（3）为解决这个问题，需要确定s1长度窗口内对应每种s1的字母个数m[ch]==0，说明完全匹配，否则并不匹配。<br>时间复杂度：$O(kn)$——for为n复杂度，而while在整个for过程最多移动n长度，复杂度n，而判断完全匹配为k=26，其中n为s2长度，k为s1最多包含不同字母数。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(s1.length()&gt;s2.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> k=s1.length();</span><br><span class="line">        <span class="keyword">int</span> n=s2.length();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:s1) m[ch]++;</span><br><span class="line">        <span class="keyword">int</span> e=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(m.find(s2[i<span class="number">-1</span>])!=m.end()){</span><br><span class="line">                    m[s2[i<span class="number">-1</span>]]++;</span><br><span class="line">                }</span><br><span class="line">                k++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span>(e+<span class="number">1</span>&lt;n&amp;&amp;k&gt;<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(m.find(s2[e+<span class="number">1</span>])!=m.end()){</span><br><span class="line">                    m[s2[e+<span class="number">1</span>]]--;</span><br><span class="line">                }</span><br><span class="line">                k--;</span><br><span class="line">                e++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">bool</span> isFull=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; p:m){</span><br><span class="line">                    <span class="keyword">if</span>(p.second!=<span class="number">0</span>){isFull=<span class="literal">false</span>;}</span><br><span class="line">                }  </span><br><span class="line">                <span class="keyword">if</span>(isFull) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }  </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="992-K-个不同整数的子数组-1"><a href="#992-K-个不同整数的子数组-1" class="headerlink" title="992. K 个不同整数的子数组"></a>992. K 个不同整数的子数组</h3><p><strong>Description</strong><br>给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。<br>（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。）<br>返回 A 中好子数组的数目。<br><strong>Example</strong><br>示例 1：<br>输入：A = [1,2,1,2,3], K = 2<br>输出：7<br>解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].</p>
<p>示例 2：<br>输入：A = [1,2,1,3,4], K = 3<br>输出：3<br>解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].</p>
<p>提示：<br>1 &lt;= A.length &lt;= 20000<br>1 &lt;= A[i] &lt;= A.length<br>1 &lt;= K &lt;= A.length<br><strong>Program</strong><br><strong>滑窗</strong><br>错误代码<br>样例一就有问题[1,2,1,2]中的{2,1,2}无法识别orz。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; mst;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> end=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(mst.count(A[i<span class="number">-1</span>])==<span class="number">1</span>){</span><br><span class="line">                    st.erase(A[i<span class="number">-1</span>]);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">//mst.erase(A[i-1]); //这里删除所有A[i-1]值了！错误！</span></span><br><span class="line">                mst.erase(mst.find(A[i<span class="number">-1</span>])); <span class="comment">//这样才对</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(st.size()==K) ans++;</span><br><span class="line">            <span class="keyword">while</span>(end+<span class="number">1</span>&lt;n&amp;&amp;(st.size()&lt;K||mst.count(A[end+<span class="number">1</span>])&gt;=<span class="number">1</span>)){</span><br><span class="line">                mst.insert(A[end+<span class="number">1</span>]);</span><br><span class="line">                st.insert(A[end+<span class="number">1</span>]);</span><br><span class="line">                end++;</span><br><span class="line">                <span class="keyword">if</span>(st.size()==K) ans++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>详见官方题解<br>K个不同整数的子数组个数=最多包含K种不同整数的子数组个数-最多包含K-1种不同整数的子数组个数，妙啊！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> atMostKDistinct(A, K) - atMostKDistinct(A, K<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">atMostKDistinct</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(K==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; freq(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>; <span class="comment">//不同数的个数</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(freq[A[i<span class="number">-1</span>]]==<span class="number">1</span>) cnt--;</span><br><span class="line">                freq[A[i<span class="number">-1</span>]]--;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span>(end+<span class="number">1</span>&lt;n&amp;&amp;(cnt&lt;K||freq[A[end+<span class="number">1</span>]]&gt;<span class="number">0</span>)){ <span class="comment">//cnt==K时，后者还可以继续递增end</span></span><br><span class="line">                end++;</span><br><span class="line">                <span class="keyword">if</span>(freq[A[end]]==<span class="number">0</span>) cnt++;</span><br><span class="line">                freq[A[end]]++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//精髓，[i, end]区间, 例如[1,2,1,2],有[1],[1,2],[1,2,1,],[1,2,1,2]四个区间，</span></span><br><span class="line">            <span class="comment">//那么[2,1,2]咋办，这个会在下一次以2为起点的时候进行计算！</span></span><br><span class="line">            <span class="comment">//类似这种计算技巧遇到好几次了，orz，记录一波，下次遇到好整理，好菜啊</span></span><br><span class="line">            ans+=end-i+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1004-最大连续1的个数-III"><a href="#1004-最大连续1的个数-III" class="headerlink" title="1004. 最大连续1的个数 III"></a>1004. 最大连续1的个数 III</h3><p><strong>Description</strong><br>给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。<br>返回仅包含 1 的最长（连续）子数组的长度。<br><strong>Example</strong><br>示例 1：<br>输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2<br>输出：6<br>解释：<br>[1,1,1,0,0,1,1,1,1,1,1]<br>粗体数字从 0 翻转到 1，最长的子数组长度为 6。</p>
<p>示例 2：<br>输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3<br>输出：10<br>解释：<br>[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]<br>粗体数字从 0 翻转到 1，最长的子数组长度为 10。</p>
<p>提示：<br>1 &lt;= A.length &lt;= 20000<br>0 &lt;= K &lt;= A.length<br>A[i] 为 0 或 1<br><strong>Program</strong><br><strong>滑动窗口</strong><br>双指针，l，r表示当前满足条件的子数组头尾下标，如果[l,r]为满足题意的子数组，则[l+1,r]也为满足题意的子数组，不同的是应当尽可能翻转所有K个0使得子数组长尽可能大。<br>（1）移动左指针l，如果上个位置l-1为0则，K++，可翻转0数增加1；<br>（2）每个l不动，移动r，若后续为1或者K&gt;0，不断移动r;<br>（3）更新每个[l,r]的最大长度。<br>时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="keyword">int</span> r=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;n;l++){</span><br><span class="line">            <span class="keyword">if</span>(l&gt;<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(A[l<span class="number">-1</span>]==<span class="number">0</span>) K++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span>(r+<span class="number">1</span>&lt;n&amp;&amp;(A[r+<span class="number">1</span>]==<span class="number">1</span>||K&gt;<span class="number">0</span>)){</span><br><span class="line">                <span class="keyword">if</span>(A[r+<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;K&gt;<span class="number">0</span>) K--;</span><br><span class="line">                r+=<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//cout&lt;&lt;l&lt;&lt;" "&lt;&lt;r-l+1&lt;&lt;endl;</span></span><br><span class="line">            ans=max(ans, r-l+<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1052-爱生气的书店老板"><a href="#1052-爱生气的书店老板" class="headerlink" title="1052. 爱生气的书店老板"></a>1052. 爱生气的书店老板</h3><p><strong>Description</strong><br>今天，书店老板有一家店打算试营业 customers.length 分钟。每分钟都有一些顾客（customers[i]）会进入书店，所有这些顾客都会在那一分钟结束后离开。<br>在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。<br>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 X 分钟不生气，但却只能使用一次。<br>请你返回这一天营业下来，最多有多少客户能够感到满意的数量。<br><strong>Example</strong><br>示例：<br>输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3<br>输出：16<br>解释：<br>书店老板在最后 3 分钟保持冷静。<br>感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16.</p>
<p>提示：<br>1 &lt;= X &lt;= customers.length == grumpy.length &lt;= 20000<br>0 &lt;= customers[i] &lt;= 1000<br>0 &lt;= grumpy[i] &lt;= 1<br><strong>Program</strong><br><strong>思路</strong><br>题目求一整天最大顾客满意数。<br>其中老板不生气的时候肯定都是满意的，关键就是在连续X分钟内能够使得其中老板生气时间下顾客最多就是最终答案。<br>典型就是求X窗口内顾客满意数的最大值！（注意需要的是对应分钟内老板在生气！你TM真傲娇！）</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSatisfied</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; customers, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; grumpy, <span class="keyword">int</span> X)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=customers.size();</span><br><span class="line">        <span class="keyword">int</span> e=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxWindow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmpWindow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(grumpy[i<span class="number">-1</span>]==<span class="number">1</span>) tmpWindow-=customers[i<span class="number">-1</span>]; <span class="comment">//移出窗口</span></span><br><span class="line">                X++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(grumpy[i]==<span class="number">0</span>) ans+=customers[i];</span><br><span class="line">            <span class="keyword">while</span>(e+<span class="number">1</span>&lt;n&amp;&amp;X&gt;<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(grumpy[e+<span class="number">1</span>]==<span class="number">1</span>) tmpWindow+=customers[e+<span class="number">1</span>]; <span class="comment">//老板生气分钟</span></span><br><span class="line">                maxWindow=max(maxWindow, tmpWindow);</span><br><span class="line">                X--;</span><br><span class="line">                e++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans+maxWindow;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1208-尽可能使字符串相等"><a href="#1208-尽可能使字符串相等" class="headerlink" title="1208. 尽可能使字符串相等"></a>1208. 尽可能使字符串相等</h3><p><strong>Description</strong><br>给你两个长度相同的字符串，s 和 t。<br>将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。<br>用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。<br>如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。<br>如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。<br><strong>Example</strong><br>示例 1：<br>输入：s = “abcd”, t = “bcdf”, cost = 3<br>输出：3<br>解释：s 中的 “abc” 可以变为 “bcd”。开销为 3，所以最大长度为 3。</p>
<p>示例 2：<br>输入：s = “abcd”, t = “cdef”, cost = 3<br>输出：1<br>解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。</p>
<p>示例 3：<br>输入：s = “abcd”, t = “acde”, cost = 0<br>输出：1<br>解释：你无法作出任何改动，所以最大长度为 1。</p>
<p>提示：<br>1 &lt;= s.length, t.length &lt;= 10^5<br>0 &lt;= maxCost &lt;= 10^6<br>s 和 t 都只含小写英文字母。<br><strong>Program</strong><br>滑动窗口套路，注意细节。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">equalSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t, <span class="keyword">int</span> maxCost)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">int</span> e=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis(n, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(vis[i<span class="number">-1</span>]) maxCost+=<span class="built_in">abs</span>(s[i<span class="number">-1</span>]-t[i<span class="number">-1</span>]);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(e&lt;i<span class="number">-1</span>) e=i<span class="number">-1</span>; <span class="comment">//避免窗口不移动</span></span><br><span class="line">            <span class="keyword">while</span>(e+<span class="number">1</span>&lt;n&amp;&amp;<span class="built_in">abs</span>(s[e+<span class="number">1</span>]-t[e+<span class="number">1</span>])&lt;=maxCost){</span><br><span class="line">                maxCost-=<span class="built_in">abs</span>(s[e+<span class="number">1</span>]-t[e+<span class="number">1</span>]);</span><br><span class="line">                vis[e+<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">                e++;</span><br><span class="line">            }</span><br><span class="line">            ans=max(ans, e-i+<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1234-替换子串得到平衡字符串"><a href="#1234-替换子串得到平衡字符串" class="headerlink" title="1234. 替换子串得到平衡字符串"></a>1234. 替换子串得到平衡字符串</h3><p><strong>Description</strong><br>有一个只含有 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符，且长度为 n 的字符串。<br>假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。<br>给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。<br>你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。<br>请返回待替换子串的最小可能长度。<br>如果原字符串自身就是一个平衡字符串，则返回 0。<br><strong>Example</strong><br>示例 1：<br>输入：s = “QWER”<br>输出：0<br>解释：s 已经是平衡的了。</p>
<p>示例 2：<br>输入：s = “QQWE”<br>输出：1<br>解释：我们需要把一个 ‘Q’ 替换成 ‘R’，这样得到的 “RQWE” (或 “QRWE”) 是平衡的。</p>
<p>示例 3：<br>输入：s = “QQQW”<br>输出：2<br>解释：我们可以把前面的 “QQ” 替换成 “ER”。</p>
<p>示例 4：<br>输入：s = “QQQQ”<br>输出：3<br>解释：我们可以替换后 3 个 ‘Q’，使 s = “QWER”。</p>
<p>提示：<br>$1 &lt;= s.length &lt;= 10^5$<br>s.length 是 4 的倍数<br>s 中只含有 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符<br><strong>Program</strong><br><strong>滑动窗口</strong><br>（1）题目要求替换一个子串得到满足条件的字符串，可以考虑滑动窗口；<br>（2）窗口外的所有字符必须满足个数小于等于n/4即可，上模板！<br>注意更新ans的时候需要判断是否窗口外满足条件；</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">balancedString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">int</span> k=n/<span class="number">4</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:s) m[ch]++; <span class="comment">//统计[left, right]外的区间字符个数</span></span><br><span class="line">        <span class="keyword">int</span> ans=n;</span><br><span class="line">        <span class="keyword">int</span> end=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>) m[s[i<span class="number">-1</span>]]++;</span><br><span class="line">            <span class="keyword">while</span>(end+<span class="number">1</span>&lt;n&amp;&amp;(m[<span class="string">'Q'</span>]&gt;k||m[<span class="string">'W'</span>]&gt;k||m[<span class="string">'E'</span>]&gt;k||m[<span class="string">'R'</span>]&gt;k)){ <span class="comment">//区间外字符个数不满足要求，则扩大窗口</span></span><br><span class="line">                m[s[end+<span class="number">1</span>]]--;</span><br><span class="line">                end++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(m[<span class="string">'Q'</span>]&lt;=k&amp;&amp;m[<span class="string">'W'</span>]&lt;=k&amp;&amp;m[<span class="string">'E'</span>]&lt;=k&amp;&amp;m[<span class="string">'R'</span>]&lt;=k) ans=min(ans, end-i+<span class="number">1</span>); <span class="comment">//窗口外的所有字符满足要求，则更新结果</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1456-定长子串中元音的最大数目"><a href="#1456-定长子串中元音的最大数目" class="headerlink" title="1456. 定长子串中元音的最大数目"></a>1456. 定长子串中元音的最大数目</h3><p><strong>Description</strong><br>给你字符串 s 和整数 k 。<br>请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。<br>英文中的 元音字母 为（a, e, i, o, u）。<br><strong>Example</strong><br>示例 1：<br>输入：s = “abciiidef”, k = 3<br>输出：3<br>解释：子字符串 “iii” 包含 3 个元音字母。</p>
<p>示例 2：<br>输入：s = “aeiou”, k = 2<br>输出：2<br>解释：任意长度为 2 的子字符串都包含 2 个元音字母。</p>
<p>示例 3：<br>输入：s = “leetcode”, k = 3<br>输出：2<br>解释：”lee”、”eet” 和 “ode” 都包含 2 个元音字母。</p>
<p>示例 4：<br>输入：s = “rhythms”, k = 4<br>输出：0<br>解释：字符串 s 中不含任何元音字母。</p>
<p>示例 5：<br>输入：s = “tryhard”, k = 4<br>输出：1</p>
<p>提示：<br>1 &lt;= s.length &lt;= 10^5<br>s 由小写英文字母组成<br>1 &lt;= k &lt;= s.length<br><strong>Program</strong><br><strong>滑动窗口</strong><br>典型滑动窗口题，这里需要将所有元音字母统一计数。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span> STR=<span class="string">"aeiou"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxVowels</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> nCount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> e=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(STR.find(s[i<span class="number">-1</span>])!=<span class="built_in">string</span>::npos){</span><br><span class="line">                    nCount--;</span><br><span class="line">                }</span><br><span class="line">                k++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span>(e+<span class="number">1</span>&lt;n&amp;&amp;k&gt;<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(STR.find(s[e+<span class="number">1</span>])!=<span class="built_in">string</span>::npos) nCount++;</span><br><span class="line">                ans=max(ans, nCount);</span><br><span class="line">                k--;</span><br><span class="line">                e++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1658-将-x-减到-0-的最小操作数"><a href="#1658-将-x-减到-0-的最小操作数" class="headerlink" title="1658. 将 x 减到 0 的最小操作数"></a>1658. 将 x 减到 0 的最小操作数</h3><p><strong>Description</strong><br>给你一个整数数组 nums 和一个整数 x 。每一次操作时，你应当移除数组 nums 最左边或最右边的元素，然后从 x 中减去该元素的值。请注意，需要 修改 数组以供接下来的操作使用。<br>如果可以将 x 恰好 减到 0 ，返回 最小操作数 ；否则，返回 -1 。<br><strong>Example</strong><br>示例 1：<br>输入：nums = [1,1,4,2,3], x = 5<br>输出：2<br>解释：最佳解决方案是移除后两个元素，将 x 减到 0 。</p>
<p>示例 2：<br>输入：nums = [5,6,7,8,9], x = 4<br>输出：-1</p>
<p>示例 3：<br>输入：nums = [3,2,20,1,1,3], x = 10<br>输出：5<br>解释：最佳解决方案是移除后三个元素和前两个元素（总共 5 次操作），将 x 减到 0 。</p>
<p>提示：<br>$1 &lt;= nums.length &lt;= 10^5$<br>$1 &lt;= nums[i] &lt;= 10^4$<br>$1 &lt;= x &lt;= 10^9$<br><strong>Program</strong><br><strong>哈希表</strong><br>（1）题目要找的就是[j, i]范围内和为k=sum-x的i-j+1值最大的区间！，sum为数组总和；<br>（2）滑窗为常规做法，这里采用哈希表；<br>（3）题目preSum[i]-preSum[j]=k，也就是preSum[j]=preSum[i]-k，对于每个preSum[i]找满足该条件的j(j&lt;i)，完全就是区间个数的求法！详见代码；<br>时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preSum(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            preSum[i] = preSum[i<span class="number">-1</span>] + nums[i<span class="number">-1</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(preSum[n]==x) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = preSum[n] - x;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++){</span><br><span class="line">            <span class="keyword">if</span>(m.find(preSum[i] - k) != m.end()){</span><br><span class="line">                res = max(res, i - m[preSum[i] - k]);</span><br><span class="line">            }</span><br><span class="line">            m[preSum[i]] = i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res==<span class="number">-1</span>?res:n-res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a>剑指 Offer 48. 最长不含重复字符的子字符串</h3><p><strong>Description</strong><br>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。<br><strong>Example</strong><br>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<p>示例 2:<br>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
<p>示例 3:<br>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<p>提示：<br>s.length &lt;= 40000<br><strong>Program</strong><br>[s:e]为无重复子串，那么[s+1…:e]即s以后都为无重复子串，所以无需重复，移动窗口剔除前面出去的字符，判断后续字母能否继续增长即可。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> e=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>) st.erase(s[i<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">while</span>(e+<span class="number">1</span>&lt;n&amp;&amp;st.find(s[e+<span class="number">1</span>])==st.end()) {st.insert(s[e+<span class="number">1</span>]);e++;}</span><br><span class="line">            ans=ans&gt;st.size()?ans:st.size();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>



<h2 id="技巧滑窗"><a href="#技巧滑窗" class="headerlink" title="技巧滑窗"></a>技巧滑窗</h2><h3 id="239-滑动窗口最大值-1"><a href="#239-滑动窗口最大值-1" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h3><p><strong>Description</strong><br>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回滑动窗口中的最大值。<br>进阶：<br>你能在线性时间复杂度内解决此题吗？<br><strong>Example</strong><br>示例:<br>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></tbody></table></figure>

<p>提示：<br>1 &lt;= nums.length &lt;= 10^5<br>-10^4 &lt;= nums[i] &lt;= 10^4<br>1 &lt;= k &lt;= nums.length<br><strong>Program</strong><br><strong>滑动窗口</strong><br>一个很自然的思路就是维护一个保有索引的优先队列，然而时间复杂度为$O(n\log{k})$<br>线性复杂度的做法：<br>维护一个双端队列window：<br>（1）变量的最前端（也就是 window.front()）是此次遍历的最大值的下标<br>（2）当我们遇到新的数时，将新的数和双项队列的末尾（也就是window.back()）比较，如果末尾比新数小，则把末尾扔掉，直到该队列的末尾比新数大或者队列为空的时候才停止。<br>（3）双项队列中的所有值都要在窗口范围内<br><strong>特点1：队列头尾当前最大元素下标</strong><br>特点2：队列降序排列，最大值、次大值…下标<br>例如</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,3,1,2,0,5]</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure>
<p>[[1,3,1],2,0,5]，队列3,1<br>[1,[3,1,2],0,5]，队列3,2<br>[1,3,[1,2,0],5]，剔除3，新进0，队列2,0<br>[1,3,1,[2,0,5]]，队列5</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++){</span><br><span class="line">            <span class="keyword">while</span>(!dq.empty()&amp;&amp;nums[dq.back()]&lt;nums[i]){</span><br><span class="line">                dq.pop_back();</span><br><span class="line">            }</span><br><span class="line">            dq.push_back(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        res.push_back(nums[dq[<span class="number">0</span>]]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(dq[<span class="number">0</span>]&lt;=i-k) dq.pop_front();</span><br><span class="line">            <span class="keyword">while</span>(!dq.empty()&amp;&amp;nums[dq.back()]&lt;nums[i]){</span><br><span class="line">                dq.pop_back();</span><br><span class="line">            }</span><br><span class="line">            dq.push_back(i);</span><br><span class="line">            res.push_back(nums[dq[<span class="number">0</span>]]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>传统思路</strong><br>超时</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> idx;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> i, <span class="keyword">int</span> n):idx(i),num(n){}</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; node)<span class="keyword">const</span>{</span><br><span class="line">            <span class="keyword">return</span> num&lt;node.num;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) {</span><br><span class="line">        priority_queue&lt;Node&gt; pq;</span><br><span class="line">        <span class="built_in">deque</span>&lt;Node&gt; dq;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++){</span><br><span class="line">            dq.push_back(Node(i, nums[i]));</span><br><span class="line">            pq.push(Node(i, nums[i]));</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        res.push_back(pq.top().num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;n;i++){</span><br><span class="line">            dq.pop_front();</span><br><span class="line">            dq.push_back(Node(i, nums[i]));</span><br><span class="line">            priority_queue&lt;Node&gt; pq(dq.begin(), dq.end());</span><br><span class="line">            res.push_back(pq.top().num);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1033-移动石子直到连续"><a href="#1033-移动石子直到连续" class="headerlink" title="1033. 移动石子直到连续"></a>1033. 移动石子直到连续</h3><p><strong>Description</strong><br>三枚石子放置在数轴上，位置分别为 a，b，c。<br>每一回合，我们假设这三枚石子当前分别位于位置 x, y, z 且 $x &lt; y &lt; z$。从位置 x 或者是位置 z 拿起一枚石子，并将该石子移动到某一整数位置 k 处，其中 $x &lt; k &lt; z$ 且 k != y。<br>当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。<br>要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves]<br><strong>Example</strong><br>示例 1：<br>输入：a = 1, b = 2, c = 5<br>输出：[1, 2]<br>解释：将石子从 5 移动到 4 再移动到 3，或者我们可以直接将石子移动到 3。</p>
<p>示例 2：<br>输入：a = 4, b = 3, c = 2<br>输出：[0, 0]<br>解释：我们无法进行任何移动。</p>
<p>提示：<br>1 &lt;= a &lt;= 100<br>1 &lt;= b &lt;= 100<br>1 &lt;= c &lt;= 100<br>a != b, b != c, c != a<br><strong>Program</strong><br>假设a,b,c升序<br>最大步数为a,c一步步走到与b紧靠<br>最小步数：<br>（1）三者紧靠，0；<br>（2）其中有一对紧靠，1；<br>（3）三者之间两两各间隔一位，1；//直接插空到位<br>（4）三者之间两两间隔大于1，2；//a,c之间各一步移动到b紧靠</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numMovesStones(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) {</span><br><span class="line">        <span class="keyword">int</span> num[<span class="number">3</span>]={a, b, c};</span><br><span class="line">        sort(num, num+<span class="number">3</span>);</span><br><span class="line">        a=num[<span class="number">0</span>],b=num[<span class="number">1</span>],c=num[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> max_moves=c-a<span class="number">-2</span>;<span class="comment">//最值之差-2即可，一步一步走到三者紧靠</span></span><br><span class="line">        <span class="keyword">int</span> min_moves=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(c-a==<span class="number">2</span>) min_moves=<span class="number">0</span>; <span class="comment">//三者紧靠，无法移动</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b-a==<span class="number">1</span>||c-b==<span class="number">1</span>||b-a==<span class="number">2</span>||c-b==<span class="number">2</span>) min_moves=<span class="number">1</span>; <span class="comment">//其中两个紧靠或者相隔一位，一步到位</span></span><br><span class="line">        <span class="keyword">else</span> min_moves=<span class="number">2</span>; <span class="comment">//两两中间间隔大于1，最多两步到位</span></span><br><span class="line">        <span class="keyword">return</span> {min_moves, max_moves};</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1438-绝对差不超过限制的最长连续子数组-1"><a href="#1438-绝对差不超过限制的最长连续子数组-1" class="headerlink" title="1438. 绝对差不超过限制的最长连续子数组"></a>1438. 绝对差不超过限制的最长连续子数组</h3><p><strong>Description</strong><br>给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。<br>如果不存在满足条件的子数组，则返回 0 。<br><strong>Example</strong><br>示例 1：<br>输入：nums = [8,2,4,7], limit = 4<br>输出：2<br>解释：所有子数组如下：<br>[8] 最大绝对差 |8-8| = 0 &lt;= 4.<br>[8,2] 最大绝对差 |8-2| = 6 &gt; 4.<br>[8,2,4] 最大绝对差 |8-2| = 6 &gt; 4.<br>[8,2,4,7] 最大绝对差 |8-2| = 6 &gt; 4.<br>[2] 最大绝对差 |2-2| = 0 &lt;= 4.<br>[2,4] 最大绝对差 |2-4| = 2 &lt;= 4.<br>[2,4,7] 最大绝对差 |2-7| = 5 &gt; 4.<br>[4] 最大绝对差 |4-4| = 0 &lt;= 4.<br>[4,7] 最大绝对差 |4-7| = 3 &lt;= 4.<br>[7] 最大绝对差 |7-7| = 0 &lt;= 4.<br>因此，满足题意的最长子数组的长度为 2 。</p>
<p>示例 2：<br>输入：nums = [10,1,2,4,7,2], limit = 5<br>输出：4<br>解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| = 5 &lt;= 5 。</p>
<p>示例 3：<br>输入：nums = [4,2,2,2,4,4,2,2], limit = 0<br>输出：3</p>
<p>提示：<br>1 &lt;= nums.length &lt;= 10^5<br>1 &lt;= nums[i] &lt;= 10^9<br>0 &lt;= limit &lt;= 10^9<br><strong>Program</strong><br>滑动窗口最大值变型题，所不同的是需要维护两个双端队列，分别保存窗口最大值和最小值（其实是窗口最值排序）</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; miDq, mxDq; <span class="comment">//记录窗口最小最大值</span></span><br><span class="line">        <span class="keyword">int</span> e=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(!mxDq.empty()&amp;&amp;mxDq[<span class="number">0</span>]==i<span class="number">-1</span>) mxDq.pop_front();</span><br><span class="line">                <span class="keyword">if</span>(!miDq.empty()&amp;&amp;miDq[<span class="number">0</span>]==i<span class="number">-1</span>) miDq.pop_front();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//miDq非空，则mxDq必非空</span></span><br><span class="line">            <span class="keyword">while</span>(e+<span class="number">1</span>&lt;n&amp;&amp;(miDq.empty()||(!miDq.empty()&amp;&amp;<span class="built_in">abs</span>(nums[miDq[<span class="number">0</span>]]-nums[e+<span class="number">1</span>])&lt;=limit&amp;&amp;<span class="built_in">abs</span>(nums[mxDq[<span class="number">0</span>]]-nums[e+<span class="number">1</span>])&lt;=limit))){</span><br><span class="line">                <span class="keyword">while</span>(!miDq.empty()&amp;&amp;nums[miDq.back()]&gt;nums[e+<span class="number">1</span>]){</span><br><span class="line">                    miDq.pop_back();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">while</span>(!mxDq.empty()&amp;&amp;nums[mxDq.back()]&lt;nums[e+<span class="number">1</span>]){</span><br><span class="line">                    mxDq.pop_back();</span><br><span class="line">                }</span><br><span class="line">                miDq.push_back(e+<span class="number">1</span>);</span><br><span class="line">                mxDq.push_back(e+<span class="number">1</span>);</span><br><span class="line">                e++;</span><br><span class="line">            }</span><br><span class="line">            ans=max(ans, e-i+<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1040-移动石子直到连续-II"><a href="#1040-移动石子直到连续-II" class="headerlink" title="1040. 移动石子直到连续 II"></a>1040. 移动石子直到连续 II</h3><p><strong>Description</strong><br>在一个长度无限的数轴上，第 i 颗石子的位置为 stones[i]。如果一颗石子的位置最小/最大，那么该石子被称作端点石子。<br>每个回合，你可以将一颗端点石子拿起并移动到一个未占用的位置，使得该石子不再是一颗端点石子。<br>值得注意的是，如果石子像 stones = [1,2,5] 这样，你将无法移动位于位置 5 的端点石子，因为无论将它移动到任何位置（例如 0 或 3），该石子都仍然会是端点石子。<br>当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。<br>要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves] 。<br><strong>Example</strong><br>示例 1：<br>输入：[7,4,9]<br>输出：[1,2]<br>解释：<br>我们可以移动一次，4 -&gt; 8，游戏结束。<br>或者，我们可以移动两次 9 -&gt; 5，4 -&gt; 6，游戏结束。</p>
<p>示例 2：<br>输入：[6,5,4,3,10]<br>输出：[2,3]<br>解释：<br>我们可以移动 3 -&gt; 8，接着是 10 -&gt; 7，游戏结束。<br>或者，我们可以移动 3 -&gt; 7, 4 -&gt; 8, 5 -&gt; 9，游戏结束。<br>注意，我们无法进行 10 -&gt; 2 这样的移动来结束游戏，因为这是不合要求的移动。</p>
<p>示例 3：<br>输入：[100,101,104,102,103]<br>输出：[0,0]</p>
<p>提示：<br>3 &lt;= stones.length &lt;= 10^4<br>1 &lt;= stones[i] &lt;= 10^9<br>stones[i] 的值各不相同。<br><strong>Program</strong><br><strong>解题思路：</strong><br>题目是上一题的扩展，但是有点不同。<br>由题意可知，每进行一轮操作，石子的左右端点的距离会缩短，一轮一轮收敛。最后会石子都紧邻游戏结束。<br>举个例子：<br>初始时有 8 颗石子，在数轴上的有石子的刻度为：<br>4，6，8，9，15，16，19，20<br><strong>最大值求解方法：</strong><br>石子可以放置的空间，等于左右两端石子之间的未占用位置。在例子中，一共有 20-4+1-8 个位置。<br>石子覆盖的线段长度是 20-4 个，加上一个端点的位置即 20-4+1，再减去已经占用的 8 个位置。<br>用公式表示为：<br>$s1=stones[n-1]-stones[0]+1-n$<br>但是第一次移动的左端点或右端点的石子后，这个移动的石子和它相邻的那颗石子之间的空间，后面就不能被放置了，因为与他相邻的那个点变为端点，他们之间的位置不可以被放置了。<br>例如第一步移动了 4，那么 5 这个位置就不可能放置石子了。所以要计算不能被访问的空间<br>$s2=min(stones[n-1]-stones[n-2]-1, stones[1]-stones[0] -1)$<br>最大值为 s1-s2。<strong>因为在后面的步骤里，我们都可以做出策略，让每一轮左右端点的差值只减1。</strong></p>
<p><strong>最小值求解方法：</strong><br>如果最后游戏结束，那么一定有 n 个连续坐标摆满了石子。如果我们要移动最少，必定要找一个石子序列，使得在 n 大小连续的坐标内，初始时有最多的石子。<br>设想有个尺子，上面有 n 个刻度点，我们用这个尺子在石子从最左边到最右边移动，每动一次都查看下在尺子范围内有 m 个石子，那么要使这个区间填满，就需要移动 n-m 次。<br>只要在尺子外部有石子，就有策略填满尺子内的。<br>这些次数中最小的就为虽少次数。<br>但是有一种特例：<br>1，2，3，4，7<br>这种 1-4 是最好的序列，但是 7 不能移动到端点，只能 1 先移动到 6，然后 7 移动到 5 解决，这种情况要用 2 步。就是尺子内的石子都是连续的，中间没空洞，只在边上有空，要用 2 次。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numMovesStonesII(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones) {</span><br><span class="line">        sort(stones.begin(), stones.end());</span><br><span class="line">        <span class="keyword">int</span> n=stones.size();</span><br><span class="line">        <span class="keyword">int</span> mx=stones[n<span class="number">-1</span>]-stones[<span class="number">0</span>]+<span class="number">1</span>-n</span><br><span class="line">                -min(stones[n<span class="number">-1</span>]-stones[n<span class="number">-2</span>]<span class="number">-1</span>, stones[<span class="number">1</span>]-stones[<span class="number">0</span>]<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> mi=n;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">while</span>(j+<span class="number">1</span>&lt;n&amp;&amp;stones[j+<span class="number">1</span>]-stones[i]+<span class="number">1</span>&lt;=n) j++; <span class="comment">//滑动窗口[i,j]个数小于等于n，则[i+1...,j]的个数肯定也小于等于n</span></span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">cos</span>=n-(j-i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(j-i+<span class="number">1</span>==n<span class="number">-1</span>&amp;&amp;stones[j]-stones[i]+<span class="number">1</span>==n<span class="number">-1</span>)</span><br><span class="line">               <span class="built_in">cos</span>=<span class="number">2</span>;</span><br><span class="line">            mi=min(mi, <span class="built_in">cos</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> {mi, mx};</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1498-满足条件的子序列数目"><a href="#1498-满足条件的子序列数目" class="headerlink" title="1498. 满足条件的子序列数目"></a>1498. 满足条件的子序列数目</h3><p><strong>Description</strong><br>给你一个整数数组 nums 和一个整数 target 。<br>请你统计并返回 nums 中能满足其最小元素与最大元素的 和 小于或等于 target 的 非空 子序列的数目。<br>由于答案可能很大，请将结果对 10^9 + 7 取余后返回。<br><strong>Example</strong><br>示例 1：<br>输入：nums = [3,5,6,7], target = 9<br>输出：4<br>解释：有 4 个子序列满足该条件。<br>[3] -&gt; 最小元素 + 最大元素 &lt;= target (3 + 3 &lt;= 9)<br>[3,5] -&gt; (3 + 5 &lt;= 9)<br>[3,5,6] -&gt; (3 + 6 &lt;= 9)<br>[3,6] -&gt; (3 + 6 &lt;= 9)</p>
<p>示例 2：<br>输入：nums = [3,3,6,8], target = 10<br>输出：6<br>解释：有 6 个子序列满足该条件。（nums 中可以有重复数字）<br>[3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]</p>
<p>示例 3：<br>输入：nums = [2,3,3,4,6,7], target = 12<br>输出：61<br>解释：共有 63 个非空子序列，其中 2 个不满足条件（[6,7], [7]）<br>有效序列总数为（63 - 2 = 61）</p>
<p>示例 4：<br>输入：nums = [5,2,4,1,7,6,8], target = 16<br>输出：127<br>解释：所有非空子序列都满足条件 (2^7 - 1) = 127</p>
<p>提示：<br>1 &lt;= nums.length &lt;= 10^5<br>1 &lt;= nums[i] &lt;= 10^6<br>1 &lt;= target &lt;= 10^6<br><strong>Program</strong><br><strong>思路</strong><br>题目要求满足题意的子序列，即子集。<br>刚开始想通过双端队列，发现不满足滑窗条件，且无法求子集。<br>看了题目提示后，修改如下，计算2的幂次的时候记得用快速幂，否则还是超时:<br>（1）排序，如果过大可以忽略后面的数；<br>（2）滑动窗口找出以i为起点，e为终点的满足条件的<strong>最大序列</strong>，那么该窗口满足条件的子序列数目为：<br>$2^{e-i}=1+2^{0}+2^{1]+…+2^{e-i-1}$，<br>其中每一项表示以最小值的下标i为起点，到最大值下标j的子序列数目，其中$j=i,…,e$<br>即以[i,j]为满足题意的序列，且以nums[i],nums[j]为最小最大值，那么有$2^{j-i-1}$种可能结果（如果i==j，则为1）。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calCount</span><span class="params">(<span class="keyword">int</span> n)</span></span>{ <span class="comment">//快速幂</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> ans=calCount(n/<span class="number">2</span>)%MOD;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> (ans*ans)%MOD;</span><br><span class="line">        <span class="keyword">return</span> ((ans*ans)%MOD*<span class="number">2</span>)%MOD;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        sort(nums.begin(), nums.end()); <span class="comment">//排序，子序列也就是子集，</span></span><br><span class="line">        <span class="keyword">if</span>(nums[n<span class="number">-1</span>]+nums[n<span class="number">-1</span>]&lt;=target) <span class="keyword">return</span> calCount(n)<span class="number">-1</span>; <span class="comment">//数组最大值满足条件，则整个数组都满足条件</span></span><br><span class="line">        <span class="keyword">int</span> e=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[i]&gt;target) <span class="keyword">break</span>;<span class="comment">//以i为起点的窗口，nums[i]为窗口最小值，如果最小值*2都比target大，肯定不用继续了</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;=e&amp;&amp;nums[i]+nums[e]&gt;target) e--; <span class="comment">//窗口右边界缩减，因为新的最小值为nums[i]</span></span><br><span class="line">            <span class="keyword">while</span>(e+<span class="number">1</span>&lt;n&amp;&amp;nums[i]+nums[e+<span class="number">1</span>]&lt;=target){ <span class="comment">//寻找满足条件的窗口最大右边界</span></span><br><span class="line">                e++;</span><br><span class="line">            }</span><br><span class="line">            ans=((<span class="keyword">long</span>)ans+calCount(e-i))%MOD;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="剑指-Offer-59-II-队列的最大值-1"><a href="#剑指-Offer-59-II-队列的最大值-1" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a>剑指 Offer 59 - II. 队列的最大值</h3><p><strong>Description</strong><br>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。<br>若队列为空，pop_front 和 max_value 需要返回 -1<br><strong>Example</strong><br>示例 1：<br>输入:<br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]<br>输出: [null,null,null,2,1,2]</p>
<p>示例 2：<br>输入:<br>[“MaxQueue”,”pop_front”,”max_value”]<br>[[],[],[]]<br>输出: [null,-1,-1]</p>
<p>限制：<br>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000<br>1 &lt;= value &lt;= 10^5<br><strong>Program</strong><br>双端队列保留队列最大值，思路与滑动窗口最大值相同。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">    MaxQueue() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(q.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dq[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        q.push(value);</span><br><span class="line">        <span class="keyword">while</span>(!dq.empty()&amp;&amp;dq.back()&lt;value) dq.pop_back(); <span class="comment">//双端队列保存队列最大值</span></span><br><span class="line">        dq.push_back(value);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(q.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(q.front()==dq[<span class="number">0</span>]) dq.pop_front();</span><br><span class="line">        <span class="keyword">int</span> res=q.front();q.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxQueue* obj = new MaxQueue();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;max_value();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push_back(value);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="面试题-17-18-最短超串"><a href="#面试题-17-18-最短超串" class="headerlink" title="面试题 17.18. 最短超串"></a>面试题 17.18. 最短超串</h3><p><strong>Description</strong><br>假设你有两个数组，一个长一个短，短的元素均不相同。找到长数组中包含短数组所有的元素的最短子数组，其出现顺序无关紧要。<br>返回最短子数组的左端点和右端点，如有多个满足条件的子数组，返回左端点最小的一个。若不存在，返回空数组。<br><strong>Example</strong><br>示例 1:<br>输入:<br>big = [7,5,9,0,2,1,3,5,7,9,1,1,5,8,8,9,7]<br>small = [1,5,9]<br>输出: [7,10]</p>
<p>示例 2:<br>输入:<br>big = [1,2,3]<br>small = [4]<br>输出: []<br>提示：<br>big.length &lt;= 100000<br>1 &lt;= small.length &lt;= 100000<br><strong>Program</strong><br><strong>滑动窗口</strong><br>最近一直在写滑窗题，基本思路清楚，这里有点想歪了，纠结窗口怎么取了，后面看了人家的题解的一句话恍然大悟：<strong>窗口包含了small的所有元素就停止扩大窗口！</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; shortestSeq(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; big, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; small) {</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>&amp; x:small) m[x]=<span class="number">1</span>; <span class="comment">//记录small元素</span></span><br><span class="line">        <span class="keyword">int</span> n=big.size();</span><br><span class="line">        <span class="keyword">int</span> k=small.size();</span><br><span class="line">        <span class="keyword">int</span> e=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> nCount=k; <span class="comment">//记录剩余没被窗口包含的small元素个数</span></span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> minLen=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(m.find(big[i<span class="number">-1</span>])!=m.end()){</span><br><span class="line">                    m[big[i<span class="number">-1</span>]]++;</span><br><span class="line">                    <span class="keyword">if</span>(m[big[i<span class="number">-1</span>]]==<span class="number">1</span>) nCount++; <span class="comment">//只有small对应的元素为1使，nCount才自增，表示再也没有一个small对应的元素在窗口内</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span>(e+<span class="number">1</span>&lt;n&amp;&amp;nCount&gt;<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(m.find(big[e+<span class="number">1</span>])!=m.end()) {</span><br><span class="line">                    m[big[e+<span class="number">1</span>]]--;</span><br><span class="line">                    <span class="keyword">if</span>(m[big[e+<span class="number">1</span>]]==<span class="number">0</span>) nCount--; <span class="comment">//只要small对应的元素有一个在窗口内就自减，表示元素在窗口内了，注意只记录一次！</span></span><br><span class="line">                }</span><br><span class="line">                e++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(nCount==<span class="number">0</span>&amp;&amp;e-i+<span class="number">1</span>&lt;minLen){ <span class="comment">//nCount表示small的所有元素都包含在窗口内了</span></span><br><span class="line">                minLen=e-i+<span class="number">1</span>;</span><br><span class="line">                res.first=i;</span><br><span class="line">                res.second=e;</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(minLen==INT_MAX) <span class="keyword">return</span> {}; <span class="comment">//没有找到答案</span></span><br><span class="line">        <span class="keyword">return</span> {res.first, res.second};</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1></blockquote>
<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h2><p><strong>Description</strong><br>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br><strong>Example</strong><br>示例:<br>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode* firstNode=head;</span><br><span class="line">        ListNode* secondNode=head-&gt;next;</span><br><span class="line"></span><br><span class="line">        firstNode-&gt;next=swapPairs(secondNode-&gt;next);</span><br><span class="line">        secondNode-&gt;next=firstNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> secondNode;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a>61. 旋转链表</h2><p><strong>Description</strong><br>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。<br><strong>Example</strong><br>示例 1:<br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>解释:<br>向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p>
<p>示例 2:<br>输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4<br>输出: 2-&gt;0-&gt;1-&gt;NULL<br>解释:<br>向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL<br>向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL<br>向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL<br>向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>){</span><br><span class="line">            n++;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        k%=n;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> head; <span class="comment">//无需旋转</span></span><br><span class="line">        ListNode* dummyHead=<span class="keyword">new</span> ListNode(<span class="number">-1</span>); <span class="comment">//伪头结点</span></span><br><span class="line">        dummyHead-&gt;next=head;</span><br><span class="line">        ListNode* p1=dummyHead, *p2=head; <span class="comment">//双指针</span></span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p2-&gt;next!=<span class="literal">NULL</span>){</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(cnt&lt;k) cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt==k) p1=p1-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        p2-&gt;next=dummyHead-&gt;next;</span><br><span class="line">        dummyHead-&gt;next=p1-&gt;next;</span><br><span class="line">        p1-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a>82. 删除排序链表中的重复元素 II</h2><p><strong>Description</strong><br>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。<br><strong>Example</strong><br>示例 1:<br>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>输出: 1-&gt;2-&gt;5</p>
<p>示例 2:<br>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3<br>输出: 2-&gt;3<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* dummyhead=<span class="keyword">new</span> ListNode(INT_MIN);</span><br><span class="line">        dummyhead-&gt;next=head;</span><br><span class="line">        ListNode* pre=dummyhead;</span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;next!=<span class="literal">NULL</span>){</span><br><span class="line">            ListNode* cur=pre-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next==<span class="literal">NULL</span>||cur-&gt;next-&gt;val!=cur-&gt;val) pre=cur;</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">NULL</span>&amp;&amp;cur-&gt;next-&gt;val==cur-&gt;val) cur=cur-&gt;next; <span class="comment">//找到相同元素的最后一个节点</span></span><br><span class="line">                pre-&gt;next=cur-&gt;next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dummyhead-&gt;next;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a>86. 分隔链表</h2><p><strong>Description</strong><br>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。<br>你应当保留两个分区中每个节点的初始相对位置。<br><strong>Example</strong><br>示例:<br>输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* dummyHead1=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* dummyHead2=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* d1=dummyHead1, *d2=dummyHead2;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>){</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val&lt;x){</span><br><span class="line">                d1-&gt;next=p;</span><br><span class="line">                d1=d1-&gt;next;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">                d1-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                d2-&gt;next=p;</span><br><span class="line">                d2=d2-&gt;next;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">                d2-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">            }    </span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        d1-&gt;next=dummyHead2-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummyHead1-&gt;next;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a>92. 反转链表 II</h2><p><strong>Description</strong><br>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。<br>说明:<br>1 ≤ m ≤ n ≤ 链表长度。<br><strong>Example</strong><br>示例:<br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br>输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(m==n) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dummyHead=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        dummyHead-&gt;next=head;</span><br><span class="line">        ListNode* cur=head;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">        ListNode* tail=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* pre=dummyHead;</span><br><span class="line">        ListNode* curPre=<span class="literal">NULL</span>;</span><br><span class="line">        ListNode* curNext=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(cnt&lt;=n){</span><br><span class="line">            <span class="keyword">if</span>(cnt==m<span class="number">-1</span>) pre=cur;</span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;=m&amp;&amp;cnt&lt;=n){</span><br><span class="line">                <span class="keyword">if</span>(cnt==m) tail-&gt;next=cur;</span><br><span class="line">                curNext=cur-&gt;next;</span><br><span class="line">                cur-&gt;next=curPre;</span><br><span class="line">                curPre=cur;</span><br><span class="line">                <span class="keyword">if</span>(cnt&lt;n) cur=curNext;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">if</span>(cnt&lt;n) cur=cur-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            cnt++;</span><br><span class="line">        }</span><br><span class="line">        pre-&gt;next=cur;</span><br><span class="line">        tail-&gt;next-&gt;next=curNext;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h2><p><strong>Description</strong><br>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。<br>说明：不允许修改给定的链表。<br><strong>Example</strong><br>示例 1：<br>输入：head = [3,2,0,-4], pos = 1<br>输出：tail connects to node index 1<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
<p>示例 2：<br>输入：head = [1,2], pos = 0<br>输出：tail connects to node index 0<br>解释：链表中有一个环，其尾部连接到第一个节点。</p>
<p>示例 3：<br>输入：head = [1], pos = -1<br>输出：no cycle<br>解释：链表中没有环。</p>
<p>进阶：<br>你是否可以不用额外空间解决此题？<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;ListNode*&gt; st;</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>{</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>){</span><br><span class="line">            <span class="keyword">if</span>(st.find(p)==st.end()) st.insert(p);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> p;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//fast走了f=2s步，slow走了s步，而第一次相遇f=s+nb，所以s=nb</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>{ <span class="comment">//链表分成两部分，进环前a个节点，环有b个节点</span></span><br><span class="line">        ListNode *fast=head, *slow=head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">NULL</span>||fast-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            fast=fast-&gt;next-&gt;next; <span class="comment">//fast步幅为2</span></span><br><span class="line">            slow=slow-&gt;next;  <span class="comment">//slow步幅为1</span></span><br><span class="line">            <span class="keyword">if</span>(slow==fast) <span class="keyword">break</span>; <span class="comment">//第一次相遇，slow走了nb步</span></span><br><span class="line">        }</span><br><span class="line">        fast=head;</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast){ <span class="comment">//为了得到入环第一个节点，那么需要再走a步即可，通过fast重置为head，fast和slow步幅都为1，再走a步就得到了答案，即slow与fast第二次相遇时即到达入环第一个节点</span></span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a>143. 重排链表</h2><p><strong>Description</strong><br>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br><strong>Example</strong><br>示例 1:<br>给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</p>
<p>示例 2:<br>给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        ListNode *fast=head, *slow=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>){ <span class="comment">//快指针到达末尾时，slow刚好位于链表中点</span></span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        ListNode* q=reverseList(slow-&gt;next);</span><br><span class="line">        slow-&gt;next=<span class="literal">NULL</span>; <span class="comment">//断链</span></span><br><span class="line">        ListNode* dummyHead=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* cur=dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;q!=<span class="literal">NULL</span>){</span><br><span class="line">            cur-&gt;next=p;p=p-&gt;next;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=q;q=q-&gt;next;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>){</span><br><span class="line">            cur-&gt;next=p;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(q!=<span class="literal">NULL</span>){</span><br><span class="line">            cur-&gt;next=q;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* root)</span></span>{</span><br><span class="line">        ListNode* pre=<span class="literal">NULL</span>;</span><br><span class="line">        ListNode* p=root;</span><br><span class="line">        ListNode* ne;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>){</span><br><span class="line">            ne=p-&gt;next;</span><br><span class="line">            p-&gt;next=pre;</span><br><span class="line">            pre=p;</span><br><span class="line">            p=ne;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a>234. 回文链表</h2><p><strong>Description</strong><br>请判断一个链表是否为回文链表。<br><strong>Example</strong><br>示例 1:<br>输入: 1-&gt;2<br>输出: false</p>
<p>示例 2:<br>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true<br>进阶：<br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>){</span><br><span class="line">            vec.push_back(p-&gt;val);</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=vec.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">if</span>(vec[left]!=vec[right]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237. 删除链表中的节点"></a>237. 删除链表中的节点</h2><p><strong>Description</strong><br>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。<br>现有一个链表 – head = [4,5,1,9]，它可以表示为:<br><img src="/assets/img/algorithm/237_example.png" alt="image"><br>示例 1:<br>输入: head = [4,5,1,9], node = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p>
<p>示例 2:<br>输入: head = [4,5,1,9], node = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p>
<p>说明:<br>链表至少包含两个节点。<br>链表中所有节点的值都是唯一的。<br>给定的节点为非末尾节点并且一定是链表中的一个有效节点。<br>不要从你的函数中返回任何结果。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>{</span><br><span class="line">        node-&gt;val=node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next=node-&gt;next-&gt;next;<span class="comment">//跳过下一个节点</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a>328. 奇偶链表</h2><p><strong>Description</strong><br>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。<br>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。<br><strong>Example</strong><br>示例 1:<br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</p>
<p>示例 2:<br>输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL<br>输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL<br>说明:<br>应当保持奇数节点和偶数节点的相对顺序。<br>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode* oddDummyHead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* evenDummyHead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        ListNode* op=oddDummyHead;</span><br><span class="line">        ListNode* ep=evenDummyHead;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>){</span><br><span class="line">            <span class="keyword">if</span>(ans%<span class="number">2</span>==<span class="number">1</span>){</span><br><span class="line">                op-&gt;next=p;</span><br><span class="line">                op=op-&gt;next;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                ep-&gt;next=p;</span><br><span class="line">                ep=ep-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            ans++;</span><br><span class="line">        }</span><br><span class="line">        ep-&gt;next=<span class="literal">NULL</span>; <span class="comment">//断尾</span></span><br><span class="line">        op-&gt;next=evenDummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> oddDummyHead-&gt;next;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="430-扁平化多级双向链表"><a href="#430-扁平化多级双向链表" class="headerlink" title="430. 扁平化多级双向链表"></a>430. 扁平化多级双向链表</h2><p><strong>Description</strong><br>多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。<br>给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。<br><strong>Example</strong><br>示例 1：<br>输入：head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]<br>输出：[1,2,3,7,8,11,12,9,10,4,5,6]<br>解释：<br>输入的多级列表如下图所示：<br><img src="/assets/img/algorithm/multilevellinkedlist.png" alt="image"><br>扁平化后的链表如下图：<br><img src="/assets/img/algorithm/multilevellinkedlistflattened.png" alt="image"><br>示例 2：<br>输入：head = [1,2,null,3]<br>输出：[1,3,2]<br>解释：</p>
<p>输入的多级列表如下图所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1---2---NULL</span><br><span class="line">|</span><br><span class="line">3---NULL</span><br></pre></td></tr></tbody></table></figure>
<p>示例 3：</p>
<p>输入：head = []<br>输出：[]</p>
<p>如何表示测试用例中的多级链表？</p>
<p>以 示例 1 为例：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1---2---3---4---5---6--NULL</span><br><span class="line">        |</span><br><span class="line">        7---8---9---10--NULL</span><br><span class="line">            |</span><br><span class="line">            11--12--NULL</span><br></pre></td></tr></tbody></table></figure>
<p>序列化其中的每一级之后：</p>
<p>[1,2,3,4,5,6,null]<br>[7,8,9,10,null]<br>[11,12,null]<br>为了将每一级都序列化到一起，我们需要每一级中添加值为 null 的元素，以表示没有节点连接到上一级的上级节点。</p>
<p>[1,2,3,4,5,6,null]<br>[null,null,7,8,9,10,null]<br>[null,11,12,null]<br>合并所有序列化结果，并去除末尾的 null 。<br>[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]</p>
<p>提示：<br>节点数目不超过 1000<br>1 &lt;= Node.val &lt;= 10^5<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* prev;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* child;</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">dfs</span><span class="params">(Node* pre, Node* p)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="keyword">return</span> pre; <span class="comment">//遍历完子链表需要返回最后一个节点值，方便与父链表进行链接</span></span><br><span class="line">        pre-&gt;next=p;</span><br><span class="line">        Node* tail;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;child!=<span class="literal">NULL</span>){  </span><br><span class="line">            Node* q=p-&gt;next; <span class="comment">//注意保留p的后一个节点，因为dfs会将p-&gt;next指向p-&gt;child</span></span><br><span class="line">            tail=dfs(pre-&gt;next, p-&gt;child); <span class="comment">//遍历子链表</span></span><br><span class="line">            tail=dfs(tail, q); <span class="comment">//遍历本链表后续节点</span></span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            tail=dfs(pre-&gt;next, p-&gt;next); <span class="comment">//只需遍历本链表后续节点</span></span><br><span class="line">        }</span><br><span class="line">        p-&gt;prev=pre;</span><br><span class="line">        pre=pre-&gt;next;</span><br><span class="line">        pre-&gt;child=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> tail; <span class="comment">//遍历完本链表，不需要返回节点</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        Node* dummyHead=<span class="keyword">new</span> Node();</span><br><span class="line">        dummyHead-&gt;val=<span class="number">-1</span>;dummyHead-&gt;prev=dummyHead-&gt;next=dummyHead-&gt;child=<span class="literal">NULL</span>;</span><br><span class="line">        Node* pre=dummyHead;</span><br><span class="line">        dfs(pre, head);</span><br><span class="line">        pre=pre-&gt;next;</span><br><span class="line">        pre-&gt;prev=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="445-两数相加-II"><a href="#445-两数相加-II" class="headerlink" title="445. 两数相加 II"></a>445. 两数相加 II</h2><p><strong>Description</strong><br>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。<br>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p>进阶：<br>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。<br><strong>Example</strong><br>示例：<br>输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 8 -&gt; 0 -&gt; 7<br><strong>Program</strong><br><strong>思路</strong><br>栈</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>{</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk1, stk2;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span>){</span><br><span class="line">            stk1.push(l1-&gt;val);</span><br><span class="line">            l1=l1-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(l2!=<span class="literal">NULL</span>){</span><br><span class="line">            stk2.push(l2-&gt;val);</span><br><span class="line">            l2=l2-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        ListNode* dummyHead=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stk1.empty()&amp;&amp;!stk2.empty()){</span><br><span class="line">            <span class="keyword">int</span> a=stk1.top(), b=stk2.top();</span><br><span class="line">            stk1.pop(), stk2.pop();</span><br><span class="line">            ListNode* node=<span class="keyword">new</span> ListNode((a+b+carry)%<span class="number">10</span>);</span><br><span class="line">            carry=(a+b+carry)/<span class="number">10</span>;</span><br><span class="line">            node-&gt;next=dummyHead-&gt;next;</span><br><span class="line">            dummyHead-&gt;next=node;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(!stk1.empty()){</span><br><span class="line">            <span class="keyword">int</span> a=stk1.top();</span><br><span class="line">            stk1.pop();</span><br><span class="line">            ListNode* node=<span class="keyword">new</span> ListNode((a+carry)%<span class="number">10</span>);</span><br><span class="line">            carry=(a+carry)/<span class="number">10</span>;</span><br><span class="line">            node-&gt;next=dummyHead-&gt;next;</span><br><span class="line">            dummyHead-&gt;next=node;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(!stk2.empty()){</span><br><span class="line">            <span class="keyword">int</span> b=stk2.top();</span><br><span class="line">            stk2.pop();</span><br><span class="line">            ListNode* node=<span class="keyword">new</span> ListNode((b+carry)%<span class="number">10</span>);</span><br><span class="line">            carry=(b+carry)/<span class="number">10</span>;</span><br><span class="line">            node-&gt;next=dummyHead-&gt;next;</span><br><span class="line">            dummyHead-&gt;next=node;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(carry!=<span class="number">0</span>){</span><br><span class="line">            ListNode* node=<span class="keyword">new</span> ListNode(carry);</span><br><span class="line">            node-&gt;next=dummyHead-&gt;next;</span><br><span class="line">            dummyHead-&gt;next=node;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="725-分隔链表"><a href="#725-分隔链表" class="headerlink" title="725. 分隔链表"></a>725. 分隔链表</h2><p><strong>Description</strong><br>给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。<br>每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。<br>这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。<br>返回一个符合上述规则的链表的列表。<br>举例： 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 结果 [ [1], [2], [3], [4], null ]<br><strong>Example</strong><br>示例 1：<br>输入:<br>root = [1, 2, 3], k = 5<br>输出: [[1],[2],[3],[],[]]<br>解释:<br>输入输出各部分都应该是链表，而不是数组。<br>例如, 输入的结点 root 的 val= 1, root.next.val = 2, \root.next.next.val = 3, 且 root.next.next.next = null。<br>第一个输出 output[0] 是 output[0].val = 1, output[0].next = null。<br>最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。</p>
<p>示例 2：<br>输入:<br>root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3<br>输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]<br>解释:<br>输入被分成了几个连续的部分，并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度。</p>
<p>提示:<br>root 的长度范围： [0, 1000].<br>输入的每个节点的大小范围：[0, 999].<br>k 的取值范围： [1, 50].<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode* root)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">NULL</span>){</span><br><span class="line">            ans++;</span><br><span class="line">            root=root-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;ListNode*&gt; splitListToParts(ListNode* root, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="keyword">int</span> len=getLength(root);</span><br><span class="line">        <span class="keyword">int</span> m=len/k; <span class="comment">//每组的元素个数</span></span><br><span class="line">        <span class="keyword">int</span> n=len-m*k; <span class="comment">//多一个的元素的组的个数</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;ListNode*&gt; vec;</span><br><span class="line">        vec.push_back(root);</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">NULL</span>&amp;&amp;k&gt;<span class="number">0</span>){</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">if</span>(n&gt;<span class="number">0</span>&amp;&amp;ans==m+<span class="number">1</span>){</span><br><span class="line">                ListNode* ne=root-&gt;next;</span><br><span class="line">                root-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">                vec.push_back(ne);</span><br><span class="line">                ans=<span class="number">0</span>;</span><br><span class="line">                n--;</span><br><span class="line">                root=ne;</span><br><span class="line">                k--;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;ans==m){</span><br><span class="line">                ListNode* ne=root-&gt;next;</span><br><span class="line">                root-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">                vec.push_back(ne);</span><br><span class="line">                ans=<span class="number">0</span>;</span><br><span class="line">                root=ne;</span><br><span class="line">                k--;</span><br><span class="line">            }<span class="keyword">else</span> root=root-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">0</span>){</span><br><span class="line">            vec.push_back(<span class="literal">NULL</span>);</span><br><span class="line">            k--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a>876. 链表的中间结点</h2><p><strong>Description</strong><br>给定一个带有头结点 head 的非空单链表，返回链表的中间结点。<br>如果有两个中间结点，则返回第二个中间结点。<br><strong>Example</strong><br>示例 1：<br>输入：[1,2,3,4,5]<br>输出：此列表中的结点 3 (序列化形式：[3,4,5])<br>返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>注意，我们返回了一个 ListNode 类型的对象 ans，这样：<br>ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.</p>
<p>示例 2：<br>输入：[1,2,3,4,5,6]<br>输出：此列表中的结点 4 (序列化形式：[4,5,6])<br>由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</p>
<p>提示：<br>给定链表的结点数介于 1 和 100 之间。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode* fast, *slow;</span><br><span class="line">        fast=slow=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>){</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// if(fast!=NULL&amp;&amp;fast-&gt;next!=NULL) return slow-&gt;next;</span></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1171-从链表中删去总和值为零的连续节点"><a href="#1171-从链表中删去总和值为零的连续节点" class="headerlink" title="1171. 从链表中删去总和值为零的连续节点"></a>1171. 从链表中删去总和值为零的连续节点</h2><p><strong>Description</strong><br>给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和 值为 0 的连续节点组成的序列，直到不存在这样的序列为止。<br>删除完毕后，请你返回最终结果链表的头节点。<br>你可以返回任何满足题目要求的答案。</p>
<p>（注意，下面示例中的所有序列，都是对 ListNode 对象序列化的表示。）<br><strong>Example</strong><br>示例 1：<br>输入：head = [1,2,-3,3,1]<br>输出：[3,1]<br>提示：答案 [1,2,1] 也是正确的。</p>
<p>示例 2：<br>输入：head = [1,2,3,-3,4]<br>输出：[1,2,4]</p>
<p>示例 3：<br>输入：head = [1,2,3,-3,-2]<br>输出：[1]</p>
<p>提示：<br>给你的链表中可能有 1 到 1000 个节点。<br>对于链表中的每个节点，节点的值：-1000 &lt;= node.val &lt;= 1000.<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeZeroSumSublists</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* ne=removeZeroSumSublists(head-&gt;next); <span class="comment">//剔除后面的和为0的链表段</span></span><br><span class="line">        head-&gt;next=ne;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>){</span><br><span class="line">            sum+=p-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(sum==<span class="number">0</span>){</span><br><span class="line">                head=p-&gt;next; <span class="comment">//头结点更新</span></span><br><span class="line">            }</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="面试题-02-01-移除重复节点"><a href="#面试题-02-01-移除重复节点" class="headerlink" title="面试题 02.01. 移除重复节点"></a>面试题 02.01. 移除重复节点</h2><p><strong>Description</strong><br>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。<br><strong>Example</strong><br>示例1:<br> 输入：[1, 2, 3, 3, 2, 1]<br> 输出：[1, 2, 3]</p>
<p>示例2:<br> 输入：[1, 1, 1, 1, 2]<br> 输出：[1, 2]</p>
<p>提示：<br>链表长度在[0, 20000]范围内。<br>链表元素在[0, 20000]范围内。<br>进阶：<br>如果不得使用临时缓冲区，该怎么解决？<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeDuplicateNodes</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        st.insert(head-&gt;val);</span><br><span class="line">        ListNode* p=head-&gt;next;</span><br><span class="line">        ListNode* pre=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>){</span><br><span class="line">            <span class="keyword">if</span>(st.find(p-&gt;val)!=st.end()){</span><br><span class="line">                pre-&gt;next=p-&gt;next;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                st.insert(p-&gt;val);</span><br><span class="line">                pre=p;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="面试题-02-08-环路检测"><a href="#面试题-02-08-环路检测" class="headerlink" title="面试题 02.08. 环路检测"></a>面试题 02.08. 环路检测</h2><p><strong>Description</strong><br>给定一个链表，如果它是有环链表，实现一个算法返回环路的开头节点。<br>有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则表明该链表存在环路。<br><strong>Example</strong><br>示例 1：<br>输入：head = [3,2,0,-4], pos = 1<br>输出：tail connects to node index 1<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
<p>示例 2：<br>输入：head = [1,2], pos = 0<br>输出：tail connects to node index 0<br>解释：链表中有一个环，其尾部连接到第一个节点。</p>
<p>示例 3：<br>输入：head = [1], pos = -1<br>输出：no cycle<br>解释：链表中没有环。</p>
<p>进阶：<br>你是否可以不用额外空间解决此题？<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>{</span><br><span class="line">        ListNode *fast=head, *slow=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>){</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow) <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="literal">NULL</span>||fast-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=slow){</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a>剑指 Offer 52. 两个链表的第一个公共节点</h2><p><strong>Description</strong><br>输入两个链表，找出它们的第一个公共节点。<br>如下面的两个链表：<br><img src="/assets/img/algorithm/160_statement.png" alt="image"><br>在节点 c1 开始相交。<br><strong>Example</strong><br>示例 1：<br>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p>
<p>示例 2：<br>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>输出：Reference of the node with value = 2<br>输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p>
<p>示例 3：<br>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>输出：null<br>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 null。</p>
<p>注意：<br>如果两个链表没有交点，返回 null.<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。<br><strong>Program</strong><br><strong>思路</strong><br>（1）若存在交点，那么链表A结尾与链表B头链接，链表B结尾与链表A头链接，那么元素节点数一直，双指针一定能够到达同一个点，这个点就是交点！<br>（2）若不存在交点，那么上述链接一定不会相交，此时应当进行判断！记录双指针到达各自尾节点时的尾节点是否一致即可！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(headA==<span class="literal">NULL</span>||headB==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* pA=headA;</span><br><span class="line">        ListNode* pB=headB;</span><br><span class="line">        ListNode* lastA=<span class="literal">NULL</span>;</span><br><span class="line">        ListNode* lastB=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(pA!=pB){</span><br><span class="line">            <span class="keyword">if</span>(pA-&gt;next==<span class="literal">NULL</span>){ <span class="comment">//到达A尾节点</span></span><br><span class="line">                lastA=pA;</span><br><span class="line">                pA=headB; <span class="comment">//指向链表B</span></span><br><span class="line">            }<span class="keyword">else</span> pA=pA-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(pB-&gt;next==<span class="literal">NULL</span>){ <span class="comment">//到达B尾节点</span></span><br><span class="line">                lastB=pB;</span><br><span class="line">                pB=headA; <span class="comment">//指向链表A</span></span><br><span class="line">            }<span class="keyword">else</span> pB=pB-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(lastA!=<span class="literal">NULL</span>&amp;&amp;lastB!=<span class="literal">NULL</span>&amp;&amp;lastA!=lastB) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//两个链表尾都被访问过，比较是否为同一个节点即可</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1></blockquote>
<h2 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146. LRU缓存机制"></a>146. LRU缓存机制</h2><p><strong>Description</strong><br>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。<br>获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p>
<p>进阶:<br>你是否可以在 O(1) 时间复杂度内完成这两种操作？<br><strong>Example</strong><br>示例:<br>LRUCache cache = new LRUCache( 2 /* 缓存容量 <em>/ );<br>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       // 返回  1<br>cache.put(3, 3);    // 该操作会使得关键字 2 作废<br>cache.get(2);       // 返回 -1 (未找到)<br>cache.put(4, 4);    // 该操作会使得关键字 1 作废<br>cache.get(1);       // 返回 -1 (未找到)<br>cache.get(3);       // 返回  3<br>cache.get(4);       // 返回  4<br>*</em>Program**<br><strong>思路</strong><br>（1）用双向链表进行存储最近使用的节点，最近使用的节点考前，最近最少使用的在末尾<br>（2）HashMap存储key对应的节点位置；<br>get方法：</p>
<ul>
<li>如果链表为空或未找到，返回-1；</li>
<li>如果找到，则需要将key节点移至链表头；<br>put方法：</li>
<li>如果链表不存在key：①链表满，则应当剔除末尾节点，但是更好的做法就是讲末尾节点的key和value更新为最新值，然后移至链表头；②未满，新建节点，移至链表头</li>
<li>如果链表已存在key，则更新value，且移至链表头；</li>
</ul>
<p><strong>注意：以下代码没有多余头结点，故注意头指针指向当前m[key]的时候，不要移动！因为需要移动的话需要将前后两个节点相连，但是head也随着变化了!</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CycleLinkDeList</span>{</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        CycleLinkDeList* next;</span><br><span class="line">        CycleLinkDeList* pre;</span><br><span class="line">        CycleLinkDeList(<span class="keyword">int</span> _key, <span class="keyword">int</span> _val){</span><br><span class="line">            key=_key;</span><br><span class="line">            val=_val;</span><br><span class="line">            next=pre=<span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, CycleLinkDeList*&gt; m;</span><br><span class="line">    <span class="keyword">int</span> Capacity;</span><br><span class="line">    <span class="keyword">int</span> nowCapacity;</span><br><span class="line">    CycleLinkDeList *head;</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) {</span><br><span class="line">        Capacity=capacity;</span><br><span class="line">        nowCapacity=<span class="number">0</span>;</span><br><span class="line">        head=<span class="literal">NULL</span>;</span><br><span class="line">        m.clear();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nowCapacity==<span class="number">0</span>||m.find(key)==m.end()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(head==m[key]) <span class="keyword">return</span> head-&gt;val;</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            CycleLinkDeList* node=m[key];</span><br><span class="line">            node-&gt;pre-&gt;next=node-&gt;next;</span><br><span class="line">            node-&gt;next-&gt;pre=node-&gt;pre;</span><br><span class="line">            node-&gt;next=node-&gt;pre=<span class="literal">NULL</span>;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head-&gt;val;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(m.find(key)==m.end()){</span><br><span class="line">            <span class="keyword">if</span>(nowCapacity==Capacity){ <span class="comment">//尾节点原键值丢弃</span></span><br><span class="line">                m.erase(head-&gt;pre-&gt;key);</span><br><span class="line">                CycleLinkDeList* tail=head-&gt;pre;</span><br><span class="line">                m[key]=tail;</span><br><span class="line">                tail-&gt;key=key;</span><br><span class="line">                tail-&gt;val=value;</span><br><span class="line">                head=head-&gt;pre;   </span><br><span class="line">            }<span class="keyword">else</span>{ <span class="comment">//创建新头结点</span></span><br><span class="line">                CycleLinkDeList* node=<span class="keyword">new</span> CycleLinkDeList(key, value);</span><br><span class="line">                nowCapacity++;</span><br><span class="line">                m[key]=node;</span><br><span class="line">                <span class="keyword">if</span>(nowCapacity==<span class="number">1</span>){ <span class="comment">//当前节点为第一个节点</span></span><br><span class="line">                    node-&gt;pre=node;</span><br><span class="line">                    node-&gt;next=node;</span><br><span class="line">                    head=node;</span><br><span class="line">                }<span class="keyword">else</span> {</span><br><span class="line">                    moveToHead(node);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">if</span>(head==m[key]){</span><br><span class="line">                head-&gt;key=key;</span><br><span class="line">                head-&gt;val=value;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                CycleLinkDeList* node=m[key];</span><br><span class="line">                node-&gt;val=value;</span><br><span class="line">                node-&gt;pre-&gt;next=node-&gt;next;</span><br><span class="line">                node-&gt;next-&gt;pre=node-&gt;pre;</span><br><span class="line">                moveToHead(node);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(CycleLinkDeList* node)</span></span>{</span><br><span class="line">        node-&gt;next=head;</span><br><span class="line">        node-&gt;pre=head-&gt;pre;</span><br><span class="line">        head-&gt;pre-&gt;next=node;</span><br><span class="line">        head-&gt;pre=node;</span><br><span class="line">        head=node;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>双端双向链表</strong><br>简化，双向链表即可，且带有头尾两个伪节点！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DeLinkList</span>{</span></span><br><span class="line">        <span class="keyword">int</span> key, value;</span><br><span class="line">        DeLinkList *pre, *next;</span><br><span class="line">        DeLinkList(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value){</span><br><span class="line">            key=_key;</span><br><span class="line">            value=_value;</span><br><span class="line">            pre=next=<span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, DeLinkList*&gt; m;</span><br><span class="line">    DeLinkList *head, *tail;</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity=capacity;</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">        head=<span class="keyword">new</span> DeLinkList(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        tail=<span class="keyword">new</span> DeLinkList(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        head-&gt;next=tail;</span><br><span class="line">        tail-&gt;pre=head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>||m.find(key)==m.end()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        moveToHead(m[key]);</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next-&gt;value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(m.find(key)==m.end()){</span><br><span class="line">            <span class="keyword">if</span>(size==capacity){</span><br><span class="line">                DeLinkList* node=tail-&gt;pre;</span><br><span class="line">                m.erase(node-&gt;key);</span><br><span class="line">                m[key]=node;</span><br><span class="line">                node-&gt;key=key;</span><br><span class="line">                node-&gt;value=value;</span><br><span class="line">                moveToHead(node);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                DeLinkList* node=<span class="keyword">new</span> DeLinkList(key, value);</span><br><span class="line">                m[key]=node;</span><br><span class="line">                addToHead(node);</span><br><span class="line">                size++;</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            DeLinkList* node=m[key];</span><br><span class="line">            node-&gt;value=value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DeLinkList* node)</span></span>{</span><br><span class="line">        node-&gt;next=head-&gt;next;</span><br><span class="line">        node-&gt;pre=head;</span><br><span class="line">        head-&gt;next-&gt;pre=node;</span><br><span class="line">        head-&gt;next=node;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DeLinkList* node)</span></span>{</span><br><span class="line">        node-&gt;pre-&gt;next=node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;pre=node-&gt;pre;</span><br><span class="line">        addToHead(node);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="170-两数之和-III-数据结构设计"><a href="#170-两数之和-III-数据结构设计" class="headerlink" title="170. 两数之和 III - 数据结构设计"></a>170. 两数之和 III - 数据结构设计</h2><p><strong>Description</strong><br>设计并实现一个 TwoSum 的类，使该类需要支持 add 和 find 的操作。</p>
<ul>
<li>add 操作 -  对内部数据结构增加一个数。</li>
<li>find 操作 - 寻找内部数据结构中是否存在一对整数，使得两数之和与给定的数相等。</li>
</ul>
<p><strong>Example</strong><br>示例 1:<br>add(1); add(3); add(5);<br>find(4) -&gt; true<br>find(7) -&gt; false</p>
<p>示例 2:<br>add(3); add(1); add(2);<br>find(3) -&gt; true<br>find(6) -&gt; false<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    TwoSum() {</span><br><span class="line">        n=<span class="number">0</span>;</span><br><span class="line">        vec.clear();</span><br><span class="line">        m.clear();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Add the number to an internal data structure.. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number)</span> </span>{</span><br><span class="line">        vec.push_back(number);</span><br><span class="line">        m[number]=n++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Find if there exists any pair of numbers which sum is equal to the value. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> tmp=value-vec[i];</span><br><span class="line">            <span class="keyword">if</span>(m.find(tmp)!=m.end()&amp;&amp;m[tmp]!=i) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TwoSum object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TwoSum* obj = new TwoSum();</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(number);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;find(value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="173-二叉搜索树迭代器"><a href="#173-二叉搜索树迭代器" class="headerlink" title="173. 二叉搜索树迭代器"></a>173. 二叉搜索树迭代器</h2><p><strong>Description</strong><br>实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。<br>调用 next() 将返回二叉搜索树中的下一个最小的数。<br><strong>Example</strong><br>示例：<br>BSTIterator iterator = new BSTIterator(root);<br>iterator.next();    // 返回 3<br>iterator.next();    // 返回 7<br>iterator.hasNext(); // 返回 true<br>iterator.next();    // 返回 9<br>iterator.hasNext(); // 返回 true<br>iterator.next();    // 返回 15<br>iterator.hasNext(); // 返回 true<br>iterator.next();    // 返回 20<br>iterator.hasNext(); // 返回 false</p>
<p>提示：<br>next() 和 hasNext() 操作的时间复杂度是 O(1)，并使用 O(h) 内存，其中 h 是树的高度。<br>你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 中至少存在一个下一个最小的数。<br><strong>Program</strong><br>平均时间复杂度O(1)!题目没讲清楚。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;TreeNode*&gt; vis;</span><br><span class="line">    BSTIterator(TreeNode* root) {</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>){</span><br><span class="line">            travelLeft(root);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line">        TreeNode* node=st.top();st.pop();</span><br><span class="line">        vis.insert(node);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right!=<span class="literal">NULL</span>){</span><br><span class="line">            travelLeft(node-&gt;right);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> !st.empty();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">travelLeft</span><span class="params">(TreeNode* root)</span></span>{</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">NULL</span>){</span><br><span class="line">            st.push(root);</span><br><span class="line">            root=root-&gt;left;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BSTIterator* obj = new BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;next();</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a>208. 实现 Trie (前缀树)</h2><p><strong>Description</strong><br>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。<br><strong>Example</strong><br>示例:<br>Trie trie = new Trie();<br>trie.insert(“apple”);<br>trie.search(“apple”);   // 返回 true<br>trie.search(“app”);     // 返回 false<br>trie.startsWith(“app”); // 返回 true<br>trie.insert(“app”);<br>trie.search(“app”);     // 返回 true<br>说明:<br>你可以假设所有的输入都是由小写字母 a-z 构成的。<br>保证所有输入均为非空字符串。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">bool</span> isEnd;</span><br><span class="line">        Node* next[<span class="number">26</span>];</span><br><span class="line">        Node(){</span><br><span class="line">            isEnd=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) next[i]=<span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    Node* root;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie() {</span><br><span class="line">        root=<span class="keyword">new</span> Node();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len=word.length();</span><br><span class="line">        Node* node=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++){</span><br><span class="line">            <span class="keyword">int</span> idx=word[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[idx]==<span class="literal">NULL</span>) node-&gt;next[idx]=<span class="keyword">new</span> Node();</span><br><span class="line">            node=node-&gt;next[idx];</span><br><span class="line">        }</span><br><span class="line">        node-&gt;isEnd=<span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len=word.length();</span><br><span class="line">        Node* node=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++){</span><br><span class="line">            <span class="keyword">int</span> idx=word[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[idx]==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            node=node-&gt;next[idx];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> node-&gt;isEnd;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len=prefix.length();</span><br><span class="line">        Node* node=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++){</span><br><span class="line">            <span class="keyword">int</span> idx=prefix[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[idx]==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            node=node-&gt;next[idx];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="211-添加与搜索单词-数据结构设计"><a href="#211-添加与搜索单词-数据结构设计" class="headerlink" title="211. 添加与搜索单词 - 数据结构设计"></a>211. 添加与搜索单词 - 数据结构设计</h2><p><strong>Description</strong><br>设计一个支持以下两种操作的数据结构：</p>
<ul>
<li>void addWord(word)</li>
<li>bool search(word)</li>
<li>search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。 . 可以表示任何一个字母。</li>
</ul>
<p><strong>Example</strong><br>示例:<br>addWord(“bad”)<br>addWord(“dad”)<br>addWord(“mad”)<br>search(“pad”) -&gt; false<br>search(“bad”) -&gt; true<br>search(“.ad”) -&gt; true<br>search(“b..”) -&gt; true<br>说明:<br>你可以假设所有单词都是由小写字母 a-z 组成的。<br><strong>program</strong><br><strong>字典树+递归</strong><br>关键就是在于search方法对于正则匹配的问题，遇到’.’则尝试接下来26个字母的可能，如果其中一种可达true，则不再继续，或者当所有都不可达，则返回false。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>{</span></span><br><span class="line">        <span class="keyword">bool</span> isEnd;</span><br><span class="line">        Trie* next[<span class="number">26</span>];</span><br><span class="line">        Trie(){</span><br><span class="line">            isEnd=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) next[i]=<span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    Trie* root;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    WordDictionary() {</span><br><span class="line">        root=<span class="keyword">new</span> Trie();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds a word into the data structure. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(<span class="built_in">string</span> word)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=word.length();</span><br><span class="line">        Trie* node=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> idx=word[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[idx]==<span class="literal">NULL</span>) node-&gt;next[idx]=<span class="keyword">new</span> Trie();</span><br><span class="line">            node=node-&gt;next[idx];</span><br><span class="line">        }</span><br><span class="line">        node-&gt;isEnd=<span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> subSearch(root, word);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">subSearch</span><span class="params">(Trie* p, <span class="built_in">string</span> word)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n=word.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(word[i]==<span class="string">'.'</span>){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++){</span><br><span class="line">                    <span class="keyword">if</span>(subSearch(p-&gt;next[j], word.substr(i+<span class="number">1</span>))) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">int</span> idx=word[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next[idx]==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p=p-&gt;next[idx];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> p-&gt;isEnd;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordDictionary* obj = new WordDictionary();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addWord(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a>232. 用栈实现队列</h2><p><strong>Description</strong><br>使用栈实现队列的下列操作：</p>
<ul>
<li>push(x) – 将一个元素放入队列的尾部。</li>
<li>pop() – 从队列首部移除元素。</li>
<li>peek() – 返回队列首部的元素。</li>
<li>empty() – 返回队列是否为空。</li>
</ul>
<p><strong>Example</strong><br>示例:<br>MyQueue queue = new MyQueue();<br>queue.push(1);<br>queue.push(2);<br>queue.peek();  // 返回 1<br>queue.pop();   // 返回 1<br>queue.empty(); // 返回 false</p>
<p>说明:<br>你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。<br>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; inSt, ouSt;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyQueue() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        inSt.push(x);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        moveTo();</span><br><span class="line">        <span class="keyword">int</span> e=ouSt.top();ouSt.pop();</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">        moveTo();</span><br><span class="line">        <span class="keyword">int</span> e=ouSt.top();</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> inSt.empty()&amp;&amp;ouSt.empty();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveTo</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(ouSt.empty()){</span><br><span class="line">            <span class="keyword">while</span>(!inSt.empty()){</span><br><span class="line">                <span class="keyword">int</span> e=inSt.top();inSt.pop();</span><br><span class="line">                ouSt.push(e);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="284-顶端迭代器"><a href="#284-顶端迭代器" class="headerlink" title="284. 顶端迭代器"></a>284. 顶端迭代器</h2><p><strong>Description</strong><br>给定一个迭代器类的接口，接口包含两个方法： next() 和 hasNext()。设计并实现一个支持 peek() 操作的顶端迭代器 – 其本质就是把原本应由 next() 方法返回的元素 peek() 出来。<br><strong>Example</strong><br>示例:<br>假设迭代器被初始化为列表 [1,2,3]。<br>调用 next() 返回 1，得到列表中的第一个元素。<br>现在调用 peek() 返回 2，下一个元素。在此之后调用 next() 仍然返回 2。<br>最后一次调用 next() 返回 3，末尾元素。在此之后调用 hasNext() 应该返回 false。<br>进阶：你将如何拓展你的设计？使之变得通用化，从而适应所有的类型，而不只是整数型？<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Below is the interface for Iterator, which is already defined for you.</span></span><br><span class="line"><span class="comment"> * **DO NOT** modify the interface for Iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  class Iterator {</span></span><br><span class="line"><span class="comment"> *		struct Data;</span></span><br><span class="line"><span class="comment"> * 		Data* data;</span></span><br><span class="line"><span class="comment"> *		Iterator(const vector&lt;int&gt;&amp; nums);</span></span><br><span class="line"><span class="comment"> * 		Iterator(const Iterator&amp; iter);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 		// Returns the next element in the iteration.</span></span><br><span class="line"><span class="comment"> *		int next();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		// Returns true if the iteration has more elements.</span></span><br><span class="line"><span class="comment"> *		bool hasNext() const;</span></span><br><span class="line"><span class="comment"> *	};</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeekingIterator</span> :</span> <span class="keyword">public</span> Iterator {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> isPeek;</span><br><span class="line">    <span class="keyword">int</span> pre;</span><br><span class="line">	PeekingIterator(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) : Iterator(nums) {</span><br><span class="line">	    <span class="comment">// Initialize any member here.</span></span><br><span class="line">	    <span class="comment">// **DO NOT** save a copy of nums and manipulate it directly.</span></span><br><span class="line">	    <span class="comment">// You should only use the Iterator interface methods.</span></span><br><span class="line">	    isPeek=<span class="literal">false</span>;</span><br><span class="line">        pre=<span class="number">-1</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the next element in the iteration without advancing the iterator.</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(isPeek) <span class="keyword">return</span> pre;</span><br><span class="line">        isPeek=<span class="literal">true</span>; pre=Iterator::next();</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// hasNext() and next() should behave the same as in the Iterator interface.</span></span><br><span class="line">	<span class="comment">// Override them if needed.</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line">	    <span class="keyword">if</span>(isPeek) {isPeek=<span class="literal">false</span>;<span class="keyword">return</span> pre;}</span><br><span class="line">        <span class="keyword">return</span> Iterator::next();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">	    <span class="keyword">return</span> isPeek || Iterator::hasNext();</span><br><span class="line">	}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="341-扁平化嵌套列表迭代器"><a href="#341-扁平化嵌套列表迭代器" class="headerlink" title="341. 扁平化嵌套列表迭代器"></a>341. 扁平化嵌套列表迭代器</h2><p><strong>Description</strong><br>给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。<br>列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。<br><strong>Example</strong><br>示例 1:<br>输入: [[1,1],2,[1,1]]<br>输出: [1,1,2,1,1]<br>解释: 通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,1,2,1,1]。</p>
<p>示例 2:<br>输入: [1,[4,[6]]]<br>输出: [1,4,6]<br>解释: 通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,4,6]。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger {</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    NestedIterator(<span class="built_in">vector</span>&lt;NestedInteger&gt; &amp;nestedList) {</span><br><span class="line">        idx=<span class="number">0</span>;</span><br><span class="line">        flatten(nestedList);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt; nestedList)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(NestedInteger&amp; x:nestedList){</span><br><span class="line">            <span class="keyword">if</span>(x.isInteger()) vec.push_back(x.getInteger());</span><br><span class="line">            <span class="keyword">else</span> flatten(x.getList());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> vec[idx++];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> idx&lt;vec.size();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NestedIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NestedIterator i(nestedList);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="355-设计推特"><a href="#355-设计推特" class="headerlink" title="355. 设计推特"></a>355. 设计推特</h2><p><strong>Description</strong><br>设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近十条推文。你的设计需要支持以下的几个功能：</p>
<ul>
<li>postTweet(userId, tweetId): 创建一条新的推文</li>
<li>getNewsFeed(userId): 检索最近的十条推文。每个推文都必须是由此用户关注的人或者是用户自己发出的。推文必须按照时间顺序由最近的开始排序。</li>
<li>follow(followerId, followeeId): 关注一个用户</li>
<li>unfollow(followerId, followeeId): 取消关注一个用户</li>
</ul>
<p><strong>Example</strong><br>示例:</p>
<p>Twitter twitter = new Twitter();</p>
<p>// 用户1发送了一条新推文 (用户id = 1, 推文id = 5).<br>twitter.postTweet(1, 5);</p>
<p>// 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文.<br>twitter.getNewsFeed(1);</p>
<p>// 用户1关注了用户2.<br>twitter.follow(1, 2);</p>
<p>// 用户2发送了一个新推文 (推文id = 6).<br>twitter.postTweet(2, 6);</p>
<p>// 用户1的获取推文应当返回一个列表，其中包含两个推文，id分别为 -&gt; [6, 5].<br>// 推文id6应当在推文id5之前，因为它是在5之后发送的.<br>twitter.getNewsFeed(1);</p>
<p>// 用户1取消关注了用户2.<br>twitter.unfollow(1, 2);</p>
<p>// 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文.<br>// 因为用户1已经不再关注用户2.<br>twitter.getNewsFeed(1);<br><strong>Program</strong><br><strong>思路</strong><br>用户类：关注者集合，推文链表（最近的发文靠前）<br>关键在于拉取推文：需要合并两个链表，最多recentMax=10条！多了肯定不会是他。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">User</span>{</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; followees; <span class="comment">//关注者</span></span><br><span class="line">        <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; tweetIds; <span class="comment">//用户发的推文id-&gt;time</span></span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">int</span> time, recentMax;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, User&gt; idToUser;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Twitter() {</span><br><span class="line">        time=<span class="number">0</span>;</span><br><span class="line">        recentMax=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Compose a new tweet. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> tweetId)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(idToUser.find(userId)==idToUser.end()){ <span class="comment">//未注册用户</span></span><br><span class="line">            User user;</span><br><span class="line">            user.tweetIds.push_front(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(tweetId, time++));</span><br><span class="line">            idToUser[userId] = user;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            idToUser[userId].tweetIds.push_front(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(tweetId, time++));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */</span></span><br><span class="line">    <span class="comment">//最多取recentMax个结果进行合并</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getNewsFeed(<span class="keyword">int</span> userId) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;::iterator it=idToUser[userId].tweetIds.begin();it!=idToUser[userId].tweetIds.end()&amp;&amp;size&lt;recentMax;it++) {vec.emplace_back(*it);size++;}</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> followeeId: idToUser[userId].followees){</span><br><span class="line">            <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; tweetIds=idToUser[followeeId].tweetIds;</span><br><span class="line">            size=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">            <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;::iterator it=tweetIds.begin();</span><br><span class="line">            <span class="comment">//归并</span></span><br><span class="line">            <span class="keyword">while</span>(size&lt;vec.size()&amp;&amp;it!=tweetIds.end()){</span><br><span class="line">                <span class="keyword">if</span>(it-&gt;second&gt;vec[size].second){</span><br><span class="line">                    res.emplace_back(*it);</span><br><span class="line">                    it++;</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    res.emplace_back(vec[size++]);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(res.size()==recentMax) <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span>(size&lt;vec.size()&amp;&amp;res.size()&lt;recentMax) {res.emplace_back(vec[size++]);}</span><br><span class="line">            <span class="keyword">while</span>(it!=tweetIds.end()&amp;&amp;res.size()&lt;recentMax) {res.emplace_back(*it);it++;}</span><br><span class="line">            vec.assign(res.begin(), res.end());</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; tweet:vec) res.emplace_back(tweet.first);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Follower follows a followee. If the operation is invalid, it should be a no-op. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(followerId==followeeId) <span class="keyword">return</span>; <span class="comment">//自己关注自己</span></span><br><span class="line">        <span class="keyword">if</span>(idToUser.find(followerId)==idToUser.end()){ <span class="comment">//未注册用户</span></span><br><span class="line">            User user;</span><br><span class="line">            idToUser[followerId] = user;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(idToUser.find(followeeId)==idToUser.end()){ <span class="comment">//未注册用户</span></span><br><span class="line">            User user;</span><br><span class="line">            idToUser[followeeId] = user;</span><br><span class="line">        }</span><br><span class="line">        idToUser[followerId].followees.insert(followeeId);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>{</span><br><span class="line">        idToUser[followerId].followees.erase(followeeId);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Twitter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Twitter* obj = new Twitter();</span></span><br><span class="line"><span class="comment"> * obj-&gt;postTweet(userId,tweetId);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_2 = obj-&gt;getNewsFeed(userId);</span></span><br><span class="line"><span class="comment"> * obj-&gt;follow(followerId,followeeId);</span></span><br><span class="line"><span class="comment"> * obj-&gt;unfollow(followerId,followeeId);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="497-非重叠矩形中的随机点"><a href="#497-非重叠矩形中的随机点" class="headerlink" title="497. 非重叠矩形中的随机点"></a>497. 非重叠矩形中的随机点</h2><p><strong>Description</strong><br>给定一个非重叠轴对齐矩形的列表 rects，写一个函数 pick 随机均匀地选取矩形覆盖的空间中的整数点。</p>
<p>提示：<br>整数点是具有整数坐标的点。<br>矩形周边上的点包含在矩形覆盖的空间中。<br>第 i 个矩形 rects [i] = [x1，y1，x2，y2]，其中 [x1，y1] 是左下角的整数坐标，[x2，y2] 是右上角的整数坐标。<br>每个矩形的长度和宽度不超过 2000。<br>1 &lt;= rects.length &lt;= 100<br>pick 以整数坐标数组 [p_x, p_y] 的形式返回一个点。<br>pick 最多被调用10000次。<br><strong>Example</strong><br>示例 1：<br>输入:<br>[“Solution”,”pick”,”pick”,”pick”]<br>[[[[1,1,5,5]]],[],[],[]]<br>输出:<br>[null,[4,1],[4,1],[3,3]]</p>
<p>示例 2：<br>输入:<br>[“Solution”,”pick”,”pick”,”pick”,”pick”,”pick”]<br>[[[[-2,-2,-1,-1],[1,0,3,0]]],[],[],[],[],[]]<br>输出:<br>[null,[-1,-2],[2,0],[-2,-1],[3,0],[-2,-2]]</p>
<p>输入语法的说明：<br>输入是两个列表：调用的子例程及其参数。Solution 的构造函数有一个参数，即矩形数组 rects。pick 没有参数。参数总是用列表包装的，即使没有也是如此。<br><strong>Program</strong><br><strong>思路</strong><br>（1）若干个矩形，总共ans个点，利用均匀分布生成随机数idx表示选取ans个点中的第idx个（从1开始），那么需要判断第idx个点在哪个矩形上，通过二分查找$preSum[i-1]&lt;idx&lt;=preSum[i]$，即找到第一个不比idx小的矩形(preSum[i]表示前i个矩形的整点数目)；<br>（2）确定好之后，需要判断第idx点为矩形上的第几个点，可以将矩形从下到上，从左到右依次编号，0,…,n-1，n为矩形的整点个数，那么$id_{rect}=(idx-1-preSum[i-1])$为选中的第i个矩形上的id_{rect}个点（-1表示下标从0开始，方便后面模和除法运算）；<br>（3）最终坐标：$x_{res}=rects[i][0]+id_{rect}, mod , (rects[i][2]-rects[i][0]),y_{res}=rects[i][1]+id_{rect} / (rects[i][2]-rects[i][0])$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; rects;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preSum;</span><br><span class="line">    mt19937 rng{random_device{}()};  <span class="comment">//初始化随机种子</span></span><br><span class="line">    uniform_int_distribution&lt;<span class="keyword">int</span>&gt; uni; <span class="comment">//设置均匀分布随机数</span></span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rects) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;rects = rects;</span><br><span class="line">        n=rects.size();</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rect:rects){</span><br><span class="line">            ans+=(rect[<span class="number">2</span>]-rect[<span class="number">0</span>]+<span class="number">1</span>)*(rect[<span class="number">3</span>]-rect[<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">            preSum.push_back(ans);</span><br><span class="line">        }</span><br><span class="line">        uni = uniform_int_distribution&lt;<span class="keyword">int</span>&gt;{<span class="number">1</span>, ans}; <span class="comment">//设置均匀分布的上下界</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pick() {</span><br><span class="line">        <span class="keyword">int</span> idx=uni(rng); <span class="comment">//随机选择第idx个点,从1开始</span></span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){  <span class="comment">//找第一个不比x小的矩形</span></span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(preSum[mid]&lt;idx) left=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right=mid;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rect=rects[left];</span><br><span class="line">        <span class="keyword">int</span> id_rect=idx-(left<span class="number">-1</span>&gt;=<span class="number">0</span>?preSum[left<span class="number">-1</span>]:<span class="number">0</span>)<span class="number">-1</span>; <span class="comment">//所选矩形内的第id_rect个点，-1表示从0开始</span></span><br><span class="line">        <span class="keyword">return</span> {rect[<span class="number">0</span>]+id_rect%(rect[<span class="number">2</span>]-rect[<span class="number">0</span>]+<span class="number">1</span>), rect[<span class="number">1</span>]+id_rect/(rect[<span class="number">2</span>]-rect[<span class="number">0</span>]+<span class="number">1</span>)};</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(rects);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_1 = obj-&gt;pick();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="622-设计循环队列"><a href="#622-设计循环队列" class="headerlink" title="622. 设计循环队列"></a>622. 设计循环队列</h2><p><strong>Description</strong><br>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p>
<p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p>
<p>你的实现应该支持如下操作：<br>MyCircularQueue(k): 构造器，设置队列长度为 k 。<br>Front: 从队首获取元素。如果队列为空，返回 -1 。<br>Rear: 获取队尾元素。如果队列为空，返回 -1 。<br>enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。<br>deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。<br>isEmpty(): 检查循环队列是否为空。<br>isFull(): 检查循环队列是否已满。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3</span><br><span class="line">circularQueue.enQueue(1); &nbsp;// 返回 true</span><br><span class="line">circularQueue.enQueue(2); &nbsp;// 返回 true</span><br><span class="line">circularQueue.enQueue(3); &nbsp;// 返回 true</span><br><span class="line">circularQueue.enQueue(4); &nbsp;// 返回 false，队列已满</span><br><span class="line">circularQueue.Rear(); &nbsp;// 返回 3</span><br><span class="line">circularQueue.isFull(); &nbsp;// 返回 true</span><br><span class="line">circularQueue.deQueue(); &nbsp;// 返回 true</span><br><span class="line">circularQueue.enQueue(4); &nbsp;// 返回 true</span><br><span class="line">circularQueue.Rear(); &nbsp;// 返回 4</span><br></pre></td></tr></tbody></table></figure>

<p>提示：<br>所有的值都在 0 至 1000 的范围内；<br>操作数将在 1 至 1000 的范围内；<br>请不要使用内置的队列库。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> s,e;</span><br><span class="line">    <span class="keyword">int</span> K;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the queue to be k. */</span></span><br><span class="line">    MyCircularQueue(<span class="keyword">int</span> k) {</span><br><span class="line">        K=k+<span class="number">1</span>;</span><br><span class="line">        s=e=<span class="number">0</span>;</span><br><span class="line">        vec.resize(k+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Insert an element into the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>((e+<span class="number">1</span>)%K==s) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        vec[e]=value;</span><br><span class="line">        e=(e+<span class="number">1</span>)%K;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delete an element from the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(s==e) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        s=(s+<span class="number">1</span>)%K;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(s==e) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> vec[s];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the last item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(s==e) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> vec[(e<span class="number">-1</span>+K)%K];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> s==e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is full or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (e+<span class="number">1</span>)%K==s;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCircularQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCircularQueue* obj = new MyCircularQueue(k);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;enQueue(value);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;deQueue();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;Front();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;Rear();</span></span><br><span class="line"><span class="comment"> * bool param_5 = obj-&gt;isEmpty();</span></span><br><span class="line"><span class="comment"> * bool param_6 = obj-&gt;isFull();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="641-设计循环双端队列"><a href="#641-设计循环双端队列" class="headerlink" title="641. 设计循环双端队列"></a>641. 设计循环双端队列</h2><p><strong>Description</strong><br>设计实现双端队列。<br>你的实现需要支持以下操作：</p>
<p>MyCircularDeque(k)：构造函数,双端队列的大小为k。<br>insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。<br>insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。<br>deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。<br>deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。<br>getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。<br>getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。<br>isEmpty()：检查双端队列是否为空。<br>isFull()：检查双端队列是否满了。<br><strong>Example</strong><br>示例：<br>MyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3<br>circularDeque.insertLast(1);                    // 返回 true<br>circularDeque.insertLast(2);                    // 返回 true<br>circularDeque.insertFront(3);                    // 返回 true<br>circularDeque.insertFront(4);                    // 已经满了，返回 false<br>circularDeque.getRear();                  // 返回 2<br>circularDeque.isFull();                        // 返回 true<br>circularDeque.deleteLast();                    // 返回 true<br>circularDeque.insertFront(4);                    // 返回 true<br>circularDeque.getFront();                // 返回 4</p>
<p>提示：<br>所有值的范围为 [1, 1000]<br>操作次数的范围为 [1, 1000]<br>请不要使用内置的双端队列库。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularDeque</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> s,e;</span><br><span class="line">    <span class="keyword">int</span> K;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the deque to be k. */</span></span><br><span class="line">    MyCircularDeque(<span class="keyword">int</span> k) {</span><br><span class="line">        K=k+<span class="number">1</span>;</span><br><span class="line">        s=e=<span class="number">0</span>;</span><br><span class="line">        vec.resize(K);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds an item at the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insertFront</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>((e+<span class="number">1</span>)%K==s) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//满队</span></span><br><span class="line">        s=(s<span class="number">-1</span>+K)%K;</span><br><span class="line">        vec[s]=value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds an item at the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insertLast</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>((e+<span class="number">1</span>)%K==s) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//满队</span></span><br><span class="line">        vec[e]=value;</span><br><span class="line">        e=(e+<span class="number">1</span>)%K;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Deletes an item from the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deleteFront</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(s==e) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//队空</span></span><br><span class="line">        s=(s+<span class="number">1</span>)%K;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Deletes an item from the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deleteLast</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(s==e) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//队空</span></span><br><span class="line">        e=(e<span class="number">-1</span>+K)%K;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front item from the deque. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getFront</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(s==e) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//队空</span></span><br><span class="line">        <span class="keyword">return</span> vec[s];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the last item from the deque. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRear</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(s==e) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//队空</span></span><br><span class="line">        <span class="keyword">return</span> vec[(e<span class="number">-1</span>+K)%K];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> s==e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is full or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (e+<span class="number">1</span>)%K==s;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCircularDeque object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCircularDeque* obj = new MyCircularDeque(k);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;insertFront(value);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;insertLast(value);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;deleteFront();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;deleteLast();</span></span><br><span class="line"><span class="comment"> * int param_5 = obj-&gt;getFront();</span></span><br><span class="line"><span class="comment"> * int param_6 = obj-&gt;getRear();</span></span><br><span class="line"><span class="comment"> * bool param_7 = obj-&gt;isEmpty();</span></span><br><span class="line"><span class="comment"> * bool param_8 = obj-&gt;isFull();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="703-数据流中的第K大元素"><a href="#703-数据流中的第K大元素" class="headerlink" title="703. 数据流中的第K大元素"></a>703. 数据流中的第K大元素</h2><p><strong>Description</strong><br>设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。<br>你的 KthLargest 类需要一个同时接收整数 k 和整数数组nums 的构造器，它包含数据流中的初始元素。每次调用 KthLargest.add，返回当前数据流中第K大的元素。<br><strong>Example</strong><br>示例:<br>int k = 3;<br>int[] arr = [4,5,8,2];<br>KthLargest kthLargest = new KthLargest(3, arr);<br>kthLargest.add(3);   // returns 4<br>kthLargest.add(5);   // returns 5<br>kthLargest.add(10);  // returns 5<br>kthLargest.add(9);   // returns 8<br>kthLargest.add(4);   // returns 8<br>说明:<br>你可以假设 nums 的长度≥ k-1 且k ≥ 1。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; pq;</span><br><span class="line"></span><br><span class="line">    KthLargest(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;k=k;</span><br><span class="line">        sort(nums.begin(), nums.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k&amp;&amp;i&lt;nums.size();i++) pq.push(nums[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        pq.push(val);</span><br><span class="line">        <span class="keyword">if</span>(pq.size()&gt;k) pq.pop();</span><br><span class="line">        <span class="keyword">return</span> pq.top();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your KthLargest object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * KthLargest* obj = new KthLargest(k, nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;add(val);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a>707. 设计链表</h2><p><strong>Description</strong><br>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p>
<p>在链表类中实现这些功能：</p>
<ul>
<li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li>
<li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li>
<li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li>
<li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li>
<li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li>
</ul>
<p><strong>Example</strong><br>示例：<br>MyLinkedList linkedList = new MyLinkedList();<br>linkedList.addAtHead(1);<br>linkedList.addAtTail(3);<br>linkedList.addAtIndex(1,2);   //链表变为1-&gt; 2-&gt; 3<br>linkedList.get(1);            //返回2<br>linkedList.deleteAtIndex(1);  //现在链表是1-&gt; 3<br>linkedList.get(1);            //返回3</p>
<p>提示：<br>所有val值都在 [1, 1000] 之内。<br>操作次数将在  [1, 1000] 之内。<br>请不要使用内置的 LinkedList 库。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkList</span>{</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        LinkList *pre, *next;</span><br><span class="line">        LinkList(<span class="keyword">int</span> _val){</span><br><span class="line">            val=_val;</span><br><span class="line">            pre=next=<span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    LinkList *head, *tail;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyLinkedList() {</span><br><span class="line">        head=<span class="keyword">new</span> LinkList(<span class="number">-1</span>);</span><br><span class="line">        tail=<span class="keyword">new</span> LinkList(<span class="number">-1</span>);</span><br><span class="line">        head-&gt;next=tail;</span><br><span class="line">        tail-&gt;pre=head;</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=size) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        LinkList* node=head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(idx!=index){</span><br><span class="line">            node=node-&gt;next;</span><br><span class="line">            idx++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        LinkList* node=<span class="keyword">new</span> LinkList(val);</span><br><span class="line">        node-&gt;next=head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;pre=node;</span><br><span class="line">        node-&gt;pre=head;</span><br><span class="line">        head-&gt;next=node;</span><br><span class="line">        size++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        LinkList* node=<span class="keyword">new</span> LinkList(val);</span><br><span class="line">        tail-&gt;pre-&gt;next=node;</span><br><span class="line">        node-&gt;pre=tail-&gt;pre;</span><br><span class="line">        node-&gt;next=tail;</span><br><span class="line">        tail-&gt;pre=node;</span><br><span class="line">        size++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(index&gt;size) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(index==size) {addAtTail(val);<span class="keyword">return</span>;}</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>) {addAtHead(val);<span class="keyword">return</span>;}</span><br><span class="line">        LinkList* node=head;</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx!=index){</span><br><span class="line">            node=node-&gt;next;</span><br><span class="line">            idx++;</span><br><span class="line">        }</span><br><span class="line">        LinkList* newNode=<span class="keyword">new</span> LinkList(val);</span><br><span class="line">        newNode-&gt;next=node-&gt;next;</span><br><span class="line">        newNode-&gt;pre=node;</span><br><span class="line">        node-&gt;next-&gt;pre=newNode;</span><br><span class="line">        node-&gt;next=newNode;</span><br><span class="line">        size++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;=size) <span class="keyword">return</span>;</span><br><span class="line">        LinkList* node=head;</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx!=index){</span><br><span class="line">            node=node-&gt;next;</span><br><span class="line">            idx++;</span><br><span class="line">        }</span><br><span class="line">        LinkList* deNode=node-&gt;next;</span><br><span class="line">        deNode-&gt;next-&gt;pre=node;</span><br><span class="line">        node-&gt;next=deNode-&gt;next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">delete</span> deNode;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="981-基于时间的键值存储"><a href="#981-基于时间的键值存储" class="headerlink" title="981. 基于时间的键值存储"></a>981. 基于时间的键值存储</h2><p><strong>Description</strong><br>创建一个基于时间的键值存储类 TimeMap，它支持下面两个操作：</p>
<ol>
<li>set(string key, string value, int timestamp)<br>存储键 key、值 value，以及给定的时间戳 timestamp。</li>
<li>get(string key, int timestamp)<br>返回先前调用 set(key, value, timestamp_prev) 所存储的值，其中 timestamp_prev &lt;= timestamp。<br>如果有多个这样的值，则返回对应最大的  timestamp_prev 的那个值。<br>如果没有值，则返回空字符串（””）。</li>
</ol>
<p><strong>Example</strong><br>示例 1：<br>输入：inputs = [“TimeMap”,”set”,”get”,”get”,”set”,”get”,”get”], inputs = [[],[“foo”,”bar”,1],[“foo”,1],[“foo”,3],[“foo”,”bar2”,4],[“foo”,4],[“foo”,5]]<br>输出：[null,null,”bar”,”bar”,null,”bar2”,”bar2”]<br>解释：<br>TimeMap kv;<br>kv.set(“foo”, “bar”, 1); // 存储键 “foo” 和值 “bar” 以及时间戳 timestamp = 1<br>kv.get(“foo”, 1);  // 输出 “bar”<br>kv.get(“foo”, 3); // 输出 “bar” 因为在时间戳 3 和时间戳 2 处没有对应 “foo” 的值，所以唯一的值位于时间戳 1 处（即 “bar”）<br>kv.set(“foo”, “bar2”, 4);<br>kv.get(“foo”, 4); // 输出 “bar2”<br>kv.get(“foo”, 5); // 输出 “bar2”  </p>
<p>示例 2：<br>输入：inputs = [“TimeMap”,”set”,”set”,”get”,”get”,”get”,”get”,”get”], inputs = [[],[“love”,”high”,10],[“love”,”low”,20],[“love”,5],[“love”,10],[“love”,15],[“love”,20],[“love”,25]]<br>输出：[null,null,null,””,”high”,”high”,”low”,”low”]</p>
<p>提示：<br>所有的键/值字符串都是小写的。<br>所有的键/值字符串长度都在 [1, 100] 范围内。<br>所有 TimeMap.set 操作中的时间戳 timestamps 都是严格递增的。<br>1 &lt;= timestamp &lt;= 10^7<br>TimeMap.set 和 TimeMap.get 函数在每个测试用例中将（组合）调用总计 120000 次。<br><strong>Program</strong><br><strong>哈希+二分</strong><br>首先key值可以对应多个键值、时间戳，而时间戳timestamps是唯一的，即时间戳对应唯一的(key，value)<br>所以设置哈希sTov存储键值对应的时间戳，设置哈希tTos存储时间戳timestamps对应的value值<br>（1）set中只需要分别更新两个哈希表即可；<br>（2）get中先在sTov查找是否存在键值key，如果不存在，直接返回空字符串；否则，对sTov[key]，即vector数组进行二分查找是否存在小于等于timestamps的最大时间戳即可；<br>时间复杂度：$O(n\log{T})$，其中$n$为get的调用次数，而$T$为timestamp的范围。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeMap</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; sTov; <span class="comment">//键值对应的时间戳</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; tTos; <span class="comment">//时间戳对应的value值</span></span><br><span class="line"></span><br><span class="line">    TimeMap() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="built_in">string</span> key, <span class="built_in">string</span> value, <span class="keyword">int</span> timestamp)</span> </span>{</span><br><span class="line">        sTov[key].push_back(timestamp);</span><br><span class="line">        tTos[timestamp]=value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">get</span><span class="params">(<span class="built_in">string</span> key, <span class="keyword">int</span> timestamp)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(sTov.find(key)==sTov.end()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec=sTov[key];</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=vec.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(vec[mid]&lt;=timestamp) left=mid;</span><br><span class="line">            <span class="keyword">else</span> right=mid<span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(vec[left]&gt;timestamp) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> tTos[vec[left]];</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TimeMap object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TimeMap* obj = new TimeMap();</span></span><br><span class="line"><span class="comment"> * obj-&gt;set(key,value,timestamp);</span></span><br><span class="line"><span class="comment"> * string param_2 = obj-&gt;get(key,timestamp);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="1286-字母组合迭代器"><a href="#1286-字母组合迭代器" class="headerlink" title="1286. 字母组合迭代器"></a>1286. 字母组合迭代器</h2><p><strong>Description</strong><br>请你设计一个迭代器类，包括以下内容：<br>一个构造函数，输入参数包括：一个 有序且字符唯一 的字符串 characters（该字符串只包含小写英文字母）和一个数字 combinationLength 。<br>函数 next() ，按 字典序 返回长度为 combinationLength 的下一个字母组合。<br>函数 hasNext() ，只有存在长度为 combinationLength 的下一个字母组合时，才返回 True；否则，返回 False。<br><strong>Example</strong><br>示例：<br>CombinationIterator iterator = new CombinationIterator(“abc”, 2); // 创建迭代器 iterator<br>iterator.next(); // 返回 “ab”<br>iterator.hasNext(); // 返回 true<br>iterator.next(); // 返回 “ac”<br>iterator.hasNext(); // 返回 true<br>iterator.next(); // 返回 “bc”<br>iterator.hasNext(); // 返回 false</p>
<p>提示：<br>1 &lt;= combinationLength &lt;= characters.length &lt;= 15<br>每组测试数据最多包含 10^4 次函数调用。<br>题目保证每次调用函数 next 时都存在下一个字母组合。<br><strong>Program</strong><br><strong>二进制编码</strong><br>利用二进制进行全排列选择长度满足要求的组合字符串，然后进行排序。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CombinationIterator</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> combinationLength;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    CombinationIterator(<span class="built_in">string</span> characters, <span class="keyword">int</span> combinationLength) {</span><br><span class="line">        idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;combinationLength=combinationLength;</span><br><span class="line">        dictStr(characters);</span><br><span class="line">        sort(vec.begin(), vec.end());</span><br><span class="line">        len=vec.size();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> vec[idx++];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> idx&lt;len;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dictStr</span><span class="params">(<span class="built_in">string</span> characters)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> n=characters.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++){</span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; p=calOnes(i, n, characters);</span><br><span class="line">            <span class="keyword">if</span>(p.first==combinationLength){</span><br><span class="line">                vec.push_back(p.second);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    pair&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; calOnes(<span class="keyword">int</span> x, <span class="keyword">int</span> n, <span class="built_in">string</span> characters){</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> bit=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            <span class="keyword">if</span>((bit&amp;x)){</span><br><span class="line">                ans++;</span><br><span class="line">                res+=characters[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> {ans, res};</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CombinationIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CombinationIterator* obj = new CombinationIterator(characters, combinationLength);</span></span><br><span class="line"><span class="comment"> * string param_1 = obj-&gt;next();</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="面试题-03-01-三合一"><a href="#面试题-03-01-三合一" class="headerlink" title="面试题 03.01. 三合一"></a>面试题 03.01. 三合一</h2><p><strong>Description</strong><br>三合一。描述如何只用一个数组来实现三个栈。<br>你应该实现push(stackNum, value)、pop(stackNum)、isEmpty(stackNum)、peek(stackNum)方法。stackNum表示栈下标，value表示压入的值。<br>构造函数会传入一个stackSize参数，代表每个栈的大小。<br><strong>Example</strong><br>示例1:<br> 输入：<br>[“TripleInOne”, “push”, “push”, “pop”, “pop”, “pop”, “isEmpty”]<br>[[1], [0, 1], [0, 2], [0], [0], [0], [0]]<br> 输出：<br>[null, null, null, 1, -1, -1, true]<br>说明：当栈为空时<code>pop, peek</code>返回-1，当栈满时<code>push</code>不压入元素。</p>
<p>示例2:<br> 输入：<br>[“TripleInOne”, “push”, “push”, “push”, “pop”, “pop”, “pop”, “peek”]<br>[[2], [0, 1], [0, 2], [0, 3], [0], [0], [0], [0]]<br> 输出：<br>[null, null, null, null, 2, 1, -1, -1]<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TripleInOne</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">int</span> stackSize;</span><br><span class="line">    <span class="keyword">int</span> stackIdx[<span class="number">3</span>];</span><br><span class="line">    TripleInOne(<span class="keyword">int</span> stackSize) {</span><br><span class="line">        vec.resize(<span class="number">3</span>*stackSize);</span><br><span class="line">        <span class="keyword">this</span>-&gt;stackSize=stackSize;</span><br><span class="line">        stackIdx[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        stackIdx[<span class="number">1</span>]=stackSize<span class="number">-1</span>;</span><br><span class="line">        stackIdx[<span class="number">2</span>]=<span class="number">2</span>*stackSize<span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> stackNum, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(stackIdx[stackNum]-stackNum*stackSize+<span class="number">1</span>==stackSize) <span class="keyword">return</span>;</span><br><span class="line">        vec[++stackIdx[stackNum]]=value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(stackIdx[stackNum]==stackNum*stackSize<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//空栈</span></span><br><span class="line">        <span class="keyword">return</span> vec[stackIdx[stackNum]--];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(stackIdx[stackNum]==stackNum*stackSize<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//空栈</span></span><br><span class="line">        <span class="keyword">return</span> vec[stackIdx[stackNum]];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> stackIdx[stackNum]==stackNum*stackSize<span class="number">-1</span>;<span class="comment">//空栈</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TripleInOne object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TripleInOne* obj = new TripleInOne(stackSize);</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(stackNum,value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop(stackNum);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek(stackNum);</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;isEmpty(stackNum);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="面试题-03-06-动物收容所"><a href="#面试题-03-06-动物收容所" class="headerlink" title="面试题 03.06. 动物收容所"></a>面试题 03.06. 动物收容所</h2><p><strong>Description</strong><br>动物收容所。有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。在收养该收容所的动物时，收养人只能收养所有动物中“最老”（由其进入收容所的时间长短而定）的动物，或者可以挑选猫或狗（同时必须收养此类动物中“最老”的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如enqueue、dequeueAny、dequeueDog和dequeueCat。允许使用Java内置的LinkedList数据结构。</p>
<ul>
<li>enqueue方法有一个animal参数，animal[0]代表动物编号，animal[1]代表动物种类，其中 0 代表猫，1 代表狗。</li>
<li>dequeue*方法返回一个列表[动物编号, 动物种类]，若没有可以收养的动物，则返回[-1,-1]。</li>
</ul>
<p><strong>Example</strong><br>示例1:<br> 输入：<br>[“AnimalShelf”, “enqueue”, “enqueue”, “dequeueCat”, “dequeueDog”, “dequeueAny”]<br>[[], [[0, 0]], [[1, 0]], [], [], []]<br> 输出：<br>[null,null,null,[0,0],[-1,-1],[1,0]]</p>
<p>示例2:<br> 输入：<br>[“AnimalShelf”, “enqueue”, “enqueue”, “enqueue”, “dequeueDog”, “dequeueCat”, “dequeueAny”]<br>[[], [[0, 0]], [[1, 0]], [[2, 1]], [], [], []]<br> 输出：<br>[null,null,null,null,[2,1],[0,0],[1,0]]<br>说明:<br>收纳所的最大容量为20000<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalShelf</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">int</span> time;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> _id, <span class="keyword">int</span> _time):id(_id),time(_time){}</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&gt; qCat, qDog;</span><br><span class="line">    AnimalShelf() {</span><br><span class="line">        time=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; animal)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> kind=animal[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(kind==<span class="number">0</span>){</span><br><span class="line">            qCat.push(Node(animal[<span class="number">0</span>], time++));</span><br><span class="line">        }<span class="keyword">else</span> qDog.push(Node(animal[<span class="number">0</span>], time++));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dequeueAny() {</span><br><span class="line">        <span class="keyword">if</span>(qCat.empty()&amp;&amp;qDog.empty()) <span class="keyword">return</span> {<span class="number">-1</span>, <span class="number">-1</span>};</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(qCat.empty()){</span><br><span class="line">            Node node=qDog.front();qDog.pop();</span><br><span class="line">            <span class="keyword">return</span> {node.id, <span class="number">1</span>};</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(qDog.empty()){</span><br><span class="line">            Node node=qCat.front();qCat.pop();</span><br><span class="line">            <span class="keyword">return</span> {node.id, <span class="number">0</span>};</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            Node dnode=qDog.front();</span><br><span class="line">            Node cnode=qCat.front();</span><br><span class="line">            <span class="keyword">if</span>(dnode.time&lt;cnode.time){</span><br><span class="line">                qDog.pop();</span><br><span class="line">                <span class="keyword">return</span> {dnode.id, <span class="number">1</span>};</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                qCat.pop();</span><br><span class="line">                <span class="keyword">return</span> {cnode.id, <span class="number">0</span>};</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dequeueDog() {</span><br><span class="line">        <span class="keyword">if</span>(qDog.empty()) <span class="keyword">return</span> {<span class="number">-1</span>, <span class="number">-1</span>};</span><br><span class="line">        Node node=qDog.front();qDog.pop();</span><br><span class="line">        <span class="keyword">return</span> {node.id, <span class="number">1</span>};</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dequeueCat() {</span><br><span class="line">        <span class="keyword">if</span>(qCat.empty()) <span class="keyword">return</span> {<span class="number">-1</span>, <span class="number">-1</span>};</span><br><span class="line">        Node node=qCat.front();qCat.pop();</span><br><span class="line">        <span class="keyword">return</span> {node.id, <span class="number">0</span>};</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your AnimalShelf object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * AnimalShelf* obj = new AnimalShelf();</span></span><br><span class="line"><span class="comment"> * obj-&gt;enqueue(animal);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_2 = obj-&gt;dequeueAny();</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_3 = obj-&gt;dequeueDog();</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_4 = obj-&gt;dequeueCat();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="面试题-16-25-LRU缓存"><a href="#面试题-16-25-LRU缓存" class="headerlink" title="面试题 16.25. LRU缓存"></a>面试题 16.25. LRU缓存</h2><p><strong>Description</strong><br>设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。<br>它应该支持以下操作： 获取数据 get 和 写入数据 put 。<br>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。<br><strong>Example</strong><br>示例:<br>LRUCache cache = new LRUCache( 2 /* 缓存容量 <em>/ );<br>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       // 返回  1<br>cache.put(3, 3);    // 该操作会使得密钥 2 作废<br>cache.get(2);       // 返回 -1 (未找到)<br>cache.put(4, 4);    // 该操作会使得密钥 1 作废<br>cache.get(1);       // 返回 -1 (未找到)<br>cache.get(3);       // 返回  3<br>cache.get(4);       // 返回  4<br>*</em>Program**</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DeLinkList</span>{</span></span><br><span class="line">        <span class="keyword">int</span> key, value;</span><br><span class="line">        DeLinkList *pre, *next;</span><br><span class="line">        DeLinkList(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value){</span><br><span class="line">            key=_key;</span><br><span class="line">            value=_value;</span><br><span class="line">            pre=next=<span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    DeLinkList *head, *tail;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, DeLinkList*&gt; m;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) {</span><br><span class="line">        head=<span class="keyword">new</span> DeLinkList(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        tail=<span class="keyword">new</span> DeLinkList(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        head-&gt;next=tail;</span><br><span class="line">        tail-&gt;pre=head;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity=capacity;</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(m.find(key)==m.end()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        DeLinkList* node=m[key];</span><br><span class="line">        node-&gt;pre-&gt;next=node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;pre=node-&gt;pre;</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(m.find(key)==m.end()){</span><br><span class="line">            <span class="keyword">if</span>(size==capacity){</span><br><span class="line">                DeLinkList* node=tail-&gt;pre;</span><br><span class="line">                m.erase(node-&gt;key);</span><br><span class="line">                node-&gt;key=key,node-&gt;value=value;</span><br><span class="line">                m[key]=node;</span><br><span class="line">                node-&gt;value=value;</span><br><span class="line">                node-&gt;pre-&gt;next=node-&gt;next;</span><br><span class="line">                node-&gt;next-&gt;pre=node-&gt;pre;</span><br><span class="line">                moveToHead(node);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                size++;</span><br><span class="line">                DeLinkList* node=<span class="keyword">new</span> DeLinkList(key, value);</span><br><span class="line">                m[key]=node;</span><br><span class="line">                moveToHead(node);</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            DeLinkList* node=m[key];</span><br><span class="line">            node-&gt;value=value;</span><br><span class="line">            node-&gt;pre-&gt;next=node-&gt;next;</span><br><span class="line">            node-&gt;next-&gt;pre=node-&gt;pre;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DeLinkList* root)</span></span>{</span><br><span class="line">        root-&gt;next=head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;pre=root;</span><br><span class="line">        head-&gt;next=root;</span><br><span class="line">        root-&gt;pre=head;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1></blockquote>
<h2 id="常规题"><a href="#常规题" class="headerlink" title="常规题"></a>常规题</h2><h3 id="329-矩阵中的最长递增路径"><a href="#329-矩阵中的最长递增路径" class="headerlink" title="329. 矩阵中的最长递增路径"></a>329. 矩阵中的最长递增路径</h3><p><strong>Description</strong><br>给定一个整数矩阵，找出最长递增路径的长度。<br>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。<br><strong>Example</strong><br>示例 1:<br>输入: nums =<br>[<br>  [9,9,4],<br>  [6,6,8],<br>  [2,1,1]<br>]<br>输出: 4<br>解释: 最长递增路径为 [1, 2, 6, 9]。</p>
<p>示例 2:<br>输入: nums =<br>[<br>  [3,4,5],<br>  [3,2,6],<br>  [2,2,1]<br>]<br>输出: 4<br>解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。<br><strong>Program</strong><br><strong>记忆化深搜</strong><br>dfs(i,j)求得当前起始的最大递增长度<br>时间复杂度：$O(mn)$，朴素深搜时间复杂度$O(V+E)$，$V=mn$，$E≈4mn$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> steps[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vis;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        m=matrix.size(), n=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        vis.resize(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                ans=max(ans, dfs(matrix, i, j));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(vis[i][j]!=<span class="number">0</span>) <span class="keyword">return</span> vis[i][j];</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++){</span><br><span class="line">            <span class="keyword">int</span> new_x=i+steps[k][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> new_y=j+steps[k][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(new_x&gt;=<span class="number">0</span>&amp;&amp;new_x&lt;m&amp;&amp;new_y&gt;=<span class="number">0</span>&amp;&amp;new_y&lt;n&amp;&amp;matrix[new_x][new_y]&gt;matrix[i][j]){</span><br><span class="line">                ans=max(ans, dfs(matrix, new_x, new_y));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        vis[i][j]=ans+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>拓扑排序</strong><br>可以考虑动规，DP[i][j]=max(DP[x][y])+1，即与i,j相邻的四个方向x,y，但是不好DP，可以先将所有点从大到小排序，然后进行状态转移，但是时间复杂度$O(mn\log{mn})$<br>这里使用拓扑排序，计算每个点的出度，出度为0的点加入队列进行拓扑排序，然后更新其相邻的节点，广搜的层数就是最终答案。<br>时间复杂度：$O(mn)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> steps[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; outDegrees;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> x&gt;=<span class="number">0</span>&amp;&amp;x&lt;m&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;n;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        m=matrix.size(), n=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        outDegrees.resize(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++){</span><br><span class="line">                    <span class="keyword">int</span> new_x=i+steps[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> new_y=j+steps[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(judge(new_x,new_y)&amp;&amp;matrix[new_x][new_y]&gt;matrix[i][j]) outDegrees[i][j]++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(outDegrees[i][j]==<span class="number">0</span>) q.push({i, j});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">int</span> size=q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++){</span><br><span class="line">                pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; node=q.front();q.pop();</span><br><span class="line">                <span class="keyword">int</span> x=node.first, y=node.second;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++){</span><br><span class="line">                    <span class="keyword">int</span> new_x=x+steps[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> new_y=y+steps[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(judge(new_x, new_y)&amp;&amp;matrix[new_x][new_y]&lt;matrix[x][y]){</span><br><span class="line">                        outDegrees[new_x][new_y]--;</span><br><span class="line">                        <span class="keyword">if</span>(outDegrees[new_x][new_y]==<span class="number">0</span>) q.push({new_x, new_y});</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>入度同理</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> steps[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; inDegrees;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> x&gt;=<span class="number">0</span>&amp;&amp;x&lt;m&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;n;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        m=matrix.size(), n=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        inDegrees.resize(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++){</span><br><span class="line">                    <span class="keyword">int</span> new_x=i+steps[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> new_y=j+steps[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(judge(new_x,new_y)&amp;&amp;matrix[new_x][new_y]&lt;matrix[i][j]) inDegrees[i][j]++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(inDegrees[i][j]==<span class="number">0</span>) q.push({i, j});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">int</span> size=q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++){</span><br><span class="line">                pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; node=q.front();q.pop();</span><br><span class="line">                <span class="keyword">int</span> x=node.first, y=node.second;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++){</span><br><span class="line">                    <span class="keyword">int</span> new_x=x+steps[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> new_y=y+steps[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(judge(new_x, new_y)&amp;&amp;matrix[new_x][new_y]&gt;matrix[x][y]){</span><br><span class="line">                        inDegrees[new_x][new_y]--;</span><br><span class="line">                        <span class="keyword">if</span>(inDegrees[new_x][new_y]==<span class="number">0</span>) q.push({new_x, new_y});</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="851-喧闹和富有"><a href="#851-喧闹和富有" class="headerlink" title="851. 喧闹和富有"></a>851. 喧闹和富有</h3><p><strong>Description</strong><br>在一组 N 个人（编号为 0, 1, 2, …, N-1）中，每个人都有不同数目的钱，以及不同程度的安静（quietness）。<br>为了方便起见，我们将编号为 x 的人简称为 “person x “。<br>如果能够肯定 person x 比 person y 更有钱的话，我们会说 richer[i] = [x, y] 。注意 richer 可能只是有效观察的一个子集。<br>另外，如果 person x 的安静程度为 q ，我们会说 quiet[x] = q 。<br>现在，返回答案 answer ，其中 answer[x] = y 的前提是，在所有拥有的钱不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。</p>
<p><strong>Example</strong><br>示例：<br>输入：richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]<br>输出：[5,5,2,5,4,5,6,7]<br>解释：<br>answer[0] = 5，<br>person 5 比 person 3 有更多的钱，person 3 比 person 1 有更多的钱，person 1 比 person 0 有更多的钱。<br>唯一较为安静（有较低的安静值 quiet[x]）的人是 person 7，<br>但是目前还不清楚他是否比 person 0 更有钱。<br>answer[7] = 7，<br>在所有拥有的钱肯定不少于 person 7 的人中(这可能包括 person 3，4，5，6 以及 7)，<br>最安静(有较低安静值 quiet[x])的人是 person 7。<br>其他的答案也可以用类似的推理来解释。</p>
<p>提示：<br>1 &lt;= quiet.length = N &lt;= 500<br>0 &lt;= quiet[i] &lt; N，所有 quiet[i] 都不相同。<br>0 &lt;= richer.length &lt;= N * (N-1) / 2<br>0 &lt;= richer[i][j] &lt; N<br>richer[i][0] != richer[i][1]<br>richer[i] 都是不同的。<br>对 richer 的观察在逻辑上是一致的。<br><strong>Program</strong><br><strong>记忆化搜索思路</strong><br>（1）邻接表记录比u富有的所有编号v（不包括自己）;<br>（2）记忆化搜索记录比u富有的最安静值及其编号；</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; Adj;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minQuiet; <span class="comment">//记录比u富有的最安静值</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minIdx;   <span class="comment">//记录比u富有的最安静的编号</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis;     <span class="comment">//是否被已经被记录</span></span><br><span class="line">    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; dfs(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; quiet, <span class="keyword">int</span> u){ <span class="comment">//记忆化搜索，如果vis[u]搜索过了，后续不需要再次遍历</span></span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">return</span> {minQuiet[u], minIdx[u]};</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">            <span class="keyword">int</span> v=Adj[u][i];</span><br><span class="line">            <span class="keyword">int</span> q, idx;</span><br><span class="line">            tie(q, idx)=dfs(quiet, v);</span><br><span class="line">            <span class="keyword">if</span>(q&lt;minQuiet[u]){</span><br><span class="line">                minQuiet[u]=q;</span><br><span class="line">                minIdx[u]=idx;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        vis[u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> {minQuiet[u], minIdx[u]};</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; loudAndRich(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; richer, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; quiet) {</span><br><span class="line">        N=quiet.size();</span><br><span class="line">        vis.resize(N, <span class="literal">false</span>);</span><br><span class="line">        Adj.resize(N);</span><br><span class="line">        minQuiet.resize(N);</span><br><span class="line">        minIdx.resize(N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){ <span class="comment">//初始化为自己，因为题意表示最一般的情况是自己</span></span><br><span class="line">            minIdx[i]=i;</span><br><span class="line">            minQuiet[i]=quiet[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;richer.size();i++){</span><br><span class="line">            <span class="keyword">int</span> u=richer[i][<span class="number">0</span>], v=richer[i][<span class="number">1</span>];</span><br><span class="line">            Adj[v].push_back(u);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line">            dfs(quiet, i);</span><br><span class="line">            res.push_back(minIdx[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>拓扑排序</strong><br>（1）构建邻接表Adj[u]记录所有比u穷的v；<br>（2）res[u]记录u的所有前导节点（所有祖先节点）的最小安静值编号；</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; Adj;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inDegree;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; loudAndRich(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; richer, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; quiet) {</span><br><span class="line">        N=quiet.size();</span><br><span class="line">        Adj.resize(N); <span class="comment">//富指向穷</span></span><br><span class="line">        inDegree.resize(N, <span class="number">0</span>);</span><br><span class="line">        res.resize(N, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;richer.size();i++){</span><br><span class="line">            <span class="keyword">int</span> u=richer[i][<span class="number">0</span>], v=richer[i][<span class="number">1</span>];</span><br><span class="line">            Adj[u].push_back(v);</span><br><span class="line">            inDegree[v]++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line">            res[i]=i; <span class="comment">//自己</span></span><br><span class="line">            <span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>) q.push(i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            <span class="keyword">int</span> u=q.front();q.pop();</span><br><span class="line">            <span class="keyword">int</span> val=quiet[res[u]];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v:Adj[u]){ <span class="comment">//所有比u穷的人</span></span><br><span class="line">                <span class="keyword">if</span>(val&lt;quiet[res[v]]){</span><br><span class="line">                    res[v]=res[u];</span><br><span class="line">                }</span><br><span class="line">                inDegree[v]--;</span><br><span class="line">                <span class="keyword">if</span>(inDegree[v]==<span class="number">0</span>) q.push(v);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1></blockquote>
<h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h2><p><strong>Description</strong><br>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br><strong>Example</strong><br>示例:<br>输入：”23”<br>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].<br>说明:<br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span> iToc[<span class="number">8</span>]={</span><br><span class="line">        <span class="string">"abc"</span>,</span><br><span class="line">        <span class="string">"def"</span>,</span><br><span class="line">        <span class="string">"ghi"</span>,</span><br><span class="line">        <span class="string">"jkl"</span>,</span><br><span class="line">        <span class="string">"mno"</span>,</span><br><span class="line">        <span class="string">"pqrs"</span>,</span><br><span class="line">        <span class="string">"tuv"</span>,</span><br><span class="line">        <span class="string">"wxyz"</span></span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n, <span class="built_in">string</span>&amp; digits)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(i==n){</span><br><span class="line">            res.push_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">string</span> dToc=iToc[digits[i]-<span class="string">'0'</span><span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;dToc.length();j++){</span><br><span class="line">            str+=dToc[j];</span><br><span class="line">            dfs(i+<span class="number">1</span>, n, digits);</span><br><span class="line">            str.erase(str.length()<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) {</span><br><span class="line">        <span class="keyword">if</span>(digits.length()==<span class="number">0</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="keyword">int</span> n=digits.length();</span><br><span class="line">        dfs(<span class="number">0</span>, n, digits);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h2><p><strong>Description</strong><br>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。<br><strong>Example</strong><br>示例：<br>输入：n = 3<br>输出：[<br>       “((()))”,<br>       “(()())”,<br>       “(())()”,<br>       “()(())”,<br>       “()()()”<br>     ]<br><strong>Program</strong><br><strong>回溯</strong><br>dfs(lb,rb)，lb,rb分别表示当前左右括号数目</p>
<ul>
<li>当lb==rb==n时，就得到目标组合；</li>
<li>如果lb==rb!=n，那么此时只能增加左括号</li>
<li>如果lb&gt;rb，那么可以增加左括号（lb&lt;n时），也可以增加右括号<br>整个过程lb不会超过n，rb不会超过lb，当然不会超过n了<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">int</span> nCount;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> lbrackets, <span class="keyword">int</span> rbrackets)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(lbrackets==rbrackets&amp;&amp;lbrackets==nCount){</span><br><span class="line">            res.push_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(lbrackets==rbrackets){</span><br><span class="line">            str+=<span class="string">'('</span>;</span><br><span class="line">            dfs(lbrackets+<span class="number">1</span>, rbrackets);</span><br><span class="line">            str.erase(str.length()<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">if</span>(lbrackets&lt;nCount){</span><br><span class="line">                str+=<span class="string">'('</span>;</span><br><span class="line">                dfs(lbrackets+<span class="number">1</span>, rbrackets);</span><br><span class="line">                str.erase(str.length()<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            str+=<span class="string">')'</span>;</span><br><span class="line">            dfs(lbrackets, rbrackets+<span class="number">1</span>);</span><br><span class="line">            str.erase(str.length()<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) {</span><br><span class="line">        nCount=n;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a>37. 解数独</h2></li>
</ul>
<p><strong>Description</strong><br>编写一个程序，通过已填充的空格来解决数独问题。<br>一个数独的解法需遵循如下规则：</p>
<ul>
<li>数字 1-9 在每一行只能出现一次。</li>
<li>数字 1-9 在每一列只能出现一次。</li>
<li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。<br>空白格用 ‘.’ 表示。<br><img src="/assets/img/algorithm/37_example_01.png" alt="image"><br>一个数独。<br><img src="/assets/img/algorithm/37_example_01.png" alt="image"><br>答案被标成红色。<br>Note:<br>给定的数独序列只包含数字 1-9 和字符 ‘.’ 。<br>你可以假设给定的数独只有唯一解。<br>给定数独永远是 9x9 形式的。</li>
</ul>
<p><strong>Program</strong><br><strong>回溯</strong><br>分别用三个数组进行行、列、九宫格标记<br>时间复杂度：$O((9!)^9)$，一行最多$9!$，总共9个九宫格。<br>空间复杂度：$O{1}$，确切的9*9级别。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> row[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">bool</span> col[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">bool</span> group[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; points;</span><br><span class="line">    <span class="keyword">bool</span> isSolution;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> k)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(k==points.size()){</span><br><span class="line">            isSolution=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> r=points[k].first;</span><br><span class="line">        <span class="keyword">int</span> c=points[k].second;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++){</span><br><span class="line">            <span class="keyword">if</span>(!row[r][i<span class="number">-1</span>]&amp;&amp;!col[c][i<span class="number">-1</span>]&amp;&amp;!group[r/<span class="number">3</span>][c/<span class="number">3</span>][i<span class="number">-1</span>]&amp;&amp;!isSolution){</span><br><span class="line">                row[r][i<span class="number">-1</span>]=col[c][i<span class="number">-1</span>]=group[r/<span class="number">3</span>][c/<span class="number">3</span>][i<span class="number">-1</span>]=<span class="literal">true</span>;</span><br><span class="line">                board[r][c]=i+<span class="string">'0'</span>;</span><br><span class="line">                dfs(board, k+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(!isSolution){</span><br><span class="line">                    board[r][c]=<span class="string">'.'</span>;</span><br><span class="line">                    row[r][i<span class="number">-1</span>]=col[c][i<span class="number">-1</span>]=group[r/<span class="number">3</span>][c/<span class="number">3</span>][i<span class="number">-1</span>]=<span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>{</span><br><span class="line">        <span class="built_in">memset</span>(row, <span class="literal">false</span>, <span class="keyword">sizeof</span>(row));</span><br><span class="line">        <span class="built_in">memset</span>(col, <span class="literal">false</span>, <span class="keyword">sizeof</span>(col));</span><br><span class="line">        <span class="built_in">memset</span>(group, <span class="literal">false</span>, <span class="keyword">sizeof</span>(group));</span><br><span class="line">        isSolution=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++){</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">'.'</span>){</span><br><span class="line">                    points.push_back({i, j});</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    <span class="keyword">int</span> x=board[i][j]-<span class="string">'0'</span><span class="number">-1</span>;</span><br><span class="line">                    row[i][x]=col[j][x]=group[i/<span class="number">3</span>][j/<span class="number">3</span>][x]=<span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(points.size()&gt;<span class="number">0</span>) dfs(board, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h2><p><strong>Description</strong><br>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的数字可以无限制重复被选取。<br>说明：<br>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。<br><strong>Example</strong><br>示例 1：<br>输入：candidates = [2,3,6,7], target = 7,<br>所求解集为：<br>[<br>  [7],<br>  [2,2,3]<br>]<br>示例 2：</p>
<p>输入：candidates = [2,3,5], target = 8,<br>所求解集为：<br>[<br>  [2,2,2,2],<br>  [2,3,3],<br>  [3,5]<br>]</p>
<p>提示：<br>1 &lt;= candidates.length &lt;= 30<br>1 &lt;= candidates[i] &lt;= 200<br>candidate 中的每个元素都是独一无二的。<br>1 &lt;= target &lt;= 500<br><strong>Program</strong><br><strong>深搜</strong><br>类似于多叉树搜索，这里使用递增排序，否则可以通过画图发现例如[2,3,5]，target=7，会出现{2,2,3}，{2,3,2},即选择当前元素会出现比之前已选择的元素小，<br>这种情况会出现重复，所以已经搜索过的不在搜索可以避免了这种问题，即设置start避免重复。<br><img src="/assets/img/algorithm/39_example_01.png" alt="image"><br>画出图以后，我看了一下，我这张图画出的结果有 44 个 00，对应的路径是 [[2, 2, 3], [2, 3, 2], [3, 2, 2], [7]]，而示例中的解集只有 [[7], [2, 2, 3]]，很显然，重复的原因是在较深层的结点值考虑了之前考虑过的元素，因此我们需要设置“下一轮搜索的起点”即可。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> start, <span class="keyword">int</span> target)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>){</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(candidates[i]&gt;target) <span class="keyword">break</span>; <span class="comment">//剪枝</span></span><br><span class="line">            vec.push_back(candidates[i]);</span><br><span class="line">            dfs(candidates, i, target-candidates[i]);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) {</span><br><span class="line">        n=candidates.size();</span><br><span class="line">        sort(candidates.begin(), candidates.end()); <span class="comment">//排序，方便剪枝！</span></span><br><span class="line">        dfs(candidates, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a>40. 组合总和 II</h2><p><strong>Description</strong><br>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的每个数字在每个组合中只能使用一次。<br>说明：<br>所有数字（包括目标数）都是正整数。<br>解集不能包含重复的组合。<br><strong>Example</strong><br>示例 1:<br>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>所求解集为:<br>[<br>  [1, 7],<br>  [1, 2, 5],<br>  [2, 6],<br>  [1, 1, 6]<br>]</p>
<p>示例 2:<br>输入: candidates = [2,5,2,1,2], target = 5,<br>所求解集为:<br>[<br>  [1,2,2],<br>  [5]<br>]<br><strong>Program</strong><br><strong>回溯+剪枝</strong><br><img src="/assets/img/algorithm/40_example_01.png" alt="image"><br>在上一题的避免重复的基础上，本题由于存在重复元素，根据上图所示同一层如果存在重复，只取一个即可！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> start, <span class="keyword">int</span> target)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>){</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(candidates[i]&gt;target) <span class="keyword">break</span>; <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;start&amp;&amp;candidates[i<span class="number">-1</span>]==candidates[i]) <span class="keyword">continue</span>;<span class="comment">//避免重复</span></span><br><span class="line">            vec.push_back(candidates[i]);</span><br><span class="line">            dfs(candidates, i+<span class="number">1</span>, target-candidates[i]);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) {</span><br><span class="line">        n=candidates.size();</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        dfs(candidates, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h2><p><strong>Description</strong><br>给定一个 没有重复 数字的序列，返回其所有可能的全排列。<br><strong>Example</strong><br>示例:<br>输入: [1,2,3]<br>输出:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(vec.size()==n){</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(!vis[i]){</span><br><span class="line">                vis[i]=<span class="literal">true</span>;</span><br><span class="line">                vec.push_back(nums[i]);</span><br><span class="line">                dfs(nums);</span><br><span class="line">                vec.pop_back();</span><br><span class="line">                vis[i]=<span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        n=nums.size();</span><br><span class="line">        vis.resize(n, <span class="literal">false</span>);</span><br><span class="line">        dfs(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a>47. 全排列 II</h2><p><strong>Description</strong><br>给定一个可包含重复数字的序列，返回所有不重复的全排列。<br><strong>Example</strong><br>示例:<br>输入: [1,1,2]<br>输出:<br>[<br>  [1,1,2],<br>  [1,2,1],<br>  [2,1,1]<br>]<br><strong>Program</strong><br><strong>思路</strong><br>首先画出dfs多叉树图，可以发现同一层次如果使用同一元素多次就会产生重复！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(vec.size()==n){</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//unordered_set&lt;int&gt; st; //同一层只能访问一次同一个值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(!vis[i]){</span><br><span class="line">                 <span class="comment">//if(st.count(nums[i])) continue;</span></span><br><span class="line">                 <span class="comment">//st.insert(nums[i]);</span></span><br><span class="line">                <span class="comment">//if(i&gt;0&amp;&amp;nums[i]==nums[i-1]&amp;&amp;!vis[i-1]) continue;//同一层只能访问一次同一个值，且访问只访问本层未访问的同层第一个</span></span><br><span class="line">                vis[i]=<span class="literal">true</span>;</span><br><span class="line">                vec.push_back(nums[i]);</span><br><span class="line">                dfs(nums);</span><br><span class="line">                vec.pop_back();</span><br><span class="line">                vis[i]=<span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        n=nums.size();</span><br><span class="line">        sort(nums.begin(), nums.end());<span class="comment">//为了更好的判断和剪枝</span></span><br><span class="line">        vis.resize(n, <span class="literal">false</span>);</span><br><span class="line">        dfs(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a>51. N 皇后</h2><p><strong>Description</strong><br>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br><img src="/assets/img/algorithm/8-queens.png" alt="image"><br>上图为 8 皇后问题的一种解法。<br>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。<br>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。<br><strong>Example</strong><br>示例：<br>输入：4<br>输出：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"> [".Q..",  // 解法 1</span><br><span class="line">  "...Q",</span><br><span class="line">  "Q...",</span><br><span class="line">  "..Q."],</span><br><span class="line"></span><br><span class="line"> ["..Q.",  // 解法 2</span><br><span class="line">  "Q...",</span><br><span class="line">  "...Q",</span><br><span class="line">  ".Q.."]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<p>解释: 4 皇后问题存在两个不同的解法。</p>
<p>提示：<br>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。<br><strong>Program</strong><br><strong>回溯</strong><br>（1）首先，对于第k行，我们需要遍历n列位置是否可以放置皇后，这里就需要之前k(从0开始)个皇后的位置queens；<br>（2）queens[i]表示第i行的皇后的列位置，有了queens就不需要列标记数组了，因为每次判断第k行的皇后位置时，都需要与之前的k个已放置皇后进行比较，列不冲突直接queens[j]==i即表示列冲突，abs(queens[j]-i)==abs(j-k)即表示斜线冲突；<br>时间复杂度：$O(n!)$<br>空间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; queens; <span class="comment">//queens[i]表示第i行的皇后的列位置，因为每一行只有一个皇后</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(k==N){</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;k;j++){ <span class="comment">//与前k个皇后比较位置</span></span><br><span class="line">                <span class="keyword">if</span>(queens[j]==i||<span class="built_in">abs</span>(queens[j]-i)==<span class="built_in">abs</span>(k-j)) <span class="keyword">break</span>; <span class="comment">//列或斜线重叠</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(j==k){ <span class="comment">//不冲突</span></span><br><span class="line">                vec[k][i]=<span class="string">'Q'</span>;</span><br><span class="line">                queens[k]=i;</span><br><span class="line">                dfs(k+<span class="number">1</span>);</span><br><span class="line">                queens[k]=<span class="number">0</span>;</span><br><span class="line">                vec[k][i]=<span class="string">'.'</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) {</span><br><span class="line">        N=n;</span><br><span class="line">        vec.resize(n);</span><br><span class="line">        queens.resize(n, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            str+=<span class="string">'.'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            vec[i]=str;</span><br><span class="line">        }</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>第二版</strong><br>（1）col[i]记录每一列;<br>（2）primary_diagonal[i]记录每一个主对角线，我们将左下角作为第一条主对角线，索引为0，那么对于[i,j]来说，其对应的主对角线下标为[j-i+n-1];<br>（2）secondary_diagonal[i]记录每一个副对角线，我们将左上角作为第一条副对角线，索引为0，那么对于[i,j]来说，其对应的副对角线下标为[i+j];</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; col, primary_diagonal, secondary_diagonal; <span class="comment">//列、主/副对角线</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> row)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(row==N){</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line">            <span class="keyword">if</span>(!col[i]&amp;&amp;!primary_diagonal[i-row+N<span class="number">-1</span>]&amp;&amp;!secondary_diagonal[row+i]){ <span class="comment">//不冲突</span></span><br><span class="line">                vec[row][i]=<span class="string">'Q'</span>;</span><br><span class="line">                col[i]=primary_diagonal[i-row+N<span class="number">-1</span>]=secondary_diagonal[row+i]=<span class="literal">true</span>;</span><br><span class="line">                dfs(row+<span class="number">1</span>);</span><br><span class="line">                col[i]=primary_diagonal[i-row+N<span class="number">-1</span>]=secondary_diagonal[row+i]=<span class="literal">false</span>;</span><br><span class="line">                vec[row][i]=<span class="string">'.'</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) {</span><br><span class="line">        N=n;</span><br><span class="line">        vec.resize(n);</span><br><span class="line">        col.resize(n, <span class="literal">false</span>);</span><br><span class="line">        primary_diagonal.resize(<span class="number">2</span>*n<span class="number">-1</span>, <span class="literal">false</span>);</span><br><span class="line">        secondary_diagonal.resize(<span class="number">2</span>*n<span class="number">-1</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            str+=<span class="string">'.'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            vec[i]=str;</span><br><span class="line">        }</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="52-N皇后-II"><a href="#52-N皇后-II" class="headerlink" title="52. N皇后 II"></a>52. N皇后 II</h2><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br><img src="/assets/img/algorithm/8-queens.png" alt="image"><br>上图为 8 皇后问题的一种解法。<br>给定一个整数 n，返回 n 皇后不同的解决方案的数量。<br><strong>Example</strong><br>示例:<br>输入: 4<br>输出: 2<br>解释: 4 皇后问题存在如下两个不同的解法。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&nbsp;[".Q..", &nbsp;// 解法 1</span><br><span class="line">&nbsp; "...Q",</span><br><span class="line">&nbsp; "Q...",</span><br><span class="line">&nbsp; "..Q."],</span><br><span class="line"></span><br><span class="line">&nbsp;["..Q.", &nbsp;// 解法 2</span><br><span class="line">&nbsp; "Q...",</span><br><span class="line">&nbsp; "...Q",</span><br><span class="line">&nbsp; ".Q.."]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<p>提示：<br>皇后，是国际象棋中的棋子，意味着国王的妻子。皇后只做一件事，那就是“吃子”。当她遇见可以吃的棋子时，就迅速冲上去吃掉棋子。当然，她横、竖、斜都可走一或 N-1 步，可进可退。（引用自 百度百科 - 皇后 ）<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; queens; <span class="comment">//queens[i]表示第i行的皇后的列位置，因为每一行只有一个皇后</span></span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(k==N){</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;k;j++){ <span class="comment">//与前k个皇后比较位置</span></span><br><span class="line">                <span class="keyword">if</span>(queens[j]==i||<span class="built_in">abs</span>(queens[j]-i)==<span class="built_in">abs</span>(k-j)) <span class="keyword">break</span>; <span class="comment">//列或斜线重叠</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(j==k){ <span class="comment">//不冲突</span></span><br><span class="line">                vec[k][i]=<span class="string">'Q'</span>;</span><br><span class="line">                queens[k]=i;</span><br><span class="line">                dfs(k+<span class="number">1</span>);</span><br><span class="line">                queens[k]=<span class="number">0</span>;</span><br><span class="line">                vec[k][i]=<span class="string">'.'</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        N=n;</span><br><span class="line">        vec.resize(n);</span><br><span class="line">        queens.resize(n, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            str+=<span class="string">'.'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            vec[i]=str;</span><br><span class="line">        }</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="60-第k个排列"><a href="#60-第k个排列" class="headerlink" title="60. 第k个排列"></a>60. 第k个排列</h2><p><strong>Description</strong><br>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。<br>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：<br>“123”<br>“132”<br>“213”<br>“231”<br>“312”<br>“321”<br>给定 n 和 k，返回第 k 个排列。</p>
<p>说明：</p>
<ul>
<li>给定 n 的范围是 [1, 9]。</li>
<li>给定 k 的范围是[1,  n!]。</li>
</ul>
<p><strong>Example</strong><br>示例 1:<br>输入: n = 3, k = 3<br>输出: “213”</p>
<p>示例 2:<br>输入: n = 4, k = 9<br>输出: “2314”<br><strong>Program</strong><br><strong>回溯+剪枝</strong><br>普通全排列的方法肯定超时，考虑如何剪枝，考虑每一层未选择的数字个数的阶乘cnt，<br>如果cnt&lt;k，说明该分治不能得到答案，k-=cnt；<br>如果cnt&gt;=k,说明在本分支内，进入下一层；<br>只要找到答案就不需要回溯！再次剪枝。<br>时间复杂度：$O(n^2)$，最差时间复杂度下是查找第n!个排列，第一层比较n-1次，第二层n-2次，…，以此类推。<br><img src="/assets/img/algorithm/60_example_01.png" alt="image"><br><img src="/assets/img/algorithm/60_example_02.png" alt="image"><br><img src="/assets/img/algorithm/60_example_03.png" alt="image"><br><img src="/assets/img/algorithm/60_example_04.png" alt="image"></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> K;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; factorial;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(str.length()==N){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> len=str.length();</span><br><span class="line">        <span class="keyword">int</span> cnt=factorial[N<span class="number">-1</span>-len];<span class="comment">//还有N-1-len个数字未确定</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++){</span><br><span class="line">            <span class="keyword">if</span>(!vis[i]){</span><br><span class="line">                <span class="keyword">if</span>(cnt&lt;K){ <span class="comment">//剪枝</span></span><br><span class="line">                    K-=cnt;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                str+=i+<span class="string">'0'</span>;</span><br><span class="line">                vis[i]=<span class="literal">true</span>;</span><br><span class="line">                dfs();</span><br><span class="line">                <span class="comment">//不回溯，相当于剪枝，找到一个就是最后的答案！</span></span><br><span class="line">                <span class="comment">// vis[i]=false;</span></span><br><span class="line">                <span class="comment">// str.erase(str.length()-1, 1);</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        K=k;</span><br><span class="line">        N=n;</span><br><span class="line">        vis.resize(n+<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        factorial.resize(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        factorial[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) factorial[i]=i*factorial[i<span class="number">-1</span>];</span><br><span class="line">        dfs();</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a>77. 组合</h2><p><strong>Description</strong><br>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。<br><strong>Example</strong><br>示例:<br>输入: n = 4, k = 2<br>输出:<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]<br><strong>Program</strong><br><strong>回溯+剪枝</strong><br>与之前做过的组合题类似，这里也是通过画图，从start开始往后遍历，因为往前遍历会出现组合重复！再者，继续分析图，可以发现，如果当前组合数量加上剩余元素的数量不够k，则没必要继续搜索了，剪枝！<br><img src="/assets/img/algorithm/77_example_01.png" alt="image"></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(vec.size()==k){</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=n;i++){ <span class="comment">//i从start开始也是剪枝，避免重复，因为是组合！</span></span><br><span class="line">            <span class="keyword">if</span>(n-start+<span class="number">1</span>+vec.size()&lt;k) <span class="keyword">break</span>;<span class="comment">//剪枝</span></span><br><span class="line">            vec.push_back(i);</span><br><span class="line">            dfs(n, k, i+<span class="number">1</span>);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) {</span><br><span class="line">        dfs(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a>79. 单词搜索</h2><p><strong>Description</strong><br>给定一个二维网格和一个单词，找出该单词是否存在于网格中。<br>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。<br><strong>Example</strong><br>示例:<br>board =<br>[<br>  [‘A’,’B’,’C’,’E’],<br>  [‘S’,’F’,’C’,’S’],<br>  [‘A’,’D’,’E’,’E’]<br>]<br>给定 word = “ABCCED”, 返回 true<br>给定 word = “SEE”, 返回 true<br>给定 word = “ABCB”, 返回 false</p>
<p>提示：<br>board 和 word 中只包含大写和小写英文字母。<br>1 &lt;= board.length &lt;= 200<br>1 &lt;= board[i].length &lt;= 200<br>1 &lt;= word.length &lt;= 10^3<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> steps[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="built_in">string</span> words;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(res.length()==words.length()){</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++){</span><br><span class="line">            <span class="keyword">int</span> new_x=x+steps[k][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> new_y=y+steps[k][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(new_x&gt;=<span class="number">0</span>&amp;&amp;new_x&lt;m&amp;&amp;new_y&gt;=<span class="number">0</span>&amp;&amp;new_y&lt;n</span><br><span class="line">                &amp;&amp;!vis[new_x][new_y]&amp;&amp;board[new_x][new_y]==words[res.length()]){</span><br><span class="line">                    res+=words[res.length()];</span><br><span class="line">                    vis[new_x][new_y]=<span class="literal">true</span>;</span><br><span class="line">                    dfs(board, new_x, new_y);</span><br><span class="line">                    <span class="keyword">if</span>(res.length()!=words.length()){</span><br><span class="line">                        res.erase(res.length()<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">                        vis[new_x][new_y]=<span class="literal">false</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>{</span><br><span class="line">        words=word;</span><br><span class="line">        m=board.size(), n=board[<span class="number">0</span>].size();</span><br><span class="line">        vis.resize(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">if</span>(res==<span class="string">""</span>&amp;&amp;board[i][j]==word[<span class="number">0</span>]){</span><br><span class="line">                    vis[i][j]=<span class="literal">true</span>;</span><br><span class="line">                    res=word[<span class="number">0</span>];</span><br><span class="line">                    dfs(board, i, j);</span><br><span class="line">                    <span class="keyword">if</span>(res!=words){</span><br><span class="line">                        vis[i][j]=<span class="literal">false</span>;</span><br><span class="line">                        res=<span class="string">""</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res==words;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="89-格雷编码"><a href="#89-格雷编码" class="headerlink" title="89. 格雷编码"></a>89. 格雷编码</h2><p><strong>Description</strong><br>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。<br>给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。<br>格雷编码序列必须以 0 开头。<br><strong>Example</strong><br>示例 1:<br>输入: 2<br>输出: [0,1,3,2]<br>解释:<br>00 - 0<br>01 - 1<br>11 - 3<br>10 - 2</p>
<p>对于给定的 n，其格雷编码序列并不唯一。<br>例如，[0,2,3,1] 也是一个有效的格雷编码序列。<br>00 - 0<br>10 - 2<br>11 - 3<br>01 - 1</p>
<p>示例 2:<br>输入: 0<br>输出: [0]<br>解释: 我们定义格雷编码序列必须以 0 开头。<br>     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。<br>     因此，当 n = 0 时，其格雷编码序列为 [0]。<br><strong>Program</strong><br><strong>递归</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sToi</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++) ans=ans*<span class="number">2</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="built_in">string</span> s=str;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'0'</span>) s[i]=<span class="string">'1'</span>;</span><br><span class="line">            <span class="keyword">else</span> s[i]=<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> x=sToi(s);</span><br><span class="line">            <span class="keyword">if</span>(vis.find(x)==vis.end()){</span><br><span class="line">                str=s;</span><br><span class="line">                vis.insert(x);</span><br><span class="line">                res.push_back(x);</span><br><span class="line">                dfs(n);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; grayCode(<span class="keyword">int</span> n) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) str+=<span class="string">'0'</span>;</span><br><span class="line">        vis.insert(<span class="number">0</span>);</span><br><span class="line">        res.push_back(<span class="number">0</span>);</span><br><span class="line">        dfs(n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>找规律</strong><br>设G[n]为n阶格雷码序列，则对G[n]倒序后，对每个元素二进制表示前导加1(变成n+1位了)得到R[n]，最终结果为G[n+1]=G[n]+R<a href="这里的加号表示并集">n</a>，时间复杂度由元素个数决定$O(2^n)$<br>例如：<br>n=0, [0]<br>n=1, [0,1]<br>n=2, [00,01,11,10]<br>n=3,[000,001,011,010,110,111,101,100]<br>…<br>以此类推！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; grayCode(<span class="keyword">int</span> n) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        res.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp=res;</span><br><span class="line">            reverse(tmp.begin(), tmp.end());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x:tmp){</span><br><span class="line">                x+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">                res.push_back(x);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a>90. 子集 II</h2><p><strong>Description</strong><br>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>说明：解集不能包含重复的子集。<br><strong>Example</strong><br>示例:<br>输入: [1,2,2]<br>输出:<br>[<br>  [2],<br>  [1],<br>  [1,2,2],<br>  [2,2],<br>  [1,2],<br>  []<br>]<br><strong>Program</strong><br><strong>回溯+剪枝</strong><br>（1）首先，排序剪枝常见套路；<br>（2）关键在于每一层每个节点都是一个结果，这个很关键！因为每一层的选择包含了前面不选则的结果。<br><img src="/assets/img/algorithm/90_example_01.png" alt="image"></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(start==n){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i&gt;start&amp;&amp;nums[i<span class="number">-1</span>]==nums[i]) <span class="keyword">continue</span>; <span class="comment">//剪枝, 同层去重！</span></span><br><span class="line">            <span class="comment">//选</span></span><br><span class="line">            vec.push_back(nums[i]);</span><br><span class="line">            res.push_back(vec); <span class="comment">//每一层每个节点都是一种结果！</span></span><br><span class="line">            dfs(nums, i+<span class="number">1</span>);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        sort(nums.begin(), nums.end()); <span class="comment">//便于剪枝</span></span><br><span class="line">        n=nums.size();</span><br><span class="line">        res.push_back({});<span class="comment">//空集</span></span><br><span class="line">        dfs(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93. 复原IP地址"></a>93. 复原IP地址</h2><p><strong>Description</strong><br>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。<br>有效的 IP 地址正好由四个整数（每个整数位于 0 到 255 之间组成），整数之间用 ‘.’ 分隔。<br><strong>Example</strong><br>示例:<br>输入: “25525511135”<br>输出: [“255.255.11.135”, “255.255.111.35”]<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; dq;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPass</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++){</span><br><span class="line">            ans=ans*<span class="number">10</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans&lt;=<span class="number">255</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> i, <span class="keyword">int</span> count)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(count&gt;<span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;n&amp;&amp;count==<span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(i==n&amp;&amp;count==<span class="number">4</span>){</span><br><span class="line">            <span class="built_in">string</span> str;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dq.size();i++){</span><br><span class="line">                str+=dq[i];</span><br><span class="line">                <span class="keyword">if</span>(i!=dq.size()<span class="number">-1</span>) str+=<span class="string">'.'</span>;</span><br><span class="line">            }</span><br><span class="line">            res.push_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n&amp;&amp;j&lt;i+<span class="number">3</span>;j++){</span><br><span class="line">            <span class="built_in">string</span> ss=s.substr(i,j-i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(ss.length()&gt;=<span class="number">2</span>&amp;&amp;ss[<span class="number">0</span>]==<span class="string">'0'</span>) <span class="keyword">break</span>;<span class="comment">//首元素不为零（长度大于等于2时）</span></span><br><span class="line">            <span class="keyword">if</span>(isPass(ss)){</span><br><span class="line">                dq.push_back(ss);</span><br><span class="line">                dfs(s, j+<span class="number">1</span>, count+<span class="number">1</span>);</span><br><span class="line">                dq.pop_back();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; restoreIpAddresses(<span class="built_in">string</span> s) {</span><br><span class="line">        n=s.length();</span><br><span class="line">        dfs(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a>131. 分割回文串</h2><p><strong>Description</strong><br>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。<br>返回 s 所有可能的分割方案。<br><strong>Example</strong><br>示例:<br>输入: “aab”<br>输出:<br>[<br>  [“aa”,”b”],<br>  [“a”,”a”,”b”]<br>]<br><strong>Program</strong><br><strong>错误思路</strong><br>将字符串二分，递归算出两部分的可划分的方案合并。<br>存在重复！，例如“aab”，划分为”a””ab”和”aa”,”b”后都会产生”a,a,b”这样的重复结果！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">if</span>(s[left]!=s[right]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; dfs(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right){</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(judge(s, left, right)) res.push_back({s.substr(left, right-left+<span class="number">1</span>)});</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;right;i++){</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; leftRes=dfs(s, left, i);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; rightRes=dfs(s, i+<span class="number">1</span>, right);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;leftRes.size();m++){</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmpRes(leftRes[m].begin(), leftRes[m].end());</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n&lt;rightRes.size();n++){</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;rightRes[n].size();k++){</span><br><span class="line">                        tmpRes.push_back(rightRes[n][k]);</span><br><span class="line">                    }</span><br><span class="line">                    res.push_back(tmpRes);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) {</span><br><span class="line">        <span class="keyword">return</span> dfs(s, <span class="number">0</span>, s.length()<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>回溯+剪枝+动规预处理</strong><br>因为需要全部划分为回文子串，可以从第一个子串入手，进行选择判断和回溯！还是老套路！<br><img src="/assets/img/algorithm/131_example_01.png" alt="image"></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; DP;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> start)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(start==n){</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(DP[start][i]){</span><br><span class="line">                <span class="built_in">string</span> str=s.substr(start, i-start+<span class="number">1</span>);</span><br><span class="line">                vec.push_back(str);</span><br><span class="line">                dfs(s, i+<span class="number">1</span>);</span><br><span class="line">                vec.pop_back();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) {</span><br><span class="line">        n=s.length();</span><br><span class="line">        DP.resize(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            DP[i][i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;s[i]==s[i<span class="number">-1</span>]) DP[i<span class="number">-1</span>][i]=<span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">3</span>;len&lt;=n;len++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+len<span class="number">-1</span>&lt;n;i++){</span><br><span class="line">                <span class="keyword">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j]) DP[i][j]=DP[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        dfs(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="140-单词拆分-II"><a href="#140-单词拆分-II" class="headerlink" title="140. 单词拆分 II"></a>140. 单词拆分 II</h2><p><strong>Description</strong><br>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。</p>
<p>说明：<br>分隔时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br><strong>Example</strong><br>示例 1：<br>输入:<br>s = “catsanddog”<br>wordDict = [“cat”, “cats”, “and”, “sand”, “dog”]<br>输出:<br>[<br>  “cats and dog”,<br>  “cat sand dog”<br>]</p>
<p>示例 2：<br>输入:<br>s = “pineapplepenapple”<br>wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”]<br>输出:<br>[<br>  “pine apple pen apple”,<br>  “pineapple pen apple”,<br>  “pine applepen apple”<br>]<br>解释: 注意你可以重复使用字典中的单词。</p>
<p>示例 3：<br>输入:<br>s = “catsandog”<br>wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出:<br>[]<br><strong>Program</strong><br><strong>DP+回溯</strong><br>首先计算DP，判断是否可以拆分到底，然后在回溯。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">const</span> <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict, <span class="keyword">int</span> end, <span class="keyword">int</span>* DP)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(end==<span class="number">0</span>){</span><br><span class="line">            res.push_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start=<span class="number">1</span>;start&lt;=end;start++){</span><br><span class="line">            <span class="keyword">if</span>(DP[start<span class="number">-1</span>]){ <span class="comment">//有解</span></span><br><span class="line">                <span class="built_in">string</span> word=s.substr(start<span class="number">-1</span>, end-start+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(wordDict.find(word)!=wordDict.end()){</span><br><span class="line">                    <span class="keyword">if</span>(str!=<span class="string">""</span>) str=word+<span class="string">" "</span>+str;</span><br><span class="line">                    <span class="keyword">else</span> str=word; <span class="comment">//最后一个单词</span></span><br><span class="line">                    dfs(s, wordDict, start<span class="number">-1</span>, DP);</span><br><span class="line">                    <span class="keyword">if</span>(str.find_first_of(<span class="string">' '</span>, <span class="number">0</span>)!=<span class="built_in">string</span>::npos) str=str.substr(word.length()+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span> str=<span class="string">""</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; wordBreak(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict) {</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; words(wordDict.begin(), wordDict.end());</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">int</span> DP[n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="literal">false</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        DP[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++){</span><br><span class="line">                <span class="built_in">string</span> word=s.substr(j, i-j);</span><br><span class="line">                <span class="keyword">if</span>(DP[j]&amp;&amp;words.find(word)!=words.end()){</span><br><span class="line">                    DP[i]=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">//已经为true了，剪枝</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(!DP[n]) <span class="keyword">return</span> {}; <span class="comment">//无解</span></span><br><span class="line">        dfs(s, words, s.length(), DP);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a>216. 组合总和 III</h2><p><strong>Description</strong><br>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p>
<p>说明：<br>所有数字都是正整数。<br>解集不能包含重复的组合。<br><strong>Example</strong><br>示例 1:<br>输入: k = 3, n = 7<br>输出: [[1,2,4]]</p>
<p>示例 2:<br>输入: k = 3, n = 9<br>输出: [[1,2,6], [1,3,5], [2,3,4]]<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> start)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(vec.size()==k&amp;&amp;sum==n){</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }  </span><br><span class="line">        <span class="keyword">if</span>(vec.size()&gt;=k) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=<span class="number">9</span>;i++){</span><br><span class="line">            <span class="keyword">if</span>(sum+i&gt;n) <span class="keyword">break</span>;</span><br><span class="line">            vec.push_back(i);</span><br><span class="line">            sum+=i;</span><br><span class="line">            dfs(k, n, i+<span class="number">1</span>);</span><br><span class="line">            sum-=i;</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) {</span><br><span class="line">        dfs(k,n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491. 递增子序列"></a>491. 递增子序列</h2><p><strong>Description</strong><br>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。<br><strong>Example</strong><br>示例:<br>输入: [4, 6, 7, 7]<br>输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</p>
<p>说明:<br>给定数组的长度不会超过15。<br>数组中的整数范围是 [-100,100]。<br>给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。<br><strong>Program</strong><br><strong>回溯+剪枝</strong><br>首先画出多叉树图，两个关键点：<br>（1）为了避免重复，那么同个父亲的孩子层不能存在重复元素，这里通过HashSet记录当前层已遍历的数字进行去重；<br>（2）由于题目是求递增序列，那么前面访问的元素再次访问，这里通过start索引解决；</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(vec.size()&gt;=<span class="number">2</span>){</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// if(start==n) return;</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(st.find(nums[i])!=st.end()) <span class="keyword">continue</span>; <span class="comment">//本层遍历过同一元素，避免重复</span></span><br><span class="line">            <span class="keyword">if</span>(vec.empty()||vec.back()&lt;=nums[i]){</span><br><span class="line">                vec.push_back(nums[i]);</span><br><span class="line">                st.insert(nums[i]);</span><br><span class="line">                dfs(nums, i+<span class="number">1</span>);</span><br><span class="line">                vec.pop_back();</span><br><span class="line">            }    </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findSubsequences(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        n=nums.size();</span><br><span class="line">        dfs(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="526-优美的排列"><a href="#526-优美的排列" class="headerlink" title="526. 优美的排列"></a>526. 优美的排列</h2><p><strong>Description</strong><br>假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 &lt;= i &lt;= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：</p>
<p>第 i 位的数字能被 i 整除<br>i 能被第 i 位上的数字整除<br>现在给定一个整数 N，请问可以构造多少个优美的排列？<br><strong>Example</strong><br>示例1:<br>输入: 2<br>输出: 2<br>解释:<br>第 1 个优美的排列是 [1, 2]:<br>  第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除<br>  第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除</p>
<p>第 2 个优美的排列是 [2, 1]:<br>  第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除<br>  第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除<br>说明:<br>N 是一个正整数，并且不会超过15。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(s==n){</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="keyword">if</span>(!vis[i]){</span><br><span class="line">                <span class="keyword">if</span>(((s+<span class="number">1</span>)%i==<span class="number">0</span>)||(i%(s+<span class="number">1</span>)==<span class="number">0</span>)){</span><br><span class="line">                    vis[i]=<span class="literal">true</span>;</span><br><span class="line">                    dfs(s+<span class="number">1</span>);</span><br><span class="line">                    vis[i]=<span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countArrangement</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        n=N;</span><br><span class="line">        vis.resize(n+<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>状态压缩DP</strong><br>设DP[i]为排列i的个数，其中i用二进制表示，例如1011表示数1,2,4被使用:<br>令j为待排列的数字(1…N)，那么i中第j-1位必须为0表示未用，状态转移方程：<br>DP[i|(1&lt;&lt;(j-1))]+=DP[i]，当i的第j-1位未使用，且j与s成倍数关系（s为当前待排的第s个数）</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countArrangement</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP(<span class="number">1</span>&lt;&lt;N, <span class="number">0</span>);</span><br><span class="line">        DP[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;N);i++){</span><br><span class="line">            <span class="keyword">int</span> s=<span class="number">0</span>; <span class="comment">//已经使用的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++){</span><br><span class="line">                s+=(i&gt;&gt;j)&amp;<span class="number">1</span>; <span class="comment">//第j位是否为1,1表示使用，0表示未使用</span></span><br><span class="line">            }</span><br><span class="line">            s++;<span class="comment">//正在使用的第s个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++){ <span class="comment">//遍历第s个数的可能值</span></span><br><span class="line">                <span class="keyword">if</span>(((i&gt;&gt;(j<span class="number">-1</span>))&amp;<span class="number">1</span>)==<span class="number">0</span>&amp;&amp;(j%s==<span class="number">0</span>||s%j==<span class="number">0</span>)){</span><br><span class="line">                    DP[i|(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))]+=DP[i];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[(<span class="number">1</span>&lt;&lt;N)<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="679-24-点游戏"><a href="#679-24-点游戏" class="headerlink" title="679. 24 点游戏"></a>679. 24 点游戏</h2><p><strong>Description</strong><br>你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 <em>，/，+，-，(，) 的运算得到 24。<br>*</em>Example**<br>示例 1:<br>输入: [4, 1, 8, 7]<br>输出: True<br>解释: (8-4) * (7-1) = 24</p>
<p>示例 2:<br>输入: [1, 2, 1, 2]<br>输出: False</p>
<p>注意:<br>除法运算符 / 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。<br>每个运算符对两个数进行运算。特别是我们不能用 - 作为一元运算符。例如，[1, 1, 1, 1] 作为输入时，表达式 -1 - 1 - 1 - 1 是不允许的。<br>你不能将数字连接在一起。例如，输入为 [1, 2, 1, 2] 时，不能写成 12 + 12 。<br><strong>Program</strong><br><strong>回溯</strong><br>每次选择两个数进行四则运算，结果放入数组进行下一次选择，最终只有一个数的时候判断绝对值是否满足$1e-6$精度。<br>剪枝：乘法和加法满足交换律，可以剪枝。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgePoint24</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            vec.push_back((<span class="keyword">double</span>)nums[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> isPass(vec);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPass</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; vec)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(vec.size()==<span class="number">1</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(vec[<span class="number">0</span>]<span class="number">-24.0</span>)&lt;=<span class="number">1e-6</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> n=vec.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">if</span>(i!=j){</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; tmpVec;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++){</span><br><span class="line">                        <span class="keyword">if</span>(k!=i&amp;&amp;k!=j) tmpVec.push_back(vec[k]);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++){</span><br><span class="line">                        <span class="keyword">if</span>((k==<span class="number">0</span>||k==<span class="number">2</span>)&amp;&amp;i&gt;j) <span class="keyword">continue</span>;<span class="comment">//加法和乘法可以剪枝，满足交换律</span></span><br><span class="line">                        <span class="keyword">if</span>(k==<span class="number">0</span>){</span><br><span class="line">                            tmpVec.push_back(vec[i]+vec[j]);</span><br><span class="line">                        }<span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">1</span>){</span><br><span class="line">                            tmpVec.push_back(vec[i]-vec[j]);</span><br><span class="line">                        }<span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">2</span>){</span><br><span class="line">                            tmpVec.push_back(vec[i]*vec[j]);</span><br><span class="line">                        }<span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">3</span>){</span><br><span class="line">                            <span class="keyword">if</span>(vec[j]==<span class="number">0</span>) <span class="keyword">break</span>;;</span><br><span class="line">                            tmpVec.push_back(vec[i]/vec[j]);</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">if</span>(isPass(tmpVec)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        tmpVec.pop_back();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="797-所有可能的路径"><a href="#797-所有可能的路径" class="headerlink" title="797. 所有可能的路径"></a>797. 所有可能的路径</h2><p><strong>Description</strong><br>给一个有 n 个结点的有向无环图，找到所有从 0 到 n-1 的路径并输出（不要求按顺序）<br>二维数组的第 i 个数组中的单元都表示有向图中 i 号结点所能到达的下一些结点（译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a ）空就是没有下一个结点了。<br><strong>Example</strong><br>示例 1：<br>输入：graph = [[1,2],[3],[3],[]]<br>输出：[[0,1,3],[0,2,3]]<br>解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3</p>
<p>示例 2：<br>输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]<br>输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]</p>
<p>示例 3：<br>输入：graph = [[1],[]]<br>输出：[[0,1]]</p>
<p>示例 4：<br>输入：graph = [[1,2,3],[2],[3],[]]<br>输出：[[0,1,2,3],[0,2,3],[0,3]]</p>
<p>示例 5：<br>输入：graph = [[1,3],[2],[3],[]]<br>输出：[[0,1,2,3],[0,3]]</p>
<p>提示：<br>结点的数量会在范围 [2, 15] 内。<br>你可以把路径以任意顺序输出，但在路径内的结点的顺序必须保证<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> u)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(u==n<span class="number">-1</span>){</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph[u].size();i++){</span><br><span class="line">            <span class="keyword">int</span> v=graph[u][i];</span><br><span class="line">            path.push_back(v);</span><br><span class="line">            dfs(graph, v);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; allPathsSourceTarget(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph) {</span><br><span class="line">        n=graph.size();</span><br><span class="line">        path.push_back(<span class="number">0</span>);</span><br><span class="line">        dfs(graph, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="980-不同路径-III"><a href="#980-不同路径-III" class="headerlink" title="980. 不同路径 III"></a>980. 不同路径 III</h2><p><strong>Description</strong><br>在二维网格 grid 上，有 4 种类型的方格：<br>1 表示起始方格。且只有一个起始方格。<br>2 表示结束方格，且只有一个结束方格。<br>0 表示我们可以走过的空方格。<br>-1 表示我们无法跨越的障碍。<br>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目。<br>每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格。<br><strong>Example</strong><br>示例 1：<br>输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]<br>输出：2<br>解释：我们有以下两条路径：</p>
<ol>
<li>(0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)</li>
<li>(0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</li>
</ol>
<p>示例 2：<br>输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]<br>输出：4<br>解释：我们有以下四条路径：</p>
<ol>
<li>(0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)</li>
<li>(0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)</li>
<li>(0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)</li>
<li>(0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)</li>
</ol>
<p>示例 3：<br>输入：[[0,1],[2,0]]<br>输出：0<br>解释：<br>没有一条路能完全穿过每一个空的方格一次。<br>请注意，起始和结束方格可以位于网格中的任意位置。</p>
<p>提示：<br>1 &lt;= grid.length * grid[0].length &lt;= 20<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> steps[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">int</span> nCount=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;m&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> count)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(grid[x][y]==<span class="number">2</span>){</span><br><span class="line">            <span class="keyword">if</span>(count+<span class="number">1</span>==nCount) ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        count+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line">            <span class="keyword">int</span> new_x=x+steps[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> new_y=y+steps[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(judge(new_x, new_y)&amp;&amp;grid[new_x][new_y]!=<span class="number">-1</span>){</span><br><span class="line">                <span class="keyword">int</span> tmp=grid[new_x][new_y];</span><br><span class="line">                grid[new_x][new_y]=(tmp!=<span class="number">2</span>?<span class="number">-1</span>:tmp);</span><br><span class="line">                dfs(grid, new_x, new_y, count);</span><br><span class="line">                grid[new_x][new_y]=tmp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsIII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>{</span><br><span class="line">        m=grid.size(), n=grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> s_x, s_y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]!=<span class="number">-1</span>) nCount++;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>){</span><br><span class="line">                    s_x=i;</span><br><span class="line">                    s_y=j;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        grid[s_x][s_y]=<span class="number">-1</span>;</span><br><span class="line">        dfs(grid, s_x, s_y, <span class="number">0</span>);</span><br><span class="line">        grid[s_x][s_y]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="996-正方形数组的数目"><a href="#996-正方形数组的数目" class="headerlink" title="996. 正方形数组的数目"></a>996. 正方形数组的数目</h2><p><strong>Description</strong><br>给定一个非负整数数组 A，如果该数组每对相邻元素之和是一个完全平方数，则称这一数组为正方形数组。<br>返回 A 的正方形排列的数目。两个排列 A1 和 A2 不同的充要条件是存在某个索引 i，使得 A1[i] != A2[i]。<br><strong>Example</strong><br>示例 1：<br>输入：[1,17,8]<br>输出：2<br>解释：<br>[1,8,17] 和 [17,8,1] 都是有效的排列。</p>
<p>示例 2：<br>输入：[2,2,2]<br>输出：1</p>
<p>提示：<br>1 &lt;= A.length &lt;= 12<br>0 &lt;= A[i] &lt;= 1e9<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> vis[<span class="number">12</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> a=(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(x);</span><br><span class="line">        <span class="keyword">return</span> a*a==x;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(vec.size()==n){</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> pre=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(pre!=<span class="number">-1</span>&amp;&amp;pre==A[i]) <span class="keyword">continue</span>; <span class="comment">//同一层不能出现两个一样的元素</span></span><br><span class="line">            <span class="keyword">if</span>(!vis[i]&amp;&amp;(vec.empty()||judge(vec.back()+A[i]))){</span><br><span class="line">                pre=A[i];</span><br><span class="line">                vis[i]=<span class="literal">true</span>;</span><br><span class="line">                vec.push_back(A[i]);</span><br><span class="line">                dfs(A);</span><br><span class="line">                vec.pop_back();</span><br><span class="line">                vis[i]=<span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquarefulPerms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>{</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        sort(A.begin(), A.end()); <span class="comment">//排序，方便剪枝</span></span><br><span class="line">        n=A.size();</span><br><span class="line">        dfs(A);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1079-活字印刷"><a href="#1079-活字印刷" class="headerlink" title="1079. 活字印刷"></a>1079. 活字印刷</h2><p><strong>Description</strong><br>你有一套活字字模 tiles，其中每个字模上都刻有一个字母 tiles[i]。返回你可以印出的非空字母序列的数目。<br>注意：本题中，每个活字字模只能使用一次。<br><strong>Example</strong><br>示例 1：<br>输入：”AAB”<br>输出：8<br>解释：可能的序列为 “A”, “B”, “AA”, “AB”, “BA”, “AAB”, “ABA”, “BAA”。</p>
<p>示例 2：<br>输入：”AAABBC”<br>输出：188</p>
<p>提示：<br>1 &lt;= tiles.length &lt;= 7<br>tiles 由大写英文字母组成<br><strong>Program</strong><br><strong>回溯</strong><br>首先画出多叉树图，可以发现剪枝项，与之前全排列、组合等类似套路，不同点在于这里字符串的组合允许顺序不同。<br>所以每次需要裁减子串进行递归，同时需要注意每个节点都是一种情况！！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> tiles)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tiles.length();i++){</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;tiles[i<span class="number">-1</span>]==tiles[i]) <span class="keyword">continue</span>; <span class="comment">//剪枝，同一层不允许选择同一种字母！</span></span><br><span class="line">            ans++;</span><br><span class="line">            <span class="built_in">string</span> str=tiles;</span><br><span class="line">            str=str.erase(i, <span class="number">1</span>);</span><br><span class="line">            dfs(str);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTilePossibilities</span><span class="params">(<span class="built_in">string</span> tiles)</span> </span>{</span><br><span class="line">        n=tiles.length();</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        sort(tiles.begin(), tiles.end()); <span class="comment">//排序，方便剪枝</span></span><br><span class="line">        dfs(tiles);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>进一步优化空间</strong><br>首先注意到上面每次递归是需要剔除原串中的某个字母，且每层只能访问不同的字母，这样直接可以用ch[26]数组分别表示原串中各个字母的个数，然后进行递归！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++){</span><br><span class="line">            <span class="keyword">if</span>(ch[i]&gt;<span class="number">0</span>){</span><br><span class="line">                ans++;</span><br><span class="line">                ch[i]--;</span><br><span class="line">                dfs();</span><br><span class="line">                ch[i]++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTilePossibilities</span><span class="params">(<span class="built_in">string</span> tiles)</span> </span>{</span><br><span class="line">        <span class="built_in">memset</span>(ch, <span class="number">0</span>, <span class="keyword">sizeof</span>(ch));</span><br><span class="line">        n=tiles.length();</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) ch[tiles[i]-<span class="string">'A'</span>]++;</span><br><span class="line">        dfs();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1219-黄金矿工"><a href="#1219-黄金矿工" class="headerlink" title="1219. 黄金矿工"></a>1219. 黄金矿工</h2><p><strong>Description</strong><br>你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。<br>为了使收益最大化，矿工需要按以下规则来开采黄金：</p>
<ul>
<li>每当矿工进入一个单元，就会收集该单元格中的所有黄金。</li>
<li>矿工每次可以从当前位置向上下左右四个方向走。</li>
<li>每个单元格只能被开采（进入）一次。</li>
<li>不得开采（进入）黄金数目为 0 的单元格。</li>
<li>矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止。</li>
</ul>
<p><strong>Example</strong><br>示例 1：<br>输入：grid = [[0,6,0],[5,8,7],[0,9,0]]<br>输出：24<br>解释：<br>[[0,6,0],<br> [5,8,7],<br> [0,9,0]]<br>一种收集最多黄金的路线是：9 -&gt; 8 -&gt; 7。</p>
<p>示例 2：<br>输入：grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]<br>输出：28<br>解释：<br>[[1,0,7],<br> [2,0,6],<br> [3,4,5],<br> [0,3,0],<br> [9,0,20]]<br>一种收集最多黄金的路线是：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7。</p>
<p>提示：<br>1 &lt;= grid.length, grid[i].length &lt;= 15<br>0 &lt;= grid[i][j] &lt;= 100<br>最多 25 个单元格中有黄金。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> steps[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">-1</span>,<span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>,<span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,<span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line">            <span class="keyword">int</span> new_x=x+steps[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> new_y=y+steps[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(new_x&gt;=<span class="number">0</span>&amp;&amp;new_x&lt;m&amp;&amp;new_y&gt;=<span class="number">0</span>&amp;&amp;new_y&lt;n&amp;&amp;grid[new_x][new_y]&gt;<span class="number">0</span>){</span><br><span class="line">                now+=grid[new_x][new_y];</span><br><span class="line">                grid[new_x][new_y]=-grid[new_x][new_y];</span><br><span class="line">                dfs(grid, new_x, new_y);</span><br><span class="line">                grid[new_x][new_y]=-grid[new_x][new_y];</span><br><span class="line">                now-=grid[new_x][new_y];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        ans=max(ans, now);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaximumGold</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>{</span><br><span class="line">        m=grid.size(), n=grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]&gt;<span class="number">0</span>){</span><br><span class="line">                    now+=grid[i][j];</span><br><span class="line">                    grid[i][j]=-grid[i][j];</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                    grid[i][j]=-grid[i][j];</span><br><span class="line">                    now-=grid[i][j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1415-长度为-n-的开心字符串中字典序第-k-小的字符串"><a href="#1415-长度为-n-的开心字符串中字典序第-k-小的字符串" class="headerlink" title="1415. 长度为 n 的开心字符串中字典序第 k 小的字符串"></a>1415. 长度为 n 的开心字符串中字典序第 k 小的字符串</h2><p><strong>Description</strong><br>一个 「开心字符串」定义为：</p>
<ul>
<li>仅包含小写字母 [‘a’, ‘b’, ‘c’].</li>
<li>对所有在 1 到 s.length - 1 之间的 i ，满足 s[i] != s[i + 1] （字符串的下标从 1 开始）。<br>比方说，字符串 “abc”，”ac”，”b” 和 “abcbabcbcb” 都是开心字符串，但是 “aa”，”baa” 和 “ababbc” 都不是开心字符串。</li>
</ul>
<p>给你两个整数 n 和 k ，你需要将长度为 n 的所有开心字符串按字典序排序。<br>请你返回排序后的第 k 个开心字符串，如果长度为 n 的开心字符串少于 k 个，那么请你返回 空字符串 。<br><strong>Example</strong><br>示例 1：<br>输入：n = 1, k = 3<br>输出：”c”<br>解释：列表 [“a”, “b”, “c”] 包含了所有长度为 1 的开心字符串。按照字典序排序后第三个字符串为 “c” 。</p>
<p>示例 2：<br>输入：n = 1, k = 4<br>输出：””<br>解释：长度为 1 的开心字符串只有 3 个。</p>
<p>示例 3：<br>输入：n = 3, k = 9<br>输出：”cab”<br>解释：长度为 3 的开心字符串总共有 12 个 [“aba”, “abc”, “aca”, “acb”, “bab”, “bac”, “bca”, “bcb”, “cab”, “cac”, “cba”, “cbc”] 。第 9 个字符串为 “cab”</p>
<p>示例 4：<br>输入：n = 2, k = 7<br>输出：””</p>
<p>示例 5：<br>输入：n = 10, k = 100<br>输出：”abacbabacb”</p>
<p>提示：<br>1 &lt;= n &lt;= 10<br>1 &lt;= k &lt;= 100<br><strong>Program</strong><br><strong>深搜+剪枝</strong><br>（1）一个基本想法是深搜，回溯保存结果，但是太慢了，没必要；<br>（2）画出多叉树图，可以发现如果该分支的子树的叶子节点个数比k小，可以直接跳过，k-=ans；<br>（3）k&gt;ans时，说明在该子树上找到结果，继续该子树的递归，知道结果字符串长度为n。<br>时间复杂度：$O(n)$，只与第一层“a,b,c”以及后面子树层高有关，即$O(3+2*(n-1))$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> n=res.length();</span><br><span class="line">        <span class="keyword">if</span>(n==N) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch=<span class="string">'a'</span>;ch&lt;=<span class="string">'c'</span>;ch++){</span><br><span class="line">            <span class="keyword">if</span>(n&gt;<span class="number">0</span>&amp;&amp;res[n<span class="number">-1</span>]==ch) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> ans=(<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>, N<span class="number">-1</span>-n);</span><br><span class="line">            <span class="keyword">if</span>(ans&lt;k){ <span class="comment">//剪枝</span></span><br><span class="line">                k-=ans;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            res+=ch;</span><br><span class="line">            dfs(k);</span><br><span class="line">            <span class="keyword">if</span>(res.length()==N) <span class="keyword">break</span>; <span class="comment">//剪枝</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getHappyString</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">3</span>*((<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>,n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">if</span>(ans&lt;k) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        N=n;</span><br><span class="line">        dfs(k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="5520-拆分字符串使唯一子字符串的数目最大"><a href="#5520-拆分字符串使唯一子字符串的数目最大" class="headerlink" title="5520. 拆分字符串使唯一子字符串的数目最大"></a>5520. 拆分字符串使唯一子字符串的数目最大</h2><p><strong>Description</strong><br>给你一个字符串 s ，请你拆分该字符串，并返回拆分后唯一子字符串的最大数目。<br>字符串 s 拆分后可以得到若干 非空子字符串 ，这些子字符串连接后应当能够还原为原字符串。但是拆分出来的每个子字符串都必须是 唯一的 。<br>注意：子字符串 是字符串中的一个连续字符序列。<br><strong>Example</strong><br>示例 1：<br>输入：s = “ababccc”<br>输出：5<br>解释：一种最大拆分方法为 [‘a’, ‘b’, ‘ab’, ‘c’, ‘cc’] 。像 [‘a’, ‘b’, ‘a’, ‘b’, ‘c’, ‘cc’] 这样拆分不满足题目要求，因为其中的 ‘a’ 和 ‘b’ 都出现了不止一次。</p>
<p>示例 2：<br>输入：s = “aba”<br>输出：2<br>解释：一种最大拆分方法为 [‘a’, ‘ba’] 。</p>
<p>示例 3：<br>输入：s = “aa”<br>输出：1<br>解释：无法进一步拆分字符串。</p>
<p>提示：<br>1 &lt;= s.length &lt;= 16<br>s 仅包含小写英文字母<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; st;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> start)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(start==n){</span><br><span class="line">            ans=max(ans, size);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;n;i++){</span><br><span class="line">            <span class="built_in">string</span> str=s.substr(start, i-start+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(st.find(str)!=st.end()) <span class="keyword">continue</span>;</span><br><span class="line">            st.insert(str);</span><br><span class="line">            size++;</span><br><span class="line">            dfs(s, i+<span class="number">1</span>);</span><br><span class="line">            size--;</span><br><span class="line">            st.erase(str);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxUniqueSplit</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        n=s.length();</span><br><span class="line">        ans=size=<span class="number">0</span>;</span><br><span class="line">        dfs(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a>剑指 Offer 38. 字符串的排列</h2><p><strong>Description</strong><br>输入一个字符串，打印出该字符串中字符的所有排列。<br>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。<br><strong>Example</strong><br>示例:<br>输入：s = “abc”<br>输出：[“abc”,”acb”,”bac”,”bca”,”cab”,”cba”]</p>
<p>限制：<br>1 &lt;= s 的长度 &lt;= 8<br><strong>Program</strong><br><strong>回溯+剪枝</strong><br>注意s可能存在重复元素，所以要先排序，然后画出多叉树图，同层不能选择重复元素即可！<br>时间复杂度：$O(N!)$，排列数！<br>空间复杂度：$O(N^2)$，栈$O(N)$，而辅助s为$N+N-1+N-2+…+1$为$O(N^2)$。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(str.length()==n){</span><br><span class="line">            res.push_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> len=s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++){</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;s[i<span class="number">-1</span>]==s[i]) <span class="keyword">continue</span>; <span class="comment">//同一层不能选择重复元素！</span></span><br><span class="line">            <span class="built_in">string</span> tmp=s; tmp.erase(i,<span class="number">1</span>);</span><br><span class="line">            str+=s[i];</span><br><span class="line">            dfs(tmp);</span><br><span class="line">            str.erase(str.length()<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; permutation(<span class="built_in">string</span> s) {</span><br><span class="line">        sort(s.begin(), s.end()); <span class="comment">//排序将相同字符放在一块，方便剪枝</span></span><br><span class="line">        n=s.length();</span><br><span class="line">        dfs(s);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="面试题-08-04-幂集"><a href="#面试题-08-04-幂集" class="headerlink" title="面试题 08.04. 幂集"></a>面试题 08.04. 幂集</h2><p><strong>Description</strong><br>幂集。编写一种方法，返回某集合的所有子集。集合中不包含重复的元素。<br>说明：解集不能包含重复的子集。<br><strong>Example</strong><br>示例:<br> 输入： nums = [1,2,3]<br> 输出：<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]<br><strong>Program</strong><br><strong>回溯</strong><br>多叉树图上每个节点都是一个结果，注意每一层不能重复选择。<br>时间复杂度：$O(2^n)$<br>空间复杂度：$O(n)$，数组和递归栈都为$O(n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;n;i++){</span><br><span class="line">            vec.push_back(nums[i]);</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            dfs(nums, i+<span class="number">1</span>);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        n=nums.size();</span><br><span class="line">        res.push_back({}); <span class="comment">//空集</span></span><br><span class="line">        dfs(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="面试题-08-07-无重复字符串的排列组合"><a href="#面试题-08-07-无重复字符串的排列组合" class="headerlink" title="面试题 08.07. 无重复字符串的排列组合"></a>面试题 08.07. 无重复字符串的排列组合</h2><p><strong>Description</strong><br>无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。<br><strong>Example</strong><br>示例1:<br> 输入：S = “qwe”<br> 输出：[“qwe”, “qew”, “wqe”, “weq”, “ewq”, “eqw”]</p>
<p>示例2:<br> 输入：S = “ab”<br> 输出：[“ab”, “ba”]</p>
<p>提示:<br>字符都是英文字母。<br>字符串长度在[1, 9]之间。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(str.length()==n){</span><br><span class="line">            res.push_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it=m.begin();</span><br><span class="line">        <span class="keyword">for</span>(;it!=m.end();it++){</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second&gt;<span class="number">0</span>){</span><br><span class="line">                str+=it-&gt;first;</span><br><span class="line">                it-&gt;second--;</span><br><span class="line">                dfs();</span><br><span class="line">                str.erase(str.length()<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">                it-&gt;second++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; permutation(<span class="built_in">string</span> S) {</span><br><span class="line">        n=S.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:S) m[ch]++;</span><br><span class="line">        dfs();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="面试题-08-08-有重复字符串的排列组合"><a href="#面试题-08-08-有重复字符串的排列组合" class="headerlink" title="面试题 08.08. 有重复字符串的排列组合"></a>面试题 08.08. 有重复字符串的排列组合</h2><p><strong>Description</strong><br>有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。<br><strong>Example</strong><br>示例1:<br> 输入：S = “qqe”<br> 输出：[“eqq”,”qeq”,”qqe”]</p>
<p>示例2:<br> 输入：S = “ab”<br> 输出：[“ab”, “ba”]</p>
<p>提示:<br>字符都是英文字母。<br>字符串长度在[1, 9]之间。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> chs[<span class="number">52</span>]; <span class="comment">//大小写字母计数</span></span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(str.length()==n){</span><br><span class="line">            res.push_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">52</span>;i++){</span><br><span class="line">            <span class="keyword">if</span>(chs[i]&gt;<span class="number">0</span>){</span><br><span class="line">                chs[i]--;</span><br><span class="line">                <span class="keyword">char</span> ch=(i&lt;=<span class="number">25</span>?i+<span class="string">'a'</span>:i<span class="number">-26</span>+<span class="string">'A'</span>);</span><br><span class="line">                str+=ch;</span><br><span class="line">                dfs();</span><br><span class="line">                str.erase(str.length()<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">                chs[i]++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; permutation(<span class="built_in">string</span> S) {</span><br><span class="line">        n=S.length();</span><br><span class="line">        <span class="built_in">memset</span>(chs, <span class="number">0</span>, <span class="keyword">sizeof</span>(chs));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:S){</span><br><span class="line">            <span class="keyword">if</span>(ch&gt;=<span class="string">'a'</span>&amp;&amp;ch&lt;=<span class="string">'z'</span>) chs[ch-<span class="string">'a'</span>]++;</span><br><span class="line">            <span class="keyword">else</span> chs[ch-<span class="string">'A'</span>+<span class="number">26</span>]++;</span><br><span class="line">        }</span><br><span class="line">        dfs();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="面试题-08-09-括号"><a href="#面试题-08-09-括号" class="headerlink" title="面试题 08.09. 括号"></a>面试题 08.09. 括号</h2><p><strong>Description</strong><br>括号。设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。<br>说明：解集不能包含重复的子集。<br><strong>Example</strong><br>例如，给出 n = 3，生成结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  "((()))",</span><br><span class="line">  "(()())",</span><br><span class="line">  "(())()",</span><br><span class="line">  "()(())",</span><br><span class="line">  "()()()"</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> lBrace, rBrace;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(lBrace==<span class="number">0</span>&amp;&amp;rBrace==<span class="number">0</span>){</span><br><span class="line">            res.push_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(lBrace==rBrace){</span><br><span class="line">            lBrace--;</span><br><span class="line">            str+=<span class="string">'('</span>;</span><br><span class="line">            dfs();</span><br><span class="line">            str.erase(str.length()<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">            lBrace++;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">if</span>(lBrace&gt;<span class="number">0</span>){</span><br><span class="line">                lBrace--;</span><br><span class="line">                str+=<span class="string">'('</span>;</span><br><span class="line">                dfs();</span><br><span class="line">                str.erase(str.length()<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">                lBrace++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(rBrace&gt;<span class="number">0</span>){</span><br><span class="line">                rBrace--;</span><br><span class="line">                str+=<span class="string">')'</span>;</span><br><span class="line">                dfs();</span><br><span class="line">                str.erase(str.length()<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">                rBrace++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) {</span><br><span class="line">        lBrace=rBrace=n;</span><br><span class="line">        dfs();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="面试题-08-12-八皇后"><a href="#面试题-08-12-八皇后" class="headerlink" title="面试题 08.12. 八皇后"></a>面试题 08.12. 八皇后</h2><p><strong>Description</strong><br>设计一种算法，打印 N 皇后在 N × N 棋盘上的各种摆法，其中每个皇后都不同行、不同列，也不在对角线上。这里的“对角线”指的是所有的对角线，不只是平分整个棋盘的那两条对角线。<br>注意：本题相对原题做了扩展<br><strong>Example</strong><br>示例:<br> 输入：4<br> 输出：[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]<br> 解释: 4 皇后问题存在如下两个不同的解法。<br>[<br> [“.Q..”,  // 解法 1<br>  “…Q”,<br>  “Q…”,<br>  “..Q.”],</p>
<p> [“..Q.”,  // 解法 2<br>  “Q…”,<br>  “…Q”,<br>  “.Q..”]<br>]<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; col, primary_diagonal, secondary_diagonal; <span class="comment">//列、主/副对角线</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> row)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(row==N){</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line">            <span class="keyword">if</span>(!col[i]&amp;&amp;!primary_diagonal[i-row+N<span class="number">-1</span>]&amp;&amp;!secondary_diagonal[row+i]){ <span class="comment">//不冲突</span></span><br><span class="line">                vec[row][i]=<span class="string">'Q'</span>;</span><br><span class="line">                col[i]=primary_diagonal[i-row+N<span class="number">-1</span>]=secondary_diagonal[row+i]=<span class="literal">true</span>;</span><br><span class="line">                dfs(row+<span class="number">1</span>);</span><br><span class="line">                col[i]=primary_diagonal[i-row+N<span class="number">-1</span>]=secondary_diagonal[row+i]=<span class="literal">false</span>;</span><br><span class="line">                vec[row][i]=<span class="string">'.'</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) {</span><br><span class="line">        N=n;</span><br><span class="line">        vec.resize(n);</span><br><span class="line">        col.resize(n, <span class="literal">false</span>);</span><br><span class="line">        primary_diagonal.resize(<span class="number">2</span>*n<span class="number">-1</span>, <span class="literal">false</span>);</span><br><span class="line">        secondary_diagonal.resize(<span class="number">2</span>*n<span class="number">-1</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            str+=<span class="string">'.'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            vec[i]=str;</span><br><span class="line">        }</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1></blockquote>
<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><p><strong>Description</strong><br>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<br><strong>Example</strong><br>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]<br><strong>Program</strong><br>Hash只记录最后一次nums[i]出现的位置，之后判断即可。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) {</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++){</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(m.find(target-nums[i])!=m.end()){</span><br><span class="line">                <span class="keyword">if</span>(nums[i]!=target-nums[i]||(nums[i]==target-nums[i]&amp;&amp;m[nums[i]]!=i)){</span><br><span class="line">                    result.push_back(i);</span><br><span class="line">                    result.push_back(m[target-nums[i]]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>方法：反转一半数字<br>思路</strong><br>映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。<br>第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。<br>但是，如果反转后的数字大于 $\text{int.MAX}int.MAX$，我们将遇到整数溢出问题。<br>按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 \text{int}int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。<br>例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。<br>让我们看看如何将这个想法转化为一个算法。<br><strong>算法</strong><br>首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。<br>现在，让我们来考虑如何反转后半部分的数字。<br>对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。<br>现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？<br>我们将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字。<br><strong>时间复杂度：</strong>对于每次迭代，我们会将输入除以10，因此时间复杂度为$O\left(\log_{10}{n}\right)$<br><strong>空间复杂度：</strong>$O\left(1\right)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||(x%<span class="number">10</span>==<span class="number">0</span>&amp;&amp;x!=<span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> reverseNum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;reverseNum){</span><br><span class="line">            reverseNum=reverseNum*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> x==reverseNum || x==reverseNum/<span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13.罗马数字转整数"></a>13.罗马数字转整数</h2><p><strong>Description</strong><br>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。<br>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>
<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li>
<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</li>
</ul>
<p><strong>Example</strong><br>示例 1:<br>输入: “III”<br>输出: 3</p>
<p>示例 2:<br>输入: “IV”<br>输出: 4</p>
<p>示例 3:<br>输入: “IX”<br>输出: 9</p>
<p>示例 4:<br>输入: “LVIII”<br>输出: 58<br>解释: L = 50, V= 5, III = 3.</p>
<p>示例 5:<br>输入: “MCMXCIV”<br>输出: 1994<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.<br><strong>Program</strong><br>代码行数：解析<br>构建一个字典记录所有罗马数字子串，注意长度为2的子串记录的值是（实际值 - 子串内左边罗马数字代表的数值）<br>这样一来，遍历整个 ss 的时候判断当前位置和后一个位置的两个字符组成的字符串是否在字典内，如果在就记录值，不在就说明当前位置不存在小数字在前面的情况，直接记录当前位置字符对应值</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m={</span><br><span class="line">            {<span class="string">"I"</span>, <span class="number">1</span>},</span><br><span class="line">            {<span class="string">"IV"</span>, <span class="number">4</span>},</span><br><span class="line">            {<span class="string">"IX"</span>, <span class="number">9</span>},</span><br><span class="line">            {<span class="string">"V"</span>, <span class="number">5</span>},</span><br><span class="line">            {<span class="string">"X"</span>, <span class="number">10</span>},</span><br><span class="line">            {<span class="string">"XL"</span>, <span class="number">40</span>},</span><br><span class="line">            {<span class="string">"XC"</span>, <span class="number">90</span>},</span><br><span class="line">            {<span class="string">"L"</span>, <span class="number">50</span>},</span><br><span class="line">            {<span class="string">"C"</span>, <span class="number">100</span>},</span><br><span class="line">            {<span class="string">"CD"</span>, <span class="number">400</span>},</span><br><span class="line">            {<span class="string">"CM"</span>, <span class="number">900</span>},</span><br><span class="line">            {<span class="string">"D"</span>, <span class="number">500</span>},</span><br><span class="line">            {<span class="string">"M"</span>, <span class="number">1000</span>}</span><br><span class="line">        };</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();){</span><br><span class="line">            <span class="built_in">string</span> s1=s.substr(i, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(i&lt;s.length()<span class="number">-1</span>){</span><br><span class="line">                <span class="built_in">string</span> s2 = s.substr(i, <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">if</span>(m.find(s2)!=m.end()){</span><br><span class="line">                    result+=m[s2];</span><br><span class="line">                    i+=<span class="number">2</span>;</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    result+=m[s1];</span><br><span class="line">                    i++;</span><br><span class="line">                }</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                result+=m[s1];</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h2><p><strong>Description</strong><br>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。<br><strong>Example</strong><br>示例 1:<br>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”</p>
<p>示例 2:<br>输入: [“dog”,”racecar”,”car”]<br>输出: “”<br>解释: 输入不存在公共前缀。<br>说明:<br>所有输入只包含小写字母 a-z 。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp; s2)</span></span>{</span><br><span class="line">        <span class="built_in">string</span> result=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s1.length()&amp;&amp;i&lt;s2.length();i++){</span><br><span class="line">            <span class="keyword">if</span>(s1[i]!=s2[i]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> result+=s1[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(strs.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> result=strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;strs.size();i++){</span><br><span class="line">            result=cmp(result, strs[i]);</span><br><span class="line">            <span class="keyword">if</span>(result.length()==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><p><strong>Description</strong><br>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。<br><strong>Example</strong><br>示例 1:<br>输入: “()”<br>输出: true</p>
<p>示例 2:<br>输入: “()[]{}”<br>输出: true</p>
<p>示例 3:<br>输入: “(]”<br>输出: false</p>
<p>示例 4:<br>输入: “([)]”<br>输出: false</p>
<p>示例 5:<br>输入: “{[]}”<br>输出: true<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt; sToe={</span><br><span class="line">            {<span class="string">'('</span>, <span class="string">')'</span>},</span><br><span class="line">            {<span class="string">'{'</span>, <span class="string">'}'</span>},</span><br><span class="line">            {<span class="string">'['</span>, <span class="string">']'</span>}</span><br><span class="line">        };</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++){</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=<span class="string">']'</span></span><br><span class="line">            &amp;&amp;s[i]!=<span class="string">')'</span></span><br><span class="line">            &amp;&amp;s[i]!=<span class="string">'\}'</span>) {</span><br><span class="line">                st.push(s[i]);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">if</span>(st.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span>{</span><br><span class="line">                    <span class="keyword">char</span> ch=st.top();</span><br><span class="line">                    st.pop();</span><br><span class="line">                    <span class="keyword">if</span>(sToe[ch]!=s[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(!st.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h2><p><strong>Description</strong><br>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br><strong>Example</strong><br>示例：<br>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        ListNode* node=<span class="keyword">new</span> ListNode(val);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>{</span><br><span class="line">        ListNode* result=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* tmp=result;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span>&amp;&amp;l2!=<span class="literal">NULL</span>){</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val&lt;=l2-&gt;val){</span><br><span class="line">                tmp-&gt;next=newNode(l1-&gt;val);</span><br><span class="line">                tmp=tmp-&gt;next;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                tmp-&gt;next=newNode(l2-&gt;val);</span><br><span class="line">                tmp=tmp-&gt;next;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span>){</span><br><span class="line">            tmp-&gt;next=newNode(l1-&gt;val);</span><br><span class="line">            tmp=tmp-&gt;next;</span><br><span class="line">            l1=l1-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(l2!=<span class="literal">NULL</span>){</span><br><span class="line">            tmp-&gt;next=newNode(l2-&gt;val);</span><br><span class="line">            tmp=tmp-&gt;next;</span><br><span class="line">            l2=l2-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(result-&gt;next!=<span class="literal">NULL</span>) result=result-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> result=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a>26. 删除排序数组中的重复项</h2><p><strong>Description</strong><br>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br><strong>Example</strong><br>示例 1:<br>给定数组 nums = [1,1,2],<br>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。<br>你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 2:<br>给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br>你不需要考虑数组中超出新长度后面的元素。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=nums[i<span class="number">-1</span>]){</span><br><span class="line">                nums[++idx]=nums[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> idx+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h2><p><strong>Description</strong><br>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。<br><strong>Example</strong><br>示例 1:<br>给定 nums = [3,2,2,3], val = 3,<br>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。<br>你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 2:<br>给定 nums = [0,1,2,2,3,0,4,2], val = 2,<br>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。<br>注意这五个元素可为任意顺序。<br>你不需要考虑数组中超出新长度后面的元素。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=val){</span><br><span class="line">                nums[++idx]=nums[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> idx+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28. 实现strStr"></a>28. 实现strStr</h2><p><strong>Description</strong><br>现 strStr() 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。<br><strong>Example</strong><br>示例 1:<br>输入: haystack = “hello”, needle = “ll”<br>输出: 2</p>
<p>示例 2:<br>输入: haystack = “aaaaa”, needle = “bba”<br>输出: -1<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span>* <span class="title">getNextval</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str)</span></span>{</span><br><span class="line">        <span class="keyword">int</span>* nextval=<span class="keyword">new</span> <span class="keyword">int</span>[str.length()];</span><br><span class="line">        nextval[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=nextval[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;str.length();i++){</span><br><span class="line">            <span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;str[i]!=str[j+<span class="number">1</span>]){</span><br><span class="line">                j=nextval[j];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(str[i]==str[j+<span class="number">1</span>]){</span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">-1</span>||str[i+<span class="number">1</span>]!=str[j+<span class="number">1</span>]){</span><br><span class="line">                nextval[i]=j;</span><br><span class="line">            }<span class="keyword">else</span> nextval[i]=nextval[j];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nextval;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(needle.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>* nextval=getNextval(needle);</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;haystack.length();i++){</span><br><span class="line">            <span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;haystack[i]!=needle[j+<span class="number">1</span>]){</span><br><span class="line">                j=nextval[j];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(haystack[i]==needle[j+<span class="number">1</span>]){</span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(j==needle.length()<span class="number">-1</span>){</span><br><span class="line">                <span class="keyword">return</span> i - needle.length() + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="38-报数"><a href="#38-报数" class="headerlink" title="38. 报数"></a>38. 报数</h2><p><strong>Description</strong><br>报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br></pre></td></tr></tbody></table></figure>
<p>1 被读作  “one 1”  (“一个一”) , 即 11。<br>11 被读作 “two 1s” (“两个一”）, 即 21。<br>21 被读作 “one 2”,  “one 1” （”一个二” ,  “一个一”) , 即 1211。<br>给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。<br>注意：整数顺序将表示为一个字符串。<br><strong>Example</strong><br>示例 1:<br>输入: 1<br>输出: “1”</p>
<p>示例 2:<br>输入: 4<br>输出: “1211”<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="built_in">string</span> strs[<span class="number">30</span>];</span><br><span class="line">    strs[<span class="number">0</span>]=<span class="string">"1"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">30</span>;i++){</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;strs[i<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        strs[i]=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;strs[i<span class="number">-1</span>].length();j++){</span><br><span class="line">            <span class="keyword">if</span>(strs[i<span class="number">-1</span>][j]==strs[i<span class="number">-1</span>][j<span class="number">-1</span>]) ans++;</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                strs[i]+=ans+<span class="string">'0'</span>;</span><br><span class="line">                strs[i]+=strs[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                ans=<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        strs[i]+=ans+<span class="string">'0'</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;strs[i<span class="number">-1</span>].length()&lt;&lt;<span class="string">"last:"</span>&lt;&lt;strs[i<span class="number">-1</span>][strs[i<span class="number">-1</span>].length()<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        strs[i]+=strs[i<span class="number">-1</span>][strs[i<span class="number">-1</span>].length()<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;strs[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> strs[n<span class="number">-1</span>];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;countAndSay(<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a>48. 旋转图像</h2><p><strong>Description</strong><br>给定一个 n × n 的二维矩阵表示一个图像。<br>将图像顺时针旋转 90 度。<br>说明：<br>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。<br><strong>Example</strong><br>示例 1:<br>给定 matrix =</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br></pre></td></tr></tbody></table></figure>
<p>原地旋转输入矩阵，使其变为:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<p>示例 2:<br>给定 matrix =</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">],</span><br></pre></td></tr></tbody></table></figure>
<p>原地旋转输入矩阵，使其变为:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong><br>先转置再对换。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=matrix.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++){</span><br><span class="line">                swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n/<span class="number">2</span>;j++){</span><br><span class="line">                swap(matrix[i][j], matrix[i][n-j<span class="number">-1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58. 最后一个单词的长度"></a>58. 最后一个单词的长度</h2><p><strong>Description</strong><br>给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。<br>如果不存在最后一个单词，请返回 0 。<br>说明：一个单词是指由字母组成，但不包含任何空格的字符串。<br><strong>Example</strong><br>示例:<br>输入: “Hello World”<br>输出: 5<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>* DP=<span class="keyword">new</span> <span class="keyword">int</span>[nums.size()];</span><br><span class="line">        <span class="built_in">memset</span>(DP,<span class="number">0</span>,<span class="keyword">sizeof</span>(DP));</span><br><span class="line">        DP[<span class="number">0</span>]=max(DP[<span class="number">0</span>], nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++){</span><br><span class="line">            DP[i]=max(nums[i],DP[i<span class="number">-1</span>]+nums[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> Max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(DP[i]&gt;Max) Max=DP[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Max;</span><br><span class="line">    }</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">string</span> str=<span class="string">"a"</span>;</span><br><span class="line">	<span class="keyword">int</span> idx=str.find_last_of(<span class="string">' '</span>);</span><br><span class="line">	<span class="keyword">if</span>(idx!=<span class="built_in">string</span>::npos) <span class="built_in">cout</span>&lt;&lt;str.length()-idx<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;str.length()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a>66. 加一</h2><p><strong>Description</strong><br>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。<br>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。<br>你可以假设除了整数 0 之外，这个整数不会以零开头。<br><strong>Example</strong><br>示例 1:<br>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。</p>
<p>示例 2:<br>输入: [4,3,2,1]<br>输出: [4,3,2,2]<br>解释: 输入数组表示数字 4321。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) {</span><br><span class="line">        <span class="keyword">int</span> carry_bit=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=digits.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">int</span> tmp=(digits[i]+carry_bit)%<span class="number">10</span>;</span><br><span class="line">            carry_bit=(digits[i]+carry_bit)/<span class="number">10</span>;</span><br><span class="line">            digits[i]=tmp;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(carry_bit!=<span class="number">0</span>){</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">            result.push_back(carry_bit);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;digits.size();i++){</span><br><span class="line">                result.push_back(digits[i]);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a>83. 删除排序链表中的重复元素</h2><p><strong>Description</strong><br>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。<br><strong>Example</strong><br>示例 1:<br>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2</p>
<p>示例 2:<br>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* tmp=head;</span><br><span class="line">        ListNode* pre=tmp;</span><br><span class="line">        tmp=tmp-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(tmp!=<span class="literal">NULL</span>){</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;val==pre-&gt;val){</span><br><span class="line">                pre-&gt;next=tmp-&gt;next;</span><br><span class="line">                tmp=pre-&gt;next;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                pre=tmp;</span><br><span class="line">                tmp=tmp-&gt;next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a>88. 合并两个有序数组</h2><p><strong>Description</strong><br>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。<br>说明:<br>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br><strong>Example</strong><br>示例:<br>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3<br>输出: [1,2,2,3,5,6]<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> idx1=<span class="number">0</span>, idx2=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">while</span>(idx1&lt;m&amp;&amp;idx2&lt;n){</span><br><span class="line">            <span class="keyword">if</span>(nums1[idx1]&lt;=nums2[idx2]){</span><br><span class="line">                result.push_back(nums1[idx1++]);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                result.push_back(nums2[idx2++]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(idx1&lt;m){</span><br><span class="line">            result.push_back(nums1[idx1++]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(idx2&lt;n){</span><br><span class="line">            result.push_back(nums2[idx2++]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;result.size();i++) nums1[i]=result[i];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a>100. 相同的树</h2><p><strong>Description</strong><br>给定两个二叉树，编写一个函数来检验它们是否相同。<br>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。<br><strong>Example</strong><br>示例 1:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line">输出: true</span><br></pre></td></tr></tbody></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:      1          1</span><br><span class="line">          /           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></tbody></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>&amp;&amp;q==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p!=<span class="literal">NULL</span>&amp;&amp;q!=<span class="literal">NULL</span>&amp;&amp;p-&gt;val==q-&gt;val){</span><br><span class="line">            <span class="keyword">if</span>(isSameTree(p-&gt;left,q-&gt;left)){</span><br><span class="line">                <span class="keyword">return</span> isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><p><strong>Description</strong><br>给定一个二叉树，检查它是否是镜像对称的。<br><strong>Example</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br><span class="line">但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line">   \   \</span><br><span class="line">   3    3</span><br><span class="line">说明:</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMirror</span><span class="params">(TreeNode* r1, TreeNode* r2)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(r1==<span class="literal">NULL</span>&amp;&amp;r2==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(r1!=<span class="literal">NULL</span>&amp;&amp;r2!=<span class="literal">NULL</span>&amp;&amp;r1-&gt;val==r2-&gt;val){</span><br><span class="line">            <span class="keyword">if</span>(isMirror(r1-&gt;left, r2-&gt;right)) <span class="keyword">return</span> isMirror(r1-&gt;right, r2-&gt;left);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> isMirror(root, root);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q1, q2;</span><br><span class="line">        q1.push(root);</span><br><span class="line">        q2.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q1.empty()){</span><br><span class="line">            TreeNode* t1=q1.front();</span><br><span class="line">            TreeNode* t2=q2.front();</span><br><span class="line">            q1.pop();q2.pop();</span><br><span class="line">            <span class="keyword">if</span>(t1!=<span class="literal">NULL</span>&amp;&amp;t2!=<span class="literal">NULL</span>&amp;&amp;t1-&gt;val!=t2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((t1==<span class="literal">NULL</span>&amp;&amp;t2!=<span class="literal">NULL</span>)||(t1!=<span class="literal">NULL</span>&amp;&amp;t2==<span class="literal">NULL</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(t1!=<span class="literal">NULL</span>){</span><br><span class="line">                q1.push(t1-&gt;left);</span><br><span class="line">                q1.push(t1-&gt;right);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(t2!=<span class="literal">NULL</span>){</span><br><span class="line">                q2.push(t2-&gt;right);</span><br><span class="line">                q2.push(t2-&gt;left);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h2><p><strong>Description</strong><br>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。<br><strong>Example</strong><br>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></tbody></table></figure>
<p>返回它的最大深度 3 。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> max(maxDepth(root-&gt;left), maxDepth(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="107-二叉树的层次遍历-II"><a href="#107-二叉树的层次遍历-II" class="headerlink" title="107. 二叉树的层次遍历 II"></a>107. 二叉树的层次遍历 II</h2><p><strong>Description<br>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）<br>**Example</strong><br>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回其自底向上的层次遍历为：</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> height;</span><br><span class="line">        Node* left;</span><br><span class="line">        Node* right;</span><br><span class="line">    };</span><br><span class="line">    Node* newRoot;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) {</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dq;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        getHeight(root, <span class="number">0</span>, newRoot);</span><br><span class="line">        q.push(newRoot);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">int</span> pre=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            Node* top=q.front();</span><br><span class="line">            <span class="keyword">if</span>(top-&gt;height!=pre){</span><br><span class="line">                pre=top-&gt;height;</span><br><span class="line">                dq.push_front(tmp);</span><br><span class="line">                tmp.clear();        </span><br><span class="line">            }</span><br><span class="line">            tmp.push_back(top-&gt;val);</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(top-&gt;left!=<span class="literal">NULL</span>) q.push(top-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(top-&gt;right!=<span class="literal">NULL</span>) q.push(top-&gt;right);</span><br><span class="line">        }</span><br><span class="line">        dq.push_front(tmp);</span><br><span class="line">        <span class="keyword">while</span>(!dq.empty()){</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; top=dq.front();</span><br><span class="line">            dq.pop_front();</span><br><span class="line">            result.push_back(top);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getHeight</span><span class="params">(TreeNode* root, <span class="keyword">int</span> height, Node* &amp;newRoot)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            newRoot = <span class="keyword">new</span> Node;</span><br><span class="line">            newRoot-&gt;val=root-&gt;val;</span><br><span class="line">            newRoot-&gt;left=newRoot-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">            newRoot-&gt;height=height+<span class="number">1</span>;</span><br><span class="line">            getHeight(root-&gt;left, height+<span class="number">1</span>, newRoot-&gt;left);</span><br><span class="line">            getHeight(root-&gt;right, height+<span class="number">1</span>, newRoot-&gt;right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        levelorder(root,<span class="number">0</span>,res);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(res.rbegin(),res.rend());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">levelorder</span><span class="params">(TreeNode* node, <span class="keyword">int</span> level, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(res.size()==level) res.push_back({});</span><br><span class="line">        res[level].push_back(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left) levelorder(node-&gt;left,level+<span class="number">1</span>, res);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right) levelorder(node-&gt;right,level+<span class="number">1</span>,res);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a>108. 将有序数组转换为二叉搜索树</h2><p><strong>Description</strong><br>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。<br>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。<br><strong>Example</strong><br>示例:<br>给定有序数组: [-10,-3,0,5,9],<br>一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     0</span><br><span class="line">    / \</span><br><span class="line">  -3   9</span><br><span class="line">  /   /</span><br><span class="line">-10  5</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong><br>一开始还想直接上平衡二叉树模板….</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* root;</span><br><span class="line">        tree(root, nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tree</span><span class="params">(TreeNode* &amp;root,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right){</span><br><span class="line">            root=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        root=<span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root-&gt;left=root-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">        tree(root-&gt;left, nums, left, mid<span class="number">-1</span>);</span><br><span class="line">        tree(root-&gt;right, nums, mid+<span class="number">1</span>, right);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a>110. 平衡二叉树</h2><p><strong>Description</strong><br>给定一个二叉树，判断它是否是高度平衡的二叉树。<br>本题中，一棵高度平衡二叉树定义为：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。<br><strong>Example</strong><br>示例 1:<br>给定二叉树 [3,9,20,null,null,15,7]</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></tbody></table></figure>
<p>返回 true 。</p>
<p>示例 2:<br>给定二叉树 [1,2,2,3,3,null,null,4,4]</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    2   2</span><br><span class="line">   / \</span><br><span class="line">  3   3</span><br><span class="line"> / \</span><br><span class="line">4   4</span><br></pre></td></tr></tbody></table></figure>
<p>返回 false 。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> judge(root, num);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(TreeNode* root, <span class="keyword">int</span> &amp;num)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>){</span><br><span class="line">            num=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(judge(root-&gt;left, num)){</span><br><span class="line">            <span class="keyword">int</span> l=num;</span><br><span class="line">            <span class="keyword">if</span>(judge(root-&gt;right, num)){</span><br><span class="line">                <span class="keyword">int</span> r=num;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(l-r)&lt;=<span class="number">1</span>){</span><br><span class="line">                    num=max(l, r)+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a>111. 二叉树的最小深度</h2><p><strong>Description</strong><br>给定一个二叉树，找出其最小深度。<br>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>说明: 叶子节点是指没有子节点的节点。<br><strong>Example</strong><br>示例:<br>给定二叉树 [3,9,20,null,null,15,7],</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></tbody></table></figure>
<p>返回它的最小深度  2.<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> minD=INF;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        depth(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> minD;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">depth</span><span class="params">(TreeNode* root, <span class="keyword">int</span> num)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>){</span><br><span class="line">            minD=min(minD, num+<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        depth(root-&gt;left, num+<span class="number">1</span>);</span><br><span class="line">        depth(root-&gt;right, num+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a>112. 路径总和</h2><p><strong>Description</strong><br>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。<br>说明: 叶子节点是指没有子节点的节点。<br><strong>Example</strong><br>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">              5</span><br><span class="line">             / \</span><br><span class="line">            4   8</span><br><span class="line">           /   / \</span><br><span class="line">          11  13  4</span><br><span class="line">         /  \      \</span><br><span class="line">        7    2      1</span><br><span class="line">`</span><br></pre></td></tr></tbody></table></figure>
<p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 <code>5-&gt;4-&gt;11-&gt;2</code>。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum-=root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">0</span>&amp;&amp;root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left, sum) || hasPathSum(root-&gt;right, sum);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a>118. 杨辉三角</h2><p><strong>Description</strong><br>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。<br><img src="/assets/img/algorithm/PascalTriangleAnimated2.gif" alt="图示"><br>在杨辉三角中，每个数是它左上方和右上方的数的和。<br><strong>Example</strong><br>示例:<br>输入: 5<br>输出:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;numRows;row++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=row;i++){</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>||i==row) tmp.push_back(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span>{</span><br><span class="line">                    <span class="keyword">int</span> sum=vec[row<span class="number">-1</span>][i<span class="number">-1</span>]+vec[row<span class="number">-1</span>][i];</span><br><span class="line">                    tmp.push_back(sum);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            vec.push_back(tmp);</span><br><span class="line">            tmp.clear();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="119-杨辉三角-II"><a href="#119-杨辉三角-II" class="headerlink" title="119. 杨辉三角 II"></a>119. 杨辉三角 II</h2><p><strong>Description</strong><br>给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。<br><img src="/assets/img/algorithm/PascalTriangleAnimated2.gif" alt="图示"><br>在杨辉三角中，每个数是它左上方和右上方的数的和。<br><strong>Example</strong><br>示例:<br>输入: 3<br>输出: [1,3,3,1]<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getRow(<span class="keyword">int</span> rowIndex) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        vec.resize(rowIndex+<span class="number">1</span>);</span><br><span class="line">        fill(vec.begin(), vec.end(), <span class="number">0</span>);</span><br><span class="line">        vec[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">1</span>;row&lt;=rowIndex;row++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=rowIndex;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span>) vec[i]=vec[i<span class="number">-1</span>]+vec[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a>125. 验证回文串</h2><p><strong>Description</strong><br>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。<br>说明：本题中，我们将空字符串定义为有效的回文串。<br><strong>Example</strong><br>示例 1:<br>输入: “A man, a plan, a canal: Panama”<br>输出: true</p>
<p>示例 2:<br>输入: “race a car”<br>输出: false<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="built_in">string</span> result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++){</span><br><span class="line">            <span class="keyword">if</span>((s[i]&gt;=<span class="string">'0'</span>&amp;&amp;s[i]&lt;=<span class="string">'9'</span>)||</span><br><span class="line">                (s[i]&gt;=<span class="string">'a'</span>&amp;&amp;s[i]&lt;=<span class="string">'z'</span>)){</span><br><span class="line">                result+=s[i];</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(s[i]&gt;=<span class="string">'A'</span>&amp;&amp;s[i]&lt;=<span class="string">'Z'</span>){</span><br><span class="line">                result+=s[i]+<span class="string">'a'</span>-<span class="string">'A'</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;result&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=result.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right){</span><br><span class="line">            <span class="keyword">if</span>(result[left++]!=result[right--]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h2><p><strong>Description</strong><br>给定一个链表，判断链表中是否有环。<br>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。<br><strong>Example</strong><br>示例 1：<br>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。<br><img src="/assets/img/algorithm/circularlinkedlist.png" alt="图示"><br>示例 2：<br>输入：head = [1,2], pos = 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。<br><img src="/assets/img/algorithm/circularlinkedlist_test2.png" alt="图示"><br>示例 3：<br>输入：head = [1], pos = -1<br>输出：false<br>解释：链表中没有环。<br><img src="/assets/img/algorithm/circularlinkedlist_test3.png" alt="图示"><br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* first=head-&gt;next-&gt;next;</span><br><span class="line">        ListNode* second=head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(first!=<span class="literal">NULL</span>&amp;&amp;first-&gt;next!=<span class="literal">NULL</span>&amp;&amp;second!=<span class="literal">NULL</span>){</span><br><span class="line">            <span class="keyword">if</span>(first==second) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            first=first-&gt;next-&gt;next;</span><br><span class="line">            second=second-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a>155. 最小栈</h2><p><strong>Description</strong><br>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。<br>push(x) – 将元素 x 推入栈中。<br>pop() – 删除栈顶的元素。<br>top() – 获取栈顶元素。<br>getMin() – 检索栈中的最小元素。<br><strong>Example</strong><br>示例:<br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. * /</span></span><br><span class="line"><span class="comment">    stack&lt;int&gt; st;</span></span><br><span class="line"><span class="comment">    stack&lt;int&gt; min_st;</span></span><br><span class="line"><span class="comment">    MinStack() {</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    void push(int x) {</span></span><br><span class="line"><span class="comment">        st.push(x);</span></span><br><span class="line"><span class="comment">        if(!min_st.empty()){</span></span><br><span class="line"><span class="comment">            if(x&lt;=min_st.top()) min_st.push(x);</span></span><br><span class="line"><span class="comment">        }else min_st.push(x);</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    void pop() {</span></span><br><span class="line"><span class="comment">        if(st.top()==min_st.top()) min_st.pop();</span></span><br><span class="line"><span class="comment">        st.pop();</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int top() {</span></span><br><span class="line"><span class="comment">        return st.top();</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int getMin() {</span></span><br><span class="line"><span class="comment">        return min_st.top();</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h2><p><strong>Description</strong><br>编写一个程序，找到两个单链表相交的起始节点。<br>如下面的两个链表：<br><img src="/assets/img/algorithm/160_statement.png" alt="图示"><br>在节点 c1 开始相交。<br><strong>Example</strong><br>示例 1：<br><img src="/assets/img/algorithm/160_example_1.png" alt="图示"><br>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p>
<p>示例 2：<br><img src="/assets/img/algorithm/160_example_2.png" alt="图示"><br>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>输出：Reference of the node with value = 2<br>输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p>
<p>示例 3：<br><img src="/assets/img/algorithm/160_example_3.png" alt="图示"><br>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>输出：null<br>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 null。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注意:</span><br><span class="line">如果两个链表没有交点，返回 null.</span><br><span class="line">在返回结果后，两个链表仍须保持原有的结构。</span><br><span class="line">可假定整个链表结构中没有循环。</span><br><span class="line">程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(headA==<span class="literal">NULL</span>||headB==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;ListNode*&gt; vecA,vecB;</span><br><span class="line">        <span class="keyword">while</span>(headA!=<span class="literal">NULL</span>){</span><br><span class="line">            vecA.push_back(headA);</span><br><span class="line">            headA=headA-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(headB!=<span class="literal">NULL</span>){</span><br><span class="line">            vecB.push_back(headB);</span><br><span class="line">            headB=headB-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        reverse(vecA.begin(),vecA.end());</span><br><span class="line">        reverse(vecB.begin(), vecB.end());</span><br><span class="line">        ListNode* result=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vecA.size()&amp;&amp;i&lt;vecB.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(vecA[i]==vecB[i]) result=vecA[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(headA==<span class="literal">NULL</span>||headB==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *pA, *pB;</span><br><span class="line">        pA=headA;</span><br><span class="line">        pB=headB;</span><br><span class="line">        ListNode *lastA=<span class="literal">NULL</span>, *lastB=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(pA!=pB){</span><br><span class="line">            <span class="keyword">if</span>(pA-&gt;next==<span class="literal">NULL</span>){</span><br><span class="line">                lastA=pA;</span><br><span class="line">                pA=headB;</span><br><span class="line">            }<span class="keyword">else</span> pA=pA-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(pB-&gt;next==<span class="literal">NULL</span>){</span><br><span class="line">                lastB=pB;</span><br><span class="line">                pB=headA;</span><br><span class="line">            }<span class="keyword">else</span> pB=pB-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(lastA!=<span class="literal">NULL</span>&amp;&amp;lastB!=<span class="literal">NULL</span>&amp;&amp;lastA!=lastB) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a>167. 两数之和 II - 输入有序数组</h2><p><strong>Destription</strong><br>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。<br>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。<br>说明:<br>返回的下标值（index1 和 index2）不是从零开始的。<br>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。<br><strong>Example</strong><br>示例:<br>输入: numbers = [2, 7, 11, 15], target = 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target) {</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.size();i++){</span><br><span class="line">            m[numbers[i]] = i;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(m.find(target-numbers[i])!=m.end()){</span><br><span class="line">                <span class="keyword">if</span>(numbers[i]!=target-numbers[i]||(numbers[i]==target-numbers[i]&amp;&amp;m[numbers[i]]!=i)){</span><br><span class="line">                    vec.push_back(i+<span class="number">1</span>);</span><br><span class="line">                    vec.push_back(m[target-numbers[i]]+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a>169. 多数元素</h2><p><strong>Description</strong><br>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br><strong>Example</strong><br>示例 1:<br>输入: [3,2,3]<br>输出: 3</p>
<p>示例 2:<br>输入: [2,2,1,1,1,2,2]<br>输出: 2<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> result=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(result==nums[i]) ans++;</span><br><span class="line">            <span class="keyword">else</span> ans--;</span><br><span class="line">            <span class="keyword">if</span>(ans==<span class="number">0</span>){</span><br><span class="line">                result=nums[i];</span><br><span class="line">                ans=<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>面试题 17.10. 主要元素</strong><br><strong>Description</strong><br>数组中占比超过一半的元素称之为主要元素。给定一个整数数组，找到它的主要元素。若没有，返回-1。<br><strong>Example</strong><br>示例 1：<br>输入：[1,2,5,9,5,9,5,5,5]<br>输出：5</p>
<p>示例 2：<br>输入：[3,2]<br>输出：-1</p>
<p>示例 3：<br>输入：[2,2,1,1,1,2,2]<br>输出：2</p>
<p>说明：<br>你有办法在时间复杂度为 O(N)，空间复杂度为 O(1) 内完成吗？<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pre=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(t==<span class="number">0</span>) pre=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==pre) t++;</span><br><span class="line">            <span class="keyword">else</span> t--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(t&gt;<span class="number">0</span>) <span class="keyword">return</span> pre;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a>189. 旋转数组</h2><p><strong>Description</strong><br>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。<br><strong>Example</strong><br>示例 1:<br>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]</p>
<p>示例 2:<br>输入: [-1,-100,3,99] 和 k = 2<br>输出: [3,99,-1,-100]<br>解释:<br>向右旋转 1 步: [99,-1,-100,3]<br>向右旋转 2 步: [3,99,-1,-100]<br><strong>Progam</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        k%=n;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, n-k<span class="number">-1</span>);</span><br><span class="line">        reverse(nums,n-k, n<span class="number">-1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>{</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r){</span><br><span class="line">            swap(nums[l], nums[r]);</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190. 颠倒二进制位"></a>190. 颠倒二进制位</h2><p><strong>Description</strong><br>颠倒给定的 32 位无符号整数的二进制位。<br><strong>Example</strong><br>示例 1：<br>输入: 00000010100101000001111010011100<br>输出: 00111001011110000010100101000000<br>解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，<br>      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。<br>示例 2：<br>输入：11111111111111111111111111111101<br>输出：10111111111111111111111111111111<br>解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，<br>      因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) {</span><br><span class="line">        <span class="keyword">uint32_t</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i!=<span class="number">32</span>){</span><br><span class="line">            result=result*<span class="number">2</span>+n%<span class="number">2</span>;</span><br><span class="line">            n/=<span class="number">2</span>;</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a>191. 位1的个数</h2><p><strong>Description</strong><br>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。<br><strong>Example</strong><br>示例 1：<br>输入：00000000000000000000000000001011<br>输出：3<br>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。</p>
<p>示例 2：<br>输入：00000000000000000000000010000000<br>输出：1<br>解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。</p>
<p>示例 3：<br>输入：11111111111111111111111111111101<br>输出：31<br>解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> one=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++){</span><br><span class="line">            ans+=((n%<span class="number">2</span>)&amp;one);</span><br><span class="line">            n/=<span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>计算末尾1的个数即可，$n&amp;(n-1)$会将最后一位置0</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>){</span><br><span class="line">            n&amp;=n<span class="number">-1</span>;</span><br><span class="line">            ans++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h2><p><strong>Description</strong><br>删除链表中等于给定值 val 的所有节点。<br><strong>Example</strong><br>示例:<br>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6<br>输出: 1-&gt;2-&gt;3-&gt;4-&gt;5<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        ListNode* node=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        node-&gt;next=head;</span><br><span class="line">        ListNode* pre=node;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>){</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val==val){</span><br><span class="line">                pre-&gt;next=head-&gt;next;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                pre=head;</span><br><span class="line">            }</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> node-&gt;next;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205. 同构字符串"></a>205. 同构字符串</h2><p><strong>Description</strong><br>给定两个字符串 s 和 t，判断它们是否是同构的。<br>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。<br>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。<br><strong>Example</strong><br>示例 1:<br>输入: s = “egg”, t = “add”<br>输出: true</p>
<p>示例 2:<br>输入: s = “foo”, t = “bar”<br>输出: false</p>
<p>示例 3:<br>输入: s = “paper”, t = “title”<br>输出: true<br><strong>Program</strong><br>1.Hash</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(s.length()!=t.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1, vec2;</span><br><span class="line">        vec1.resize(s.length());</span><br><span class="line">        vec2.resize(s.length());</span><br><span class="line">        fill(vec1.begin(), vec1.end(), <span class="number">0</span>);</span><br><span class="line">        fill(vec2.begin(), vec2.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m1, m2;</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++){</span><br><span class="line">            <span class="keyword">if</span>(m1.find(s[i])==m1.end()){</span><br><span class="line">                m1[s[i]]=idx;</span><br><span class="line">                vec1[i]=idx++;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                vec1[i]=m1[s[i]];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.length();i++){</span><br><span class="line">            <span class="keyword">if</span>(m2.find(t[i])==m2.end()){</span><br><span class="line">                m2[t[i]]=idx;</span><br><span class="line">                vec2[i]=idx++;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                vec2[i]=m2[t[i]];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++){</span><br><span class="line">            <span class="keyword">if</span>(vec1[i]!=vec2[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>2.比较字母首次出现位置</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(s.length()!=t.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++){</span><br><span class="line">            <span class="keyword">if</span>(s.find(s[i])!=t.find(t[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><p><strong>Description</strong><br>反转一个单链表。<br><strong>Example</strong><br>示例:<br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode* pre, *p, *tmp;</span><br><span class="line">        pre=<span class="literal">NULL</span>;</span><br><span class="line">        p=head;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>){</span><br><span class="line">            tmp=head-&gt;next;</span><br><span class="line">            head-&gt;next=pre;</span><br><span class="line">            pre=head;</span><br><span class="line">            head=tmp;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a>217. 存在重复元素</h2><p><strong>Description</strong><br>给定一个整数数组，判断是否存在重复元素。<br>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。<br><strong>Example</strong><br>示例 1:<br>输入: [1,2,3,1]<br>输出: true</p>
<p>示例 2:<br>输入: [1,2,3,4]<br>输出: false</p>
<p>示例 3:<br>输入: [1,1,1,3,3,4,3,2,4,2]<br>输出: true<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(m.find(nums[i])==m.end()){</span><br><span class="line">                m[nums[i]] = <span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                m[nums[i]]++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it=m.begin();it!=m.end();it++){</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second&gt;=<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="219-存在重复元素-II"><a href="#219-存在重复元素-II" class="headerlink" title="219. 存在重复元素 II"></a>219. 存在重复元素 II</h2><p><strong>Description</strong><br>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。<br><strong>Example</strong><br>示例 1:<br>输入: nums = [1,2,3,1], k = 3<br>输出: true</p>
<p>示例 2:<br>输入: nums = [1,0,1,1], k = 1<br>输出: true</p>
<p>示例 3:<br>输入: nums = [1,2,3,1,2,3], k = 2<br>输出: false<br><strong>Progam</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(m.find(nums[i])==m.end()){</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">                m[nums[i]]=vec;</span><br><span class="line">                m[nums[i]].push_back(i);</span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m[nums[i]].size();j++){</span><br><span class="line">                    <span class="keyword">if</span>(i-m[nums[i]][j]&lt;=k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">                m[nums[i]].push_back(i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(m.find(nums[i])==m.end()){</span><br><span class="line">                m[nums[i]]=i;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(i-m[nums[i]]&lt;=k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> m[nums[i]]=i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a>225. 用队列实现栈</h2><p><strong>Description</strong><br>使用队列实现栈的下列操作：<br>push(x) – 元素 x 入栈<br>pop() – 移除栈顶元素<br>top() – 获取栈顶元素<br>empty() – 返回栈是否为空<br>注意:<br>你只能使用队列的基本操作– 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。<br>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。<br>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyStack() {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        q.push(x);</span><br><span class="line">        <span class="keyword">int</span> sz=q.size();</span><br><span class="line">        <span class="keyword">while</span>(sz&gt;<span class="number">1</span>){</span><br><span class="line">            q.push(q.front());</span><br><span class="line">            q.pop();</span><br><span class="line">            sz--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(q.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> front = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">return</span> front;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(q.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> q.front();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> q.empty();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h2><p><strong>Description</strong><br>翻转一棵二叉树。<br><strong>Example</strong><br>示例：<br>输入：</p>
<pre><code>4</code></pre><p>   /   <br>  2     7<br> / \   / <br>1   3 6   9<br>输出：</p>
<pre><code>4</code></pre><p>   /   <br>  7     2<br> / \   / <br>9   6 3   1<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* tmp=root-&gt;left;</span><br><span class="line">        root-&gt;left=root-&gt;right;</span><br><span class="line">        root-&gt;right=tmp;</span><br><span class="line">        invertTree(root-&gt;left);</span><br><span class="line">        invertTree(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a>207. 课程表</h2><p><strong>Description</strong><br>现在你总共有 n 门课需要选，记为 0 到 n-1。<br>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]<br>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？<br><strong>Example</strong><br>示例 1:<br>输入: 2, [[1,0]]<br>输出: true<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</p>
<p>示例 2:<br>输入: 2, [[1,0],[0,1]]<br>输出: false<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</p>
<p><strong>说明:</strong><br>输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。<br>你可以假定输入的先决条件中没有重复的边。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; Adj;</span><br><span class="line">        Adj.resize(numCourses);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inDegree;</span><br><span class="line">        inDegree.resize(numCourses);</span><br><span class="line">        fill(inDegree.begin(), inDegree.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.size();i++){</span><br><span class="line">            <span class="keyword">int</span> v=prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> u=prerequisites[i][<span class="number">1</span>];</span><br><span class="line">            inDegree[v]++;</span><br><span class="line">            Adj[u].push_back(v);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++){</span><br><span class="line">            <span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>) q.push(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            <span class="keyword">int</span> u=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">                <span class="keyword">int</span> v=Adj[u][i];</span><br><span class="line">                inDegree[v]--;</span><br><span class="line">                <span class="keyword">if</span>(inDegree[v]==<span class="number">0</span>) q.push(v);</span><br><span class="line">            }</span><br><span class="line">            num++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(num!=numCourses) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a>210. 课程表 II</h2><p><strong>Description</strong><br>现在你总共有 n 门课需要选，记为 0 到 n-1。<br>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]<br>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。<br>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。<br><strong>Example</strong><br>示例 1:<br>输入: 2, [[1,0]]<br>输出: [0,1]<br>解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</p>
<p>示例 2:<br>输入: 4, [[1,0],[2,0],[3,1],[3,2]]<br>输出: [0,1,2,3] or [0,2,1,3]<br>解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。<br>     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findOrder(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; Adj;</span><br><span class="line">        Adj.resize(numCourses);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inDegree;</span><br><span class="line">        inDegree.resize(numCourses);</span><br><span class="line">        fill(inDegree.begin(), inDegree.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.size();i++){</span><br><span class="line">            <span class="keyword">int</span> v=prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> u=prerequisites[i][<span class="number">1</span>];</span><br><span class="line">            inDegree[v]++;</span><br><span class="line">            Adj[u].push_back(v);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++){</span><br><span class="line">            <span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>) q.push(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            <span class="keyword">int</span> u=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            result.push_back(u);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">                <span class="keyword">int</span> v=Adj[u][i];</span><br><span class="line">                inDegree[v]--;</span><br><span class="line">                <span class="keyword">if</span>(inDegree[v]==<span class="number">0</span>) q.push(v);</span><br><span class="line">            }</span><br><span class="line">            num++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(num!=numCourses) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h2><p><strong>Description</strong><br>给定两个数组，编写一个函数来计算它们的交集。<br><strong>Example</strong><br>示例 1：<br>输入：nums1 = [1,2,2,1], nums2 = [2,2]<br>输出：[2]</p>
<p>示例 2：<br>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>输出：[9,4]</p>
<p>说明：<br>输出结果中的每个元素一定是唯一的。<br>我们可以不考虑输出结果的顺序。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) {</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; st(nums1.begin(), nums1.end()), st_res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums2){</span><br><span class="line">            <span class="keyword">if</span>(st.find(x)!=st.end()) st_res.insert(x);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(st_res.begin(), st_res.end());</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) {</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; st(nums1.begin(), nums1.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        sort(nums2.begin(), nums2.end());</span><br><span class="line">        nums2.erase(unique(nums2.begin(), nums2.end()), nums2.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums2){</span><br><span class="line">            <span class="keyword">if</span>(st.find(x)!=st.end()) res.push_back(x);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a>130. 被围绕的区域</h2><p><strong>Description</strong><br>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。<br>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。<br><strong>Example</strong><br>示例:<br>X X X X<br>X O O X<br>X X O X<br>X O X X<br>运行你的函数后，矩阵变为：<br>X X X X<br>X X X X<br>X X X X<br>X O X X<br><strong>Program</strong><br><strong>并查集</strong><br>这里只需合并所有是O的区域，每个位置用father[i]标记，然后多用一个father[nCount]表示与边界相连，所以每个在边界上的O都与其合并，其他O只需要遍历四个方向合并即可。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father;</span><br><span class="line">    <span class="keyword">int</span> step[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(x!=father[x]){</span><br><span class="line">            father[x]=findFather(father[x]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> father[x];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionSet</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> fa=findFather(x);</span><br><span class="line">        <span class="keyword">int</span> fb=findFather(y);</span><br><span class="line">        <span class="keyword">if</span>(fa!=fb){</span><br><span class="line">            father[fa]=fb;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">index</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> cols)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> i*cols + j;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(board.size()==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> rows=board.size();</span><br><span class="line">        <span class="keyword">int</span> cols=board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> nCount=rows*cols;</span><br><span class="line">        father.resize(nCount+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nCount+<span class="number">1</span>;i++) father[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++){</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>){</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span>||i==rows<span class="number">-1</span>||j==<span class="number">0</span>||j==cols<span class="number">-1</span>){</span><br><span class="line">                        unionSet(index(i, j, cols), nCount);</span><br><span class="line">                    }<span class="keyword">else</span>{</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++){</span><br><span class="line">                            <span class="keyword">int</span> x=i+step[k][<span class="number">0</span>];</span><br><span class="line">                            <span class="keyword">int</span> y=j+step[k][<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;rows&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;cols&amp;&amp;board[x][y]==<span class="string">'O'</span>) unionSet(index(i, j, cols), index(x, y, cols));</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++){</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>){</span><br><span class="line">                    <span class="keyword">int</span> fa=findFather(index(i, j, cols));</span><br><span class="line">                    <span class="keyword">int</span> fb=findFather(nCount);</span><br><span class="line">                    <span class="keyword">if</span>(fa!=fb){</span><br><span class="line">                        board[i][j]=<span class="string">'X'</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>深搜</strong><br>从边界的O开始深搜，标记与边界相连的O为A，最后遍历矩阵，如果没被标记为A的O，那么表示被X围绕，如果被标记则还原为O<br>时间复杂度$O(n * m)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> step[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    };</span><br><span class="line">    <span class="comment">//标记所有与边界相连的O</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>{</span><br><span class="line">        board[i][j]=<span class="string">'A'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++){</span><br><span class="line">            <span class="keyword">int</span> new_i=i+step[k][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> new_j=j+step[k][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(new_i&gt;=<span class="number">0</span>&amp;&amp;new_i&lt;rows&amp;&amp;new_j&gt;=<span class="number">0</span>&amp;&amp;new_j&lt;cols&amp;&amp;board[new_i][new_j]==<span class="string">'O'</span>){</span><br><span class="line">                dfs(board, new_i, new_j);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(board.size()==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        rows=board.size();</span><br><span class="line">        cols=board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++){</span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">0</span>][j]==<span class="string">'O'</span>) dfs(board, <span class="number">0</span>, j);</span><br><span class="line">            <span class="keyword">if</span>(board[rows<span class="number">-1</span>][j]==<span class="string">'O'</span>) dfs(board, rows<span class="number">-1</span>, j);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++){</span><br><span class="line">            <span class="keyword">if</span>(board[i][<span class="number">0</span>]==<span class="string">'O'</span>) dfs(board, i, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(board[i][cols<span class="number">-1</span>]==<span class="string">'O'</span>) dfs(board, i, cols<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++){</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>){</span><br><span class="line">                    board[i][j]=<span class="string">'X'</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">'A'</span>){</span><br><span class="line">                    board[i][j]=<span class="string">'O'</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h2><p><strong>Description</strong><br>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。<br><strong>Example</strong><br>示例 1:<br>输入:<br>11110<br>11010<br>11000<br>00000<br>输出: 1</p>
<p>示例 2:<br>输入:<br>11000<br>11000<br>00100<br>00011<br>输出: 3<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father;</span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line">    <span class="keyword">int</span> nCount;</span><br><span class="line">    <span class="keyword">int</span> step[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">-1</span>,  <span class="number">0</span>,</span><br><span class="line">         <span class="number">1</span>,  <span class="number">0</span>,</span><br><span class="line">         <span class="number">0</span>, <span class="number">-1</span>,</span><br><span class="line">         <span class="number">0</span>,  <span class="number">1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">toIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> i*cols+j;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(x!=father[x]){</span><br><span class="line">            father[x]=findFather(father[x]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> father[x];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionSet</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> fa=findFather(x);</span><br><span class="line">        <span class="keyword">int</span> fb=findFather(y);</span><br><span class="line">        <span class="keyword">if</span>(fa!=fb){</span><br><span class="line">            father[fa]=fb;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(grid.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        rows=grid.size();</span><br><span class="line">        cols=grid[<span class="number">0</span>].size();</span><br><span class="line">        nCount=rows*cols;</span><br><span class="line">        father.resize(nCount);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nCount;i++) father[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++){</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">'1'</span>){</span><br><span class="line">                    <span class="keyword">int</span> idx1=toIndex(i, j);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++){</span><br><span class="line">                        <span class="keyword">int</span> x=i+step[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y=j+step[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">int</span> idx2=toIndex(x, y);</span><br><span class="line">                        <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;rows&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;cols&amp;&amp;grid[x][y]==<span class="string">'1'</span>) unionSet(idx1, idx2);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++){</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">'1'</span>){</span><br><span class="line">                    s.insert(findFather(toIndex(i, j)));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s.size();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="399-除法求值"><a href="#399-除法求值" class="headerlink" title="399. 除法求值"></a>399. 除法求值</h2><p><strong>Description</strong><br>给出方程式 $A / B = k$, 其中 $A$ 和 $B$ 均为代表字符串的变量， $k$ 是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 -1.0。<br><strong>Example</strong><br>示例 :</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定&nbsp;a / b = 2.0, b / c = 3.0</span><br><span class="line">问题: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?&nbsp;</span><br><span class="line">返回&nbsp;[6.0, 0.5, -1.0, 1.0, -1.0 ]</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入为: vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries(方程式，方程式结果，问题方程式)，&nbsp;其中&nbsp;equations.size() == values.size()，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。&nbsp;返回vector&lt;double&gt;类型。</span><br></pre></td></tr></tbody></table></figure>
<p>基于上述例子，输入如下：<br>equations(方程式) = [ [“a”, “b”], [“b”, “c”] ],<br>values(方程式结果) = [2.0, 3.0],<br>queries(问题方程式) = [ [“a”, “c”], [“b”, “a”], [“a”, “e”], [“a”, “a”], [“x”, “x”] ].<br>输入总是有效的。你可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。<br><strong>Program</strong></p>
<ul>
<li>father 记录的是每个节点的父节点是谁。</li>
<li>val 记录的是每个节点到其<strong>父节点</strong>的权值<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; sToi;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; iTos;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; val;</span><br><span class="line">    <span class="keyword">int</span> nCount=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(sToi.find(str)==sToi.end()){</span><br><span class="line">            sToi[str]=nCount;</span><br><span class="line">            iTos[nCount++]=str;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// return nCount++:</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(x!=father[x]){</span><br><span class="line">            <span class="keyword">int</span> fa=findFather(father[x]);</span><br><span class="line">            val[x]=val[x]*val[father[x]];</span><br><span class="line">            father[x]=fa;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> father[x];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">double</span> v)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> fa=findFather(x);</span><br><span class="line">        <span class="keyword">int</span> fb=findFather(y);</span><br><span class="line">        <span class="keyword">if</span>(fa!=fb){</span><br><span class="line">            father[fa]=fb;</span><br><span class="line">            val[fa]=v*val[y]/val[x];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(sToi.find(s1)==sToi.end()||sToi.find(s2)==sToi.end()) <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">        <span class="keyword">int</span> a=sToi[s1];</span><br><span class="line">        <span class="keyword">int</span> b=sToi[s2];</span><br><span class="line">        <span class="keyword">int</span> fa=findFather(a);</span><br><span class="line">        <span class="keyword">int</span> fb=findFather(b);</span><br><span class="line">        <span class="keyword">if</span>(fa!=fb) <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">        <span class="keyword">return</span> val[a]/val[b];</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; calcEquation(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; equations, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; values, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; queries) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;equations.size();i++){</span><br><span class="line">            convert(equations[i][<span class="number">0</span>]);</span><br><span class="line">            convert(equations[i][<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        father.resize(nCount);</span><br><span class="line">        val.resize(nCount);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nCount;i++){</span><br><span class="line">            father[i]=i;</span><br><span class="line">            val[i]=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;equations.size();i++){</span><br><span class="line">            merge(sToi[equations[i][<span class="number">0</span>]], sToi[equations[i][<span class="number">1</span>]], values[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;queries.size();i++){</span><br><span class="line">            result.push_back(getResult(queries[i][<span class="number">0</span>], queries[i][<span class="number">1</span>]));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="547-朋友圈"><a href="#547-朋友圈" class="headerlink" title="547. 朋友圈"></a>547. 朋友圈</h2></li>
</ul>
<p><strong>Description</strong><br>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p>
<p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。<br><strong>Example</strong><br>示例 1:<br>输入:<br>[[1,1,0],<br> [1,1,0],<br> [0,0,1]]<br>输出: 2<br>说明：已知学生0和学生1互为朋友，他们在一个朋友圈。<br>第2个学生自己在一个朋友圈。所以返回2。</p>
<p>示例 2:<br>输入:<br>[[1,1,0],<br> [1,1,1],<br> [0,1,1]]<br>输出: 1<br>说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。<br>注意：<br>N 在[1,200]的范围内。<br>对于所有学生，有M[i][i] = 1。<br>如果有M[i][j] = 1，则有M[j][i] = 1。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father;</span><br><span class="line">    <span class="keyword">int</span> nCount;</span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(x!=father[x]){</span><br><span class="line">            father[x]=findFather(father[x]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> father[x];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionSet</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> fa=findFather(x);</span><br><span class="line">        <span class="keyword">int</span> fb=findFather(y);</span><br><span class="line">        <span class="keyword">if</span>(fa!=fb){</span><br><span class="line">            father[fa]=fb;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(M.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nCount=rows=M.size();</span><br><span class="line">        <span class="keyword">int</span> cols=M[<span class="number">0</span>].size();</span><br><span class="line">        father.resize(nCount);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nCount;i++) father[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++){</span><br><span class="line">                <span class="keyword">if</span>(M[i][j]==<span class="number">1</span>) unionSet(i, j);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nCount;i++){</span><br><span class="line">            s.insert(findFather(i));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s.size();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="315-计算右侧小于当前元素的个数"><a href="#315-计算右侧小于当前元素的个数" class="headerlink" title="315. 计算右侧小于当前元素的个数"></a>315. 计算右侧小于当前元素的个数</h2><p><strong>Description</strong><br>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。<br><strong>Example</strong><br>示例:<br>输入: [5,2,6,1]<br>输出: [2,1,1,0]<br>解释:<br>5 的右侧有 2 个更小的元素 (2 和 1).<br>2 的右侧仅有 1 个更小的元素 (1).<br>6 的右侧有 1 个更小的元素 (1).<br>1 的右侧有 0 个更小的元素.<br><strong>Prgoram</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C, A;</span><br><span class="line">    <span class="keyword">int</span> nCount;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> idx;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> v, <span class="keyword">int</span> i):val(v), idx(i){}</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;tmp) <span class="keyword">const</span>{</span><br><span class="line">            <span class="keyword">return</span> val&lt;tmp.val;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; vec;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;<span class="number">0</span>;i-=lowbit(i)){</span><br><span class="line">            sum+=C[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=nCount;i+=lowbit(i)){</span><br><span class="line">            C[i]+=val;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countSmaller(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> {};</span><br><span class="line">        nCount=nums.size();</span><br><span class="line">        C.resize(nCount+<span class="number">1</span>);</span><br><span class="line">        A.resize(nCount);</span><br><span class="line">        fill(C.begin(), C.end(), <span class="number">0</span>);</span><br><span class="line">        reverse(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nCount;i++){</span><br><span class="line">            vec.push_back(Node(nums[i], i));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//离散化</span></span><br><span class="line">        sort(vec.begin(), vec.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nCount;i++){</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>||vec[i<span class="number">-1</span>].val!=vec[i].val){</span><br><span class="line">                A[vec[i].idx]=i+<span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                A[vec[i].idx]=A[vec[i<span class="number">-1</span>].idx];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nCount;i++){</span><br><span class="line">            update(A[i], <span class="number">1</span>);</span><br><span class="line">            result.push_back(getSum(A[i]<span class="number">-1</span>));</span><br><span class="line">        }</span><br><span class="line">        reverse(result.begin(),result.end());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="187-重复的DNA序列"><a href="#187-重复的DNA序列" class="headerlink" title="187. 重复的DNA序列"></a>187. 重复的DNA序列</h2><p><strong>Description</strong><br>所有 DNA 都由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。<br>编写一个函数来查找 DNA 分子中所有出现超过一次的 10 个字母长的序列（子串）。<br><strong>Example</strong><br>示例：<br>输入：s = “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT”<br>输出：[“AAAAACCCCC”, “CCCCCAAAAA”]<br><strong>Program</strong><br>A:00<br>C:01<br>G:10<br>T:11<br>滑动窗口左移两位，最后两位填充上述对应二进制位，或运算后，即新一次的字符串所对应的key</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findRepeatedDnaSequences(<span class="built_in">string</span> s) {</span><br><span class="line">        <span class="keyword">int</span> len=s.length();</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        m[<span class="string">'A'</span>-<span class="string">'A'</span>]=<span class="number">0</span>;</span><br><span class="line">        m[<span class="string">'C'</span>-<span class="string">'A'</span>]=<span class="number">1</span>;</span><br><span class="line">        m[<span class="string">'G'</span>-<span class="string">'A'</span>]=<span class="number">2</span>;</span><br><span class="line">        m[<span class="string">'T'</span>-<span class="string">'A'</span>]=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++){</span><br><span class="line">            key&lt;&lt;=<span class="number">2</span>;</span><br><span class="line">            key|=m[s[i]-<span class="string">'A'</span>];</span><br><span class="line">            key&amp;=<span class="number">0xfffff</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; sKey;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        sKey.insert(key);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">10</span>;i&lt;len;i++){</span><br><span class="line">            key&lt;&lt;=<span class="number">2</span>;</span><br><span class="line">            key|=m[s[i]-<span class="string">'A'</span>];</span><br><span class="line">            key&amp;=<span class="number">0xfffff</span>;</span><br><span class="line">            <span class="keyword">if</span>(sKey.find(key)==sKey.end()){</span><br><span class="line">                sKey.insert(key);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                res.insert(s.substr(i<span class="number">-9</span>, <span class="number">10</span>));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> str: res){</span><br><span class="line">            result.push_back(str);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="201-数字范围按位与"><a href="#201-数字范围按位与" class="headerlink" title="201. 数字范围按位与"></a>201. 数字范围按位与</h2><p><strong>Description</strong><br>给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。<br><strong>Example</strong><br>示例 1:<br>输入: [5,7]<br>输出: 4</p>
<p>示例 2:<br>输入: [0,1]<br>输出: 0<br><strong>Program</strong><br>m&lt;n时，会发现<br>m:SSS0XXXX<br>n:SSS1XXXX<br>即m与n前若干位相同，某个高位不同，后面不一定相同，区间与一定是SSS00000的形式，<br>那么如何求SSS00000就变成了m:SSS0XXXX与上11100000即可，<br>而m与n异或得到0001XXXX，将其编程00011111的形式取反就是要的11100000的形式了！！！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(m==n) <span class="keyword">return</span> m;</span><br><span class="line">        <span class="keyword">int</span> i=m^n;</span><br><span class="line">        i|=(i&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        i|=(i&gt;&gt;<span class="number">2</span>);</span><br><span class="line">        i|=(i&gt;&gt;<span class="number">4</span>);</span><br><span class="line">        i|=(i&gt;&gt;<span class="number">8</span>);</span><br><span class="line">        i|=(i&gt;&gt;<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">return</span> m&amp;~i;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="260-只出现一次的数字-III"><a href="#260-只出现一次的数字-III" class="headerlink" title="260. 只出现一次的数字 III"></a>260. 只出现一次的数字 III</h2><p><strong>Description</strong><br>给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。<br><strong>Example</strong><br>示例 :<br>输入: [1,2,1,3,2,5]<br>输出: [3,5]<br>注意：<br>结果输出的顺序并不重要，对于上面的例子， [5, 3] 也是正确答案。<br>你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？<br><strong>Program</strong><br>全部异或得到两个唯一出现一次的数的保留1bitmask，这些位上的1分别来自于两个唯一出现一次的数！<br>求lowbit后得到diff，而每个与diff与运算后不为0的数，继续异或得到第一个只出现一次的数x，x与bitmask异或得到第二个只出现一次的数。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; singleNumber(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> bitmask=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i: nums) bitmask^=i;</span><br><span class="line">        <span class="keyword">int</span> diff =bitmask&amp;(-bitmask);</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums){</span><br><span class="line">            <span class="keyword">if</span>((i&amp;diff)!=<span class="number">0</span>) x^=i;</span><br><span class="line">        }</span><br><span class="line">        result.push_back(x);</span><br><span class="line">        result.push_back((x^bitmask));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="318-最大单词长度乘积"><a href="#318-最大单词长度乘积" class="headerlink" title="318. 最大单词长度乘积"></a>318. 最大单词长度乘积</h2><p><strong>Description</strong><br>给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。<br><strong>Example</strong><br>示例 1:<br>输入: [“abcw”,”baz”,”foo”,”bar”,”xtfn”,”abcdef”]<br>输出: 16<br>解释: 这两个单词为 “abcw”, “xtfn”。</p>
<p>示例 2:<br>输入: [“a”,”ab”,”abc”,”d”,”cd”,”bcd”,”abcd”]<br>输出: 4<br>解释: 这两个单词为 “ab”, “cd”。</p>
<p>示例 3:<br>输入: [“a”,”aa”,”aaa”,”aaaa”]<br>输出: 0<br>解释: 不存在这样的两个单词。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sToi</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:str){</span><br><span class="line">            result|=<span class="number">1</span>&lt;&lt;(ch-<span class="string">'a'</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> str:words){</span><br><span class="line">            vec.push_back(sToi(str));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.size();i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;words.size();j++){</span><br><span class="line">                <span class="keyword">if</span>((vec[i]&amp;vec[j])==<span class="number">0</span>&amp;&amp;words[i].length()*words[j].length()&gt;result){</span><br><span class="line">                    result=words[i].length()*words[j].length();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a>338. 比特位计数</h2><p><strong>Description</strong><br>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。<br><strong>Example</strong><br>示例 1:<br>输入: 2<br>输出: [0,1,1]</p>
<p>示例 2:<br>输入: 5<br>输出: [0,1,1,2,1,2]<br><strong>Program</strong><br>考虑x与x&gt;&gt;1，差别就在最低位，DP[x]=DP[x&gt;&gt;1]+(x%2)</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> num) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result(num+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++){</span><br><span class="line">            result[i]=result[i&gt;&gt;<span class="number">1</span>]+(i%<span class="number">2</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="342-4的幂"><a href="#342-4的幂" class="headerlink" title="342. 4的幂"></a>342. 4的幂</h2><p><strong>Description</strong><br>给定一个整数 (32 位有符号整数)，请编写一个函数来判断它是否是 4 的幂次方。<br><strong>Example</strong><br>示例 1:<br>输入: 16<br>输出: true</p>
<p>示例 2:<br>输入: 5<br>输出: false<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> num&gt;<span class="number">0</span> &amp;&amp; (num&amp;(num<span class="number">-1</span>))==<span class="number">0</span> &amp;&amp; (num&amp;(<span class="number">0xaaaaaaaa</span>))==<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="371-两整数之和"><a href="#371-两整数之和" class="headerlink" title="371. 两整数之和"></a>371. 两整数之和</h2><p><strong>Description</strong><br>不使用运算符 + 和 - ​​​​​​​，计算两整数 ​​​​​​​a 、b ​​​​​​​之和。<br><strong>Example</strong><br>示例 1:<br>输入: a = 1, b = 2<br>输出: 3</p>
<p>示例 2:<br>输入: a = -2, b = 3<br>输出: 1<br><strong>Progam</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> b==<span class="number">0</span>?a:getSum(a^b,((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a&amp;b)&lt;&lt;<span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="389-找不同"><a href="#389-找不同" class="headerlink" title="389. 找不同"></a>389. 找不同</h2><p><strong>Description</strong><br>给定两个字符串 s 和 t，它们只包含小写字母。<br>字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。<br>请找出在 t 中被添加的字母。<br><strong>Example</strong><br>示例:<br>输入：<br>s = “abcd”<br>t = “abcde”</p>
<p>输出：<br>e<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">toInt</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:str) result^=<span class="number">1</span>&lt;&lt;(ch-<span class="string">'a'</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> x=toInt(s);</span><br><span class="line">        <span class="keyword">int</span> y=toInt(t);</span><br><span class="line">        x^=y;</span><br><span class="line">        y=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(y!=x){</span><br><span class="line">            y&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            num++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> num+<span class="string">'a'</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="393-UTF-8-编码验证"><a href="#393-UTF-8-编码验证" class="headerlink" title="393. UTF-8 编码验证"></a>393. UTF-8 编码验证</h2><p><strong>Description</strong><br>UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则：<br>对于 1 字节的字符，字节的第一位设为0，后面7位为这个符号的unicode码。<br>对于 n 字节的字符 (n &gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。<br>这是 UTF-8 编码的工作方式：</p>
<p>   Char. number range  |        UTF-8 octet sequence<br>      (hexadecimal)    |              (binary)<br>   ——————–+———————————————<br>   0000 0000-0000 007F | 0xxxxxxx<br>   0000 0080-0000 07FF | 110xxxxx 10xxxxxx<br>   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx<br>   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx<br>给定一个表示数据的整数数组，返回它是否为有效的 utf-8 编码。<br>注意:<br>输入是整数数组。只有每个整数的最低 8 个有效位用来存储数据。这意味着每个整数只表示 1 字节的数据。<br><strong>Example</strong><br>示例 1:<br>data = [197, 130, 1], 表示 8 位的序列: 11000101 10000010 00000001.<br>返回 true 。<br>这是有效的 utf-8 编码，为一个2字节字符，跟着一个1字节字符。<br>示例 2:<br>data = [235, 140, 4], 表示 8 位的序列: 11101011 10001100 00000100.<br>返回 false 。<br>前 3 位都是 1 ，第 4 位为 0 表示它是一个3字节字符。<br>下一个字节是开头为 10 的延续字节，这是正确的。<br>但第二个延续字节不以 10 开头，所以是不符合规则的。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validUtf8</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> valid(data, <span class="number">0</span>, data.size()<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;data, <span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(r-l&gt;=<span class="number">0</span>&amp;&amp;(data[l]&amp;<span class="number">0x80</span>)==<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> valid(data, l+<span class="number">1</span>, r);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(r-l&gt;=<span class="number">1</span>&amp;&amp;(data[l]&amp;<span class="number">0xe0</span>)&gt;&gt;<span class="number">5</span>==<span class="number">6</span>&amp;&amp;(data[l+<span class="number">1</span>]&amp;<span class="number">0xc0</span>)&gt;&gt;<span class="number">6</span>==<span class="number">2</span>){</span><br><span class="line">            <span class="keyword">return</span> valid(data,l+<span class="number">2</span>, r);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(r-l&gt;=<span class="number">2</span>&amp;&amp;(data[l]&amp;<span class="number">0xf0</span>)&gt;&gt;<span class="number">4</span>==<span class="number">14</span>&amp;&amp;(data[l+<span class="number">1</span>]&amp;<span class="number">0xc0</span>)&gt;&gt;<span class="number">6</span>==<span class="number">2</span>&amp;&amp;(data[l+<span class="number">2</span>]&amp;<span class="number">0xc0</span>)&gt;&gt;<span class="number">6</span>==<span class="number">2</span>){</span><br><span class="line">            <span class="keyword">return</span> valid(data, l+<span class="number">3</span>, r);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(r-l&gt;=<span class="number">3</span>&amp;&amp;(data[l]&amp;<span class="number">0xf8</span>)&gt;&gt;<span class="number">3</span>==<span class="number">30</span>&amp;&amp;(data[l+<span class="number">1</span>]&amp;<span class="number">0xc0</span>)&gt;&gt;<span class="number">6</span>==<span class="number">2</span>&amp;&amp;(data[l+<span class="number">2</span>]&amp;<span class="number">0xc0</span>)&gt;&gt;<span class="number">6</span>==<span class="number">2</span>&amp;&amp;(data[l+<span class="number">3</span>]&amp;<span class="number">0xc0</span>)&gt;&gt;<span class="number">6</span>==<span class="number">2</span>){</span><br><span class="line">            <span class="keyword">return</span> valid(data, l+<span class="number">4</span>, r);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="401-二进制手表"><a href="#401-二进制手表" class="headerlink" title="401. 二进制手表"></a>401. 二进制手表</h2><p><strong>Description</strong><br>二进制手表顶部有 4 个 LED 代表小时（0-11），底部的 6 个 LED 代表分钟（0-59）。<br><img src="/assets/img/algorithm/Binary_clock_samui_moon.jpg" alt="image"><br>每个 LED 代表一个 0 或 1，最低位在右侧。<br>例如，上面的二进制手表读取 “3:25”。<br>给定一个非负整数 n 代表当前 LED 亮着的数量，返回所有可能的时间。<br><strong>Example</strong><br>案例:<br>输入: n = 1<br>返回: [“1:00”, “2:00”, “4:00”, “8:00”, “0:01”, “0:02”, “0:04”, “0:08”, “0:16”, “0:32”]</p>
<p>注意事项:<br>输出的顺序没有要求。<br>小时不会以零开头，比如 “01:00” 是不允许的，应为 “1:00”。<br>分钟必须由两位数组成，可能会以零开头，比如 “10:2” 是无效的，应为 “10:02”。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isThreeBit</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> mask=<span class="number">0x000003ff</span>; <span class="comment">//取后10位</span></span><br><span class="line">        x&amp;=mask;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>){</span><br><span class="line">            x&amp;=(x<span class="number">-1</span>);</span><br><span class="line">            num++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> num==k;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toString</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="built_in">string</span> s=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">do</span>{</span><br><span class="line">            s+=(x%<span class="number">10</span>)+<span class="string">'0'</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        }<span class="keyword">while</span>(x!=<span class="number">0</span>);</span><br><span class="line">        reverse(s.begin(), s.end());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; readBinaryWatch(<span class="keyword">int</span> num) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;<span class="number">10</span>);i++){</span><br><span class="line">            <span class="built_in">string</span> s=<span class="string">""</span>;</span><br><span class="line">            <span class="keyword">if</span>(isThreeBit(i, num)){</span><br><span class="line">                <span class="keyword">int</span> upbit=<span class="number">0x000003c0</span>;</span><br><span class="line">                <span class="keyword">int</span> lowbit=<span class="number">0x0000003f</span>;</span><br><span class="line">                upbit&amp;=i;</span><br><span class="line">                lowbit&amp;=i;</span><br><span class="line">                upbit&gt;&gt;=<span class="number">6</span>;</span><br><span class="line">                <span class="keyword">if</span>((upbit&gt;=<span class="number">0</span>&amp;&amp;upbit&lt;=<span class="number">11</span>)&amp;&amp;(lowbit&gt;=<span class="number">0</span>&amp;&amp;lowbit&lt;=<span class="number">59</span>)){</span><br><span class="line">                    s=s+toString(upbit)+<span class="string">":"</span>;</span><br><span class="line">                    <span class="keyword">if</span>(lowbit&lt;<span class="number">10</span>) s=s+<span class="string">"0"</span>;</span><br><span class="line">                    s=s+toString(lowbit);</span><br><span class="line">                    result.push_back(s);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="397-整数替换"><a href="#397-整数替换" class="headerlink" title="397. 整数替换"></a>397. 整数替换</h2><p><strong>Description</strong><br>给定一个正整数 n，你可以做如下操作：</p>
<ol>
<li>如果 n 是偶数，则用 n / 2替换 n。</li>
<li>如果 n 是奇数，则可以用 n + 1或n - 1替换 n。<br>n 变为 1 所需的最小替换次数是多少？</li>
</ol>
<p><strong>Example</strong><br>示例 1:<br>输入:<br>8<br>输出:<br>3<br>解释:<br>8 -&gt; 4 -&gt; 2 -&gt; 1</p>
<p>示例 2:<br>输入:<br>7<br>输出:<br>4<br>解释:<br>7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1<br>或<br>7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; DP;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerReplacement</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        DP[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> integerR(n);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">integerR</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> DP[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">if</span>(DP.find(n)==DP.end()) DP[n]=integerR(n/<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>!=<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">if</span>(DP.find(n)==DP.end()) DP[n]=min(integerR(n+<span class="number">1</span>), integerR(n<span class="number">-1</span>))+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="405-数字转换为十六进制数"><a href="#405-数字转换为十六进制数" class="headerlink" title="405. 数字转换为十六进制数"></a>405. 数字转换为十六进制数</h2><p><strong>Description</strong><br>给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。<br>注意:<br>十六进制中所有字母(a-f)都必须是小写。<br>十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符’0’来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。<br>给定的数确保在32位有符号整数范围内。<br>不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。<br><strong>Example</strong><br>示例 1：<br>输入:<br>26<br>输出:<br>“1a”</p>
<p>示例 2：<br>输入:<br>-1</p>
<p>输出:<br>“ffffffff”<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> m[<span class="number">16</span>]={<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>};</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0xf</span>;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++){</span><br><span class="line">            str+=m[(carry&amp;num)];</span><br><span class="line">            num&gt;&gt;=<span class="number">4</span>;</span><br><span class="line">        }</span><br><span class="line">        reverse(str.begin(), str.end());</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[idx]==<span class="string">'0'</span>)idx++;</span><br><span class="line">        str = str.substr(idx);</span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">0</span>) str=<span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="421-数组中两个数的最大异或值-1"><a href="#421-数组中两个数的最大异或值-1" class="headerlink" title="421. 数组中两个数的最大异或值"></a>421. 数组中两个数的最大异或值</h2><p><strong>Description</strong><br>给定一个非空数组，数组中元素为 a0, a1, a2, … , an-1，其中 0 ≤ ai &lt; 231 。<br>找到 ai 和aj 最大的异或 (XOR) 运算结果，其中0 ≤ i,  j &lt; n 。<br>你能在O(n)的时间解决这个问题吗？<br><strong>Example</strong><br>示例:<br>输入: [3, 10, 5, 25, 2, 8]<br>输出: 28<br>解释: 最大的结果是 5 ^ 25 = 28.<br><strong>Program</strong><br><strong>思路</strong><br>我们需要尽可能保留高位1，根据性质$a XOR b=c, a XOR c=b$，假设每个高位初始为1，与每个数前缀（高位）异或运算，如果异或结果存在前缀则保留1，否则0.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mask=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            mask = mask | (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">            <span class="comment">//保留前缀</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x:nums){</span><br><span class="line">                s.insert(mask&amp;x);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//性质</span></span><br><span class="line">            <span class="keyword">int</span> temp = res | (<span class="number">1</span>&lt;&lt;i); <span class="comment">//前i-1位已经确定，假设第i位为1,</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> prefix:s){</span><br><span class="line">                <span class="keyword">if</span>(s.find(prefix^temp)!=s.end()){ <span class="comment">//与前缀异或，根据性质如果能够找到另一个数，则说明第i位为1</span></span><br><span class="line">                    res=temp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461. 汉明距离"></a>461. 汉明距离</h2><p><strong>Description</strong><br>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。<br>给出两个整数 x 和 y，计算它们之间的汉明距离。<br>注意：<br>0 ≤ x, y &lt; 231.<br><strong>Example</strong><br>示例:<br>输入: x = 1, y = 4<br>输出: 2<br>解释:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br></pre></td></tr></tbody></table></figure>
<p>上面的箭头指出了对应二进制位不同的位置。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{</span><br><span class="line">        x ^= y;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>){</span><br><span class="line">            x&amp;=(x<span class="number">-1</span>);</span><br><span class="line">            y++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="476-数字的补数"><a href="#476-数字的补数" class="headerlink" title="476. 数字的补数"></a>476. 数字的补数</h2><p><strong>Description</strong><br>给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。<br>注意:<br>给定的整数保证在32位带符号整数的范围内。<br>你可以假定二进制数不包含前导零位。<br><strong>Example</strong><br>示例 1:<br>输入: 5<br>输出: 2<br>解释: 5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。</p>
<p>示例 2:<br>输入: 1<br>输出: 0<br>解释: 1的二进制表示为1（没有前导零位），其补数为0。所以你需要输出0。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> upbit=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">if</span>((num&amp;upbit)!=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            upbit&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">16</span>;i*=<span class="number">2</span>) upbit|=(upbit&gt;&gt;i);</span><br><span class="line">        <span class="keyword">return</span> (upbit^num);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="477-汉明距离总和"><a href="#477-汉明距离总和" class="headerlink" title="477. 汉明距离总和"></a>477. 汉明距离总和</h2><p><strong>Description</strong><br>两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。<br>计算一个数组中，任意两个数之间汉明距离的总和。<br><strong>Example</strong><br>示例:<br>输入: 4, 14, 2<br>输出: 6<br>解释: 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系）<br>所以答案为：<br>HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.<br>注意:<br>数组中元素的范围为从 0到 10^9。<br>数组的长度不超过 $10^4$。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalHammingDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums){</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;<span class="number">32</span>){</span><br><span class="line">                vec[i]+=(x&amp;<span class="number">0x1</span>);</span><br><span class="line">                x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:vec){</span><br><span class="line">            sum+=x*(n-x);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="693-交替位二进制数"><a href="#693-交替位二进制数" class="headerlink" title="693. 交替位二进制数"></a>693. 交替位二进制数</h2><p><strong>Description</strong><br>给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。<br><strong>Example</strong><br>示例 1:<strong>Example</strong><br>输入: 5<br>输出: True<br>解释:<br>5的二进制数是: 101</p>
<p>示例 2:<br>输入: 7<br>输出: False<br>解释:<br>7的二进制数是: 111</p>
<p>示例 3:<br>输入: 11<br>输出: False<br>解释:<br>11的二进制数是: 1011</p>
<p>示例 4:<br>输入: 10<br>输出: True<br>解释:<br>10的二进制数是: 1010<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasAlternatingBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> bit=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line">        <span class="keyword">while</span>((bit&amp;n)==<span class="number">0</span>) bit&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">16</span>;i*=<span class="number">2</span>) bit|=(bit&gt;&gt;i);</span><br><span class="line">        <span class="keyword">return</span> (bit^n)==<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="756-金字塔转换矩阵"><a href="#756-金字塔转换矩阵" class="headerlink" title="756. 金字塔转换矩阵"></a>756. 金字塔转换矩阵</h2><p><strong>Description</strong><br>现在，我们用一些方块来堆砌一个金字塔。 每个方块用仅包含一个字母的字符串表示。<br>使用三元组表示金字塔的堆砌规则如下：<br>对于三元组(A, B, C) ，“C”为顶层方块，方块“A”、“B”分别作为方块“C”下一层的的左、右子块。当且仅当(A, B, C)是被允许的三元组，我们才可以将其堆砌上。<br>初始时，给定金字塔的基层 bottom，用一个字符串表示。一个允许的三元组列表 allowed，每个三元组用一个长度为 3 的字符串表示。<br>如果可以由基层一直堆到塔尖就返回 true，否则返回 false。<br><strong>Example</strong><br>示例 1:<br>输入: bottom = “BCD”, allowed = [“BCG”, “CDE”, “GEA”, “FFF”]<br>输出: true<br>解析:<br>可以堆砌成这样的金字塔:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   / \</span><br><span class="line">  G   E</span><br><span class="line"> / \ / \</span><br><span class="line">B   C   D</span><br></pre></td></tr></tbody></table></figure>
<p>因为符合(‘B’, ‘C’, ‘G’), (‘C’, ‘D’, ‘E’) 和 (‘G’, ‘E’, ‘A’) 三种规则。<br>示例 2:</p>
<p>输入: bottom = “AABA”, allowed = [“AAA”, “AAB”, “ABA”, “ABB”, “BAC”]<br>输出: false<br>解析:<br>无法一直堆到塔尖。<br>注意, 允许存在像 (A, B, C) 和 (A, B, D) 这样的三元组，其中 C != D。</p>
<p>注意：<br>bottom 的长度范围在 [2, 8]。<br>allowed 的长度范围在[0, 200]。<br>方块的标记字母范围为{‘A’, ‘B’, ‘C’, ‘D’, ‘E’, ‘F’, ‘G’}。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pyramidTransition</span><span class="params">(<span class="built_in">string</span> bottom, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; allowed)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> judge(bottom, <span class="string">""</span>, allowed);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="built_in">string</span> bottom, <span class="built_in">string</span> new_bottom, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; allowed)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(bottom.length()==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(bottom.length()-new_bottom.length()==<span class="number">1</span>) <span class="keyword">return</span> judge(new_bottom, <span class="string">""</span>, allowed);</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">string</span> str:allowed){</span><br><span class="line">                <span class="keyword">if</span>(bottom[new_bottom.size()]==str[<span class="number">0</span>]&amp;&amp;bottom[new_bottom.size()+<span class="number">1</span>]==str[<span class="number">1</span>]){</span><br><span class="line">                    <span class="keyword">if</span>(judge(bottom, new_bottom+str[<span class="number">2</span>], allowed)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="762-二进制表示中质数个计算置位"><a href="#762-二进制表示中质数个计算置位" class="headerlink" title="762. 二进制表示中质数个计算置位"></a>762. 二进制表示中质数个计算置位</h2><p><strong>Description</strong><br>给定两个整数 L 和 R ，找到闭区间 [L, R] 范围内，计算置位位数为质数的整数个数。<br>（注意，计算置位代表二进制表示中1的个数。例如 21 的二进制表示 10101 有 3 个计算置位。还有，1 不是质数。）<br><strong>Example</strong><br>示例 1:<br>输入: L = 6, R = 10<br>输出: 4<br>解释:<br>6 -&gt; 110 (2 个计算置位，2 是质数)<br>7 -&gt; 111 (3 个计算置位，3 是质数)<br>9 -&gt; 1001 (2 个计算置位，2 是质数)<br>10-&gt; 1010 (2 个计算置位，2 是质数)</p>
<p>示例 2:<br>输入: L = 10, R = 15<br>输出: 5<br>解释:<br>10 -&gt; 1010 (2 个计算置位, 2 是质数)<br>11 -&gt; 1011 (3 个计算置位, 3 是质数)<br>12 -&gt; 1100 (2 个计算置位, 2 是质数)<br>13 -&gt; 1101 (3 个计算置位, 3 是质数)<br>14 -&gt; 1110 (3 个计算置位, 3 是质数)<br>15 -&gt; 1111 (4 个计算置位, 4 不是质数)<br>注意:<br>L, R 是 L &lt;= R 且在 [1, 10^6] 中的整数。<br>R - L 的最大值为 10000。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    <span class="keyword">int</span> MAXN=<span class="number">1000001</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Euler</span><span class="params">()</span></span>{</span><br><span class="line">        vis.resize(MAXN, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;MAXN;i++){</span><br><span class="line">            <span class="keyword">if</span>(!vis[i]){</span><br><span class="line">                vis[i]=<span class="literal">true</span>;</span><br><span class="line">                prime.push_back(i);</span><br><span class="line">                s.insert(i);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;prime.size()&amp;&amp;prime[j]*i&lt;MAXN;j++){</span><br><span class="line">                vis[prime[j]*i]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>||x==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=x;i++){</span><br><span class="line">            <span class="keyword">if</span>(x%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimeSetBits</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>{</span><br><span class="line">        <span class="comment">//Euler();</span></span><br><span class="line">        <span class="keyword">int</span> nCount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=L;i&lt;=R;i++){</span><br><span class="line">            <span class="keyword">int</span> x=i;</span><br><span class="line">            <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x!=<span class="number">0</span>){</span><br><span class="line">                x&amp;=(x<span class="number">-1</span>);</span><br><span class="line">                num++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//if(s.find(num)!=s.end()) nCount++;</span></span><br><span class="line">            <span class="keyword">if</span>(isPrime(num)) nCount++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nCount;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="784-字母大小写全排列"><a href="#784-字母大小写全排列" class="headerlink" title="784. 字母大小写全排列"></a>784. 字母大小写全排列</h2><p><strong>Description</strong><br>给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。<br><strong>Example</strong><br>示例:<br>输入: S = “a1b2”<br>输出: [“a1b2”, “a1B2”, “A1b2”, “A1B2”]</p>
<p>输入: S = “3z4”<br>输出: [“3z4”, “3Z4”]</p>
<p>输入: S = “12345”<br>输出: [“12345”]</p>
<p>注意：<br>S 的长度不超过12。<br>S 仅由数字和字母组成。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCasePermutation(<span class="built_in">string</span> S) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.length();i++){</span><br><span class="line">            <span class="keyword">if</span>(S[i]&gt;=<span class="string">'a'</span>&amp;&amp;S[i]&lt;=<span class="string">'z'</span>) pos.push_back(i);</span><br><span class="line">            <span class="keyword">if</span>(S[i]&gt;=<span class="string">'A'</span>&amp;&amp;S[i]&lt;=<span class="string">'Z'</span>) pos.push_back(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;pos.size());i++){</span><br><span class="line">            <span class="built_in">string</span> str=S;</span><br><span class="line">            <span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;pos.size();j++){</span><br><span class="line">                <span class="keyword">if</span>((x&amp;i)!=<span class="number">0</span>){</span><br><span class="line">                    <span class="keyword">if</span>(str[pos[j]]&gt;=<span class="string">'a'</span>&amp;&amp;str[pos[j]]&lt;=<span class="string">'z'</span>) str[pos[j]]+=<span class="string">'A'</span>-<span class="string">'a'</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(str[pos[j]]&gt;=<span class="string">'A'</span>&amp;&amp;str[pos[j]]&lt;=<span class="string">'Z'</span>) str[pos[j]]+=<span class="string">'a'</span>-<span class="string">'A'</span>;</span><br><span class="line">                }</span><br><span class="line">                x&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            result.push_back(str);</span><br><span class="line">        }</span><br><span class="line">        sort(result.begin(), result.end(), greater&lt;<span class="built_in">string</span>&gt;());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1131-绝对值表达式的最大值"><a href="#1131-绝对值表达式的最大值" class="headerlink" title="1131. 绝对值表达式的最大值"></a>1131. 绝对值表达式的最大值</h2><p><strong>Description</strong><br>给你两个长度相等的整数数组，返回下面表达式的最大值：<br>$|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|$<br>其中下标 i，j 满足 0 &lt;= i, j &lt; arr1.length。<br><strong>Example</strong><br>示例 1：<br>输入：arr1 = [1,2,3,4], arr2 = [-1,4,5,6]<br>输出：13</p>
<p>示例 2：<br>输入：arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]<br>输出：20<br><strong>Program</strong><br><strong>分析:</strong><br>既然暴力解不可行，那么我们就需要思考有没有更好的办法，已知要求 $|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|$ 的最大值，我们可以先考虑一下子问题的求解：<br><strong>子问题 1. 求 |arr1[i] - arr1[j]| 的最大值</strong><br>这就比较简单了，可以直观地看出来答案，一个数组 arr1 里两个元素差的绝对值的最大值，应该等于 max(arr1) - min(arr1)<br><strong>子问题 2. 求 |arr1[i] - arr1[j]| + |i - j| 的最大值</strong><br>比上一题复杂了一点，观察并不能得出答案，因此，不妨把表达式的绝对值符号去掉，看看展开后会得到怎样的结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abs( arr1[i] - arr1[j]) + abs(i - j)</span><br><span class="line">=  arr1[i] - arr1[j] + i - j =  (arr1[i] + i) - (arr1[j] + j) # 式1</span><br><span class="line">=  arr1[i] - arr1[j] - i + j =  (arr1[i] - i) - (arr1[j] - j) # 式2</span><br><span class="line">= -arr1[i] + arr1[j] + i - j = -(arr1[i] - i) + (arr1[j] - j) # 式3</span><br><span class="line">= -arr1[i] + arr1[j] - i + j = -(arr1[i] + i) + (arr1[j] + j) # 式4</span><br></pre></td></tr></tbody></table></figure>
<p>因为 i 和 j 是可以互换的，所以式 11 等价于式 44， 式 22 等价于式 33，因此可以得到：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abs( arr1[i] - arr1[j]) + abs(i - j)</span><br><span class="line">= (arr1[i] + i) - (arr1[j] + j) ------式1</span><br><span class="line">= (arr1[i] - i) - (arr1[j] - j) ------式2</span><br></pre></td></tr></tbody></table></figure>
<p>现在不难发现， 原始表达式的值只取决于两个中间表达式：<br>中间表达式 A = arr1[i] + i<br>中间表达式 B = arr1[i] - i<br>所以有：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">max(abs( arr1[i] - arr1[j]) + abs(i - j) )</span><br><span class="line">= max((arr1[i] + i) - (arr1[j] + j),</span><br><span class="line">      (arr1[i] - i) - (arr1[j] - j))</span><br><span class="line">= max( max(A) - min(A),</span><br><span class="line">       max(B) - min(B))</span><br></pre></td></tr></tbody></table></figure>
<p>因此，不难得到子问题的求解代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Python</span><br><span class="line">class Solution(object):</span><br><span class="line">    def maxAbsValExpr(self, arr1, arr2):</span><br><span class="line">        """</span><br><span class="line">        :type arr1: List[int]</span><br><span class="line">        :type arr2: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span><br><span class="line">        A = []</span><br><span class="line">        B = []</span><br><span class="line">        for i, x in enumerate(arr1):</span><br><span class="line">            A.append(x + i)</span><br><span class="line">            B.append(x - i)</span><br><span class="line">        return max(max(A) - min(A), max(B) - min(B))</span><br></pre></td></tr></tbody></table></figure>
<p>现在已经知道了子问题如何求解，那么本题也可以采用相同的解法，首先把绝对值符号去掉，展开表达式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|</span><br><span class="line"></span><br><span class="line"> =  (arr1[i] + arr2[i] + i) - (arr1[j] + arr2[j] + j)</span><br><span class="line"> =  (arr1[i] + arr2[i] - i) - (arr1[j] + arr2[j] - j)</span><br><span class="line"> =  (arr1[i] - arr2[i] + i) - (arr1[j] - arr2[j] + j)</span><br><span class="line"> =  (arr1[i] - arr2[i] - i) - (arr1[j] - arr2[j] - j)</span><br><span class="line"> = -(arr1[i] + arr2[i] + i) + (arr1[j] + arr2[j] + j)</span><br><span class="line"> = -(arr1[i] + arr2[i] - i) + (arr1[j] + arr2[j] - j)</span><br><span class="line"> = -(arr1[i] - arr2[i] + i) + (arr1[j] - arr2[j] + j)</span><br><span class="line"> = -(arr1[i] - arr2[i] - i) + (arr1[j] - arr2[j] - j)</span><br></pre></td></tr></tbody></table></figure>
<p>因为存在四组两两等价的展开，所以可以优化为四个表达式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A = arr1[i] + arr2[i] + i</span><br><span class="line">B = arr1[i] + arr2[i] - i</span><br><span class="line">C = arr1[i] - arr2[i] + i</span><br><span class="line">D = arr1[i] - arr2[i] - i</span><br><span class="line"></span><br><span class="line">max( |arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|)</span><br><span class="line">= max(max(A) - min(A),</span><br><span class="line">      max(B) - min(B),</span><br><span class="line">      max(C) - min(C),</span><br><span class="line">      max(D) - min(D))</span><br></pre></td></tr></tbody></table></figure>
<p>Python代码实现:</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAbsValExpr</span><span class="params">(self, arr1, arr2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr1: List[int]</span></span><br><span class="line"><span class="string">        :type arr2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        A, B, C, D= [], [], [], []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr1)):</span><br><span class="line">            x, y = arr1[i], arr2[i]</span><br><span class="line">            A.append(x + y + i)</span><br><span class="line">            B.append(x + y - i)</span><br><span class="line">            C.append(x - y + i)</span><br><span class="line">            D.append(x - y - i)</span><br><span class="line"></span><br><span class="line">        a = max(A) - min(A)</span><br><span class="line">        b = max(B) - min(B)</span><br><span class="line">        c = max(C) - min(C)</span><br><span class="line">        d = max(D) - min(D)        </span><br><span class="line">        <span class="keyword">return</span> max(a, b, c, d)</span><br></pre></td></tr></tbody></table></figure>
<p>复杂度分析:<br>时间复杂度：$O(N)$<br>空间复杂度：$O(N)$<br>优化分析：<br>其实，并没有必要储存所有的 ·A,B,C,D· 表达式的值，<br>因为我们需要的仅仅是 ·A,B,C,D· 表达式的最大值和最小值，<br>因此可以用八个变量替代四个数组，将空间优化到 $O(1)$。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> step[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAbsValExpr</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">-1000001</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line">            <span class="keyword">int</span> x=step[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y=step[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> max_value=<span class="number">-1000001</span>;</span><br><span class="line">            <span class="keyword">int</span> min_value=<span class="number">1000001</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr1.size();j++){</span><br><span class="line">                <span class="keyword">int</span> value=arr1[j]+x*arr2[j]+y*j;</span><br><span class="line">                max_value=max(value,max_value);</span><br><span class="line">                min_value=min(value,min_value);</span><br><span class="line">            }</span><br><span class="line">            result=max(result, max_value-min_value);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1239-串联字符串的最大长度"><a href="#1239-串联字符串的最大长度" class="headerlink" title="1239. 串联字符串的最大长度"></a>1239. 串联字符串的最大长度</h2><p><strong>Description</strong><br>给定一个字符串数组 arr，字符串 s 是将 arr 某一子序列字符串连接所得的字符串，如果 s 中的每一个字符都只出现过一次，那么它就是一个可行解。<br>请返回所有可行解 s 中最长长度。<br><strong>Example</strong><br>示例 1：<br>输入：arr = [“un”,”iq”,”ue”]<br>输出：4<br>解释：所有可能的串联组合是 “”,”un”,”iq”,”ue”,”uniq” 和 “ique”，最大长度为 4。</p>
<p>示例 2：<br>输入：arr = [“cha”,”r”,”act”,”ers”]<br>输出：6<br>解释：可能的解答有 “chaers” 和 “acters”。</p>
<p>示例 3：<br>输入：arr = [“abcdefghijklmnopqrstuvwxyz”]<br>输出：26</p>
<p>提示：<br>1 &lt;= arr.length &lt;= 16<br>1 &lt;= arr[i].length &lt;= 26<br>arr[i] 中只含有小写英文字母<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; arr)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        <span class="keyword">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bitMap(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="built_in">string</span> str=arr[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;str.length();j++){</span><br><span class="line">                <span class="keyword">int</span> tmpBit = (<span class="number">1</span>&lt;&lt;(str[j]-<span class="string">'a'</span>));</span><br><span class="line">                <span class="keyword">if</span>((bitMap[i]&amp;tmpBit)==<span class="number">0</span>){</span><br><span class="line">                    bitMap[i]|=tmpBit;</span><br><span class="line">                }<span class="keyword">else</span>{  <span class="comment">//重复</span></span><br><span class="line">                    bitMap[i]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++){</span><br><span class="line">            <span class="keyword">int</span> bit=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">if</span>((i &amp; (<span class="number">1</span>&lt;&lt;j)) != <span class="number">0</span>){</span><br><span class="line">                    <span class="keyword">if</span>(bitMap[j]==<span class="number">0</span>){  <span class="comment">//重复</span></span><br><span class="line">                        len=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span>((bit&amp;bitMap[j])==<span class="number">0</span>){</span><br><span class="line">                        bit|=bitMap[j];</span><br><span class="line">                        len+=arr[j].length();</span><br><span class="line">                    }<span class="keyword">else</span>{ <span class="comment">//重复</span></span><br><span class="line">                        len=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            maxLen=max(maxLen, len);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1290-二进制链表转整数"><a href="#1290-二进制链表转整数" class="headerlink" title="1290. 二进制链表转整数"></a>1290. 二进制链表转整数</h2><p><strong>Description</strong><br>给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。<br>请你返回该链表所表示数字的 十进制值 。<br><strong>Example</strong><br>示例 1：<br>输入：head = [1,0,1]<br>输出：5<br>解释：二进制数 (101) 转化为十进制数 (5)</p>
<p>示例 2：<br>输入：head = [0]<br>输出：0</p>
<p>示例 3：<br>输入：head = [1]<br>输出：1</p>
<p>示例 4：<br>输入：head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]<br>输出：18880</p>
<p>示例 5：<br>输入：head = [0,0]<br>输出：0</p>
<p>提示：<br>链表不为空。<br>链表的结点总数不超过 30。<br>每个结点的值不是 0 就是 1。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDecimalValue</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>){</span><br><span class="line">            result=result*<span class="number">2</span>+head-&gt;val;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1297-子串的最大出现次数"><a href="#1297-子串的最大出现次数" class="headerlink" title="1297. 子串的最大出现次数"></a>1297. 子串的最大出现次数</h2><p><strong>Description</strong><br>给你一个字符串 s ，请你返回满足以下条件且出现次数最大的 任意 子串的出现次数：<br>子串中不同字母的数目必须小于等于 maxLetters 。<br>子串的长度必须大于等于 minSize 且小于等于 maxSize 。<br> <strong>Example</strong><br>示例 1：<br>输入：s = “aababcaab”, maxLetters = 2, minSize = 3, maxSize = 4<br>输出：2<br>解释：子串 “aab” 在原字符串中出现了 2 次。<br>它满足所有的要求：2 个不同的字母，长度为 3 （在 minSize 和 maxSize 范围内）。</p>
<p>示例 2：<br>输入：s = “aaaa”, maxLetters = 1, minSize = 3, maxSize = 3<br>输出：2<br>解释：子串 “aaa” 在原字符串中出现了 2 次，且它们有重叠部分。</p>
<p>示例 3：<br>输入：s = “aabcabcab”, maxLetters = 2, minSize = 2, maxSize = 3<br>输出：3</p>
<p>示例 4：<br>输入：s = “abcde”, maxLetters = 2, minSize = 3, maxSize = 3<br>输出：0</p>
<p>提示：<br>1 &lt;= s.length &lt;= 10^5<br>1 &lt;= maxLetters &lt;= 26<br>1 &lt;= minSize &lt;= maxSize &lt;= min(26, s.length)<br>s 只包含小写英文字母。<br><strong>Program</strong><br>假设字符串 T 在给定的字符串 S 中出现的次数为 k，那么 T 的任意一个子串出现的次数至少也为 k，即 T 的任意一个子串在 S 中出现的次数不会少于 T 本身。这样我们就可以断定，在所有满足条件且出现次数最多的的字符串中，一定有一个的长度恰好为 minSize。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxFreq</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> maxLetters, <span class="keyword">int</span> minSize, <span class="keyword">int</span> maxSize)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n-minSize+<span class="number">1</span>;i++){</span><br><span class="line">            <span class="built_in">string</span> str=s.substr(i, minSize);</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; st(str.begin(), str.end());</span><br><span class="line">            <span class="keyword">if</span>(st.size()&lt;=maxLetters){</span><br><span class="line">                m[str]++;</span><br><span class="line">                result=max(result, m[str]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1310-子数组异或查询"><a href="#1310-子数组异或查询" class="headerlink" title="1310. 子数组异或查询"></a>1310. 子数组异或查询</h2><p><strong>Description</strong><br>有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。<br>对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor … xor arr[Ri]）作为本次查询的结果。<br>并返回一个包含给定查询 queries 所有结果的数组。<br><strong>Example</strong><br>示例 1：<br>输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]<br>输出：[2,7,14,8]<br>解释：<br>数组中元素的二进制表示形式是：<br>1 = 0001<br>3 = 0011<br>4 = 0100<br>8 = 1000<br>查询的 XOR 值为：<br>[0,1] = 1 xor 3 = 2<br>[1,2] = 3 xor 4 = 7<br>[0,3] = 1 xor 3 xor 4 xor 8 = 14<br>[3,3] = 8</p>
<p>示例 2：<br>输入：arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]<br>输出：[8,0,4,4]</p>
<p>提示：<br>$$1 &lt;= arr.length &lt;= 3 * 10^4 \\<br>1 &lt;= arr[i] &lt;= 10^9  \\<br>1 &lt;= queries.length &lt;= 3 * 10^4 \\<br>queries[i].length == 2 \\<br>0 &lt;= queries[i][0] &lt;= queries[i][1] &lt; arr.length$$<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; xorQueries(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) {</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) s[i]=s[i<span class="number">-1</span>]^arr[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec:queries){</span><br><span class="line">            <span class="keyword">int</span> l=vec[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> r=vec[<span class="number">1</span>];</span><br><span class="line">            result.push_back(s[r+<span class="number">1</span>]^s[l]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1318-或运算的最小翻转次数"><a href="#1318-或运算的最小翻转次数" class="headerlink" title="1318. 或运算的最小翻转次数"></a>1318. 或运算的最小翻转次数</h2><p><strong>Description</strong><br>给你三个正整数 a、b 和 c。<br>你可以对 a 和 b 的二进制表示进行位翻转操作，返回能够使按位或运算   a OR b == c  成立的最小翻转次数。<br>「位翻转操作」是指将一个数的二进制表示任何单个位上的 1 变成 0 或者 0 变成 1 。<br><strong>Example</strong><br>示例 1：<br>输入：a = 2, b = 6, c = 5<br>输出：3<br>解释：翻转后 a = 1 , b = 4 , c = 5 使得 a OR b == c</p>
<p>示例 2：<br>输入：a = 4, b = 2, c = 7<br>输出：1</p>
<p>示例 3：<br>输入：a = 1, b = 2, c = 3<br>输出：0</p>
<p>提示：<br>1 &lt;= a &lt;= 10^9<br>1 &lt;= b &lt;= 10^9<br>1 &lt;= c &lt;= 10^9<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minFlips</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">31</span>;i++){</span><br><span class="line">            <span class="keyword">int</span> x=((a&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> y=((b&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> z=((c&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>((x|y)!=z){</span><br><span class="line">                <span class="keyword">if</span>(z==<span class="number">1</span>) result+=((x|y)&gt;<span class="number">0</span>)?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> result+=(x+y);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="721-账户合并"><a href="#721-账户合并" class="headerlink" title="721. 账户合并"></a>721. 账户合并</h2><p><strong>Description</strong><br>给定一个列表 accounts，每个元素 accounts[i] 是一个字符串列表，其中第一个元素 accounts[i][0] 是 名称 (name)，其余元素是 emails 表示该帐户的邮箱地址。<br>现在，我们想合并这些帐户。如果两个帐户都有一些共同的邮件地址，则两个帐户必定属于同一个人。请注意，即使两个帐户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的帐户，但其所有帐户都具有相同的名称。<br>合并帐户后，按以下格式返回帐户：每个帐户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。accounts 本身可以以任意顺序返回。<br><strong>Example</strong><br>例子 1:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">accounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]]</span><br><span class="line">Output: [["John", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]]</span><br></pre></td></tr></tbody></table></figure>
<p>Explanation:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一个和第三个 John 是同一个人，因为他们有共同的电子邮件 "johnsmith@mail.com"。</span><br><span class="line">第二个 John 和 Mary 是不同的人，因为他们的电子邮件地址没有被其他帐户使用。</span><br><span class="line">我们可以以任何顺序返回这些列表，例如答案[['Mary'，'mary@mail.com']，['John'，'johnnybravo@mail.com']，</span><br><span class="line">['John'，'john00@mail.com'，'john_newyork@mail.com'，'johnsmith@mail.com']]仍然会被接受。</span><br></pre></td></tr></tbody></table></figure>
<p>注意：<br>accounts的长度将在[1，1000]的范围内。<br>accounts[i]的长度将在[1，10]的范围内。<br>accounts[i][j]的长度将在[1，30]的范围内。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//超时，注意合并操作，复杂度O(10^6*300*log2(10))</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) father[i]=i;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(father[x]!=x) father[x]=findFather(father[x]);</span><br><span class="line">        <span class="keyword">return</span> father[x];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionSet</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; accounts)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> fa=findFather(x);</span><br><span class="line">        <span class="keyword">int</span> fb=findFather(y);</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;accounts[x].size();i++) st.insert(accounts[x][i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;accounts[y].size();i++){</span><br><span class="line">            <span class="keyword">if</span>(st.find(accounts[y][i])!=st.end()){</span><br><span class="line">                father[fa]=fb;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; accountsMerge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; accounts) {</span><br><span class="line">        n=accounts.size();</span><br><span class="line">        father.resize(n);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++){</span><br><span class="line">                unionSet(i, j, accounts);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//for(int i=0;i&lt;n;i++) cout&lt;&lt;father[i]&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> fa=findFather(i);</span><br><span class="line">            <span class="comment">// if(m.find(fa)==m.end()){</span></span><br><span class="line">            <span class="comment">//     m[fa]=set&lt;string&gt;();</span></span><br><span class="line">            <span class="comment">// }</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;accounts[i].size();j++) m[fa].insert(accounts[i][j]);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt;::iterator it=m.begin();it!=m.end();it++){</span><br><span class="line">            <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&amp; st=it-&gt;second;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">            vec.push_back(accounts[it-&gt;first][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">string</span> str:st) vec.push_back(str);</span><br><span class="line">            result.push_back(vec);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) father[i]=i;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(father[x]!=x) father[x]=findFather(father[x]);</span><br><span class="line">        <span class="keyword">return</span> father[x];</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; accountsMerge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; accounts) {</span><br><span class="line">        n=accounts.size();</span><br><span class="line">        father.resize(n);</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; vec=accounts[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;vec.size();j++) m[vec[j]].push_back(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;::iterator it=m.begin();it!=m.end();it++){</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec=it-&gt;second;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;vec.size();i++){</span><br><span class="line">                <span class="keyword">int</span> fa=findFather(vec[<span class="number">0</span>]); <span class="comment">//不能放外面！</span></span><br><span class="line">                <span class="keyword">int</span> fb=findFather(vec[i]);</span><br><span class="line">                <span class="keyword">if</span>(fa!=fb) father[fa]=fb;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt; vs;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; iTol;</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> fa=findFather(i);</span><br><span class="line">            <span class="keyword">if</span>(iTol.find(fa)==iTol.end()){</span><br><span class="line">                iTol[fa]=idx++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        vs.resize(idx);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;::iterator it=m.begin();it!=m.end();it++){</span><br><span class="line">            <span class="built_in">string</span> str=it-&gt;first;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec=it-&gt;second;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size();i++){</span><br><span class="line">                <span class="keyword">int</span> fa=findFather(vec[i]);</span><br><span class="line">                <span class="keyword">int</span> idx=iTol[fa];</span><br><span class="line">                <span class="keyword">if</span>(vs[idx].empty()){</span><br><span class="line">                    vs[idx].insert(accounts[vec[i]][<span class="number">0</span>]);</span><br><span class="line">                }</span><br><span class="line">                vs[idx].insert(str);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vs.size();i++) result.push_back(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(vs[i].begin(),vs[i].end()));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(10000)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) father[i]=i;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(father[x]!=x) father[x]=findFather(father[x]);</span><br><span class="line">        <span class="keyword">return</span> father[x];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionSet</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> fa=findFather(x);</span><br><span class="line">        <span class="keyword">int</span> fb=findFather(y);</span><br><span class="line">        <span class="keyword">if</span>(fa!=fb) father[fa]=fb;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; accountsMerge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; accounts) {</span><br><span class="line">        n=accounts.size();</span><br><span class="line">        father.resize(n);</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;accounts[i].size();j++){</span><br><span class="line">                <span class="keyword">if</span>(m.find(accounts[i][j])==m.end()) m[accounts[i][j]]=i;</span><br><span class="line">                <span class="keyword">else</span> unionSet(m[accounts[i][j]], i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; iTol;</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> fa=findFather(i);</span><br><span class="line">            <span class="keyword">if</span>(iTol.find(fa)==iTol.end()){</span><br><span class="line">                iTol[fa]=idx++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        result.resize(idx);</span><br><span class="line">        <span class="keyword">for</span>(pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; it:m){</span><br><span class="line">            <span class="built_in">string</span> str=it.first;</span><br><span class="line">            <span class="keyword">int</span> fa=findFather(it.second);</span><br><span class="line">            <span class="keyword">int</span> idx=iTol[fa];</span><br><span class="line">            <span class="keyword">if</span>(result[idx].empty()){</span><br><span class="line">                result[idx].push_back(accounts[fa][<span class="number">0</span>]);</span><br><span class="line">            }</span><br><span class="line">            result[idx].push_back(str);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;result.size();i++) sort(result[i].begin()+<span class="number">1</span>, result[i].end());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="947-移除最多的同行或同列石头"><a href="#947-移除最多的同行或同列石头" class="headerlink" title="947. 移除最多的同行或同列石头"></a>947. 移除最多的同行或同列石头</h2><p><strong>Description</strong><br>在二维平面上，我们将石头放置在一些整数坐标点上。每个坐标点上最多只能有一块石头。<br>现在，move 操作将会移除与网格上的某一块石头共享一列或一行的一块石头。<br>我们最多能执行多少次 move 操作？<br><strong>Example</strong><br>示例 1：<br>输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]<br>输出：5</p>
<p>示例 2：<br>输入：stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]<br>输出：3</p>
<p>示例 3：<br>输入：stones = [[0,0]]<br>输出：0<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> f;</span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> ff,<span class="keyword">int</span> ss):f(ff), s(ss){}</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; father;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            father[i].f=i;</span><br><span class="line">            father[i].s=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(father[x].f!=x) father[x].f=findFather(father[x].f);</span><br><span class="line">        <span class="keyword">return</span> father[x].f;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionSet</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> fa=findFather(x);</span><br><span class="line">        <span class="keyword">int</span> fb=findFather(y);</span><br><span class="line">        <span class="keyword">if</span>(fa!=fb){</span><br><span class="line">            father[fa].f=fb;</span><br><span class="line">            father[fb].s+=father[fa].s;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeStones</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; stones)</span> </span>{</span><br><span class="line">        n = stones.size();</span><br><span class="line">        father.resize(n);</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mx, my;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;stones.size();i++){</span><br><span class="line">            <span class="keyword">int</span> x=stones[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y=stones[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(mx.find(x)==mx.end()) mx[x]=i;</span><br><span class="line">            <span class="keyword">else</span> unionSet(mx[x], i);</span><br><span class="line">            <span class="keyword">if</span>(my.find(y)==my.end()) my[y]=i;</span><br><span class="line">            <span class="keyword">else</span> unionSet(my[y], i);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> fa=findFather(i);</span><br><span class="line">            st.insert(fa);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:st){</span><br><span class="line">            ans+=father[i].s<span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="959-由斜杠划分区域"><a href="#959-由斜杠划分区域" class="headerlink" title="959. 由斜杠划分区域"></a>959. 由斜杠划分区域</h2><p><strong>Description</strong><br>在由 1 x 1 方格组成的 N x N 网格 grid 中，每个 1 x 1 方块由 /、\ 或空格构成。这些字符会将方块划分为一些共边的区域。<br>（请注意，反斜杠字符是转义的，因此 \ 用 “\“ 表示。）。<br>返回区域的数目。<br><strong>Example</strong><br>示例 1：<br>输入：<br>[<br>  “ /“,<br>  “/ “<br>]<br>输出：2<br>解释：2x2 网格如下：<br><img src="/assets/img/algorithm/959_1.png" alt="image"><br>示例 2：<br>输入：<br>[<br>  “ /“,<br>  “  “<br>]<br>输出：1<br>解释：2x2 网格如下：<br><img src="/assets/img/algorithm/959_2.png" alt="image"><br>示例 3：<br>输入：<br>[<br>  “\/“,<br>  “/\“<br>]<br>输出：4<br>解释：（回想一下，因为 \ 字符是转义的，所以 “\/“ 表示 /，而 “/\“ 表示 /\。）<br>2x2 网格如下：<br><img src="/assets/img/algorithm/959_3.png" alt="image"><br>示例 4：<br>输入：<br>[<br>  “/\“,<br>  “\/“<br>]<br>输出：5<br>解释：（回想一下，因为 \ 字符是转义的，所以 “/\“ 表示 /\，而 “\/“ 表示 /。）<br>2x2 网格如下：<br><img src="/assets/img/algorithm/959_4.png" alt="image"><br>示例 5：<br>输入：<br>[<br>  “//“,<br>  “/ “<br>]<br>输出：3<br>解释：2x2 网格如下：<br><img src="/assets/img/algorithm/959_5.png" alt="image"><br>提示：<br>1 &lt;= grid.length == grid[0].length &lt;= 30<br>grid[i][j] 是 ‘/‘、’'、或 ‘ ‘。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意每个方格由0或1组成的m*m的方阵，注意m&gt;2，m=2会出现某些斜角0不连通</span></span><br><span class="line"><span class="comment">这里采用3*3方格，然后求连通分量个数</span></span><br><span class="line"><span class="comment">复杂度O(9*1000*1000)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father;</span><br><span class="line">    <span class="keyword">int</span> step[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(father[x]!=x) father[x]=findFather(father[x]);</span><br><span class="line">        <span class="keyword">return</span> father[x];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionSet</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> fa=findFather(x);</span><br><span class="line">        <span class="keyword">int</span> fb=findFather(y);</span><br><span class="line">        <span class="keyword">if</span>(fa!=fb) father[fa]=fb;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">regionsBySlashes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; grid)</span> </span>{</span><br><span class="line">        n=grid.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">        graph.resize(<span class="number">3</span>*n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>*n;i++) graph[i].resize(<span class="number">3</span>*n, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="built_in">string</span> str=grid[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">if</span>(str[j]==<span class="string">'/'</span>){</span><br><span class="line">                    graph[i*<span class="number">3</span>][j*<span class="number">3</span>+<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">                    graph[i*<span class="number">3</span>+<span class="number">1</span>][j*<span class="number">3</span>+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                    graph[i*<span class="number">3</span>+<span class="number">2</span>][j*<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(str[j]==<span class="string">'\\'</span>){</span><br><span class="line">                    graph[i*<span class="number">3</span>][j*<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line">                    graph[i*<span class="number">3</span>+<span class="number">1</span>][j*<span class="number">3</span>+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                    graph[i*<span class="number">3</span>+<span class="number">2</span>][j*<span class="number">3</span>+<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        father.resize(<span class="number">9</span>*n*n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>*n*n;i++) father[i]=i;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>*n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>*n;j++){</span><br><span class="line">                <span class="keyword">if</span>(graph[i][j]==<span class="number">0</span>){</span><br><span class="line">                    vec.push_back(i*<span class="number">3</span>*n+j);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++){</span><br><span class="line">                        <span class="keyword">int</span> x=i+step[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y=j+step[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">int</span> idx=i*<span class="number">3</span>*n+j;</span><br><span class="line">                        <span class="keyword">int</span> idy=x*<span class="number">3</span>*n+y;</span><br><span class="line">                        <span class="keyword">if</span>(judge(x, y)&amp;&amp;graph[x][y]==<span class="number">0</span>) unionSet(idx, idy);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size();i++) st.insert(findFather(vec[i]));</span><br><span class="line">        <span class="keyword">return</span> st.size();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;<span class="number">3</span>*n&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;<span class="number">3</span>*n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用(n+1)*(n+1)的图表示，</span></span><br><span class="line"><span class="comment">边框已经是相连，而后如果连线使得边框两个点再次相连说明有个划分，</span></span><br><span class="line"><span class="comment">即一个划分产生两个连通分量，所以初试1，而后每出现一个划分则增加一个连通分量，复杂度O(1001*1001)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father;</span><br><span class="line">    <span class="keyword">int</span> step[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(father[x]!=x) father[x]=findFather(father[x]);</span><br><span class="line">        <span class="keyword">return</span> father[x];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">regionsBySlashes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; grid)</span> </span>{</span><br><span class="line">        n=grid.size();</span><br><span class="line">        father.resize((n+<span class="number">1</span>)*(n+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n+<span class="number">1</span>)*(n+<span class="number">1</span>);i++) father[i]=i;</span><br><span class="line">        <span class="comment">//边框为一个相连</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++){</span><br><span class="line">            father[i]=<span class="number">0</span>;</span><br><span class="line">            father[n*(n+<span class="number">1</span>)+i]=<span class="number">0</span>;</span><br><span class="line">            father[i*(n+<span class="number">1</span>)]=<span class="number">0</span>;</span><br><span class="line">            father[i*(n+<span class="number">1</span>)+n]=<span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">'/'</span>){</span><br><span class="line">                    <span class="keyword">int</span> x1=i+<span class="number">1</span>, y1=j;</span><br><span class="line">                    <span class="keyword">int</span> x2=i, y2=j+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">int</span> fa=findFather(x1*(n+<span class="number">1</span>)+y1);</span><br><span class="line">                    <span class="keyword">int</span> fb=findFather(x2*(n+<span class="number">1</span>)+y2);</span><br><span class="line">                    <span class="keyword">if</span>(fa!=fb){</span><br><span class="line">                        father[fa]=fb;</span><br><span class="line">                    }<span class="keyword">else</span> ans++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">'\\'</span>){</span><br><span class="line">                    <span class="keyword">int</span> x1=i, y1=j;</span><br><span class="line">                    <span class="keyword">int</span> x2=i+<span class="number">1</span>, y2=j+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">int</span> fa=findFather(x1*(n+<span class="number">1</span>)+y1);</span><br><span class="line">                    <span class="keyword">int</span> fb=findFather(x2*(n+<span class="number">1</span>)+y2);</span><br><span class="line">                    <span class="keyword">if</span>(fa!=fb){</span><br><span class="line">                        father[fa]=fb;</span><br><span class="line">                    }<span class="keyword">else</span> ans++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="990-等式方程的可满足性"><a href="#990-等式方程的可满足性" class="headerlink" title="990. 等式方程的可满足性"></a>990. 等式方程的可满足性</h2><p><strong>Description</strong><br>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：”a==b” 或 “a!=b”。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。<br>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。<br><strong>Example</strong><br>示例 1：<br>输入：[“a==b”,”b!=a”]<br>输出：false<br>解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。</p>
<p>示例 2：<br>输出：[“b==a”,”a==b”]<br>输入：true<br>解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。</p>
<p>示例 3：<br>输入：[“a==b”,”b==c”,”a==c”]<br>输出：true<br>示例 4：</p>
<p>输入：[“a==b”,”b!=c”,”c==a”]<br>输出：false<br>示例 5：</p>
<p>输入：[“c==c”,”b==d”,”x!=z”]<br>输出：true</p>
<p>提示：<br>1 &lt;= equations.length &lt;= 500<br>equations[i].length == 4<br>equations[i][0] 和 equations[i][3] 是小写字母<br>equations[i][1] 要么是 ‘=’，要么是 ‘!’<br>equations[i][2] 是 ‘=’<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(father[x]!=x) father[x]=findFather(father[x]);</span><br><span class="line">        <span class="keyword">return</span> father[x];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">equationsPossible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; equations)</span> </span>{</span><br><span class="line">        n = equations.size();</span><br><span class="line">        father.resize(<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) father[i]=i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> x=equations[i][<span class="number">0</span>]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">int</span> y=equations[i][<span class="number">3</span>]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">int</span> fa=findFather(x);</span><br><span class="line">            <span class="keyword">int</span> fb=findFather(y);</span><br><span class="line">            <span class="keyword">if</span>(equations[i][<span class="number">1</span>]==<span class="string">'='</span>){</span><br><span class="line">                <span class="keyword">if</span>(fa!=fb) father[fa]=fb;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> x=equations[i][<span class="number">0</span>]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">int</span> y=equations[i][<span class="number">3</span>]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">int</span> fa=findFather(x);</span><br><span class="line">            <span class="keyword">int</span> fb=findFather(y);</span><br><span class="line">            <span class="keyword">if</span>(equations[i][<span class="number">1</span>]==<span class="string">'!'</span>){</span><br><span class="line">                <span class="keyword">if</span>(fa==fb) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1202-交换字符串中的元素"><a href="#1202-交换字符串中的元素" class="headerlink" title="1202. 交换字符串中的元素"></a>1202. 交换字符串中的元素</h2><p><strong>Description</strong><br>给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。<br>你可以 任意多次交换 在 pairs 中任意一对索引处的字符。<br>返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。<br><strong>Example</strong><br>示例 1:<br>输入：s = “dcab”, pairs = [[0,3],[1,2]]<br>输出：”bacd”<br>解释：<br>交换 s[0] 和 s[3], s = “bcad”<br>交换 s[1] 和 s[2], s = “bacd”</p>
<p>示例 2：<br>输入：s = “dcab”, pairs = [[0,3],[1,2],[0,2]]<br>输出：”abcd”<br>解释：<br>交换 s[0] 和 s[3], s = “bcad”<br>交换 s[0] 和 s[2], s = “acbd”<br>交换 s[1] 和 s[2], s = “abcd”</p>
<p>示例 3：<br>输入：s = “cba”, pairs = [[0,1],[1,2]]<br>输出：”abc”<br>解释：<br>交换 s[0] 和 s[1], s = “bca”<br>交换 s[1] 和 s[2], s = “bac”<br>交换 s[0] 和 s[1], s = “abc”</p>
<p>提示：<br>1 &lt;= s.length &lt;= 10^5<br>0 &lt;= pairs.length &lt;= 10^5<br>0 &lt;= pairs[i][0], pairs[i][1] &lt; s.length<br>s 中只含有小写英文字母<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">根据pair进行并查集合并，在同一个集合里的两两位置可以相互交换！！</span></span><br><span class="line"><span class="comment">然后每个集合对应的序列进行排序，结果对应回原字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(father[x]!=x) father[x]=findFather(father[x]);</span><br><span class="line">        <span class="keyword">return</span> father[x];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionSet</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> fa=findFather(x);</span><br><span class="line">        <span class="keyword">int</span> fb=findFather(y);</span><br><span class="line">        <span class="keyword">if</span>(fa!=fb) father[fa]=fb;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestStringWithSwaps</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>{</span><br><span class="line">        n=s.length();</span><br><span class="line">        father.resize(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) father[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pairs.size();i++){</span><br><span class="line">            unionSet(pairs[i][<span class="number">0</span>], pairs[i][<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> fa=findFather(i);</span><br><span class="line">            m[fa].push_back(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(n, <span class="string">'a'</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(pair&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; it:m){</span><br><span class="line">            <span class="built_in">string</span> ss;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;it.second.size();i++){</span><br><span class="line">                ss+=s[it.second[i]];</span><br><span class="line">            }</span><br><span class="line">            sort(ss.begin(), ss.end());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;it.second.size();i++) str[it.second[i]]=ss[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1319-连通网络的操作次数"><a href="#1319-连通网络的操作次数" class="headerlink" title="1319. 连通网络的操作次数"></a>1319. 连通网络的操作次数</h2><p><strong>Description</strong><br>用以太网线缆将 n 台计算机连接成一个网络，计算机的编号从 0 到 n-1。线缆用 connections 表示，其中 connections[i] = [a, b] 连接了计算机 a 和 b。<br>网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。<br>给你这个计算机网络的初始布线 connections，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。<br><strong>Example</strong><br>示例 1：<br><img src="/assets/img/algorithm/sample_1_1677.png" alt="image"><br>输入：n = 4, connections = [[0,1],[0,2],[1,2]]<br>输出：1<br>解释：拔下计算机 1 和 2 之间的线缆，并将它插到计算机 1 和 3 上。<br>示例 2：<br><img src="/assets/img/algorithm/sample_2_1677.png" alt="image"><br>输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]<br>输出：2</p>
<p>示例 3：<br>输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]<br>输出：-1<br>解释：线缆数量不足。</p>
<p>示例 4：<br>输入：n = 5, connections = [[0,1],[0,2],[3,4],[2,3]]<br>输出：0</p>
<p>提示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= n &lt;= 10^5</span><br><span class="line">1 &lt;= connections.length &lt;= min(n*(n-1)/2, 10^5)</span><br><span class="line">connections[i].length == 2</span><br><span class="line">0 &lt;= connections[i][0], connections[i][1]&nbsp;&lt; n</span><br><span class="line">connections[i][0] != connections[i][1]</span><br><span class="line">没有重复的连接。</span><br><span class="line">两台计算机不会通过多条线缆连接。</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">合并a和b， 如果早已连接，说明多了一条冗余可操作性的边</span></span><br><span class="line"><span class="comment">之后计算集合个数n，最少需要n-1条冗余的可操作边才满足条件，否则返回-1.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> resLine=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;father;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(father[x]!=x) father[x]=findFather(father[x]);</span><br><span class="line">        <span class="keyword">return</span> father[x];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionSet</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> fa=findFather(x);</span><br><span class="line">        <span class="keyword">int</span> fb=findFather(y);</span><br><span class="line">        <span class="keyword">if</span>(fa!=fb) father[fa]=fb;</span><br><span class="line">        <span class="keyword">else</span> resLine++;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">makeConnected</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; connections)</span> </span>{</span><br><span class="line">        father.resize(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) father[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;connections.size();i++){</span><br><span class="line">            unionSet(connections[i][<span class="number">0</span>], connections[i][<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) st.insert(findFather(i));</span><br><span class="line">        <span class="keyword">int</span> nCount=st.size();</span><br><span class="line">        <span class="keyword">if</span>(resLine&lt;nCount<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> nCount<span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a>95. 不同的二叉搜索树 II</h2><p><strong>Description</strong><br>给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。<br><strong>Example</strong><br>示例:<br>输入: 3<br>输出:<br>[<br>  [1,null,3,2],<br>  [3,2,null,1],<br>  [3,1,null,null,2],<br>  [2,1,3],<br>  [1,null,2,null,3]<br>]<br>解释:<br>以上的输出对应以下 5 种不同结构的二叉搜索树：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1         3     3      2      1</span><br><span class="line"> \       /     /      / \      \</span><br><span class="line">  3     2     1      1   3      2</span><br><span class="line"> /     /       \                 \</span><br><span class="line">2     1         2                 3</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong><br>递归中，需要遍历所有情况，但是问题在于左右子树遍历时，如果直接想得到一棵树不可能，因为一次遍历只能得到左/右子树的所有情况，所以必须拼接！！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; generateTrees(<span class="keyword">int</span> n) {</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="keyword">return</span> tree(<span class="number">1</span>, n);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; tree(<span class="keyword">int</span> l, <span class="keyword">int</span> r){</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> {<span class="literal">NULL</span>};</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++){</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; leftTree, rightTree;</span><br><span class="line">            leftTree=tree(l, i<span class="number">-1</span>);</span><br><span class="line">            rightTree=tree(i+<span class="number">1</span>, r);</span><br><span class="line">            <span class="keyword">for</span>(TreeNode* lt:leftTree){</span><br><span class="line">                <span class="keyword">for</span>(TreeNode* rt:rightTree){</span><br><span class="line">                    TreeNode* root=<span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root-&gt;left=lt;</span><br><span class="line">                    root-&gt;right=rt;</span><br><span class="line">                    result.push_back(root);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a>392. 判断子序列</h2><p><strong>Description</strong><br>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。<br>你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。<br>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。<br><strong>Example</strong><br>示例 1:<br>s = “abc”, t = “ahbgdc”<br>返回 true.</p>
<p>示例 2:<br>s = “axc”, t = “ahbgdc”<br>返回 false.<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubsequence</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(s.length()&gt;t.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">int</span> m=t.length();</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">if</span>(s[idx]==t[i]){</span><br><span class="line">                idx++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(idx==n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="787-K-站中转内最便宜的航班"><a href="#787-K-站中转内最便宜的航班" class="headerlink" title="787. K 站中转内最便宜的航班"></a>787. K 站中转内最便宜的航班</h2><p><strong>Description</strong><br>有 n 个城市通过 m 个航班连接。每个航班都从城市 u 开始，以价格 w 抵达 v。<br>现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到从 src 到 dst 最多经过 k 站中转的最便宜的价格。 如果没有这样的路线，则输出 -1。<br><strong>Example</strong><br>示例 1：<br>输入:<br>n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]<br>src = 0, dst = 2, k = 1<br>输出: 200<br>解释:<br>城市航班图如下<br><img src="/assets/img/algorithm/995.png" alt="image"><br>从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。<br>示例 2：<br>输入:<br>n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]<br>src = 0, dst = 2, k = 0<br>输出: 500<br>解释:<br>城市航班图如下<br>![image](/assets/img/algorithm/995 (1).png)<br>从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。</p>
<p>提示：<br>n 范围是 [1, 100]，城市标签从 0 到 n - 1.<br>航班数量范围是 [0, n * (n - 1) / 2].<br>每个航班的格式 (src, dst, price).<br>每个航班的价格范围是 [1, 10000].<br>k 范围是 [0, n - 1].<br>航班没有重复，且不存在环路<br><strong>Program</strong><br><strong>最短路径Dijkstra</strong><br>类似最短路径，所区别在于k与cos当做状态，并且当前节点不能vis标识掉，因为到达当前节点花费少，但步数可能多，到最后不满足。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">cos</span>;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> V,<span class="keyword">int</span> K, <span class="keyword">int</span> C):v(V),k(K),<span class="built_in">cos</span>(C){}</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;tmp) <span class="keyword">const</span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">cos</span>&gt;tmp.<span class="built_in">cos</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cost;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Node&gt;&gt; Adj;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> K)</span> </span>{</span><br><span class="line">        Adj.resize(n);</span><br><span class="line">        vis.resize(n, <span class="literal">false</span>);</span><br><span class="line">        cost.resize(n, INF);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec:flights){</span><br><span class="line">            <span class="keyword">int</span> u=vec[<span class="number">0</span>],v=vec[<span class="number">1</span>],<span class="built_in">cos</span>=vec[<span class="number">2</span>];</span><br><span class="line">            Adj[u].push_back(Node(v,<span class="number">0</span>,<span class="built_in">cos</span>));</span><br><span class="line">        }</span><br><span class="line">        priority_queue&lt;Node&gt; pq;</span><br><span class="line">        pq.push(Node(src, <span class="number">-1</span>, <span class="number">0</span>));</span><br><span class="line">        cost[src]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nCount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty()){</span><br><span class="line">            Node now = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            <span class="keyword">if</span>(now.v==dst&amp;&amp;now.k&lt;=K){</span><br><span class="line">                result=now.<span class="built_in">cos</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[now.v].size();i++){</span><br><span class="line">                <span class="keyword">int</span> v=Adj[now.v][i].v;</span><br><span class="line">                <span class="keyword">int</span> <span class="built_in">cos</span>=Adj[now.v][i].<span class="built_in">cos</span>;</span><br><span class="line">                <span class="keyword">if</span>(now.k+<span class="number">1</span>&lt;=K){</span><br><span class="line">                    pq.push(Node(v, now.k+<span class="number">1</span>, now.<span class="built_in">cos</span>+<span class="built_in">cos</span>));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>②Bellman-Ford变形</strong><br>Bellman-Ford算法变形，每次直走一步更新（注意不能连续更新），k+1步后就是答案，<br>例如，[[0,1,1],[0,2,5],[1,2,1],[2,3,1]],n=3,src=0,dst=3,k=1;<br>从src=0开始，第一步更新只更新从src=0出发的路径，而其他路径不能更新！否则就不是走了k+1步！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> K)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cost(n, INF);</span><br><span class="line">        cost[src]=<span class="number">0</span>;</span><br><span class="line">        K=min(K,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=K;k++){</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tCost=cost;  <span class="comment">//确保只更新必要的路径一次，cost是上一步更新后的，而tCost是本次要更新的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec:flights){</span><br><span class="line">                tCost[vec[<span class="number">1</span>]]=min(tCost[vec[<span class="number">1</span>]],cost[vec[<span class="number">0</span>]]+vec[<span class="number">2</span>]);</span><br><span class="line">            }</span><br><span class="line">            swap(tCost, cost);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> (cost[dst]!=INF)?cost[dst]:<span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="102-二叉树的层次遍历"><a href="#102-二叉树的层次遍历" class="headerlink" title="102. 二叉树的层次遍历"></a>102. 二叉树的层次遍历</h2><p><strong>Description</strong><br>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。<br><strong>Example</strong><br>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></tbody></table></figure>
<p>返回其层次遍历结果：<br>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        TreeNode* node;</span><br><span class="line">        <span class="keyword">int</span> idx;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(TreeNode* tNode, <span class="keyword">int</span> Idx){</span><br><span class="line">            node=tNode;</span><br><span class="line">            idx=Idx;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> level=<span class="number">0</span>, end=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node&gt;q;</span><br><span class="line">        q.push(Node(root, <span class="number">0</span>));</span><br><span class="line">        vec.push_back(root-&gt;val);</span><br><span class="line">        index++;</span><br><span class="line"></span><br><span class="line">        result.resize(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            Node tmp=q.front();</span><br><span class="line">            TreeNode* now=tmp.node;</span><br><span class="line">            <span class="keyword">int</span> idx=tmp.idx;</span><br><span class="line">            result[level].push_back(now-&gt;val);</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;left!=<span class="literal">NULL</span>){</span><br><span class="line">                q.push(Node(now-&gt;left, index));</span><br><span class="line">                vec.push_back(now-&gt;left-&gt;val);</span><br><span class="line">                index++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;right!=<span class="literal">NULL</span>){</span><br><span class="line">                q.push(Node(now-&gt;right, index));</span><br><span class="line">                vec.push_back(now-&gt;right-&gt;val);</span><br><span class="line">                index++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(idx==end){</span><br><span class="line">                end=index<span class="number">-1</span>;</span><br><span class="line">                result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">                level++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(result[level].size()==<span class="number">0</span>) result.pop_back();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) {</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            <span class="keyword">int</span> n=q.size(); <span class="comment">//每一层的个数刚好为队列中的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">                TreeNode* now=q.front();q.pop();</span><br><span class="line">                vec.push_back(now-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(now-&gt;left!=<span class="literal">NULL</span>) q.push(now-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(now-&gt;right!=<span class="literal">NULL</span>) q.push(now-&gt;right);</span><br><span class="line">            }</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            vec.clear();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="103-二叉树的锯齿形层次遍历"><a href="#103-二叉树的锯齿形层次遍历" class="headerlink" title="103. 二叉树的锯齿形层次遍历"></a>103. 二叉树的锯齿形层次遍历</h2><p><strong>Description</strong><br>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。<br><strong>Example</strong><br>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></tbody></table></figure>
<p>返回锯齿形层次遍历如下：</p>
<p>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        TreeNode* node;</span><br><span class="line">        <span class="keyword">int</span> idx;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(TreeNode* tNode, <span class="keyword">int</span> Idx){</span><br><span class="line">            node=tNode;</span><br><span class="line">            idx=Idx;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> level=<span class="number">0</span>, end=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node&gt;q;</span><br><span class="line">        q.push(Node(root, <span class="number">0</span>));</span><br><span class="line">        vec.push_back(root-&gt;val);</span><br><span class="line">        index++;</span><br><span class="line"></span><br><span class="line">        result.resize(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            Node tmp=q.front();</span><br><span class="line">            TreeNode* now=tmp.node;</span><br><span class="line">            <span class="keyword">int</span> idx=tmp.idx;</span><br><span class="line">            result[level].push_back(now-&gt;val);</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;left!=<span class="literal">NULL</span>){</span><br><span class="line">                q.push(Node(now-&gt;left, index));</span><br><span class="line">                vec.push_back(now-&gt;left-&gt;val);</span><br><span class="line">                index++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;right!=<span class="literal">NULL</span>){</span><br><span class="line">                q.push(Node(now-&gt;right, index));</span><br><span class="line">                vec.push_back(now-&gt;right-&gt;val);</span><br><span class="line">                index++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(idx==end){</span><br><span class="line">                end=index<span class="number">-1</span>;</span><br><span class="line">                result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">                level++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(result[level].size()==<span class="number">0</span>) result.pop_back();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;result.size();i+=<span class="number">2</span>){</span><br><span class="line">            reverse(result[i].begin(), result[i].end());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="126-单词接龙-II"><a href="#126-单词接龙-II" class="headerlink" title="126. 单词接龙 II"></a>126. 单词接龙 II</h2><p>给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：</p>
<p>每次转换只能改变一个字母。<br>转换后得到的单词必须是字典中的单词。<br>说明:<br>如果不存在这样的转换序列，返回一个空列表。<br>所有单词具有相同的长度。<br>所有单词只由小写字母组成。<br>字典中不存在重复的单词。<br>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。<br><strong>Example</strong><br>示例 1:<br>输入:<br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p>
<p>输出:<br>[<br>  [“hit”,”hot”,”dot”,”dog”,”cog”],<br>  [“hit”,”hot”,”lot”,”log”,”cog”]<br>]</p>
<p>示例 2:<br>输入:<br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”]</p>
<p>输出: []<br>解释: endWord “cog” 不在字典中，所以不存在符合要求的转换序列。<br><strong>Program</strong><br><strong>第一版</strong><br>数组v记录当前进队列的Node，搞得很麻烦啊…后面可以注意到没必要，每一层访问了节点，后面就不用访问了。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="built_in">string</span> word;</span><br><span class="line">        <span class="keyword">int</span> idx; <span class="comment">//word在v中的位置</span></span><br><span class="line">        <span class="keyword">int</span> fatherId; <span class="comment">//父节点位置</span></span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="built_in">string</span> _word, <span class="keyword">int</span> _idx, <span class="keyword">int</span> _fatherId):word(_word),idx(_idx),fatherId(_fatherId){}</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; v; <span class="comment">//模拟队列</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; pre; <span class="comment">//前驱节点下标</span></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; vis;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m; <span class="comment">//以入队节点的位置</span></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; wordSet; <span class="comment">//记录wordList的所有单词</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; findLadders(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList) {</span><br><span class="line"></span><br><span class="line">        wordSet=<span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;(wordList.begin(), wordList.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(wordSet.size()==<span class="number">0</span>||wordSet.find(endWord)==wordSet.end()) <span class="keyword">return</span> {}; <span class="comment">//无解</span></span><br><span class="line"></span><br><span class="line">        vis.insert(beginWord);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//广搜</span></span><br><span class="line">        q.push(Node(beginWord, <span class="number">0</span>, <span class="number">-1</span>));</span><br><span class="line">        v.push_back(Node(beginWord,<span class="number">0</span>, <span class="number">-1</span>));</span><br><span class="line">        m[beginWord]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">1</span>; <span class="comment">//队列元素索引</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isFound=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            <span class="keyword">int</span> qSize=q.size(); <span class="comment">//当前层的个数</span></span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; st; <span class="comment">//记录下一层被访问的节点，扫描完本层后，将其加入vis</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;qSize;k++){</span><br><span class="line">                Node node=q.front();q.pop();</span><br><span class="line">                <span class="keyword">if</span>(node.word==endWord){</span><br><span class="line">                    isFound=<span class="literal">true</span>;</span><br><span class="line">                    pos=node.idx;</span><br><span class="line">                    <span class="comment">//cout&lt;&lt;"pos: "&lt;&lt;pos&lt;&lt;endl;</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">int</span> n=node.word.size();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> ch=<span class="string">'a'</span>;ch&lt;=<span class="string">'z'</span>;ch++){</span><br><span class="line">                        <span class="keyword">if</span>(node.word[i]!=ch){</span><br><span class="line">                            <span class="built_in">string</span> newWord=node.word; newWord[i]=ch;</span><br><span class="line">                            <span class="keyword">if</span>(wordSet.find(newWord)!=wordSet.end()&amp;&amp;vis.find(newWord)==vis.end()){</span><br><span class="line">                                st.insert(newWord);</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span>(m.find(newWord)==m.end()){</span><br><span class="line">                                    q.push(Node(newWord, index, node.idx));</span><br><span class="line">                                    v.push_back(Node(newWord, index, node.idx));</span><br><span class="line">                                    m[newWord]=index++;</span><br><span class="line">                                }<span class="keyword">else</span>{</span><br><span class="line">                                    q.push(Node(newWord, m[newWord], node.idx));</span><br><span class="line">                                }</span><br><span class="line">                                <span class="comment">//cout&lt;&lt;node.word&lt;&lt;" "&lt;&lt;newWord&lt;&lt;" "&lt;&lt;m[newWord]&lt;&lt;"---";</span></span><br><span class="line">                                pre[newWord].insert(node.idx); <span class="comment">//前驱</span></span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// for(int i=0;i&lt;wordList.size();i++){</span></span><br><span class="line">                <span class="comment">//     int nCount=0; // 不相等字符个数</span></span><br><span class="line">                <span class="comment">//     int n=node.word.size();</span></span><br><span class="line">                <span class="comment">//     for(int j=0;j&lt;n;j++){ //当wordList太长容易超时</span></span><br><span class="line">                <span class="comment">//         if(node.word[j]!=wordList[i][j]){</span></span><br><span class="line">                <span class="comment">//             nCount++;</span></span><br><span class="line">                <span class="comment">//             if(nCount&gt;1) break;</span></span><br><span class="line">                <span class="comment">//         }</span></span><br><span class="line">                <span class="comment">//     }</span></span><br><span class="line">                <span class="comment">//     if(nCount==1&amp;&amp;vis.find(wordList[i])==vis.end()){</span></span><br><span class="line">                <span class="comment">//         st.insert(wordList[i]);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//         if(m.find(wordList[i])==m.end()){</span></span><br><span class="line">                <span class="comment">//             q.push(Node(wordList[i], index, node.idx));</span></span><br><span class="line">                <span class="comment">//             v.push_back(Node(wordList[i], index, node.idx));</span></span><br><span class="line">                <span class="comment">//             m[wordList[i]]=index++;</span></span><br><span class="line">                <span class="comment">//         }else{</span></span><br><span class="line">                <span class="comment">//             q.push(Node(wordList[i], m[wordList[i]], node.idx));</span></span><br><span class="line">                <span class="comment">//         }</span></span><br><span class="line">                <span class="comment">//         //cout&lt;&lt;node.word&lt;&lt;" "&lt;&lt;wordList[i]&lt;&lt;" "&lt;&lt;m[wordList[i]]&lt;&lt;"---";</span></span><br><span class="line">                <span class="comment">//         pre[wordList[i]].insert(node.idx); //前驱</span></span><br><span class="line">                <span class="comment">//     }</span></span><br><span class="line">                <span class="comment">// }</span></span><br><span class="line">            }</span><br><span class="line">            vis.insert(st.begin(), st.end());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(!isFound) <span class="keyword">return</span> {}; <span class="comment">//无解</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;endl&lt;&lt;"asasa";</span></span><br><span class="line">        <span class="comment">//深搜找所有路径</span></span><br><span class="line">        dfs(pos);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(v[id].fatherId==<span class="number">-1</span>){</span><br><span class="line">            path.push_back(v[id].word);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp(path.rbegin(), path.rend());</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            path.pop_back();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        Node node=v[id];</span><br><span class="line">        path.push_back(node.word);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preList(pre[node.word].begin(), pre[node.word].end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;preList.size();i++){</span><br><span class="line">            dfs(preList[i]);</span><br><span class="line">        }</span><br><span class="line">        path.pop_back();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt; pre; <span class="comment">//前驱节点下标</span></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; vis;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; wordSet; <span class="comment">//记录wordList的所有单词</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; findLadders(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList) {</span><br><span class="line"></span><br><span class="line">        wordSet=<span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;(wordList.begin(), wordList.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(wordSet.size()==<span class="number">0</span>||wordSet.count(endWord)==<span class="number">0</span>) <span class="keyword">return</span> {}; <span class="comment">//无解</span></span><br><span class="line"></span><br><span class="line">        vis.insert(beginWord);</span><br><span class="line">        pre[beginWord]=<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;(); <span class="comment">//父节点为空，表示为根结点</span></span><br><span class="line">        <span class="comment">//广搜</span></span><br><span class="line">        q.push(beginWord);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isFound=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            <span class="keyword">int</span> qSize=q.size(); <span class="comment">//当前层的个数</span></span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; st; <span class="comment">//记录下一层被访问的节点，扫描完本层后，将其加入vis</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;qSize;k++){</span><br><span class="line">                <span class="built_in">string</span> curWord=q.front();q.pop();</span><br><span class="line">                <span class="comment">// if(curWord==endWord){</span></span><br><span class="line">                <span class="comment">//     isFound=true;</span></span><br><span class="line">                <span class="comment">//     continue;</span></span><br><span class="line">                <span class="comment">// }</span></span><br><span class="line">                <span class="keyword">int</span> n=curWord.length();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> ch=<span class="string">'a'</span>;ch&lt;=<span class="string">'z'</span>;ch++){</span><br><span class="line">                        <span class="keyword">if</span>(curWord[i]!=ch){</span><br><span class="line">                            <span class="built_in">string</span> newWord=curWord; newWord[i]=ch;</span><br><span class="line">                            <span class="keyword">if</span>(wordSet.count(newWord)&gt;<span class="number">0</span>&amp;&amp;vis.count(newWord)==<span class="number">0</span>){</span><br><span class="line">                                <span class="keyword">if</span>(newWord==endWord) isFound=<span class="literal">true</span>;</span><br><span class="line">                                st.insert(newWord);</span><br><span class="line">                                q.push(newWord);</span><br><span class="line">                                pre[newWord].insert(curWord); <span class="comment">//前驱</span></span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(isFound) <span class="keyword">break</span>; <span class="comment">//小小剪枝，避免下一层继续搜索，比k循环下记录isFound的要好一些，因为这里在上一层就避开无意义的搜索！</span></span><br><span class="line">            vis.insert(st.begin(), st.end());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(!isFound) <span class="keyword">return</span> {}; <span class="comment">//无解</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;endl&lt;&lt;"asasa";</span></span><br><span class="line">        <span class="comment">//深搜找所有路径</span></span><br><span class="line">        dfs(endWord);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> curWord)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(pre[curWord].size()==<span class="number">0</span>){</span><br><span class="line">            path.push_back(curWord);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp(path.rbegin(), path.rend());</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            path.pop_back();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        path.push_back(curWord);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::iterator it=pre[curWord].begin();it!=pre[curWord].end();it++){</span><br><span class="line">            dfs(*it);</span><br><span class="line">        }</span><br><span class="line">        path.pop_back();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>优化+剪枝</strong><br>继续优化，可以看到在进行下一层的搜索时，如果同时搜索到同一个单词，应当避免重复入队列！！！重复计算！没必要！<br>注意这里的搜索下一层时不立刻加入vis，因为可能上一层的多个结果会搜索到下一层的同一个节点！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt; pre; <span class="comment">//前驱节点下标</span></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; vis;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; wordSet; <span class="comment">//记录wordList的所有单词</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; findLadders(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList) {</span><br><span class="line"></span><br><span class="line">        wordSet=<span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;(wordList.begin(), wordList.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(wordSet.size()==<span class="number">0</span>||wordSet.count(endWord)==<span class="number">0</span>) <span class="keyword">return</span> {}; <span class="comment">//无解</span></span><br><span class="line">        pre[beginWord]=<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;();<span class="comment">//根结点无父节点</span></span><br><span class="line">        vis.insert(beginWord);</span><br><span class="line">        <span class="comment">//广搜</span></span><br><span class="line">        q.push(beginWord);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isFound=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            <span class="keyword">int</span> qSize=q.size(); <span class="comment">//当前层的个数</span></span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; st; <span class="comment">//记录下一层被访问的节点，扫描完本层后，将其加入vis</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;qSize;k++){</span><br><span class="line">                <span class="built_in">string</span> curWord=q.front();q.pop();</span><br><span class="line">                <span class="keyword">int</span> n=curWord.length();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> ch=<span class="string">'a'</span>;ch&lt;=<span class="string">'z'</span>;ch++){</span><br><span class="line">                        <span class="keyword">if</span>(curWord[i]!=ch){</span><br><span class="line">                            <span class="built_in">string</span> newWord=curWord; newWord[i]=ch;</span><br><span class="line">                            <span class="keyword">if</span>(wordSet.count(newWord)&gt;<span class="number">0</span>&amp;&amp;vis.count(newWord)==<span class="number">0</span>){</span><br><span class="line">                                <span class="keyword">if</span>(newWord==endWord) isFound=<span class="literal">true</span>; <span class="comment">//当前层已经找到终点，所以可以终止搜索！！</span></span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span>(st.count(newWord)==<span class="number">0</span>){ <span class="comment">//优化，避免下一层重复加入集合！！</span></span><br><span class="line">                                    st.insert(newWord);</span><br><span class="line">                                    q.push(newWord);</span><br><span class="line">                                }</span><br><span class="line">                                pre[newWord].insert(curWord); <span class="comment">//前驱</span></span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(isFound) <span class="keyword">break</span>; <span class="comment">//终止搜索！！</span></span><br><span class="line">            vis.insert(st.begin(), st.end());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(!isFound) <span class="keyword">return</span> {}; <span class="comment">//无解</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//深搜找所有路径</span></span><br><span class="line">        dfs(endWord);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> curWord)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(pre[curWord].size()==<span class="number">0</span>){</span><br><span class="line">            path.push_back(curWord);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp(path.rbegin(), path.rend());</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            path.pop_back();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        path.push_back(curWord);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::iterator it=pre[curWord].begin();it!=pre[curWord].end();it++){</span><br><span class="line">            dfs(*it);</span><br><span class="line">        }</span><br><span class="line">        path.pop_back();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127. 单词接龙"></a>127. 单词接龙</h2><p><strong>Description</strong><br>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：<br>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典中的单词。<br>说明:<br>如果不存在这样的转换序列，返回 0。<br>所有单词具有相同的长度。<br>所有单词只由小写字母组成。<br>字典中不存在重复的单词。<br>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。<br><strong>Example</strong><br>示例 1:<br>输入:<br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br>输出: 5<br>解释: 一个最短转换序列是 “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>     返回它的长度 5。</p>
<p>示例 2:<br>输入:<br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”]<br>输出: 0<br>解释: endWord “cog” 不在字典中，所以无法进行转换。<br><strong>Program</strong><br><strong>单向广搜（超时）</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">int</span> step;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="built_in">string</span> Str, <span class="keyword">int</span> Step):str(Str),step(Step){}</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length();i++){</span><br><span class="line">            <span class="keyword">if</span>(a[i]!=b[i]) ans++;</span><br><span class="line">            <span class="keyword">if</span>(ans&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=wordList.size();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; vis;</span><br><span class="line">        vis.insert(beginWord);</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">        q.push(Node(beginWord, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            Node node=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(node.str==endWord){</span><br><span class="line">                <span class="keyword">return</span> node.step;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">                <span class="keyword">if</span>(vis.find(wordList[i])==vis.end()&amp;&amp;judge(node.str, wordList[i])){</span><br><span class="line">                    q.push(Node(wordList[i], node.step+<span class="number">1</span>));</span><br><span class="line">                    vis.insert(wordList[i]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>双向广搜</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> idx;</span><br><span class="line">        <span class="keyword">int</span> step;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> Idx, <span class="keyword">int</span> Step):idx(Idx),step(Step){}</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; mQueue[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">int</span> qHead[<span class="number">2</span>],qTail[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> matching_qNo,matching_idx, matching_step=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">DBFS</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span></span>{</span><br><span class="line">        vis[<span class="number">0</span>].resize(n, <span class="literal">false</span>);</span><br><span class="line">        vis[<span class="number">1</span>].resize(n ,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        mQueue[<span class="number">0</span>].resize(n);</span><br><span class="line">        mQueue[<span class="number">1</span>].resize(n);</span><br><span class="line"></span><br><span class="line">        qHead[<span class="number">0</span>]=qHead[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        qTail[<span class="number">0</span>]=qTail[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        mQueue[<span class="number">0</span>][qTail[<span class="number">0</span>]++]=Node(m[beginWord],<span class="number">1</span>);</span><br><span class="line">        mQueue[<span class="number">1</span>][qTail[<span class="number">1</span>]++]=Node(m[endWord],<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        vis[<span class="number">0</span>][m[beginWord]]=<span class="literal">true</span>;</span><br><span class="line">        vis[<span class="number">1</span>][m[endWord]]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(qHead[<span class="number">0</span>]!=qTail[<span class="number">0</span>]&amp;&amp;qHead[<span class="number">1</span>]!=qTail[<span class="number">1</span>]){</span><br><span class="line">            <span class="keyword">int</span> qNo=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(qHead[<span class="number">0</span>]==qTail[<span class="number">0</span>]) qNo=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(qHead[<span class="number">1</span>]==qTail[<span class="number">1</span>]) qNo=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(qTail[<span class="number">0</span>]-qHead[<span class="number">0</span>]&gt;qTail[<span class="number">1</span>]-qHead[<span class="number">1</span>]){ <span class="comment">//选择更新的队列</span></span><br><span class="line">                qNo=<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            Node node=mQueue[qNo][qHead[qNo]++];</span><br><span class="line">            <span class="built_in">string</span> str=wordList[node.idx]; <span class="comment">//队列头元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> ch=<span class="string">'a'</span>;ch&lt;=<span class="string">'z'</span>;ch++){</span><br><span class="line">                    <span class="built_in">string</span> tmp=str;</span><br><span class="line">                    tmp[i]=ch;</span><br><span class="line">                    <span class="keyword">if</span>(tmp==str) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(m.find(tmp)!=m.end()){</span><br><span class="line">                        <span class="keyword">if</span>(vis[<span class="number">1</span>-qNo][m[tmp]]){ <span class="comment">//在另一个队列中出现，说明找到路径</span></span><br><span class="line">                            matching_qNo=qNo;</span><br><span class="line">                            matching_idx=m[tmp];</span><br><span class="line">                            matching_step=node.step;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">if</span>(!vis[qNo][m[tmp]]){</span><br><span class="line">                            mQueue[qNo][qTail[qNo]]=Node(m[tmp],node.step+<span class="number">1</span>);</span><br><span class="line">                            vis[qNo][m[tmp]]=<span class="literal">true</span>;</span><br><span class="line">                            qTail[qNo]++;</span><br><span class="line">                        }   </span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>{     </span><br><span class="line">        wordList.push_back(beginWord);</span><br><span class="line">        n=wordList.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) m[wordList[i]]=i;</span><br><span class="line">        <span class="keyword">if</span>(m.find(endWord)==m.end()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> isMatch=DBFS(beginWord, endWord, wordList);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=qHead[<span class="number">1</span>-matching_qNo];i&lt;=qTail[<span class="number">1</span>-matching_qNo];i++){</span><br><span class="line">            Node node=mQueue[<span class="number">1</span>-matching_qNo][i];</span><br><span class="line">            <span class="keyword">if</span>(node.idx==matching_idx){</span><br><span class="line">                matching_step+=node.step;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> matching_step;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="310-最小高度树"><a href="#310-最小高度树" class="headerlink" title="310. 最小高度树"></a>310. 最小高度树</h2><p><strong>Description</strong><br>对于一个具有树特征的无向图，我们可选择任何一个节点作为根。图因此可以成为树，在所有可能的树中，具有最小高度的树被称为最小高度树。给出这样的一个图，写出一个函数找到所有的最小高度树并返回他们的根节点。<br>格式<br>该图包含 n 个节点，标记为 0 到 n - 1。给定数字 n 和一个无向边 edges 列表（每一个边都是一对标签）。<br>你可以假设没有重复的边会出现在 edges 中。由于所有的边都是无向边， [0, 1]和 [1, 0] 是相同的，因此不会同时出现在 edges 里。<br><strong>Example</strong><br>示例 1:<br>输入: n = 4, edges = [[1, 0], [1, 2], [1, 3]]</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  0</span><br><span class="line">  |</span><br><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br></pre></td></tr></tbody></table></figure>
<p>输出: [1]</p>
<p>示例 2:<br>输入: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0  1  2</span><br><span class="line"> \ | /</span><br><span class="line">   3</span><br><span class="line">   |</span><br><span class="line">   4</span><br><span class="line">   |</span><br><span class="line">   5</span><br></pre></td></tr></tbody></table></figure>
<p>输出: [3, 4]<br>说明:<br> 根据树的定义，树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。<br>树的高度是指根节点和叶子节点之间最长向下路径上边的数量。<br><strong>Program</strong><br><strong>思路</strong><br>一次性删除度为1的节点，直至最后剩余节点数不超过2。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; Adj;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; degree;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findMinHeightTrees(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges) {</span><br><span class="line">        Adj.resize(n);</span><br><span class="line">        degree.resize(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges.size();i++){</span><br><span class="line">            <span class="keyword">int</span> u=edges[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> v=edges[i][<span class="number">1</span>];</span><br><span class="line">            Adj[u].push_back(v);</span><br><span class="line">            Adj[v].push_back(u);</span><br><span class="line">            degree[u]++;</span><br><span class="line">            degree[v]++;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(degree[i]&lt;=<span class="number">1</span>){ <span class="comment">//散点</span></span><br><span class="line">                q.push(i);</span><br><span class="line">                cnt++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> nCount=<span class="number">0</span>; <span class="comment">//已删除的节点数</span></span><br><span class="line">        <span class="keyword">while</span>(n-nCount&gt;<span class="number">2</span>){</span><br><span class="line">            <span class="keyword">int</span> tmpCnt=<span class="number">0</span>;</span><br><span class="line">            nCount+=cnt;</span><br><span class="line">            <span class="keyword">while</span>(cnt--){ <span class="comment">//一次性删除所有度为1的点</span></span><br><span class="line">                <span class="keyword">int</span> u=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">                    <span class="keyword">int</span> v=Adj[u][i];</span><br><span class="line">                    degree[v]--;</span><br><span class="line">                    <span class="keyword">if</span>(degree[v]==<span class="number">1</span>){</span><br><span class="line">                        q.push(v);</span><br><span class="line">                        tmpCnt++;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            cnt=tmpCnt;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            result.push_back(q.front());</span><br><span class="line">            q.pop();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="914-卡牌分组"><a href="#914-卡牌分组" class="headerlink" title="914. 卡牌分组"></a>914. 卡牌分组</h2><p><strong>Description</strong><br>给定一副牌，每张牌上都写着一个整数。<br>此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：<br>每组都有 X 张牌。<br>组内所有的牌上都写着相同的整数。<br>仅当你可选的 X &gt;= 2 时返回 true。<br><strong>Example</strong><br>示例 1：<br>输入：[1,2,3,4,4,3,2,1]<br>输出：true<br>解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]</p>
<p>示例 2：<br>输入：[1,1,1,2,2,2,3,3]<br>输出：false<br>解释：没有满足要求的分组。</p>
<p>示例 3：<br>输入：[1]<br>输出：false<br>解释：没有满足要求的分组。</p>
<p>示例 4：<br>输入：[1,1]<br>输出：true<br>解释：可行的分组是 [1,1]</p>
<p>示例 5：<br>输入：[1,1,2,2,2,2]<br>输出：true<br>解释：可行的分组是 [1,1]，[2,2]，[2,2]</p>
<p>提示：<br>1 &lt;= deck.length &lt;= 10000<br>0 &lt;= deck[i] &lt; 10000<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> (y==<span class="number">0</span>)?x:gcd(y, x%y);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; deck)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=deck.size();</span><br><span class="line">        <span class="keyword">int</span> m[<span class="number">10001</span>]={<span class="number">0</span>};</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:deck) m[x]++;;</span><br><span class="line">        <span class="keyword">int</span> g=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10000</span>;i++){</span><br><span class="line">            <span class="keyword">if</span>(m[i]&gt;<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(g==<span class="number">-1</span>) g=m[i];</span><br><span class="line">                <span class="keyword">else</span> g=gcd(g, m[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> g &gt;= <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="820-单词的压缩编码"><a href="#820-单词的压缩编码" class="headerlink" title="820. 单词的压缩编码"></a>820. 单词的压缩编码</h2><p><strong>Description</strong><br>给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。<br>例如，如果这个列表是 [“time”, “me”, “bell”]，我们就可以将其表示为 S = “time#bell#” 和 indexes = [0, 2, 5]。<br>对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。<br>那么成功对给定单词列表进行编码的最小字符串长度是多少呢？<br><strong>Example</strong><br>示例：<br>输入: words = [“time”, “me”, “bell”]<br>输出: 10<br>说明: S = “time#bell#” ， indexes = [0, 2, 5] 。</p>
<p>提示：<br>1 &lt;= words.length &lt;= 2000<br>1 &lt;= words[i].length &lt;= 7<br>每个单词都是小写字母 。<br><strong>Program</strong><br><strong>集合去重，而后删除重复后缀。</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>{</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; s(words.begin(), words.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> word:words){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;word.length();i++){</span><br><span class="line">                <span class="keyword">auto</span> iter=s.find(word.substr(i));</span><br><span class="line">                <span class="keyword">if</span>(iter!=s.end()) s.erase(iter);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> word:s){</span><br><span class="line">            ans+=word.length()+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>字典树</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">bool</span> wordEnd;</span><br><span class="line">        Node* next[<span class="number">26</span>];</span><br><span class="line">        Node(){}</span><br><span class="line">    };</span><br><span class="line">    <span class="function">Node* <span class="title">newNode</span><span class="params">()</span></span>{</span><br><span class="line">        Node* node=<span class="keyword">new</span> Node();</span><br><span class="line">        node-&gt;len=<span class="number">0</span>;</span><br><span class="line">        node-&gt;wordEnd=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) node-&gt;next[i]=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(Node* root, <span class="built_in">string</span> str)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len=str.length();</span><br><span class="line">        Node* node=root;</span><br><span class="line">        <span class="keyword">while</span>(idx&lt;len){</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[str[idx]-<span class="string">'a'</span>]==<span class="literal">NULL</span>){</span><br><span class="line">                Node* tmp=newNode();</span><br><span class="line">                node-&gt;next[str[idx]-<span class="string">'a'</span>]=tmp;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//node-&gt;wordEnd=false; //覆盖</span></span><br><span class="line">            node=node-&gt;next[str[idx]-<span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">if</span>(idx==len<span class="number">-1</span>){</span><br><span class="line">                node-&gt;wordEnd=<span class="literal">true</span>;</span><br><span class="line">                node-&gt;len=len;</span><br><span class="line">            }</span><br><span class="line">            idx++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(Node* root)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++){</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;next[i]!=<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calResult</span><span class="params">(Node* root)</span></span>{</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            Node* node=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;wordEnd&amp;&amp;judge(node)) result+=node-&gt;len+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++){</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;next[i]!=<span class="literal">NULL</span>){</span><br><span class="line">                    q.push(node-&gt;next[i]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> a.length()&lt;b.length();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>{</span><br><span class="line">        Node* root=newNode();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.size();i++){</span><br><span class="line">            reverse(words[i].begin(), words[i].end());</span><br><span class="line">            create(root, words[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// sort(words.begin(),words.end(), cmp);</span></span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;words.size();i++){ //从长度短的开始建字典树，更长的可以覆盖更短的。</span></span><br><span class="line">        <span class="comment">//     create(root, words[i]);</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="keyword">return</span> calResult(root);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="417-太平洋大西洋水流问题"><a href="#417-太平洋大西洋水流问题" class="headerlink" title="417. 太平洋大西洋水流问题"></a>417. 太平洋大西洋水流问题</h2><p><strong>Description</strong><br>给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。<br>规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。<br>请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。<br>提示：<br>输出坐标的顺序不重要<br>m 和 n 都小于150<br><strong>Example</strong><br>示例：<br>给定下面的 5x5 矩阵:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">太平洋 ~   ~   ~   ~   ~</span><br><span class="line">     ~  1   2   2   3  (5) *</span><br><span class="line">     ~  3   2   3  (4) (4) *</span><br><span class="line">     ~  2   4  (5)  3   1  *</span><br><span class="line">     ~ (6) (7)  1   4   5  *</span><br><span class="line">     ~ (5)  1   1   2   4  *</span><br><span class="line">        *   *   *   *   * 大西洋</span><br></pre></td></tr></tbody></table></figure>
<p>返回:<br>[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).</p>
<p><strong>Program</strong><br>从外围开始反向搜索，高或相等的海拔可以流过！还能避免重复计算。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> I,<span class="keyword">int</span> J):i(I),j(J){}</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">int</span> step[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">bool</span> vis[<span class="number">151</span>][<span class="number">151</span>][<span class="number">3</span>]={<span class="literal">false</span>};</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>&amp;&amp;i&lt;m&amp;&amp;j&gt;=<span class="number">0</span>&amp;&amp;j&lt;n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> visIdx, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span></span>{</span><br><span class="line">        vis[i][j][visIdx]=<span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">        q.push(Node(i, j));</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            Node now=q.front();</span><br><span class="line">            <span class="keyword">if</span>(vis[now.i][now.j][<span class="number">1</span>-visIdx]&amp;&amp;!vis[now.i][now.j][<span class="number">2</span>]){</span><br><span class="line">                result.push_back({now.i, now.j});</span><br><span class="line">                vis[now.i][now.j][<span class="number">2</span>]=<span class="literal">true</span>;<span class="comment">//加入结果</span></span><br><span class="line">            }</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++){</span><br><span class="line">                <span class="keyword">int</span> x=now.i+step[k][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y=now.j+step[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(judge(x, y)&amp;&amp;!vis[x][y][visIdx]&amp;&amp;matrix[now.i][now.j]&lt;=matrix[x][y]){</span><br><span class="line">                    vis[x][y][visIdx]=<span class="literal">true</span>;</span><br><span class="line">                    q.push(Node(x,y));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pacificAtlantic(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) {</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span>) <span class="keyword">return</span> {};</span><br><span class="line">        m=matrix.size();</span><br><span class="line">        n=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            BFS(<span class="number">0</span>, i, <span class="number">0</span>, matrix);</span><br><span class="line">            BFS(m<span class="number">-1</span>, i, <span class="number">1</span>, matrix);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            BFS(i,<span class="number">0</span>,<span class="number">0</span>,matrix);</span><br><span class="line">            BFS(i,n<span class="number">-1</span>,<span class="number">1</span>,matrix);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;m;i++){</span></span><br><span class="line">        <span class="comment">//     for(int j=0;j&lt;n;j++){</span></span><br><span class="line">        <span class="comment">//         if(vis[i][j][0]&amp;&amp;vis[i][j][1]) result.push_back({i, j});</span></span><br><span class="line">        <span class="comment">//     }</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>vis[i][j]值为0,1,2,3,4时，分别表示未计算、太平洋、大西洋、已加入结果集合。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> I,<span class="keyword">int</span> J):i(I),j(J){}</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">int</span> step[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">int</span> vis[<span class="number">151</span>][<span class="number">151</span>]={<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>&amp;&amp;i&lt;m&amp;&amp;j&gt;=<span class="number">0</span>&amp;&amp;j&lt;n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> visIdx, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span></span>{</span><br><span class="line">        vis[i][j] |= (visIdx+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">        q.push(Node(i, j));</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            Node now=q.front();</span><br><span class="line">            <span class="keyword">if</span>(vis[now.i][now.j]==<span class="number">3</span>){</span><br><span class="line">                result.push_back({now.i, now.j});</span><br><span class="line">                vis[now.i][now.j] |= <span class="number">4</span>;</span><br><span class="line">            }</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++){</span><br><span class="line">                <span class="keyword">int</span> x=now.i+step[k][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y=now.j+step[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(judge(x, y)&amp;&amp;(vis[x][y]&amp;(visIdx+<span class="number">1</span>))==<span class="number">0</span>&amp;&amp;matrix[now.i][now.j]&lt;=matrix[x][y]){</span><br><span class="line">                    vis[x][y] |= visIdx+<span class="number">1</span>;</span><br><span class="line">                    q.push(Node(x,y));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pacificAtlantic(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) {</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span>) <span class="keyword">return</span> {};</span><br><span class="line">        m=matrix.size();</span><br><span class="line">        n=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            BFS(<span class="number">0</span>, i, <span class="number">0</span>, matrix);</span><br><span class="line">            BFS(m<span class="number">-1</span>, i, <span class="number">1</span>, matrix);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            BFS(i,<span class="number">0</span>,<span class="number">0</span>,matrix);</span><br><span class="line">            BFS(i,n<span class="number">-1</span>,<span class="number">1</span>,matrix);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;m;i++){</span></span><br><span class="line">        <span class="comment">//     for(int j=0;j&lt;n;j++){</span></span><br><span class="line">        <span class="comment">//         if(vis[i][j][0]&amp;&amp;vis[i][j][1]) result.push_back({i, j});</span></span><br><span class="line">        <span class="comment">//     }</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1162-地图分析"><a href="#1162-地图分析" class="headerlink" title="1162. 地图分析"></a>1162. 地图分析</h2><p><strong>Description</strong><br>你现在手里有一份大小为 N x N 的『地图』（网格） grid，上面的每个『区域』（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离它最近的陆地区域的距离。<br>我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。<br>如果我们的地图上只有陆地或者海洋，请返回 -1。<br><strong>Example</strong><br>示例 1：<br>输入：[[1,0,1],[0,0,0],[1,0,1]]<br>输出：2<br>解释：<br>海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。</p>
<p>示例 2：<br>输入：[[1,0,0],[0,0,0],[0,0,0]]<br>输出：4<br>解释：<br>海洋区域 (2, 2) 和所有陆地区域之间的距离都达到最大，最大距离为 4。</p>
<p>提示：<br>1 &lt;= grid.length == grid[0].length &lt;= 100<br>grid[i][j] 不是 0 就是 1<br><strong>Program</strong><br><strong>超时</strong><br>最暴力的方法，嘿嘿话说O(5000*5000)貌似不超时啊，卡时间哦。。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; A,B;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minD;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.size();i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].size();j++){</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">0</span>) A.push_back({i, j});</span><br><span class="line">                <span class="keyword">else</span> B.push_back({i,j});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(A.size()==<span class="number">0</span>||B.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        minD.resize(A.size(), inf);</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;B.size();j++){</span><br><span class="line">                <span class="keyword">int</span> dis=<span class="built_in">abs</span>(A[i].first-B[j].first)+<span class="built_in">abs</span>(A[i].second-B[j].second);</span><br><span class="line">                minD[i]=min(minD[i],dis);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(mx&lt;minD[i]){</span><br><span class="line">                mx=minD[i];</span><br><span class="line">                idx=i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> minD[idx];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>DP</strong><br>考虑优化方法二中的「把陆地区域作为源点集、海洋区域作为目标点集，求最短路」的过程。我们知道对于每个海洋区域 (x, y)(x,y)，离它最近的陆地区域到它的路径要么从上方或者左方来，要么从右方或者下方来。考虑做两次动态规划，第一次从左上到右下，第二次从右下到左上，记 f(x, y)f(x,y) 为 (x, y)(x,y) 距离最近的陆地区域的曼哈顿距离，则我们可以推出这样的转移方程：<br>第一阶段<br>当(x,y)为海洋，f(x,y)=min(f(x-1,y),f(x,y-1))+1；否则f(x,y)=0<br>第二阶段<br>当(x,y)为海洋，f(x,y)=min(f(x+1,y),f(x,y+1))+1；否则f(x,y)=0<br>我们初始化的时候把陆地的 f 值全部预置为 0，海洋的 f 全部预置为 INF，做完两个阶段的动态规划后，我们在所有的不为零的 f[i][j] 中比一个最大值即可，如果最终比较出的最大值为 INF，就返回 -1。<br>思考：如果用 f(x, y)f(x,y) 记录左上方的 DP 结果，g(x, y)g(x,y) 记录右下方的DP结果可行吗？ 答案是不可行。因为考虑距离点 (x, y)(x,y) 最近的点可能既不来自左上方，也不来自右下方，比如它来自右上方，这个时候，第二阶段我们就需要用到第一阶段的计算结果。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_N = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> INF = <span class="keyword">int</span>(<span class="number">1E6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f[MAX_N][MAX_N];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = grid.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a = grid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) {</span><br><span class="line">                f[i][j] = (a[i][j] ? <span class="number">0</span> : INF);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) {</span><br><span class="line">                <span class="keyword">if</span> (a[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;j<span class="number">-1</span>&gt;=<span class="number">0</span>) f[i][j]=min(f[i<span class="number">-1</span>][j], f[i][j<span class="number">-1</span>])+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>) f[i][j]=f[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j<span class="number">-1</span>&gt;=<span class="number">0</span>) f[i][j]=f[i][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) {</span><br><span class="line">                <span class="keyword">if</span> (a[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n&amp;&amp;j+<span class="number">1</span>&lt;n) f[i][j]=min(f[i][j],min(f[i+<span class="number">1</span>][j],f[i][j+<span class="number">1</span>])+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n) f[i][j]=min(f[i][j],f[i+<span class="number">1</span>][j]+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j+<span class="number">1</span>&lt;n) f[i][j]=min(f[i][j],f[i][j+<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) {</span><br><span class="line">                <span class="keyword">if</span> (!a[i][j]) {</span><br><span class="line">                    ans = max(ans, f[i][j]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ans &gt;= INF) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>广搜</strong><br>$O(n^4)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = {<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>}, dy[<span class="number">4</span>] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>};</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_N = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Coordinate</span> {</span></span><br><span class="line">        <span class="keyword">int</span> x, y, step;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> vis[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNearestLand</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="built_in">queue</span> &lt;Coordinate&gt; q;</span><br><span class="line">        q.push({x, y, <span class="number">0</span>});</span><br><span class="line">        vis[x][y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) {</span><br><span class="line">            <span class="keyword">auto</span> f = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) {</span><br><span class="line">                <span class="keyword">int</span> nx = f.x + dx[i], ny = f.y + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (!(nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt;= n - <span class="number">1</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt;= m - <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (!vis[nx][ny]) {</span><br><span class="line">                    q.push({nx, ny, f.step + <span class="number">1</span>});</span><br><span class="line">                    vis[nx][ny] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (a[nx][ny]) <span class="keyword">return</span> f.step + <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = grid.size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = grid.at(<span class="number">0</span>).size();</span><br><span class="line">        a = grid;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) {</span><br><span class="line">                <span class="keyword">if</span> (!a[i][j]) {</span><br><span class="line">                    ans = max(ans, findNearestLand(i, j));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>广搜+填充法</strong><br>由陆地开始广搜，已经计算过的都不用重复计算，因为广搜的性质，一定是最短距离！所以只要所有点都计算完毕就出结果了！<br>$O(n^2)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> steps[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">0</span>,  <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">1</span>,  <span class="number">0</span>,</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">    };</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> i, j, step;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> I,<span class="keyword">int</span> J,<span class="keyword">int</span> Step):i(I),j(J),step(Step){}</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>&amp;&amp;i&lt;n&amp;&amp;j&gt;=<span class="number">0</span>&amp;&amp;j&lt;n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>{</span><br><span class="line">        n=grid.size();</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">        <span class="keyword">int</span> nCount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">0</span>) grid[i][j]=inf;</span><br><span class="line">                <span class="keyword">else</span>{</span><br><span class="line">                    q.push(Node(i, j, <span class="number">0</span>));</span><br><span class="line">                    nCount++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(nCount&lt;n*n&amp;&amp;!q.empty()){</span><br><span class="line">            Node node=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++){</span><br><span class="line">                <span class="keyword">int</span> x=node.i+steps[k][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y=node.j+steps[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(judge(x, y)&amp;&amp;grid[x][y]==inf){</span><br><span class="line">                    grid[x][y]=node.step+<span class="number">1</span>;</span><br><span class="line">                    q.push(Node(x, y, node.step+<span class="number">1</span>));</span><br><span class="line">                    nCount++;</span><br><span class="line">                    ans=max(ans, grid[x][y]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="面试题62-圆圈中最后剩下的数字"><a href="#面试题62-圆圈中最后剩下的数字" class="headerlink" title="面试题62. 圆圈中最后剩下的数字"></a>面试题62. 圆圈中最后剩下的数字</h2><p><strong>Description</strong><br>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。<br>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。<br><strong>Example</strong><br>示例 1：<br>输入: n = 5, m = 3<br>输出: 3</p>
<p>示例 2：<br>输入: n = 10, m = 17<br>输出: 2</p>
<p>限制：<br>1 &lt;= n &lt;= 10^5<br>1 &lt;= m &lt;= 10^6<br><strong>Program</strong><br><strong>暴力超时</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len=n;</span><br><span class="line">        <span class="keyword">int</span> pre=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis(n,<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">1</span>){</span><br><span class="line">            <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span>(i=pre+<span class="number">1</span>;tmp&lt;m;i++){</span><br><span class="line">                <span class="keyword">if</span>(i==len) i=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(!vis[i]) tmp++;</span><br><span class="line">            }</span><br><span class="line">            i-=<span class="number">1</span>;</span><br><span class="line">            vis[i]=<span class="literal">true</span>;</span><br><span class="line">            pre=i;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">            n--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++){</span><br><span class="line">            <span class="keyword">if</span>(!vis[i]) <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>数学+迭代</strong><br><strong>参考：</strong> <a href="https://blog.csdn.net/weixin_42659809/article/details/82596676" target="_blank" rel="noopener">约瑟夫环</a><br>简单来说，例如N=10, M=3,如下：</p>
<table>
<thead>
<tr>
<th align="center">N\index</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
<th align="center">逆推公式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">√</td>
<td align="center"><strong>3</strong></td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">7</td>
<td align="center">8</td>
<td align="center">9</td>
<td align="center">f(10,3)=(f(9,3)+3)%10=3</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">7</td>
<td align="center">8</td>
<td align="center">×</td>
<td align="center"><strong>0</strong></td>
<td align="center">1</td>
<td align="center">√</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">f(9,3)=(f(8,3)+3)%9=0</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">×</td>
<td align="center"><strong>6</strong></td>
<td align="center">7</td>
<td align="center">×</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">√</td>
<td align="center">3</td>
<td align="center">f(8,3)=(f(7,3)+3)%8=6</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">1</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center"><strong>3</strong></td>
<td align="center">4</td>
<td align="center">×</td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">×</td>
<td align="center">0</td>
<td align="center">f(7,3)=(f(6,3)+3)%7=3</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">5</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center"><strong>0</strong></td>
<td align="center">1</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">3</td>
<td align="center">×</td>
<td align="center">4</td>
<td align="center">f(6,3)=(f(5,3)+3)%6=0</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center"><strong>3</strong></td>
<td align="center">4</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">0</td>
<td align="center">×</td>
<td align="center">1</td>
<td align="center">f(5,3)=(f(4,3)+3)%5=3</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center"><strong>0</strong></td>
<td align="center">1</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">3</td>
<td align="center">f(4,3)=(f(3,3)+3)%4=0</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center"><strong>1</strong></td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">0</td>
<td align="center">f(3,3)=(f(2,3)+3)%3=1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center"><strong>1</strong></td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">f(2,3)=(f(1,3)+3)%2=1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center"><strong>√</strong></td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">f(1,3)=0</td>
</tr>
</tbody></table>
<p>每次新环从上一轮杀死的下一个元素从0开始计数，所以之后每一轮都是杀死第m个元素<br>这里逆推：下一轮出局的元素在上一轮的位置，old_index=(new_index+M)%old_N;详见最后一列，从下往上递推！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i != n + <span class="number">1</span>; ++i)</span><br><span class="line">            f = (m + f) % i;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a>513. 找树左下角的值</h2><p><strong>Description</strong><br>给定一个二叉树，在树的最后一行找到最左边的值。<br><strong>Example</strong><br>示例 1:<br>输入:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></tbody></table></figure>
<p>输出:<br>1</p>
<p>示例 2:<br>输入:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> /   / \</span><br><span class="line">4   5   6</span><br><span class="line">   /</span><br><span class="line">  7</span><br></pre></td></tr></tbody></table></figure>
<p>输出:<br>7</p>
<p>注意: 您可以假设树（即给定的根节点）不为 NULL。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        TreeNode* node;</span><br><span class="line">        <span class="keyword">int</span> level;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(TreeNode* Node, <span class="keyword">int</span> Level){</span><br><span class="line">            node=Node;</span><br><span class="line">            level=Level;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dst;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        dst.first=<span class="number">-1</span>;</span><br><span class="line">        dst.second=<span class="number">0</span>;</span><br><span class="line">        q.push(Node(root, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            Node now=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            TreeNode* node=now.node;</span><br><span class="line">            <span class="keyword">int</span> level=now.level;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left!=<span class="literal">NULL</span>) q.push(Node(node-&gt;left, level+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right!=<span class="literal">NULL</span>) q.push(Node(node-&gt;right, level+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left==<span class="literal">NULL</span>&amp;&amp;node-&gt;right==<span class="literal">NULL</span>){</span><br><span class="line">                <span class="keyword">if</span>(level+<span class="number">1</span>&gt;dst.first){</span><br><span class="line">                    dst.first=level+<span class="number">1</span>;</span><br><span class="line">                    dst.second=node-&gt;val;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dst.second;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515. 在每个树行中找最大值"></a>515. 在每个树行中找最大值</h2><p><strong>Description</strong><br>您需要在二叉树的每一行中找到最大的值。<br><strong>Example</strong><br>示例：<br>输入:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  3   2</span><br><span class="line"> / \   \  </span><br><span class="line">5   3   9</span><br></pre></td></tr></tbody></table></figure>
<p>输出: [1, 3, 9]<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; largestValues(TreeNode* root) {</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="keyword">int</span> front, end;</span><br><span class="line">        front=end=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; mQueue;</span><br><span class="line">        mQueue.push_back(root);</span><br><span class="line">        <span class="keyword">int</span> ans=-inf;</span><br><span class="line">        <span class="keyword">while</span>(front&lt;=end){</span><br><span class="line">            TreeNode* now=mQueue[front];</span><br><span class="line">            <span class="keyword">if</span>(ans==-inf) ans=now-&gt;val;</span><br><span class="line">            <span class="keyword">else</span> ans=max(ans, now-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;left!=<span class="literal">NULL</span>) mQueue.push_back(now-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;right!=<span class="literal">NULL</span>) mQueue.push_back(now-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(front==end){</span><br><span class="line">                result.push_back(ans);</span><br><span class="line">                ans=-inf;</span><br><span class="line">                end=mQueue.size()<span class="number">-1</span>;</span><br><span class="line">            }</span><br><span class="line">            front++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="529-扫雷游戏"><a href="#529-扫雷游戏" class="headerlink" title="529. 扫雷游戏"></a>529. 扫雷游戏</h2><p><strong>Description</strong><br>让我们一起来玩扫雷游戏！<br>给定一个代表游戏板的二维字符矩阵。 ‘M’ 代表一个未挖出的地雷，’E’ 代表一个未挖出的空方块，’B’ 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（’1’ 到 ‘8’）表示有多少地雷与这块已挖出的方块相邻，’X’ 则表示一个已挖出的地雷。<br>现在给出在所有未挖出的方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：<br>如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 ‘X’。<br>如果一个没有相邻地雷的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的方块都应该被递归地揭露。<br>如果一个至少与一个地雷相邻的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。<br>如果在此次点击中，若无更多方块可被揭露，则返回面板。<br><strong>Example</strong><br>示例 1：<br>输入:<br>[[‘E’, ‘E’, ‘E’, ‘E’, ‘E’],<br> [‘E’, ‘E’, ‘M’, ‘E’, ‘E’],<br> [‘E’, ‘E’, ‘E’, ‘E’, ‘E’],<br> [‘E’, ‘E’, ‘E’, ‘E’, ‘E’]]<br>Click : [3,0]<br>输出:<br>[[‘B’, ‘1’, ‘E’, ‘1’, ‘B’],<br> [‘B’, ‘1’, ‘M’, ‘1’, ‘B’],<br> [‘B’, ‘1’, ‘1’, ‘1’, ‘B’],<br> [‘B’, ‘B’, ‘B’, ‘B’, ‘B’]]<br>解释:<br><img src="/assets/img/algorithm/minesweeper_example_1.png" alt="image"><br>示例 2：<br>输入:<br>[[‘B’, ‘1’, ‘E’, ‘1’, ‘B’],<br> [‘B’, ‘1’, ‘M’, ‘1’, ‘B’],<br> [‘B’, ‘1’, ‘1’, ‘1’, ‘B’],<br> [‘B’, ‘B’, ‘B’, ‘B’, ‘B’]]<br>Click : [1,2]<br>输出:<br>[[‘B’, ‘1’, ‘E’, ‘1’, ‘B’],<br> [‘B’, ‘1’, ‘X’, ‘1’, ‘B’],<br> [‘B’, ‘1’, ‘1’, ‘1’, ‘B’],<br> [‘B’, ‘B’, ‘B’, ‘B’, ‘B’]]<br>解释:<br><img src="/assets/img/algorithm/minesweeper_example_2.png" alt="image"><br>注意：<br>输入矩阵的宽和高的范围为 [1,50]。<br>点击的位置只能是未被挖出的方块 (‘M’ 或者 ‘E’)，这也意味着面板至少包含一个可点击的方块。<br>输入面板不会是游戏结束的状态（即有地雷已被挖出）。<br>简单起见，未提及的规则在这个问题中可被忽略。例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。<br><strong>Program</strong><br><strong>广搜</strong><br>注意如果相邻位置有地雷，没有要求递归揭露！也就是说，这种情况直接停止搜索。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> steps[<span class="number">8</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>,<span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,<span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line">        <span class="number">-1</span>,<span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>,<span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,<span class="number">-1</span>,</span><br><span class="line">        <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="keyword">bool</span> vis[<span class="number">51</span>][<span class="number">51</span>]={<span class="literal">false</span>}; <span class="comment">//防止重复加入队列</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;m&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calMine</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++){</span><br><span class="line">            <span class="keyword">int</span> new_x=x+steps[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> new_y=y+steps[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(judge(new_x, new_y)&amp;&amp;board[new_x][new_y]==<span class="string">'M'</span>) ans++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; updateBoard(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; click) {</span><br><span class="line">        m=board.size();</span><br><span class="line">        n=board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span>(board[click[<span class="number">0</span>]][click[<span class="number">1</span>]]==<span class="string">'M'</span>){</span><br><span class="line">            board[click[<span class="number">0</span>]][click[<span class="number">1</span>]]=<span class="string">'X'</span>;</span><br><span class="line">            <span class="keyword">return</span> board;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(board[click[<span class="number">0</span>]][click[<span class="number">1</span>]]!=<span class="string">'E'</span>) <span class="keyword">return</span> board;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push({click[<span class="number">0</span>], click[<span class="number">1</span>]});</span><br><span class="line">        vis[click[<span class="number">0</span>]][click[<span class="number">1</span>]]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; now=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> ans=calMine(now.first, now.second, board);</span><br><span class="line">            <span class="keyword">if</span>(ans&gt;<span class="number">0</span>){</span><br><span class="line">                board[now.first][now.second]=<span class="string">'0'</span>+ans;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            board[now.first][now.second]=<span class="string">'B'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++){</span><br><span class="line">                <span class="keyword">int</span> new_x=now.first+steps[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> new_y=now.second+steps[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(judge(new_x, new_y)&amp;&amp;board[new_x][new_y]==<span class="string">'E'</span>&amp;&amp;!vis[new_x][new_y]){</span><br><span class="line">                    q.push({new_x, new_y});</span><br><span class="line">                    vis[new_x][new_y]=<span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="542-01-矩阵"><a href="#542-01-矩阵" class="headerlink" title="542. 01 矩阵"></a>542. 01 矩阵</h2><p><strong>Description</strong><br>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。<br>两个相邻元素间的距离为 1 。<br><strong>Example</strong><br>示例 1:<br>输入:<br>0 0 0<br>0 1 0<br>0 0 0<br>输出:<br>0 0 0<br>0 1 0<br>0 0 0</p>
<p>示例 2:<br>输入:<br>0 0 0<br>0 1 0<br>1 1 1<br>输出:<br>0 0 0<br>0 1 0<br>1 2 1<br>注意:<br>给定矩阵的元素个数不超过 10000。<br>给定矩阵中至少有一个元素是 0。<br>矩阵中的元素只在四个方向上相邻: 上、下、左、右。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> steps[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">-1</span>,<span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>,<span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,<span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">int</span> step;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> xx, <span class="keyword">int</span> yy, <span class="keyword">int</span> ss){</span><br><span class="line">            x=xx;</span><br><span class="line">            y=yy;</span><br><span class="line">            step=ss;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;m&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; updateMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) {</span><br><span class="line">        m=matrix.size();</span><br><span class="line">        n=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">        <span class="keyword">int</span> nCount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="number">1</span>) matrix[i][j]=inf;</span><br><span class="line">                <span class="keyword">else</span>{</span><br><span class="line">                    q.push(Node(i,j,<span class="number">0</span>));</span><br><span class="line">                    nCount++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(nCount&lt;m*n&amp;&amp;!q.empty()){</span><br><span class="line">            Node now=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line">                <span class="keyword">int</span> new_x=now.x+steps[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> new_y=now.y+steps[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(judge(new_x, new_y)&amp;&amp;matrix[new_x][new_y]==inf){</span><br><span class="line">                    matrix[new_x][new_y]=now.step+<span class="number">1</span>;</span><br><span class="line">                    q.push(Node(new_x, new_y, now.step+<span class="number">1</span>));</span><br><span class="line">                    nCount++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="690-员工的重要性"><a href="#690-员工的重要性" class="headerlink" title="690. 员工的重要性"></a>690. 员工的重要性</h2><p><strong>Description</strong><br>给定一个保存员工信息的数据结构，它包含了员工唯一的id，重要度 和 直系下属的id。<br>比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15, 10, 5。那么员工1的数据结构是[1, 15, [2]]，员工2的数据结构是[2, 10, [3]]，员工3的数据结构是[3, 5, []]。注意虽然员工3也是员工1的一个下属，但是由于并不是直系下属，因此没有体现在员工1的数据结构中。<br>现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。<br><strong>Example</strong><br>示例 1:<br>输入: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1<br>输出: 11<br>解释:<br>员工1自身的重要度是5，他有两个直系下属2和3，而且2和3的重要度均为3。因此员工1的总重要度是 5 + 3 + 3 = 11。<br>注意:<br>一个员工最多有一个直系领导，但是可以有多个直系下属<br>员工数量不超过2000。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Employee info</span></span><br><span class="line"><span class="comment">class Employee {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    // It's the unique ID of each node.</span></span><br><span class="line"><span class="comment">    // unique id of this employee</span></span><br><span class="line"><span class="comment">    int id;</span></span><br><span class="line"><span class="comment">    // the importance value of this employee</span></span><br><span class="line"><span class="comment">    int importance;</span></span><br><span class="line"><span class="comment">    // the id of direct subordinates</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; subordinates;</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getImportance</span><span class="params">(<span class="built_in">vector</span>&lt;Employee*&gt; employees, <span class="keyword">int</span> id)</span> </span>{</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; id_to_idx;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;employees.size();i++){</span><br><span class="line">            id_to_idx[employees[i]-&gt;id]=i;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">queue</span>&lt;Employee*&gt; q;</span><br><span class="line">        q.push(employees[id_to_idx[id]]);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            Employee* now=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            ans+=now-&gt;importance;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;now-&gt;subordinates.size();i++){</span><br><span class="line">                <span class="keyword">int</span> next_id=now-&gt;subordinates[i];</span><br><span class="line">                q.push(employees[id_to_idx[next_id]]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="743-网络延迟时间"><a href="#743-网络延迟时间" class="headerlink" title="743. 网络延迟时间"></a>743. 网络延迟时间</h2><p><strong>Description</strong><br>有 N 个网络节点，标记为 1 到 N。<br>给定一个列表 times，表示信号经过有向边的传递时间。 times[i] = (u, v, w)，其中 u 是源节点，v 是目标节点， w 是一个信号从源节点传递到目标节点的时间。<br>现在，我们从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1。<br><strong>Example</strong><br>示例：<br><img src="/assets/img/algorithm/931_example_1.png" alt="image"><br>输入：times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2<br>输出：2</p>
<p>注意:<br>N 的范围在 [1, 100] 之间。<br>K 的范围在 [1, N] 之间。<br>times 的长度在 [1, 6000] 之间。<br>所有的边 times[i] = (u, v, w) 都有 1 &lt;= u, v &lt;= N 且 0 &lt;= w &lt;= 100。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Cmp</span>{</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; b)</span> <span class="keyword">const</span></span>{</span><br><span class="line">            <span class="keyword">return</span> a.second&gt;b.second;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;&gt; Adj(N+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis(N+<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dist(N+<span class="number">1</span>, inf);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;times.size();i++){</span><br><span class="line">            <span class="keyword">int</span> u=times[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> v=times[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> w=times[i][<span class="number">2</span>];</span><br><span class="line">            Adj[u].push_back({v, w});</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> nCount=<span class="number">0</span>;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;, Cmp&gt; pq;</span><br><span class="line">        pq.push({K, <span class="number">0</span>});</span><br><span class="line">        dist[K]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(nCount&lt;N&amp;&amp;!pq.empty()){</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; now=pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            <span class="keyword">if</span>(vis[now.first]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                nCount++;</span><br><span class="line">                vis[now.first]=<span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(nCount==N) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[now.first].size();i++){</span><br><span class="line">                <span class="keyword">int</span> u=now.first;</span><br><span class="line">                <span class="keyword">int</span> v=Adj[u][i].first;</span><br><span class="line">                <span class="keyword">int</span> w=Adj[u][i].second+now.second;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v]&amp;&amp;w&lt;dist[v]){</span><br><span class="line">                    dist[v]=w;</span><br><span class="line">                    pq.push({v, w});</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(nCount&lt;N) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) ans=max(ans, dist[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="752-打开转盘锁"><a href="#752-打开转盘锁" class="headerlink" title="752. 打开转盘锁"></a>752. 打开转盘锁</h2><p><strong>Description</strong><br>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为  ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。<br>锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。<br>列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。<br>字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。<br><strong>Example</strong><br>示例 1:<br>输入：deadends = [“0201”,”0101”,”0102”,”1212”,”2002”], target = “0202”<br>输出：6<br>解释：<br>可能的移动序列为 “0000” -&gt; “1000” -&gt; “1100” -&gt; “1200” -&gt; “1201” -&gt; “1202” -&gt; “0202”。<br>注意 “0000” -&gt; “0001” -&gt; “0002” -&gt; “0102” -&gt; “0202” 这样的序列是不能解锁的，<br>因为当拨动到 “0102” 时这个锁就会被锁定。</p>
<p>示例 2:<br>输入: deadends = [“8888”], target = “0009”<br>输出：1<br>解释：<br>把最后一位反向旋转一次即可 “0000” -&gt; “0009”。</p>
<p>示例 3:<br>输入: deadends = [“8887”,”8889”,”8878”,”8898”,”8788”,”8988”,”7888”,”9888”], target = “8888”<br>输出：-1<br>解释：<br>无法旋转到目标数字且不被锁定。</p>
<p>示例 4:<br>输入: deadends = [“0000”], target = “8888”<br>输出：-1</p>
<p>提示：<br>死亡列表 deadends 的长度范围为 [1, 500]。<br>目标数字 target 不会在 deadends 之中。<br>每个 deadends 和 target 中的字符串的数字会在 10,000 个可能的情况 ‘0000’ 到 ‘9999’ 中产生。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> vis[<span class="number">10000</span>]={<span class="literal">false</span>};</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++){</span><br><span class="line">            ans=ans*<span class="number">10</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; deadends, <span class="built_in">string</span> target)</span> </span>{</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        fill(vis, vis+<span class="number">10000</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;deadends.size();i++) vis[strToInt(deadends[i])]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!vis[<span class="number">0</span>]){</span><br><span class="line">            q.push({<span class="string">"0000"</span>, <span class="number">0</span>});</span><br><span class="line">            vis[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; now=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line">                <span class="keyword">int</span> nowDigit=now.first[i]-<span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">int</span> a=(nowDigit+<span class="number">10</span><span class="number">-1</span>)%<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">int</span> b=(nowDigit+<span class="number">1</span>)%<span class="number">10</span>;</span><br><span class="line">                <span class="built_in">string</span> s1=now.first;</span><br><span class="line">                s1[i]=a+<span class="string">'0'</span>;</span><br><span class="line">                <span class="built_in">string</span> s2=now.first;</span><br><span class="line">                s2[i]=b+<span class="string">'0'</span>;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;now.first&lt;&lt;" ";</span></span><br><span class="line">                <span class="keyword">if</span>(s1==target||s2==target) <span class="keyword">return</span> now.second+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(!vis[strToInt(s1)]){</span><br><span class="line">                    q.push({s1, now.second+<span class="number">1</span>});</span><br><span class="line">                    vis[strToInt(s1)]=<span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//cout&lt;&lt;s1&lt;&lt;" ";</span></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(!vis[strToInt(s2)]){</span><br><span class="line">                    q.push({s2, now.second+<span class="number">1</span>});</span><br><span class="line">                    vis[strToInt(s2)]=<span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//cout&lt;&lt;s2;</span></span><br><span class="line">                }</span><br><span class="line">                <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429. N叉树的层序遍历"></a>429. N叉树的层序遍历</h2><p><strong>Description</strong><br>给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。<br><strong>Example</strong><br>例如，给定一个 3叉树 :<br><img src="/assets/img/narytreeexample.png" alt="image"><br>返回其层序遍历:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">     [3,2,4],</span><br><span class="line">     [5,6]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>

<p>说明:<br>树的深度不会超过 1000。<br>树的节点总数不会超过 5000。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() {}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(Node* root) {</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">int</span> front, end;</span><br><span class="line">        front=end=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node*&gt; q;</span><br><span class="line">        q.push_back(root);</span><br><span class="line">        end++;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">while</span>(front&lt;end){</span><br><span class="line">            Node* now=q[front++];</span><br><span class="line">            vec.push_back(now-&gt;val);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;now-&gt;children.size();i++){</span><br><span class="line">                q.push_back(now-&gt;children[i]);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(front==end){</span><br><span class="line">                end=q.size();</span><br><span class="line">                result.push_back(vec);</span><br><span class="line">                vec.clear();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="559-N叉树的最大深度"><a href="#559-N叉树的最大深度" class="headerlink" title="559. N叉树的最大深度"></a>559. N叉树的最大深度</h2><p><strong>Description</strong><br>给定一个 N 叉树，找到其最大深度。<br>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。<br><strong>Example</strong><br>例如，给定一个 3叉树 :<br><img src="/assets/img/narytreeexample.png" alt="image"><br>我们应返回其最大深度，3。<br>说明:<br>树的深度不会超过 1000。<br>树的节点总不会超过 5000。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() {}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;Node*,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push({root, <span class="number">1</span>});</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            pair&lt;Node*, <span class="keyword">int</span>&gt; now=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            ans=max(ans, now.second);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;now.first-&gt;children.size();i++){</span><br><span class="line">                q.push({now.first-&gt;children[i], now.second+<span class="number">1</span>});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="785-判断二分图"><a href="#785-判断二分图" class="headerlink" title="785. 判断二分图"></a>785. 判断二分图</h2><p><strong>Description</strong><br>给定一个无向图graph，当这个图为二分图时返回true。<br>如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。<br>graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： graph[i] 中不存在i，并且graph[i]中没有重复的值。<br><strong>Example</strong><br>示例 1:<br>输入: [[1,3], [0,2], [1,3], [0,2]]<br>输出: true<br>解释:<br>无向图如下:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br></pre></td></tr></tbody></table></figure>
<p>我们可以将节点分成两组: {0, 2} 和 {1, 3}。</p>
<p>示例 2:<br>输入: [[1,2,3], [0,2], [0,1,3], [0,2]]<br>输出: false<br>解释:<br>无向图如下:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br></pre></td></tr></tbody></table></figure>
<p>我们不能将节点分割成两个独立的子集。<br>注意:<br>graph 的长度范围为 [1, 100]。<br>graph[i] 中的元素的范围为 [0, graph.length - 1]。<br>graph[i] 不会包含 i 或者有重复的值。<br>图是无向的: 如果j 在 graph[i]里边, 那么 i 也会在 graph[j]里边。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis[<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> u)</span></span>{</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push({u, <span class="number">0</span>});</span><br><span class="line">        vis[<span class="number">0</span>][u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; now=q.front();</span><br><span class="line">            <span class="keyword">int</span> u=now.first;</span><br><span class="line">            <span class="keyword">int</span> visIdx=now.second;</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph[u].size();i++){</span><br><span class="line">                <span class="keyword">int</span> v=graph[u][i];</span><br><span class="line">                <span class="keyword">if</span>(vis[visIdx][v]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(!vis[<span class="number">1</span>-visIdx][v]){</span><br><span class="line">                    q.push({v, <span class="number">1</span>-visIdx});</span><br><span class="line">                    vis[<span class="number">1</span>-visIdx][v]=<span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=graph.size();</span><br><span class="line"></span><br><span class="line">        vis[<span class="number">0</span>].resize(n,<span class="literal">false</span>);</span><br><span class="line">        vis[<span class="number">1</span>].resize(n,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(!vis[<span class="number">0</span>][i]&amp;&amp;!vis[<span class="number">1</span>][i]){</span><br><span class="line">                <span class="keyword">if</span>(!BFS(graph, i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="863-二叉树中所有距离为-K-的结点"><a href="#863-二叉树中所有距离为-K-的结点" class="headerlink" title="863. 二叉树中所有距离为 K 的结点"></a>863. 二叉树中所有距离为 K 的结点</h2><p><strong>Description</strong><br>给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。<br>返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。<br><strong>Example</strong><br>示例 1：<br>输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2<br>输出：[7,4,1]<br>解释：<br>所求结点为与目标结点（值为 5）距离为 2 的结点，<br>值分别为 7，4，以及 1<br><img src="/assets/img/algorithm/sketch0.png" alt="image"><br>注意，输入的 “root” 和 “target” 实际上是树上的结点。<br>上面的输入仅仅是对这些对象进行了序列化描述。<br>提示：<br>给定的树是非空的，且最多有 K 个结点。<br>树上的每个结点都具有唯一的值 0 &lt;= node.val &lt;= 500 。<br>目标结点 target 是树上的结点。<br>0 &lt;= K &lt;= 1000.<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> n)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        m[root]=n;</span><br><span class="line">        dfs(root-&gt;left, <span class="number">2</span>*n+<span class="number">1</span>);</span><br><span class="line">        dfs(root-&gt;right, <span class="number">2</span>*n+<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=y){</span><br><span class="line">            <span class="keyword">if</span>(x&gt;y) x=(x<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> y=(y<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">            res++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; distanceK(TreeNode* root, TreeNode* target, <span class="keyword">int</span> K) {</span><br><span class="line">        dfs(root, <span class="number">0</span>);  <span class="comment">//坐标化</span></span><br><span class="line">        <span class="keyword">int</span> t=m[target];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(pair&lt;TreeNode*, <span class="keyword">int</span>&gt; p:m){</span><br><span class="line">            <span class="comment">//cout&lt;&lt;p.first&lt;&lt;" "&lt;&lt;p.second&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(dis(p.second, t)==K) result.push_back(p.first-&gt;val);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="909-蛇梯棋"><a href="#909-蛇梯棋" class="headerlink" title="909. 蛇梯棋"></a>909. 蛇梯棋</h2><p><strong>Description</strong><br>在一块 N x N 的棋盘 board 上，从棋盘的左下角开始，每一行交替方向，按从 1 到 N<em>N 的数字给方格编号。例如，对于一块 6 x 6 大小的棋盘，可以编号如下：<br><img src="/assets/img/algorithm/snakes.png" alt="image"><br>玩家从棋盘上的方格 1 （总是在最后一行、第一列）开始出发。<br>每一次从方格 x 起始的移动都由以下部分组成：<br>你选择一个目标方块 S，它的编号是 x+1，x+2，x+3，x+4，x+5，或者 x+6，只要这个数字 &lt;= N</em>N。<br>如果 S 有一个蛇或梯子，你就移动到那个蛇或梯子的目的地。否则，你会移动到 S。<br>在 r 行 c 列上的方格里有 “蛇” 或 “梯子”；如果 board[r][c] != -1，那个蛇或梯子的目的地将会是 board[r][c]。<br>注意，你每次移动最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，你也不会继续移动。<br>返回达到方格 N<em>N 所需的最少移动次数，如果不可能，则返回 -1。<br>*</em>Example**<br>示例：<br>输入：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[-1,-1,-1,-1,-1,-1],</span><br><span class="line">[-1,-1,-1,-1,-1,-1],</span><br><span class="line">[-1,-1,-1,-1,-1,-1],</span><br><span class="line">[-1,35,-1,-1,13,-1],</span><br><span class="line">[-1,-1,-1,-1,-1,-1],</span><br><span class="line">[-1,15,-1,-1,-1,-1]]</span><br><span class="line">`</span><br></pre></td></tr></tbody></table></figure>
<p>输出：4<br>解释：<br>首先，从方格 1 [第 5 行，第 0 列] 开始。<br>你决定移动到方格 2，并必须爬过梯子移动到到方格 15。<br>然后你决定移动到方格 17 [第 3 行，第 5 列]，必须爬过蛇到方格 13。<br>然后你决定移动到方格 14，且必须通过梯子移动到方格 35。<br>然后你决定移动到方格 36, 游戏结束。<br>可以证明你需要至少 4 次移动才能到达第 N*N 个方格，所以答案是 4。</p>
<p>提示：<br>2 &lt;= board.length = board[0].length &lt;= 20<br>board[i][j] 介于 1 和 N<em>N 之间或者等于 -1。<br>编号为 1 的方格上没有蛇或梯子。<br>编号为 N</em>N 的方格上没有蛇或梯子。<br><strong>Program</strong><br>坑点就是一条捷径的终点如果又是另一条捷径的起点，那么走了前一条捷径到达该捷径的终点后，不能走该捷径终点作为另一条捷径起点的那条捷径了！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; calRC(<span class="keyword">int</span> x){</span><br><span class="line">        <span class="keyword">int</span> row=(x<span class="number">-1</span>)/n;</span><br><span class="line">        <span class="keyword">int</span> col=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(row%<span class="number">2</span>==<span class="number">0</span>) col=x-row*n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> col=n-(x-row*n);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;n-row-1&lt;&lt;" "&lt;&lt;col&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span> {n-row<span class="number">-1</span>, col};</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">snakesAndLadders</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>{</span><br><span class="line">        n=board.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis(n*n+<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push({<span class="number">1</span>, <span class="number">0</span>});</span><br><span class="line">        vis[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; now=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(now.first==n*n) <span class="keyword">return</span> now.second;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++){ <span class="comment">//每次可走步数</span></span><br><span class="line">                <span class="keyword">int</span> dst=now.first+i;</span><br><span class="line">                <span class="keyword">if</span>(dst&gt;n*n) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(!vis[dst]){</span><br><span class="line">                    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p=calRC(dst);</span><br><span class="line">                    <span class="keyword">int</span> tmp=board[p.first][p.second];</span><br><span class="line">                    <span class="keyword">if</span>(tmp!=<span class="number">-1</span>){</span><br><span class="line">                        q.push({tmp, now.second+<span class="number">1</span>});</span><br><span class="line">                        <span class="comment">//vis[tmp]=true; //不能被标记，因为如果该点又是另一条捷径的起点，那么可能通过该起点的路径最短，因为该点作为某次移动的捷径终点时不能使用其作为另一条捷径的起点了！可走步数只能严格x+i，i&lt;=6</span></span><br><span class="line">                    }<span class="keyword">else</span> q.push({dst, now.second+<span class="number">1</span>});</span><br><span class="line">                    vis[dst]=<span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="934-最短的桥"><a href="#934-最短的桥" class="headerlink" title="934. 最短的桥"></a>934. 最短的桥</h2><p><strong>Description</strong><br>在给定的二维二进制数组 A 中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。）<br>现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。<br>返回必须翻转的 0 的最小数目。（可以保证答案至少是 1。）<br><strong>Example</strong><br>示例 1：<br>输入：[[0,1],[1,0]]<br>输出：1<br>示例 2：<br>输入：[[0,1,0],[0,0,0],[0,0,1]]<br>输出：2<br>示例 3：<br>输入：[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]<br>输出：1</p>
<p>提示：<br>1 &lt;= A.length = A[0].length &lt;= 100<br>A[i][j] == 0 或 A[i][j] == 1<br><strong>Program</strong><br>先通过DFS标记一个岛，之后将另一个岛的坐标加入队列，最后广搜即可。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> steps[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">1</span>,<span class="number">0</span>,</span><br><span class="line">        <span class="number">-1</span>,<span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,<span class="number">-1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> mark)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> rows=A.size();</span><br><span class="line">        <span class="keyword">int</span> cols=A[<span class="number">0</span>].size();</span><br><span class="line">        A[x][y]=mark;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line">            <span class="keyword">int</span> new_x=x+steps[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> new_y=y+steps[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(new_x&gt;=<span class="number">0</span>&amp;&amp;new_x&lt;rows&amp;&amp;new_y&gt;=<span class="number">0</span>&amp;&amp;new_y&lt;cols&amp;&amp;A[new_x][new_y]==<span class="number">1</span>){</span><br><span class="line">                dfs(A, new_x, new_y, mark);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestBridge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>{</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">int</span> rows=A.size();</span><br><span class="line">        <span class="keyword">int</span> cols=A[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">bool</span> bFirst=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++){</span><br><span class="line">                <span class="keyword">if</span>(A[i][j]==<span class="number">1</span>){</span><br><span class="line">                    <span class="keyword">if</span>(bFirst){</span><br><span class="line">                        dfs(A,i,j,<span class="number">2</span>);</span><br><span class="line">                        bFirst=<span class="literal">false</span>;</span><br><span class="line">                    }<span class="keyword">else</span>{</span><br><span class="line">                        q.push({{i, j},<span class="number">0</span>});</span><br><span class="line">                        A[i][j]=<span class="number">-1</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            pair&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; now=q.front();</span><br><span class="line">            <span class="keyword">int</span> x=now.first.first;</span><br><span class="line">            <span class="keyword">int</span> y=now.first.second;</span><br><span class="line">            <span class="keyword">int</span> s=now.second;</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line">                <span class="keyword">int</span> new_x=x+steps[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> new_y=y+steps[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(new_x&gt;=<span class="number">0</span>&amp;&amp;new_x&lt;rows&amp;&amp;new_y&gt;=<span class="number">0</span>&amp;&amp;new_y&lt;cols){</span><br><span class="line">                    <span class="keyword">if</span>(A[new_x][new_y]==<span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">                    <span class="keyword">if</span>(A[new_x][new_y]==<span class="number">0</span>){</span><br><span class="line">                        q.push({{new_x,new_y},s+<span class="number">1</span>});</span><br><span class="line">                        A[new_x][new_y]=<span class="number">-1</span>; <span class="comment">//标记</span></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="993-二叉树的堂兄弟节点"><a href="#993-二叉树的堂兄弟节点" class="headerlink" title="993. 二叉树的堂兄弟节点"></a>993. 二叉树的堂兄弟节点</h2><p><strong>Description</strong><br>在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。<br>如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。<br>我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。<br>只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。<br><strong>Example</strong><br>示例 1：<br><img src="/assets/img/algorithm/q1248-01.png" alt="image"><br>输入：root = [1,2,3,4], x = 4, y = 3<br>输出：false<br>示例 2：<br><img src="/assets/img/algorithm/q1248-02.png" alt="image"><br>输入：root = [1,2,3,null,4,null,5], x = 5, y = 4<br>输出：true<br>示例 3：<br><img src="/assets/img/algorithm/q1248-03.png" alt="image"><br>输入：root = [1,2,3,null,4], x = 2, y = 3<br>输出：false<br>提示：<br>二叉树的节点数介于 2 到 100 之间。<br>每个节点的值都是唯一的、范围为 1 到 100 的整数。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;TreeNode*,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, TreeNode*&gt; valToNode;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> n)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        m[root]=n;</span><br><span class="line">        valToNode[root-&gt;val]=root;</span><br><span class="line">        dfs(root-&gt;left, <span class="number">2</span>*n+<span class="number">1</span>);</span><br><span class="line">        dfs(root-&gt;right, <span class="number">2</span>*n+<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> s1,s2;</span><br><span class="line">        s1=s2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=y){</span><br><span class="line">            <span class="keyword">if</span>(x&gt;y){</span><br><span class="line">                x=(x<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">                s1++;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                y=(y<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">                s2++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> (s1==s2)&amp;&amp;(s1&gt;=<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCousins</span><span class="params">(TreeNode* root, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> judge(m[valToNode[x]],m[valToNode[y]]);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1091-二进制矩阵中的最短路径"><a href="#1091-二进制矩阵中的最短路径" class="headerlink" title="1091. 二进制矩阵中的最短路径"></a>1091. 二进制矩阵中的最短路径</h2><p><strong>Description</strong><br>在一个 N × N 的方形网格中，每个单元格有两种状态：空（0）或者阻塞（1）。<br>一条从左上角到右下角、长度为 k 的畅通路径，由满足下述条件的单元格 C_1, C_2, …, C_k 组成：<br>相邻单元格 C_i 和 C_{i+1} 在八个方向之一上连通（此时，C_i 和 C_{i+1} 不同且共享边或角）<br>C_1 位于 (0, 0)（即，值为 grid[0][0]）<br>C_k 位于 (N-1, N-1)（即，值为 grid[N-1][N-1]）<br>如果 C_i 位于 (r, c)，则 grid[r][c] 为空（即，grid[r][c] == 0）<br>返回这条从左上角到右下角的最短畅通路径的长度。如果不存在这样的路径，返回 -1 。<br><strong>Example</strong><br>示例 1：<br>输入：[[0,1],[1,0]]<br>输出：2</p>
<p>示例 2：<br>输入：[[0,0,0],[1,1,0],[1,1,0]]<br>输出：4</p>
<p>提示：<br>1 &lt;= grid.length == grid[0].length &lt;= 100<br>grid[i][j] 为 0 或 1<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> steps[<span class="number">8</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">-1</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y, <span class="keyword">int</span> n)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;n&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="keyword">if</span>(grid[<span class="number">0</span>][<span class="number">0</span>]!=<span class="number">0</span>||grid[n<span class="number">-1</span>][n<span class="number">-1</span>]!=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push({{<span class="number">0</span>, <span class="number">0</span>}, <span class="number">1</span>});</span><br><span class="line">        grid[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            pair&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; now=q.front();</span><br><span class="line">            <span class="keyword">int</span> x=now.first.first;</span><br><span class="line">            <span class="keyword">int</span> y=now.first.second;</span><br><span class="line">            <span class="keyword">int</span> s=now.second;</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(x==n<span class="number">-1</span>&amp;&amp;y==n<span class="number">-1</span>) <span class="keyword">return</span> s;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++){</span><br><span class="line">                <span class="keyword">int</span> new_x=x+steps[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> new_y=y+steps[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(judge(new_x,new_y,n)&amp;&amp;grid[new_x][new_y]==<span class="number">0</span>){</span><br><span class="line">                    q.push({{new_x, new_y}, s+<span class="number">1</span>});</span><br><span class="line">                    grid[new_x][new_y]=<span class="number">-1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a>994. 腐烂的橘子</h2><p><strong>Description</strong><br>在给定的网格中，每个单元格可以有以下三个值之一：<br>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。<br>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。<br><strong>Example</strong><br>示例 1：<br>输入：[[2,1,1],[1,1,0],[0,1,1]]<br>输出：4</p>
<p>示例 2：<br>输入：[[2,1,1],[0,1,1],[1,0,1]]<br>输出：-1<br>解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。</p>
<p>示例 3：<br>输入：[[0,2]]<br>输出：0<br>解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</p>
<p>提示：<br>1 &lt;= grid.length &lt;= 10<br>1 &lt;= grid[0].length &lt;= 10<br>grid[i][j] 仅为 0、1 或 2</p>
<p><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> steps[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">0</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;m&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m=grid.size();</span><br><span class="line">        <span class="keyword">int</span> n=grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">int</span> nCount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">2</span>) q.push({{i,j},<span class="number">0</span>});</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>) nCount++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(q.empty()&amp;&amp;nCount==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            pair&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; now=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> x=now.first.first;</span><br><span class="line">            <span class="keyword">int</span> y=now.first.second;</span><br><span class="line">            <span class="keyword">int</span> time=now.second;</span><br><span class="line">            ans=max(ans, time);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line">                <span class="keyword">int</span> new_x=x+steps[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> new_y=y+steps[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(judge(new_x,new_y,m,n)&amp;&amp;grid[new_x][new_y]==<span class="number">1</span>){</span><br><span class="line">                    q.push({{new_x, new_y}, time+<span class="number">1</span>});</span><br><span class="line">                    grid[new_x][new_y]=<span class="number">2</span>;</span><br><span class="line">                    nCount--;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(nCount!=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="面试题-04-03-特定深度节点链表"><a href="#面试题-04-03-特定深度节点链表" class="headerlink" title="面试题 04.03. 特定深度节点链表"></a>面试题 04.03. 特定深度节点链表</h2><p><strong>Description</strong><br>给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 D，则会创建出 D 个链表）。返回一个包含所有深度的链表的数组。<br><strong>Example</strong><br>示例：<br>输入：[1,2,3,4,5,null,7,8]</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     /  \</span><br><span class="line">    2    3</span><br><span class="line">   / \    \</span><br><span class="line">  4   5    7</span><br><span class="line"> /</span><br><span class="line">8</span><br></pre></td></tr></tbody></table></figure>
<p>输出：[[1],[2,3],[4,5,7],[8]]<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;ListNode*&gt; listOfDepth(TreeNode* tree) {</span><br><span class="line">        <span class="keyword">if</span>(tree==<span class="literal">NULL</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; vec;</span><br><span class="line">        <span class="keyword">int</span> front, end;</span><br><span class="line">        front=end=<span class="number">0</span>;</span><br><span class="line">        vec.push_back(tree);</span><br><span class="line">        end++;</span><br><span class="line">        ListNode* tmp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;ListNode*&gt; result;</span><br><span class="line">        <span class="keyword">int</span> preEnd=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(front&lt;end){</span><br><span class="line">            TreeNode* now=vec[front];</span><br><span class="line">            <span class="keyword">if</span>(front==preEnd){</span><br><span class="line">                tmp=<span class="keyword">new</span> ListNode(now-&gt;val);</span><br><span class="line">                result.push_back(tmp);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                tmp-&gt;next=<span class="keyword">new</span> ListNode(now-&gt;val);</span><br><span class="line">                tmp=tmp-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;left!=<span class="literal">NULL</span>) vec.push_back(now-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;right!=<span class="literal">NULL</span>) vec.push_back(now-&gt;right);</span><br><span class="line">            front++;</span><br><span class="line">            <span class="keyword">if</span>(front==end){</span><br><span class="line">                preEnd=end;</span><br><span class="line">                end=vec.size();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="建设道路"><a href="#建设道路" class="headerlink" title="建设道路"></a>建设道路</h2><p><strong>Description</strong><br>牛牛国有 nn 个城市，编号为 1…n，第 i 个城市有一个价值$a_i$，牛国的国王牛阔落特别喜欢在牛牛国旅游，并且他不想每次旅游的时候都计算一遍走哪条路最短，于是他决定在任意两个城市之间建立一条双向道路，在第$i$座城市和第$j$座城市之间建立双向道路的代价是 $(a_i-a_j)^2$，牛阔落希望你能算出这项工程的花费。由于答案太大，你只需要输出答案模 $1e9+7$ 的余数<br><strong>Example</strong><br>输入描述:<br>第一行一个整数 n，表示城市的数量。<br>第二行 n 以空格分隔的整数 a1,a2,…,an，表示第i座城市的价值。<br>输出描述:<br>输出一行一个数字，表示工程的花费模 1e9+7的余数<br>示例1<br>输入<br>复制<br>3<br>1 2 3<br>输出<br>复制<br>6<br>说明<br>城市1到城市2的道路价值是(2 - 1)^ 2 = 1<br>城市2到城市3的道路价值是(3 - 2)^ 2 = 1<br>城市1到城市3的道路价值是(3 - 1)^ 2 = 4<br>总的花费 = 1 + 1 + 4 = 6<br>备注:<br>$1≤n≤5e5,1e91≤ai≤1e9$<br>建议使用<code>scanf</code>读入<br><strong>Program</strong><br><img src="/assets/img/algorithm/square_sum.png" alt="image"></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; a(n+<span class="number">1</span>,<span class="number">0</span>),sum1(n+<span class="number">1</span>,<span class="number">0</span>),sum2(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        sum1[i]=(sum1[i<span class="number">-1</span>]+a[i])%mod;</span><br><span class="line">        sum2[i]=(sum2[i<span class="number">-1</span>]+(a[i]*a[i]%mod))%mod;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        result=(result+((n-i)*(a[i]*a[i]%mod))%mod)%mod;</span><br><span class="line">        result=(result-(<span class="number">2</span>*(a[i]*((sum1[n]-sum1[i]+mod)%mod))%mod)%mod)%mod;</span><br><span class="line">        result=(result+(sum2[n]-sum2[i]+mod)%mod+mod)%mod;</span><br><span class="line">        <span class="comment">//long long x1=((n-i)*(a[i]*a[i]%mod))%mod;</span></span><br><span class="line">        <span class="comment">//long long x2=(2*(a[i]*((sum1[n]-sum1[i])%mod))%mod)%mod;</span></span><br><span class="line">        <span class="comment">//long long x3=(sum2[n]-sum2[i]+mod)%mod;</span></span><br><span class="line">        <span class="comment">//long long x=(x1-x2+x3+mod)%mod;</span></span><br><span class="line">        <span class="comment">//result=(result+x)%mod;</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;result&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1129-颜色交替的最短路径"><a href="#1129-颜色交替的最短路径" class="headerlink" title="1129. 颜色交替的最短路径"></a>1129. 颜色交替的最短路径</h2><p><strong>Description</strong><br>在一个有向图中，节点分别标记为 0, 1, …, n-1。这个图中的每条边不是红色就是蓝色，且存在自环或平行边。<br>red_edges 中的每一个 [i, j] 对表示从节点 i 到节点 j 的红色有向边。类似地，blue_edges 中的每一个 [i, j] 对表示从节点 i 到节点 j 的蓝色有向边。<br>返回长度为 n 的数组 answer，其中 answer[X] 是从节点 0 到节点 X 的最短路径的长度，且路径上红色边和蓝色边交替出现。如果不存在这样的路径，那么 answer[x] = -1。<br><strong>Example</strong><br>示例 1：<br>输入：n = 3, red_edges = [[0,1],[1,2]], blue_edges = []<br>输出：[0,1,-1]</p>
<p>示例 2：<br>输入：n = 3, red_edges = [[0,1]], blue_edges = [[2,1]]<br>输出：[0,1,-1]</p>
<p>示例 3：<br>输入：n = 3, red_edges = [[1,0]], blue_edges = [[2,1]]<br>输出：[0,-1,-1]</p>
<p>示例 4：<br>输入：n = 3, red_edges = [[0,1]], blue_edges = [[1,2]]<br>输出：[0,1,2]</p>
<p>示例 5：<br>输入：n = 3, red_edges = [[0,1],[0,2]], blue_edges = [[1,0]]<br>输出：[0,1,1]</p>
<p>提示：<br>1 &lt;= n &lt;= 100<br>red_edges.length &lt;= 400<br>blue_edges.length &lt;= 400<br>red_edges[i].length == blue_edges[i].length == 2<br>0 &lt;= red_edges[i][j], blue_edges[i][j] &lt; n<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">int</span> color;</span><br><span class="line">        <span class="keyword">int</span> step;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> V,<span class="keyword">int</span> C, <span class="keyword">int</span> S):v(V),color(C),step(S){}</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; shortestAlternatingPaths(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; red_edges, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; blue_edges) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;&gt; Adj(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result(n, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&gt; vis(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;(n,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;red_edges.size();i++){</span><br><span class="line">            <span class="keyword">int</span> u=red_edges[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> v=red_edges[i][<span class="number">1</span>];</span><br><span class="line">            Adj[u].push_back({v, <span class="number">0</span>});</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;blue_edges.size();i++){</span><br><span class="line">            <span class="keyword">int</span> u=blue_edges[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> v=blue_edges[i][<span class="number">1</span>];</span><br><span class="line">            Adj[u].push_back({v, <span class="number">1</span>});</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">        q.push(Node(<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            Node now=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(result[now.v]==<span class="number">-1</span>){</span><br><span class="line">                result[now.v]=now.step;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[now.v].size();i++){</span><br><span class="line">                <span class="keyword">int</span> v=Adj[now.v][i].first;</span><br><span class="line">                <span class="keyword">int</span> color=Adj[now.v][i].second;</span><br><span class="line">                <span class="keyword">if</span>(!vis[color][now.v][v]){</span><br><span class="line">                    <span class="keyword">if</span>(now.color==<span class="number">-1</span>){</span><br><span class="line">                        q.push(Node(v, color, now.step+<span class="number">1</span>));</span><br><span class="line">                        vis[color][now.v][v]=<span class="literal">true</span>;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(now.color==<span class="number">0</span>&amp;&amp;color==<span class="number">1</span>){</span><br><span class="line">                        q.push(Node(v, color, now.step+<span class="number">1</span>));</span><br><span class="line">                        vis[color][now.v][v]=<span class="literal">true</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span>(now.color==<span class="number">1</span>&amp;&amp;color==<span class="number">0</span>){</span><br><span class="line">                        q.push(Node(v, color, now.step+<span class="number">1</span>));</span><br><span class="line">                        vis[color][now.v][v]=<span class="literal">true</span>;</span><br><span class="line">                    }</span><br><span class="line">                }  </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1306-跳跃游戏-III"><a href="#1306-跳跃游戏-III" class="headerlink" title="1306. 跳跃游戏 III"></a>1306. 跳跃游戏 III</h2><p><strong>Description</strong><br>这里有一个非负整数数组 arr，你最开始位于该数组的起始下标 start 处。当你位于下标 i 处时，你可以跳到 i + arr[i] 或者 i - arr[i]。<br>请你判断自己是否能够跳到对应元素值为 0 的 任意 下标处。<br>注意，不管是什么情况下，你都无法跳到数组之外。<br><strong>Example</strong><br>示例 1：<br>输入：arr = [4,2,3,0,3,1,2], start = 5<br>输出：true<br>解释：<br>到达值为 0 的下标 3 有以下可能方案：<br>下标 5 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3<br>下标 5 -&gt; 下标 6 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3</p>
<p>示例 2：<br>输入：arr = [4,2,3,0,3,1,2], start = 0<br>输出：true<br>解释：<br>到达值为 0 的下标 3 有以下可能方案：<br>下标 0 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3</p>
<p>示例 3：<br>输入：arr = [3,0,2,1,2], start = 2<br>输出：false<br>解释：无法到达值为 0 的下标 1 处。</p>
<p>提示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= arr.length &lt;= 5 * 10^4</span><br><span class="line">0 &lt;= arr[i] &lt;&nbsp;arr.length</span><br><span class="line">0 &lt;= start &lt; arr.length</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canReach</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> start)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis(n,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(start);</span><br><span class="line">        vis[start]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            <span class="keyword">int</span> idx=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(arr[idx]==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(idx+arr[idx]&gt;=<span class="number">0</span>&amp;&amp;idx+arr[idx]&lt;n&amp;&amp;!vis[idx+arr[idx]]){</span><br><span class="line">                q.push(idx+arr[idx]);</span><br><span class="line">                vis[idx+arr[idx]]=<span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(idx-arr[idx]&gt;=<span class="number">0</span>&amp;&amp;idx-arr[idx]&lt;n&amp;&amp;!vis[idx-arr[idx]]){</span><br><span class="line">                q.push(idx-arr[idx]);</span><br><span class="line">                vis[idx-arr[idx]]=<span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1311-获取你好友已观看的视频"><a href="#1311-获取你好友已观看的视频" class="headerlink" title="1311. 获取你好友已观看的视频"></a>1311. 获取你好友已观看的视频</h2><p><strong>Description</strong><br>有 n 个人，每个人都有一个  0 到 n-1 的唯一 id 。<br>给你数组 watchedVideos  和 friends ，其中 watchedVideos[i]  和 friends[i] 分别表示 id = i 的人观看过的视频列表和他的好友列表。<br>Level 1 的视频包含所有你好友观看过的视频，level 2 的视频包含所有你好友的好友观看过的视频，以此类推。一般的，Level 为 k 的视频包含所有从你出发，最短距离为 k 的好友观看过的视频。<br>给定你的 id  和一个 level 值，请你找出所有指定 level 的视频，并将它们按观看频率升序返回。如果有频率相同的视频，请将它们按字母顺序从小到大排列。<br><strong>Example</strong><br>示例 1：<br><img src="/assets/img/algorithm/leetcode_friends_1.png" alt="image"><br>输入：watchedVideos = [[“A”,”B”],[“C”],[“B”,”C”],[“D”]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 1<br>输出：[“B”,”C”]<br>解释：<br>你的 id 为 0（绿色），你的朋友包括（黄色）：<br>id 为 1 -&gt; watchedVideos = [“C”]<br>id 为 2 -&gt; watchedVideos = [“B”,”C”]<br>你朋友观看过视频的频率为：<br>B -&gt; 1<br>C -&gt; 2</p>
<p>示例 2：<br><img src="/assets/img/algorithm/leetcode_friends_2.png" alt="image"><br>输入：watchedVideos = [[“A”,”B”],[“C”],[“B”,”C”],[“D”]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 2<br>输出：[“D”]<br>解释：<br>你的 id 为 0（绿色），你朋友的朋友只有一个人，他的 id 为 3（黄色）。</p>
<p>提示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n == watchedVideos.length ==&nbsp;friends.length</span><br><span class="line">2 &lt;= n&nbsp;&lt;= 100</span><br><span class="line">1 &lt;=&nbsp;watchedVideos[i].length &lt;= 100</span><br><span class="line">1 &lt;=&nbsp;watchedVideos[i][j].length &lt;= 8</span><br><span class="line">0 &lt;= friends[i].length &lt; n</span><br><span class="line">0 &lt;= friends[i][j]&nbsp;&lt; n</span><br><span class="line">0 &lt;= id &lt; n</span><br><span class="line">1 &lt;= level &lt; n</span><br><span class="line">如果&nbsp;friends[i] 包含&nbsp;j&nbsp;，那么&nbsp;friends[j] 包含&nbsp;i</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; &amp;a, pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; &amp;b)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(a.second!=b.second){</span><br><span class="line">            <span class="keyword">return</span> a.second&lt;b.second;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; watchedVideosByFriends(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; watchedVideos, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; friends, <span class="keyword">int</span> id, <span class="keyword">int</span> level) {</span><br><span class="line">        <span class="keyword">int</span> n=watchedVideos.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; Adj(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;friends[i].size();j++){</span><br><span class="line">                <span class="keyword">int</span> v=friends[i][j];</span><br><span class="line">                Adj[i].push_back(v);</span><br><span class="line">                Adj[v].push_back(i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis(n, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push({id,<span class="number">0</span>});</span><br><span class="line">        vis[id]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; now=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(now.second==level){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;watchedVideos[now.first].size();i++){</span><br><span class="line">                    <span class="keyword">if</span>(m.find(watchedVideos[now.first][i])==m.end()) m[watchedVideos[now.first][i]]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> m[watchedVideos[now.first][i]]++;</span><br><span class="line">                }   </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[now.first].size();i++){</span><br><span class="line">                <span class="keyword">int</span> v=Adj[now.first][i];</span><br><span class="line">                <span class="keyword">if</span>(!vis[v]){</span><br><span class="line">                    vis[v]=<span class="literal">true</span>;</span><br><span class="line">                    q.push({v, now.second+<span class="number">1</span>});</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; now:m){</span><br><span class="line">            result.push_back({now.first,now.second});</span><br><span class="line">            <span class="comment">//cout&lt;&lt;now.first&lt;&lt;" "&lt;&lt;now.second&lt;&lt;endl;</span></span><br><span class="line">        }</span><br><span class="line">        sort(result.begin(), result.end(),cmp);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; now:result) res.push_back(now.first);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="面试题32-I-从上到下打印二叉树"><a href="#面试题32-I-从上到下打印二叉树" class="headerlink" title="面试题32 - I. 从上到下打印二叉树"></a>面试题32 - I. 从上到下打印二叉树</h2><p><strong>Description</strong><br>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。<br><strong>Example</strong><br>例如:<br>给定二叉树: [3,9,20,null,null,15,7],<br>···<br>    3<br>   / <br>  9  20<br>    /  <br>   15   7<br>···<br>返回：<br>[3,9,20,15,7]</p>
<p>提示：<br>节点总数 &lt;= 1000<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; levelOrder(TreeNode* root) {</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            TreeNode* now=q.front();</span><br><span class="line">            res.push_back(now-&gt;val);</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;left!=<span class="literal">NULL</span>) q.push(now-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;right!=<span class="literal">NULL</span>) q.push(now-&gt;right);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="面试题32-II-从上到下打印二叉树-II"><a href="#面试题32-II-从上到下打印二叉树-II" class="headerlink" title="面试题32 - II. 从上到下打印二叉树 II"></a>面试题32 - II. 从上到下打印二叉树 II</h2><p><strong>Description</strong><br>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。<br><strong>Example</strong><br>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></tbody></table></figure>
<p>返回其层次遍历结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<p>提示：<br>节点总数 &lt;= 1000<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) {</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">int</span> front,end;</span><br><span class="line">        front=end=<span class="number">0</span>;</span><br><span class="line">        q.push_back(root);</span><br><span class="line">        end++;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">while</span>(front&lt;end){</span><br><span class="line">            TreeNode* now=q[front];</span><br><span class="line">            vec.push_back(now-&gt;val);</span><br><span class="line">            front++;</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;left!=<span class="literal">NULL</span>) q.push_back(now-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;right!=<span class="literal">NULL</span>) q.push_back(now-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(front==end){</span><br><span class="line">                res.push_back(vec);</span><br><span class="line">                vec.clear();</span><br><span class="line">                end=q.size();</span><br><span class="line">            }  </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="面试题32-III-从上到下打印二叉树-III"><a href="#面试题32-III-从上到下打印二叉树-III" class="headerlink" title="面试题32 - III. 从上到下打印二叉树 III"></a>面试题32 - III. 从上到下打印二叉树 III</h2><p><strong>Description</strong><br>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。<br><strong>Example</strong><br>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></tbody></table></figure>
<p>返回其层次遍历结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<p>提示：<br>节点总数 &lt;= 1000<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) {</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">int</span> front,end;</span><br><span class="line">        front=end=<span class="number">0</span>;</span><br><span class="line">        q.push_back(root);</span><br><span class="line">        end++;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">while</span>(front&lt;end){</span><br><span class="line">            TreeNode* now=q[front];</span><br><span class="line">            vec.push_back(now-&gt;val);</span><br><span class="line">            front++;</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;left!=<span class="literal">NULL</span>) q.push_back(now-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;right!=<span class="literal">NULL</span>) q.push_back(now-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(front==end){</span><br><span class="line">                res.push_back(vec);</span><br><span class="line">                vec.clear();</span><br><span class="line">                end=q.size();</span><br><span class="line">            }  </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>!=<span class="number">0</span>) reverse(res[i].begin(),res[i].end());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="面试题-16-19-水域大小"><a href="#面试题-16-19-水域大小" class="headerlink" title="面试题 16.19. 水域大小"></a>面试题 16.19. 水域大小</h2><p><strong>Description</strong><br>你有一个用于表示一片土地的整数矩阵land，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。<br><strong>Example</strong><br>示例：<br>输入：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [0,2,1,0],</span><br><span class="line">  [0,1,0,1],</span><br><span class="line">  [1,1,0,1],</span><br><span class="line">  [0,1,0,1]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<p>输出： [1,2,4]<br>提示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 &lt; len(land) &lt;= 1000</span><br><span class="line">0 &lt; len(land[i]) &lt;= 1000</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> steps[<span class="number">8</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">-1</span>,<span class="number">0</span>,</span><br><span class="line">        <span class="number">-1</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,<span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,<span class="number">-1</span>,</span><br><span class="line">        <span class="number">1</span>,<span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;rows&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;cols) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; land, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push({x,y});</span><br><span class="line">        land[x][y]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; now=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++){</span><br><span class="line">                <span class="keyword">int</span> new_x=now.first+steps[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> new_y=now.second+steps[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(judge(new_x, new_y)&amp;&amp;land[new_x][new_y]==<span class="number">0</span>){</span><br><span class="line">                    ans++;</span><br><span class="line">                    land[new_x][new_y]=<span class="number">-1</span>;</span><br><span class="line">                    q.push({new_x, new_y});</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pondSizes(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; land) {</span><br><span class="line">        rows=land.size();</span><br><span class="line">        cols=land[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++){</span><br><span class="line">                <span class="keyword">if</span>(land[i][j]==<span class="number">0</span>){</span><br><span class="line">                    res.push_back(bfs(land, i, j));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        sort(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="面试题-17-22-单词转换"><a href="#面试题-17-22-单词转换" class="headerlink" title="面试题 17.22. 单词转换"></a>面试题 17.22. 单词转换</h2><p><strong>Description</strong><br>给定字典中的两个词，长度相等。写一个方法，把一个词转换成另一个词， 但是一次只能改变一个字符。每一步得到的新词都必须能在字典中找到。<br>编写一个程序，返回一个可能的转换序列。如有多个可能的转换序列，你可以返回任何一个。<br><strong>Example</strong><br>示例 1:<br>输入:<br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br>输出:<br>[“hit”,”hot”,”dot”,”lot”,”log”,”cog”]</p>
<p>示例 2:<br>输入:<br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”]<br>输出: []</p>
<p>解释: endWord “cog” 不在字典中，所以不存在符合要求的转换序列。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> idx;</span><br><span class="line">        <span class="keyword">int</span> father;</span><br><span class="line">        <span class="keyword">int</span> q_idx;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> Idx, <span class="keyword">int</span> Father, <span class="keyword">int</span> Q_idx):idx(Idx),father(Father),q_idx(Q_idx){}</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; mQueue[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">int</span> qHead[<span class="number">2</span>],qTail[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> matching_qNo,matching_idx, matching_q_idx;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">DBFS</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span></span>{</span><br><span class="line">        vis[<span class="number">0</span>].resize(n, <span class="literal">false</span>);</span><br><span class="line">        vis[<span class="number">1</span>].resize(n ,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        mQueue[<span class="number">0</span>].resize(n);</span><br><span class="line">        mQueue[<span class="number">1</span>].resize(n);</span><br><span class="line"></span><br><span class="line">        qHead[<span class="number">0</span>]=qHead[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        qTail[<span class="number">0</span>]=qTail[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        mQueue[<span class="number">0</span>][qTail[<span class="number">0</span>]++]=Node(m[beginWord],<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">        mQueue[<span class="number">1</span>][qTail[<span class="number">1</span>]++]=Node(m[endWord],<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        vis[<span class="number">0</span>][m[beginWord]]=<span class="literal">true</span>;</span><br><span class="line">        vis[<span class="number">1</span>][m[endWord]]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(qHead[<span class="number">0</span>]!=qTail[<span class="number">0</span>]&amp;&amp;qHead[<span class="number">1</span>]!=qTail[<span class="number">1</span>]){</span><br><span class="line">            <span class="keyword">int</span> qNo=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(qHead[<span class="number">0</span>]==qTail[<span class="number">0</span>]) qNo=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(qHead[<span class="number">1</span>]==qTail[<span class="number">1</span>]) qNo=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(qTail[<span class="number">0</span>]-qHead[<span class="number">0</span>]&gt;qTail[<span class="number">1</span>]-qHead[<span class="number">1</span>]){ <span class="comment">//选择更新的队列</span></span><br><span class="line">                qNo=<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            Node node=mQueue[qNo][qHead[qNo]++];</span><br><span class="line">            <span class="built_in">string</span> str=wordList[node.idx]; <span class="comment">//队列头元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> ch=<span class="string">'a'</span>;ch&lt;=<span class="string">'z'</span>;ch++){</span><br><span class="line">                    <span class="built_in">string</span> tmp=str;</span><br><span class="line">                    tmp[i]=ch;</span><br><span class="line">                    <span class="keyword">if</span>(tmp==str) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(m.find(tmp)!=m.end()){</span><br><span class="line">                        <span class="keyword">if</span>(vis[<span class="number">1</span>-qNo][m[tmp]]){ <span class="comment">//在另一个队列中出现，说明找到路径</span></span><br><span class="line">                            matching_qNo=qNo;</span><br><span class="line">                            matching_idx=m[tmp];</span><br><span class="line">                            matching_q_idx=node.q_idx;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">if</span>(!vis[qNo][m[tmp]]){</span><br><span class="line">                            mQueue[qNo][qTail[qNo]]=Node(m[tmp],node.q_idx, qTail[qNo]);</span><br><span class="line">                            vis[qNo][m[tmp]]=<span class="literal">true</span>;</span><br><span class="line">                            qTail[qNo]++;</span><br><span class="line">                        }   </span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList, <span class="keyword">int</span> qNo, <span class="keyword">int</span> q_idx){</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(q_idx!=<span class="number">-1</span>){</span><br><span class="line">            <span class="built_in">string</span> str=wordList[mQueue[qNo][q_idx].idx];</span><br><span class="line">            res.push_back(str);</span><br><span class="line">            q_idx=mQueue[qNo][q_idx].father;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findLadders(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList) {     </span><br><span class="line">        wordList.push_back(beginWord);</span><br><span class="line">        n=wordList.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) m[wordList[i]]=i;</span><br><span class="line">        <span class="keyword">if</span>(m.find(endWord)==m.end()) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="keyword">bool</span> isMatch=DBFS(beginWord, endWord, wordList);</span><br><span class="line">        <span class="keyword">if</span>(!isMatch) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res1=path(wordList, matching_qNo, matching_q_idx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=qHead[<span class="number">1</span>-matching_qNo];i&lt;=qTail[<span class="number">1</span>-matching_qNo];i++){</span><br><span class="line">            Node node=mQueue[<span class="number">1</span>-matching_qNo][i];</span><br><span class="line">            <span class="keyword">if</span>(node.idx==matching_idx){</span><br><span class="line">                matching_q_idx=i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res2=path(wordList, <span class="number">1</span>-matching_qNo, matching_q_idx);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(matching_qNo==<span class="number">0</span>){</span><br><span class="line">            reverse(res1.begin(), res1.end());</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">string</span> x:res1) result.push_back(x);</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">string</span> x:res2) result.push_back(x);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            reverse(res2.begin(), res2.end());</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">string</span> x:res2) result.push_back(x);</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">string</span> x:res1) result.push_back(x);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="面试题-17-07-婴儿名字"><a href="#面试题-17-07-婴儿名字" class="headerlink" title="面试题 17.07. 婴儿名字"></a>面试题 17.07. 婴儿名字</h2><p><strong>Description</strong><br>每年，政府都会公布一万个最常见的婴儿名字和它们出现的频率，也就是同名婴儿的数量。有些名字有多种拼法，例如，John 和 Jon 本质上是相同的名字，但被当成了两个名字公布出来。给定两个列表，一个是名字及对应的频率，另一个是本质相同的名字对。设计一个算法打印出每个真实名字的实际频率。注意，如果 John 和 Jon 是相同的，并且 Jon 和 Johnny 相同，则 John 与 Johnny 也相同，即它们有传递和对称性。<br>在结果列表中，选择字典序最小的名字作为真实名字。<br><strong>Example</strong><br>示例：<br>输入：names = [“John(15)”,”Jon(12)”,”Chris(13)”,”Kris(4)”,”Christopher(19)”], synonyms = [“(Jon,John)”,”(John,Johnny)”,”(Chris,Kris)”,”(Chris,Christopher)”]<br>输出：[“John(27)”,”Chris(36)”]<br>提示：<br>names.length &lt;= 100000<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; resName;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; sToc,sToi;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(father[x]!=x){</span><br><span class="line">            father[x]=findFather(father[x]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> father[x];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionSet</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> fa=findFather(x);</span><br><span class="line">        <span class="keyword">int</span> fb=findFather(y);</span><br><span class="line">        <span class="keyword">if</span>(fa!=fb){</span><br><span class="line">            father[fa]=fb;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; processName(<span class="built_in">string</span> name){</span><br><span class="line">        <span class="keyword">int</span> left=name.find(<span class="string">'('</span>);</span><br><span class="line">        <span class="built_in">string</span> res=name.substr(<span class="number">0</span>,left);</span><br><span class="line">        <span class="keyword">int</span> right=name.find(<span class="string">')'</span>);</span><br><span class="line">        <span class="built_in">string</span> num=name.substr(left+<span class="number">1</span>,right-left<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;res&lt;&lt;" "&lt;&lt;num&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length();i++){</span><br><span class="line">            count=count*<span class="number">10</span>+num[i]-<span class="string">'0'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> {res, count};</span><br><span class="line">    }</span><br><span class="line">    pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; processSynonym(<span class="built_in">string</span> synonym){</span><br><span class="line">        <span class="keyword">int</span> idx=synonym.find(<span class="string">','</span>);</span><br><span class="line">        <span class="built_in">string</span> name1=synonym.substr(<span class="number">1</span>,idx<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">string</span> name2=synonym.substr(idx+<span class="number">1</span>, synonym.length()<span class="number">-1</span>-idx<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;name1&lt;&lt;" "&lt;&lt;name2&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span> {name1,name2};</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; a, pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; b)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> a.second&lt;b.second;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">processResult</span><span class="params">(<span class="built_in">string</span> name, <span class="keyword">int</span> count)</span></span>{</span><br><span class="line">        <span class="built_in">string</span> res=name+<span class="string">'('</span>;</span><br><span class="line">        <span class="built_in">string</span> num;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec;</span><br><span class="line">        <span class="keyword">while</span>(count!=<span class="number">0</span>){</span><br><span class="line">            vec.push_back(count%<span class="number">10</span>);</span><br><span class="line">            count/=<span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        reverse(vec.begin(), vec.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size();i++){</span><br><span class="line">            num+=vec[i]+<span class="string">'0'</span>;</span><br><span class="line">        }</span><br><span class="line">        num+=<span class="string">')'</span>;</span><br><span class="line">        <span class="keyword">return</span> res+num;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; trulyMostPopular(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; names, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; synonyms) {</span><br><span class="line">        <span class="keyword">int</span> n=names.size();</span><br><span class="line">        father.resize(n);</span><br><span class="line">        resName.resize(n, <span class="string">"-1"</span>);</span><br><span class="line">        result.resize(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) father[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; res=processName(names[i]);</span><br><span class="line">            sToc[res.first]=res.second;</span><br><span class="line">            sToi[res.first]=i;</span><br><span class="line">            names[i]=res.first;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> synonym:synonyms){</span><br><span class="line">            pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; res=processSynonym(synonym);</span><br><span class="line">            <span class="keyword">if</span>(sToi.find(res.first)==sToi.end()</span><br><span class="line">               ||sToi.find(res.second)==sToi.end()) <span class="keyword">continue</span>;</span><br><span class="line">            unionSet(sToi[res.first], sToi[res.second]);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;n;i++){</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;"father "&lt;&lt;findFather(father[i])&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> fa=findFather(sToi[names[i]]);</span><br><span class="line">            result[fa]+=sToc[names[i]];</span><br><span class="line">            <span class="keyword">if</span>(resName[fa]==<span class="string">"-1"</span>) resName[fa]=names[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(resName[fa]&gt;names[i]){</span><br><span class="line">                resName[fa]=names[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;n;i++){</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;resName[i]&lt;&lt;" "&lt;&lt;result[i]&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(resName[i]!=<span class="string">"-1"</span>){</span><br><span class="line">                vec.push_back({resName[i], result[i]});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        sort(vec.begin(), vec.end(), cmp);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size();i++){</span><br><span class="line">            res.push_back(processResult(vec[i].first, vec[i].second));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; sToi;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(father[x]!=x){</span><br><span class="line">            father[x]=findFather(father[x]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> father[x];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionSet</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; names,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> fa=findFather(x);</span><br><span class="line">        <span class="keyword">int</span> fb=findFather(y);</span><br><span class="line">        <span class="keyword">if</span>(fa!=fb){</span><br><span class="line">            <span class="keyword">if</span>(names[fa]&lt;names[fb]){</span><br><span class="line">                father[fb]=fa;</span><br><span class="line">                result[fa]+=result[fb];</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                father[fa]=fb;</span><br><span class="line">                result[fb]+=result[fa];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; processName(<span class="built_in">string</span> name){</span><br><span class="line">        <span class="keyword">int</span> left=name.find(<span class="string">'('</span>);</span><br><span class="line">        <span class="built_in">string</span> res=name.substr(<span class="number">0</span>,left);</span><br><span class="line">        <span class="keyword">int</span> right=name.find(<span class="string">')'</span>);</span><br><span class="line">        <span class="built_in">string</span> num=name.substr(left+<span class="number">1</span>,right-left<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;res&lt;&lt;" "&lt;&lt;num&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length();i++){</span><br><span class="line">            count=count*<span class="number">10</span>+num[i]-<span class="string">'0'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> {res, count};</span><br><span class="line">    }</span><br><span class="line">    pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; processSynonym(<span class="built_in">string</span> synonym){</span><br><span class="line">        <span class="keyword">int</span> idx=synonym.find(<span class="string">','</span>);</span><br><span class="line">        <span class="built_in">string</span> name1=synonym.substr(<span class="number">1</span>,idx<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">string</span> name2=synonym.substr(idx+<span class="number">1</span>, synonym.length()<span class="number">-1</span>-idx<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;name1&lt;&lt;" "&lt;&lt;name2&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span> {name1,name2};</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">processResult</span><span class="params">(<span class="built_in">string</span> name, <span class="keyword">int</span> count)</span></span>{</span><br><span class="line">        <span class="built_in">string</span> res=name+<span class="string">'('</span>;</span><br><span class="line">        <span class="built_in">string</span> num;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec;</span><br><span class="line">        <span class="keyword">while</span>(count!=<span class="number">0</span>){</span><br><span class="line">            vec.push_back(count%<span class="number">10</span>);</span><br><span class="line">            count/=<span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        reverse(vec.begin(), vec.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size();i++){</span><br><span class="line">            num+=vec[i]+<span class="string">'0'</span>;</span><br><span class="line">        }</span><br><span class="line">        num+=<span class="string">')'</span>;</span><br><span class="line">        <span class="keyword">return</span> res+num;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; trulyMostPopular(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; names, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; synonyms) {</span><br><span class="line">        <span class="keyword">int</span> n=names.size();</span><br><span class="line">        father.resize(n);</span><br><span class="line">        result.resize(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) father[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; res=processName(names[i]);</span><br><span class="line">            sToi[res.first]=i;</span><br><span class="line">            names[i]=res.first;</span><br><span class="line">            result[i]=res.second;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> synonym:synonyms){</span><br><span class="line">            pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; res=processSynonym(synonym);</span><br><span class="line">            <span class="keyword">if</span>(sToi.find(res.first)==sToi.end()</span><br><span class="line">               ||sToi.find(res.second)==sToi.end()) <span class="keyword">continue</span>;</span><br><span class="line">            unionSet(names, sToi[res.first], sToi[res.second]);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(father[i]!=i) <span class="keyword">continue</span>;</span><br><span class="line">            res.push_back(processResult(names[i], result[i]));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1391-检查网格中是否存在有效路径"><a href="#1391-检查网格中是否存在有效路径" class="headerlink" title="1391. 检查网格中是否存在有效路径"></a>1391. 检查网格中是否存在有效路径</h2><p><strong>Description</strong><br>给你一个 m x n 的网格 grid。网格里的每个单元都代表一条街道。grid[i][j] 的街道可以是：<br>1 表示连接左单元格和右单元格的街道。<br>2 表示连接上单元格和下单元格的街道。<br>3 表示连接左单元格和下单元格的街道。<br>4 表示连接右单元格和下单元格的街道。<br>5 表示连接左单元格和上单元格的街道。<br>6 表示连接右单元格和上单元格的街道。<br>你最开始从左上角的单元格 (0,0) 开始出发，网格中的「有效路径」是指从左上方的单元格 (0,0) 开始、一直到右下方的 (m-1,n-1) 结束的路径。该路径必须只沿着街道走。<br>注意：你不能变更街道。<br>如果网格中存在有效的路径，则返回 true，否则返回 false 。<br><strong>Example</strong><br>示例 1：<br>输入：grid = [[2,4,3],[6,5,2]]<br>输出：true<br>解释：如图所示，你可以从 (0, 0) 开始，访问网格中的所有单元格并到达 (m - 1, n - 1) 。</p>
<p>示例 2：<br>输入：grid = [[1,2,1],[1,2,1]]<br>输出：false<br>解释：如图所示，单元格 (0, 0) 上的街道没有与任何其他单元格上的街道相连，你只会停在 (0, 0) 处。</p>
<p>示例 3：<br>输入：grid = [[1,1,2]]<br>输出：false<br>解释：你会停在 (0, 1)，而且无法到达 (0, 2) 。</p>
<p>示例 4：<br>输入：grid = [[1,1,1,1,1,1,3]]<br>输出：true</p>
<p>示例 5：<br>输入：grid = [[2],[2],[2],[2],[2],[2],[6]]<br>输出：true</p>
<p>提示：<br>m == grid.length<br>n == grid[i].length<br>1 &lt;= m, n &lt;= 300<br>1 &lt;= grid[i][j] &lt;= 6<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> steps[<span class="number">12</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;m&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasValidPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>{</span><br><span class="line">        m=grid.size();</span><br><span class="line">        n=grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push({{<span class="number">0</span>, <span class="number">0</span>},grid[<span class="number">0</span>][<span class="number">0</span>]});</span><br><span class="line">        grid[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            pair&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; now=q.front();</span><br><span class="line">            <span class="keyword">int</span> x=now.first.first;</span><br><span class="line">            <span class="keyword">int</span> y=now.first.second;</span><br><span class="line">            <span class="keyword">int</span> s=now.second;</span><br><span class="line">            <span class="keyword">if</span>(x==m<span class="number">-1</span>&amp;&amp;y==n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*s<span class="number">-2</span>;i&lt;<span class="number">2</span>*s;i++){</span><br><span class="line">                <span class="keyword">int</span> new_x=x+steps[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> new_y=y+steps[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(judge(new_x, new_y)&amp;&amp;grid[new_x][new_y]!=<span class="number">-1</span>){</span><br><span class="line">                    <span class="keyword">if</span>((s==<span class="number">1</span>&amp;&amp;i==<span class="number">2</span>*s<span class="number">-2</span>&amp;&amp;</span><br><span class="line">                        (grid[new_x][new_y]==<span class="number">3</span></span><br><span class="line">                        ||grid[new_x][new_y]==<span class="number">5</span></span><br><span class="line">                        ||grid[new_x][new_y]==<span class="number">1</span>))</span><br><span class="line">                      ||(s==<span class="number">1</span>&amp;&amp;i==<span class="number">2</span>*s<span class="number">-1</span>&amp;&amp;</span><br><span class="line">                        (grid[new_x][new_y]==<span class="number">4</span></span><br><span class="line">                        ||grid[new_x][new_y]==<span class="number">6</span></span><br><span class="line">                        ||grid[new_x][new_y]==<span class="number">1</span>))</span><br><span class="line">                      ||(s==<span class="number">2</span>&amp;&amp;i==<span class="number">2</span>*s<span class="number">-2</span>&amp;&amp;</span><br><span class="line">                        (grid[new_x][new_y]==<span class="number">3</span></span><br><span class="line">                        ||grid[new_x][new_y]==<span class="number">4</span></span><br><span class="line">                        ||grid[new_x][new_y]==<span class="number">2</span>))</span><br><span class="line">                      ||(s==<span class="number">2</span>&amp;&amp;i==<span class="number">2</span>*s<span class="number">-1</span>&amp;&amp;</span><br><span class="line">                        (grid[new_x][new_y]==<span class="number">5</span></span><br><span class="line">                        ||grid[new_x][new_y]==<span class="number">6</span></span><br><span class="line">                        ||grid[new_x][new_y]==<span class="number">2</span>))</span><br><span class="line">                      ||(s==<span class="number">3</span>&amp;&amp;i==<span class="number">2</span>*s<span class="number">-2</span>&amp;&amp;</span><br><span class="line">                        (grid[new_x][new_y]==<span class="number">5</span></span><br><span class="line">                        ||grid[new_x][new_y]==<span class="number">6</span></span><br><span class="line">                        ||grid[new_x][new_y]==<span class="number">2</span>))</span><br><span class="line">                      ||(s==<span class="number">3</span>&amp;&amp;i==<span class="number">2</span>*s<span class="number">-1</span>&amp;&amp;</span><br><span class="line">                        (grid[new_x][new_y]==<span class="number">4</span></span><br><span class="line">                        ||grid[new_x][new_y]==<span class="number">6</span></span><br><span class="line">                        ||grid[new_x][new_y]==<span class="number">1</span>))</span><br><span class="line">                      ||(s==<span class="number">4</span>&amp;&amp;i==<span class="number">2</span>*s<span class="number">-2</span>&amp;&amp;</span><br><span class="line">                        (grid[new_x][new_y]==<span class="number">5</span></span><br><span class="line">                        ||grid[new_x][new_y]==<span class="number">6</span></span><br><span class="line">                        ||grid[new_x][new_y]==<span class="number">2</span>))</span><br><span class="line">                      ||(s==<span class="number">4</span>&amp;&amp;i==<span class="number">2</span>*s<span class="number">-1</span>&amp;&amp;</span><br><span class="line">                        (grid[new_x][new_y]==<span class="number">1</span></span><br><span class="line">                        ||grid[new_x][new_y]==<span class="number">3</span></span><br><span class="line">                        ||grid[new_x][new_y]==<span class="number">5</span>))</span><br><span class="line">                      ||(s==<span class="number">5</span>&amp;&amp;i==<span class="number">2</span>*s<span class="number">-2</span>&amp;&amp;</span><br><span class="line">                        (grid[new_x][new_y]==<span class="number">1</span></span><br><span class="line">                        ||grid[new_x][new_y]==<span class="number">4</span></span><br><span class="line">                        ||grid[new_x][new_y]==<span class="number">6</span>))</span><br><span class="line">                      ||(s==<span class="number">5</span>&amp;&amp;i==<span class="number">2</span>*s<span class="number">-1</span>&amp;&amp;</span><br><span class="line">                        (grid[new_x][new_y]==<span class="number">2</span></span><br><span class="line">                        ||grid[new_x][new_y]==<span class="number">3</span></span><br><span class="line">                        ||grid[new_x][new_y]==<span class="number">4</span>))</span><br><span class="line">                      ||(s==<span class="number">6</span>&amp;&amp;i==<span class="number">2</span>*s<span class="number">-2</span>&amp;&amp;</span><br><span class="line">                        (grid[new_x][new_y]==<span class="number">2</span></span><br><span class="line">                        ||grid[new_x][new_y]==<span class="number">3</span></span><br><span class="line">                        ||grid[new_x][new_y]==<span class="number">4</span>))</span><br><span class="line">                      ||(s==<span class="number">6</span>&amp;&amp;i==<span class="number">2</span>*s<span class="number">-1</span>&amp;&amp;</span><br><span class="line">                        (grid[new_x][new_y]==<span class="number">1</span></span><br><span class="line">                        ||grid[new_x][new_y]==<span class="number">3</span></span><br><span class="line">                        ||grid[new_x][new_y]==<span class="number">5</span>))){</span><br><span class="line">                            q.push({{new_x, new_y}, grid[new_x][new_y]});</span><br><span class="line">                            grid[new_x][new_y]=<span class="number">-1</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1282-用户分组"><a href="#1282-用户分组" class="headerlink" title="1282. 用户分组"></a>1282. 用户分组</h2><p><strong>Description</strong><br>有 n 位用户参加活动，他们的 ID 从 0 到 n - 1，每位用户都 恰好 属于某一用户组。给你一个长度为 n 的数组 groupSizes，其中包含每位用户所处的用户组的大小，请你返回用户分组情况（存在的用户组以及每个组中用户的 ID）。<br>你可以任何顺序返回解决方案，ID 的顺序也不受限制。此外，题目给出的数据保证至少存在一种解决方案。<br><strong>Example</strong><br>示例 1：<br>输入：groupSizes = [3,3,3,3,3,1,3]<br>输出：[[5],[0,1,2],[3,4,6]]<br>解释：<br>其他可能的解决方案有 [[2,1,6],[5],[0,4,3]] 和 [[5],[0,6,2],[4,3,1]]。</p>
<p>示例 2：<br>输入：groupSizes = [2,1,3,3,3,2]<br>输出：[[1],[0,5],[2,3,4]]</p>
<p>提示：<br>groupSizes.length == n<br>1 &lt;= n &lt;= 500<br>1 &lt;= groupSizes[i] &lt;= n<br><strong>Program</strong><br>粗分组后细分组</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; groupThePeople(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; groupSizes) {</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;groupSizes.size();i++){</span><br><span class="line">            m[groupSizes[i]].push_back(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(pair&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; now:m){</span><br><span class="line">            <span class="keyword">int</span> n=now.first;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec=now.second;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vec.size();j+=n){</span><br><span class="line">                result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(vec.begin()+j, vec.begin()+j+n));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1029-两地调度"><a href="#1029-两地调度" class="headerlink" title="1029. 两地调度"></a>1029. 两地调度</h2><p><strong>Description</strong><br>公司计划面试 2N 人。第 i 人飞往 A 市的费用为 costs[i][0]，飞往 B 市的费用为 costs[i][1]。<br>返回将每个人都飞到某座城市的最低费用，要求每个城市都有 N 人抵达。<br><strong>Example</strong><br>示例：<br>输入：[[10,20],[30,200],[400,50],[30,20]]<br>输出：110<br>解释：<br>第一个人去 A 市，费用为 10。<br>第二个人去 A 市，费用为 30。<br>第三个人去 B 市，费用为 50。<br>第四个人去 B 市，费用为 20。<br>最低总费用为 10 + 30 + 50 + 20 = 110，每个城市都有一半的人在面试。</p>
<p>提示：<br>1 &lt;= costs.length &lt;= 100<br>costs.length 为偶数<br>1 &lt;= costs[i][0], costs[i][1] &lt;= 1000<br><strong>Program</strong><br>$$min_{\lbrace x_i\rbrace}\sum_{i=1}^{2N}x_i c_{i_0} + \sum_{i=1}^{2N}(1-x_i)c_{i_1},\\<br>\implies min_{\lbrace x_i \rbrace}\sum_{i=1}^{2N}c_{i_1}+\sum_{i=1}^{2N}x_i(c_{i_0}-c_{i_1})\\<br>s.t. \sum_{i=1}^{2N}x_i = N, x_i \in \lbrace 0,1\rbrace, i=1,2,…,2N.<br>$$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">twoCitySchedCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; costs)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">int</span> n=costs.size()/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n;i++){</span><br><span class="line">            ans+=costs[i][<span class="number">1</span>];</span><br><span class="line">            vec.push_back(costs[i][<span class="number">0</span>]-costs[i][<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        sort(vec.begin(), vec.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            ans+=vec[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1046-最后一块石头的重量"><a href="#1046-最后一块石头的重量" class="headerlink" title="1046. 最后一块石头的重量"></a>1046. 最后一块石头的重量</h2><p><strong>Description</strong><br>有一堆石头，每块石头的重量都是正整数。<br>每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：<br>如果 x == y，那么两块石头都会被完全粉碎；<br>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。<br>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。<br><strong>Example</strong><br>示例：<br>输入：[2,7,4,1,8,1]<br>输出：1<br>解释：<br>先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，<br>再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，<br>接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，<br>最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。</p>
<p>提示：<br>1 &lt;= stones.length &lt;= 30<br>1 &lt;= stones[i] &lt;= 1000<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Cmp</span>{</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> <span class="keyword">const</span></span>{</span><br><span class="line">            <span class="keyword">return</span> a&lt;b;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>{</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, Cmp&gt; pq(stones.begin(), stones.end());</span><br><span class="line">        <span class="keyword">while</span>(pq.size()&gt;<span class="number">1</span>){</span><br><span class="line">            <span class="keyword">int</span> a=pq.top(); pq.pop();</span><br><span class="line">            <span class="keyword">int</span> b=pq.top(); pq.pop();</span><br><span class="line">            <span class="keyword">if</span>(a!=b){</span><br><span class="line">                <span class="keyword">if</span>(a&gt;b) pq.push(a-b);</span><br><span class="line">                <span class="keyword">else</span> pq.push(b<span class="number">-1</span>);</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(pq.size()==<span class="number">0</span>) pq.push(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> res=pq.top(); pq.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1296-划分数组为连续数字的集合"><a href="#1296-划分数组为连续数字的集合" class="headerlink" title="1296. 划分数组为连续数字的集合"></a>1296. 划分数组为连续数字的集合</h2><p><strong>Description</strong><br>给你一个整数数组 nums 和一个正整数 k，请你判断是否可以把这个数组划分成一些由 k 个连续数字组成的集合。<br>如果可以，请返回 True；否则，返回 False。<br><strong>Example</strong><br>示例 1：<br>输入：nums = [1,2,3,3,4,4,5,6], k = 4<br>输出：true<br>解释：数组可以分成 [1,2,3,4] 和 [3,4,5,6]。</p>
<p>示例 2：<br>输入：nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3<br>输出：true<br>解释：数组可以分成 [1,2,3] , [2,3,4] , [3,4,5] 和 [9,10,11]。</p>
<p>示例 3：<br>输入：nums = [3,3,2,2,1,1], k = 3<br>输出：true</p>
<p>示例 4：<br>输入：nums = [1,2,3,4], k = 3<br>输出：false<br>解释：数组不能分成几个大小为 3 的子数组。</p>
<p>提示：<br>1 &lt;= nums.length &lt;= 10^5<br>1 &lt;= nums[i] &lt;= 10^9<br>1 &lt;= k &lt;= nums.length<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPossibleDivide</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++) m[nums[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it=m.begin();it!=m.end();it++){</span><br><span class="line">            <span class="keyword">int</span> num=it-&gt;first;</span><br><span class="line">            <span class="keyword">int</span> count=it-&gt;second;</span><br><span class="line">            it-&gt;second-=count;</span><br><span class="line">            <span class="keyword">if</span>(count&gt;<span class="number">0</span>){</span><br><span class="line">                <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator tmpIt = next(it);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++, tmpIt++){</span><br><span class="line">                    <span class="keyword">if</span>(tmpIt!=m.end()&amp;&amp;tmpIt-&gt;first==num+i&amp;&amp;tmpIt-&gt;second&gt;=count){</span><br><span class="line">                        tmpIt-&gt;second-=count;</span><br><span class="line">                    }<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1053-交换一次的先前排列"><a href="#1053-交换一次的先前排列" class="headerlink" title="1053. 交换一次的先前排列"></a>1053. 交换一次的先前排列</h2><p><strong>Description</strong><br>给你一个正整数的数组 A（其中的元素不一定完全不同），请你返回可在 一次交换（交换两数字 A[i] 和 A[j] 的位置）后得到的、按字典序排列小于 A 的最大可能排列。<br>如果无法这么操作，就请返回原数组。<br><strong>Example</strong><br>示例 1：<br>输入：[3,2,1]<br>输出：[3,1,2]<br>解释：<br>交换 2 和 1</p>
<p>示例 2：<br>输入：[1,1,5]<br>输出：[1,1,5]<br>解释：<br>这已经是最小排列</p>
<p>示例 3：<br>输入：[1,9,4,6,7]<br>输出：[1,7,4,6,9]<br>解释：<br>交换 9 和 7</p>
<p>示例 4：<br>输入：[3,1,1,3]<br>输出：[1,3,1,3]<br>解释：<br>交换 1 和 3</p>
<p>提示：<br>1 &lt;= A.length &lt;= 10000<br>1 &lt;= A[i] &lt;= 10000<br><strong>Program</strong><br>从前往后查找，发现数据变小时记录下来left和right，后续如果有数据变大并且不大于left，更新right即可。示意如下：<br><img src="/assets/img/algorithm/1053_example.png" alt="image"></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prevPermOpt1(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) {</span><br><span class="line">        <span class="keyword">int</span> left, right;</span><br><span class="line">        left=right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size()<span class="number">-1</span>;i++){</span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;A[i+<span class="number">1</span>]){</span><br><span class="line">                left=i;</span><br><span class="line">                right=i+<span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(A[i]&lt;A[i+<span class="number">1</span>]&amp;&amp;A[i+<span class="number">1</span>]&lt;A[left]){</span><br><span class="line">                right=i+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        swap(A[left], A[right]);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="621-任务调度器"><a href="#621-任务调度器" class="headerlink" title="621. 任务调度器"></a>621. 任务调度器</h2><p><strong>Description</strong><br>给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。<br>然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。<br>你需要计算完成所有任务所需要的最短时间。<br><strong>Example</strong><br>示例 ：<br>输入：tasks = [“A”,”A”,”A”,”B”,”B”,”B”], n = 2<br>输出：8<br>解释：A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B.<br>     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。</p>
<p>提示：<br>任务的总个数为 [1, 10000]。<br>n 的取值范围为 [0, 100]。<br><strong>Program</strong><br><strong>①排序</strong><br>数量较多的优先执行，否则后面会出现大量待命状态。<br>考虑到长度为n的冷却时间，故同种任务在n+1个单位时间内只能出现一次。故每n+1单位时间安排任务队列(当然也可以每个单位时间安排满足要求的任务执行，但时间复杂度更高，且实现复杂)，需要注意任务都执行完了的最后多余的待命状态。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; tasks, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:tasks) vec[ch-<span class="string">'A'</span>]++;</span><br><span class="line">        sort(vec.begin(), vec.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">int</span> time=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nComplete=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nCount=tasks.size();</span><br><span class="line">        <span class="keyword">while</span>(vec[<span class="number">0</span>]&gt;<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;n+<span class="number">1</span>&amp;&amp;nComplete&lt;nCount){</span><br><span class="line">                <span class="keyword">if</span>(i&lt;<span class="number">26</span>&amp;&amp;vec[i]&gt;<span class="number">0</span>){</span><br><span class="line">                    vec[i]--;</span><br><span class="line">                    nComplete++;</span><br><span class="line">                }</span><br><span class="line">                time++;</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            sort(vec.begin(), vec.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>②桶排序</strong><br>建立大小为n+1的桶子，个数为任务数量最多的那个任务，比如下图，等待时间n=2，A任务个数6个，我们建立6个桶子，每个容量为3：<br>我们可以把一个桶子看作一轮任务<br><img src="/assets/img/algorithm/621_example_1.png" alt="image"><br>1.先从最简单的情况看起，现在就算没有其他任务，我们完成任务A所需的时间应该是<code>(6-1)*3+1=16</code>，因为最后一个桶子，不存在等待时间。<br><img src="/assets/img/algorithm/621_example_2.png" alt="image"><br>2.接下来我们添加些其他任务<br><img src="/assets/img/algorithm/621_example_3.png" alt="image"><br>可以看到C其实并没有对总体时间产生影响，因为它被安排在了其他任务的冷却期间；<br>而B和A数量相同，这会导致最后一个桶子中，我们需要多执行一次B任务，现在我们需要的时间是‘6-1）<em>3+2=17<br>*</em>前面两种情况，总结起来：总排队时间 = (桶个数 - 1) * (n + 1) + 最后一桶的任务数**<br>3.当冷却时间短，任务种类很多时<br><img src="/assets/img/algorithm/621_example_4.png" alt="image"><br>比如上图，我们刚好排满了任务，此时所需时间还是17，如果现在我还要执行两次任务F，该怎么安排呢？<br><img src="/assets/img/algorithm/621_example_5.png" alt="image"><br>此时我们可以临时扩充某些桶子的大小，插进任务F，对比一下插入前后的任务执行情况：<br>插入前：ABC | ABC | ABD | ABD | ABD |AB<br>插入后：ABCF | ABCF | ABD | ABD | ABD |AB<br>我们在第一个、第二个桶子里插入了任务F，不难发现无论再继续插入多少任务，我们都可以类似处理，而且新插入元素肯定满足冷却要求</p>
<p><strong>继续思考一下，这种情况下其实每个任务之间都不存在空余时间，冷却时间已经被完全填满了。<br>也就是说，我们执行任务所需的时间，就是任务的数量</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这样剩下就很好处理了，我们只需要算两个数：</span><br><span class="line">1.记录最大任务数量N，看一下任务数量并列最多的任务有多少个，即最后一个桶子的任务数X，计算NUM1=（N-1）*（n+1）+x</span><br><span class="line">2.NUM2=tasks.size()</span><br><span class="line">输出其中较大值即可</span><br><span class="line">因为存在空闲时间时肯定是NUM1大，不存在空闲时间时肯定是NUM2&gt;=NUM1</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; tasks, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:tasks) vec[ch-<span class="string">'A'</span>]++;</span><br><span class="line">        sort(vec.begin(), vec.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">int</span> time=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nCount=tasks.size();</span><br><span class="line">        time=(vec[<span class="number">0</span>]<span class="number">-1</span>)*(n+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">26</span>;i++){</span><br><span class="line">            <span class="keyword">if</span>(vec[i]==vec[<span class="number">0</span>]) time++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max(time, nCount);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1090-受标签影响的最大值"><a href="#1090-受标签影响的最大值" class="headerlink" title="1090. 受标签影响的最大值"></a>1090. 受标签影响的最大值</h2><p><strong>Description</strong><br>我们有一个项的集合，其中第 i 项的值为 values[i]，标签为 labels[i]。<br>我们从这些项中选出一个子集 S，这样一来：<br>|S| &lt;= num_wanted<br>对于任意的标签 L，子集 S 中标签为 L 的项的数目总满足 &lt;= use_limit。<br>返回子集 S 的最大可能的 和。<br><strong>Example</strong><br>示例 1：<br>输入：values = [5,4,3,2,1], labels = [1,1,2,2,3], num_wanted = 3, use_limit = 1<br>输出：9<br>解释：选出的子集是第一项，第三项和第五项。</p>
<p>示例 2：<br>输入：values = [5,4,3,2,1], labels = [1,3,3,3,2], num_wanted = 3, use_limit = 2<br>输出：12<br>解释：选出的子集是第一项，第二项和第三项。</p>
<p>示例 3：<br>输入：values = [9,8,8,7,6], labels = [0,0,0,1,1], num_wanted = 3, use_limit = 1<br>输出：16<br>解释：选出的子集是第一项和第四项。</p>
<p>示例 4：<br>输入：values = [9,8,8,7,6], labels = [0,0,0,1,1], num_wanted = 3, use_limit = 2<br>输出：24<br>解释：选出的子集是第一项，第二项和第四项。</p>
<p>提示：<br>1 &lt;= values.length == labels.length &lt;= 20000<br>0 &lt;= values[i], labels[i] &lt;= 20000<br>1 &lt;= num_wanted, use_limit &lt;= values.length<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; b)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> a.first&gt;b.first;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestValsFromLabels</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; values, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; labels, <span class="keyword">int</span> num_wanted, <span class="keyword">int</span> use_limit)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;values.size();i++) vec.push_back({values[i], labels[i]});</span><br><span class="line">        sort(vec.begin(), vec.end(), cmp);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> nCount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(nCount==num_wanted) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> value=vec[i].first;</span><br><span class="line">            <span class="keyword">int</span> label=vec[i].second;</span><br><span class="line">            <span class="keyword">if</span>(m[label]&lt;use_limit){</span><br><span class="line">                ans+=value;</span><br><span class="line">                m[label]++;</span><br><span class="line">                nCount++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1094-拼车"><a href="#1094-拼车" class="headerlink" title="1094. 拼车"></a>1094. 拼车</h2><p><strong>Description</strong><br>假设你是一位顺风车司机，车上最初有 capacity 个空座位可以用来载客。由于道路的限制，车 只能 向一个方向行驶（也就是说，不允许掉头或改变方向，你可以将其想象为一个向量）。<br>这儿有一份乘客行程计划表 trips[][]，其中 trips[i] = [num_passengers, start_location, end_location] 包含了第 i 组乘客的行程信息：<br>必须接送的乘客数量；<br>乘客的上车地点；<br>以及乘客的下车地点。<br>这些给出的地点位置是从你的 初始 出发位置向前行驶到这些地点所需的距离（它们一定在你的行驶方向上）。</p>
<p>请你根据给出的行程计划表和车子的座位数，来判断你的车是否可以顺利完成接送所用乘客的任务（当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false）。<br><strong>Example</strong><br>示例 1：<br>输入：trips = [[2,1,5],[3,3,7]], capacity = 4<br>输出：false</p>
<p>示例 2：<br>输入：trips = [[2,1,5],[3,3,7]], capacity = 5<br>输出：true</p>
<p>示例 3：<br>输入：trips = [[2,1,5],[3,5,7]], capacity = 3<br>输出：true</p>
<p>示例 4：<br>输入：trips = [[3,2,7],[3,7,9],[8,3,9]], capacity = 11<br>输出：true</p>
<p>提示：<br>你可以假设乘客会自觉遵守 “先下后上” 的良好素质<br>trips.length &lt;= 1000<br>trips[i].length == 3<br>1 &lt;= trips[i][0] &lt;= 100<br>0 &lt;= trips[i][1] &lt; trips[i][2] &lt;= 1000<br>1 &lt;= capacity &lt;= 100000<br><strong>Program</strong><br>路程长度就1000，<br>思路就是根据每个开始和结束重新划分trips，然后合并相等的trip。但是题中路径最长就1000，所以开数组就可以了。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">carPooling</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; trips, <span class="keyword">int</span> capacity)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">1001</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;trips.size();i++){</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp=trips[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> s=tmp[<span class="number">1</span>]+<span class="number">1</span>;s&lt;=tmp[<span class="number">2</span>];s++){</span><br><span class="line">                vec[s]+=tmp[<span class="number">0</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1001</span>;i++){</span><br><span class="line">            <span class="keyword">if</span>(vec[i]&gt;capacity) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>进一步优化，最直接的想法就是模拟每个trip上下车，但是怎么记录车容量的变化是个问题。比如一个trip上车车容减小，瞎扯车容增大，而另一个trip同理，但是两个trip可能有重叠部分，如果按照trip的起始增序排列，遍历trip，就无法做到时序的上下车过程。也就是说模拟的话，需要按时序进行每个上下车过程，但每个trip的上下车时刻不是严格不重叠，有交叉，那么如何通过遍历trips模拟该过程？<strong>见代码，只需考虑上下车时刻车容量的变化就能够免去重叠的问题</strong>。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">carPooling</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; trips, <span class="keyword">int</span> capacity)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nowCapacity(<span class="number">1001</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;trips.size();i++){</span><br><span class="line">            nowCapacity[trips[i][<span class="number">1</span>]]-=trips[i][<span class="number">0</span>];  <span class="comment">//上车容量减小</span></span><br><span class="line">            nowCapacity[trips[i][<span class="number">2</span>]]+=trips[i][<span class="number">0</span>];  <span class="comment">//下车容量增大</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1001</span>;i++){</span><br><span class="line">            capacity+=nowCapacity[i];</span><br><span class="line">            <span class="keyword">if</span>(capacity&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="649-Dota2-参议院"><a href="#649-Dota2-参议院" class="headerlink" title="649. Dota2 参议院"></a>649. Dota2 参议院</h2><p><strong>Description</strong><br>Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇)<br>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：<br>1.禁止一名参议员的权利：</p>
<ul>
<li>参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。</li>
</ul>
<p>2.宣布胜利：</p>
<ul>
<li>如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。</li>
</ul>
<p>给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。<br>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。<br>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 Radiant 或 Dire。<br><strong>Example</strong><br>示例 1:<br>输入: “RD”<br>输出: “Radiant”<br>解释:  第一个参议员来自  Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人</p>
<p>示例 2:<br>输入: “RDD”<br>输出: “Dire”<br>解释:<br>第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利<br>第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止<br>第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利<br>因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利</p>
<p>注意:<br>给定字符串的长度在 [1, 10,000] 之间.<br><strong>Program</strong><br><strong>模拟</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">predictPartyVictory</span><span class="params">(<span class="built_in">string</span> senate)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; pass(senate.length(), <span class="literal">false</span>); <span class="comment">//是否被跳过</span></span><br><span class="line">        <span class="keyword">int</span> nR,nD;</span><br><span class="line">        nR=nD=<span class="number">0</span>;  <span class="comment">//剩余R/D数量</span></span><br><span class="line">        <span class="keyword">int</span> nBan_R, nBan_D;</span><br><span class="line">        nBan_R=nBan_D=<span class="number">0</span>;  <span class="comment">//当前被禁止的R/D数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:senate){</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">'R'</span>) nR++;</span><br><span class="line">            <span class="keyword">else</span> nD++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//cout&lt;&lt;nR&lt;&lt;" "&lt;&lt;nD&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//cout&lt;&lt;"idx: idx R D"&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(nR!=<span class="number">0</span>&amp;&amp;nD!=<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">if</span>(pass[idx]){</span><br><span class="line">                idx++;</span><br><span class="line">                <span class="keyword">if</span>(idx==senate.length()) idx=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(senate[idx]==<span class="string">'R'</span>){</span><br><span class="line">                <span class="keyword">if</span>(nBan_R&gt;<span class="number">0</span>){</span><br><span class="line">                    pass[idx]=<span class="literal">true</span>;</span><br><span class="line">                    nBan_R--;</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    nBan_D++;</span><br><span class="line">                    nD--;</span><br><span class="line">                }</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">if</span>(nBan_D&gt;<span class="number">0</span>){</span><br><span class="line">                    pass[idx]=<span class="literal">true</span>;</span><br><span class="line">                    nBan_D--;</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    nBan_R++;</span><br><span class="line">                    nR--;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//cout&lt;&lt;"idx: "&lt;&lt;idx&lt;&lt;" "&lt;&lt;nR&lt;&lt;" "&lt;&lt;nD&lt;&lt;endl;</span></span><br><span class="line">            idx++;</span><br><span class="line">            <span class="keyword">if</span>(idx==senate.length()) idx=<span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> (nR&gt;<span class="number">0</span>)?<span class="string">"Radiant"</span>:<span class="string">"Dire"</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>贪心</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">predictPartyVictory</span><span class="params">(<span class="built_in">string</span> senate)</span> </span>{</span><br><span class="line">	<span class="keyword">bool</span> R = <span class="literal">true</span>, D = <span class="literal">true</span>;<span class="comment">//R,D标记senate中是否还有R,D</span></span><br><span class="line">	<span class="keyword">int</span> person = <span class="number">0</span>;<span class="comment">//标记变量person,当person&gt;0时，表示R方可以淘汰D方；person&lt;0时，表示D方可以淘汰R方。</span></span><br><span class="line">	<span class="keyword">while</span> (R&amp;&amp;D)<span class="comment">//R\D标记本轮循环中，senate是否存在R\D.（且是淘汰前的序列中）</span></span><br><span class="line">	{</span><br><span class="line">		R = <span class="literal">false</span>;</span><br><span class="line">		D = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;senate.size();i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (senate[i] == <span class="string">'R'</span>)</span><br><span class="line">			{</span><br><span class="line">				R = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">if</span> (person &lt; <span class="number">0</span>)<span class="comment">//D方有权淘汰R方</span></span><br><span class="line">					senate[i] = <span class="string">'0'</span>;</span><br><span class="line">				person++;<span class="comment">//无论有没有D淘汰掉R，person都++。cause有淘汰时，D的淘汰权用掉一次，person++；没有淘汰时，R的淘汰权增加1，person++.</span></span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (senate[i] == <span class="string">'D'</span>)</span><br><span class="line">			{</span><br><span class="line">				D = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">if</span> (person &gt; <span class="number">0</span>)</span><br><span class="line">					senate[i] = <span class="string">'0'</span>;</span><br><span class="line">				person--;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> person &gt; <span class="number">0</span> ? <span class="string">"Radiant"</span> : <span class="string">"Dire"</span>;</span><br><span class="line">}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a>134. 加油站</h2><p><strong>Description</strong><br>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。<br>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。<br>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p>说明:<br>如果题目有解，该答案即为唯一答案。<br>输入数组均为非空数组，且长度相同。<br>输入数组中的元素均为非负数。<br><strong>Example</strong><br>示例 1:<br>输入:<br>gas  = [1,2,3,4,5]<br>cost = [3,4,5,1,2]<br>输出: 3<br>解释:<br>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油<br>开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油<br>开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油<br>开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油<br>开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油<br>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。<br>因此，3 可为起始索引。</p>
<p>示例 2:<br>输入:<br>gas  = [2,3,4]<br>cost = [3,4,3]<br>输出: -1</p>
<p>解释:<br>你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。<br>我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油<br>开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油<br>开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油<br>你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。<br>因此，无论怎样，你都不可能绕环路行驶一周。<br><strong>Program</strong><br>很直观的思路就是gas[i]-cost[i]，求和后若大于0则有解，否则无解。<br>那么如何判断出发点呢？<br>用res记录从i=0开始的剩余油量，最后如果res大于0则有解，否则无解。<br>若最后res大于0，这里讨论res折线有小于0的情况(全程大于0全都是解，然而题目说了只有唯一解，那么必出现过程中res小于0的情况)，那么从过程中出现的<br>res最低点到最后res大于0，<strong>说明过程中的res最低点对应的下一个索引值开始到最后能够抵消res的最大负值！</strong><br><img src="/assets/img/algorithm/134_example_1.png" alt="image"><br>柱状图<br>绿色：可添加的汽油 gas[i]<br>橙色：消耗的汽油 cost[i]</p>
<p>折线图：<br>虚线（蓝色）：当前加油站的可用值<br>实线（黑色）：从0开始的总剩余汽油量</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len=gas.size();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minRes=inf;</span><br><span class="line">        <span class="keyword">int</span> minIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++){</span><br><span class="line">            res+=gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span>(res&lt;minRes){</span><br><span class="line">                minRes=res;</span><br><span class="line">                minIndex=i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res&gt;=<span class="number">0</span>?(minIndex+<span class="number">1</span>)%len:<span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="659-分割数组为连续子序列"><a href="#659-分割数组为连续子序列" class="headerlink" title="659. 分割数组为连续子序列"></a>659. 分割数组为连续子序列</h2><p><strong>Description</strong><br>输入一个按升序排序的整数数组（可能包含重复数字），你需要将它们分割成几个子序列，其中每个子序列至少包含三个连续整数。返回你是否能做出这样的分割？<br><strong>Example</strong><br>示例 1：<br>输入: [1,2,3,3,4,5]<br>输出: True<br>解释:<br>你可以分割出这样两个连续子序列 :<br>1, 2, 3<br>3, 4, 5</p>
<p>示例 2：<br>输入: [1,2,3,3,4,4,5,5]<br>输出: True<br>解释:<br>你可以分割出这样两个连续子序列 :<br>1, 2, 3, 4, 5<br>3, 4, 5</p>
<p>示例 3：<br>输入: [1,2,3,4,4,5]<br>输出: False</p>
<p>提示：<br>输入的数组长度范围为 [1, 10000]<br><strong>Program</strong><br><strong>贪心</strong><br>我们把 3 个或更多的连续数字称作 chain。<br>我们从左到右考虑每一个数字 x，如果 x 可以被添加到当前的 chain 中，我们将 x 添加到 chain 中，这一定会比创建一个新的 chain 要更好。<br>为什么呢？如果我们以 x 为起点新创建一个 chain ，这条新创建更短的链是可以接在之前的链上的，这可能会帮助我们避免创建一个从 x 开始的长度为 1 或者 2 的短链。<br>算法：<br>我们将每个数字的出现次数统计好，<strong>记 tails[x] 是恰好在 x 之前结束的链的数目。</strong><br>现在我们逐一考虑每个数字，如果有一个链恰好在 x 之前结束，我们将 x 加入此链中。否则，如果我们可以新建立一条链就新建。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPossible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m, tail;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)m[x]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums){</span><br><span class="line">            <span class="keyword">if</span>(m[x]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tail[x]&gt;<span class="number">0</span>){   <span class="comment">//之前有链，x加在其之后</span></span><br><span class="line">                m[x]--;</span><br><span class="line">                tail[x]--;</span><br><span class="line">                tail[x+<span class="number">1</span>]++;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(m[x+<span class="number">1</span>]&gt;<span class="number">0</span>&amp;&amp;m[x+<span class="number">2</span>]&gt;<span class="number">0</span>){ <span class="comment">//之前没链，重新新建一条链。</span></span><br><span class="line">                m[x]--;</span><br><span class="line">                m[x+<span class="number">1</span>]--;</span><br><span class="line">                m[x+<span class="number">2</span>]--;</span><br><span class="line">                tail[x+<span class="number">3</span>]++;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1111-有效括号的嵌套深度"><a href="#1111-有效括号的嵌套深度" class="headerlink" title="1111. 有效括号的嵌套深度"></a>1111. 有效括号的嵌套深度</h2><p><strong>Description</strong><br>有效括号字符串 定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「有效括号字符串」部分。<br>嵌套深度 depth 定义：即有效括号字符串嵌套的层数，depth(A) 表示有效括号字符串 A 的嵌套深度。详情参见题末「嵌套深度」部分。<br><img src="/assets/img/algorithm/1111_example_1.png" alt="image"><br>给你一个「有效括号字符串」 seq，请你将其分成两个不相交的有效括号字符串，A 和 B，并使这两个字符串的深度最小。</p>
<p>不相交：每个 seq[i] 只能分给 A 和 B 二者中的一个，不能既属于 A 也属于 B 。<br>A 或 B 中的元素在原字符串中可以不连续。<br>A.length + B.length = seq.length<br>深度最小：max(depth(A), depth(B)) 的可能取值最小。<br>划分方案用一个长度为 seq.length 的答案数组 answer 表示，编码规则如下：</p>
<p>answer[i] = 0，seq[i] 分给 A 。<br>answer[i] = 1，seq[i] 分给 B 。<br>如果存在多个满足要求的答案，只需返回其中任意 一个 即可。</p>
<p><strong>Example</strong><br>示例 1：<br>输入：seq = “(()())”<br>输出：[0,1,1,1,1,0]</p>
<p>示例 2：<br>输入：seq = “()(())()”<br>输出：[0,0,0,1,1,0,1,1]<br>解释：本示例答案不唯一。<br>按此输出 A = “()()”, B = “()()”, max(depth(A), depth(B)) = 1，它们的深度最小。<br>像 [1,1,1,0,0,1,1,1]，也是正确结果，其中 A = “()()()”, B = “()”, max(depth(A), depth(B)) = 1 。</p>
<p>提示：<br>$1 &lt; seq.size &lt;= 10000$</p>
<p><strong>有效括号字符串：</strong><br>仅由 “(“ 和 “)” 构成的字符串，对于每个左括号，都能找到与之对应的右括号，反之亦然。<br>下述几种情况同样属于有效括号字符串：</p>
<ol>
<li>空字符串</li>
<li>连接，可以记作 AB（A 与 B 连接），其中 A 和 B 都是有效括号字符串</li>
<li>嵌套，可以记作 (A)，其中 A 是有效括号字符串<br><strong>嵌套深度：</strong><br>类似地，我们可以定义任意有效括号字符串 s 的 嵌套深度 depth(S)：</li>
<li>s 为空时，depth(“”) = 0</li>
<li>s 为 A 与 B 连接时，depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是有效括号字符串</li>
<li>s 为嵌套情况，depth(“(“ + A + “)”) = 1 + depth(A)，其中 A 是有效括号字符串<br>例如：””，”()()”，和 “()(()())” 都是有效括号字符串，嵌套深度分别为 0，1，2，而 “)(“ 和 “(()” 都不是有效括号字符串。<br><strong>Program</strong><br>思路：栈 创建一个栈，遍历seq，遇到’(‘入栈，遇到’)’弹出。在这样的规则下，’(‘入栈时栈的深度就对应着当前括号对的嵌套深度深度。将奇数深度的括号分成一组，将偶数深度的括号分成一组，分别用0和1标记即可。<br>例如：<br>括号序列   ( ( ) ( ( ) ) ( ) )<br>下标编号   0 1 2 3 4 5 6 7 8 9<br>嵌套深度   1 2 2 2 3 3 2 2 2 1<br>将奇数深度的分一组用0标记，将偶数深度的括号分一组用1标记。<br>标记结果   0 1 1 1 0 0 1 1 1 0</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxDepthAfterSplit(<span class="built_in">string</span> seq) {</span><br><span class="line">        <span class="keyword">int</span> n=seq.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n);</span><br><span class="line">        <span class="keyword">int</span> depth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(seq[i]==<span class="string">'('</span>){  <span class="comment">//入栈</span></span><br><span class="line">                res[i]=++depth%<span class="number">2</span>;</span><br><span class="line">            }<span class="keyword">else</span>{    <span class="comment">//出栈</span></span><br><span class="line">                res[i]=depth--%<span class="number">2</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1338-数组大小减半"><a href="#1338-数组大小减半" class="headerlink" title="1338. 数组大小减半"></a>1338. 数组大小减半</h2><p><strong>Description</strong><br>给你一个整数数组 arr。你可以从中选出一个整数集合，并删除这些整数在数组中的每次出现。<br>返回 至少 能删除数组中的一半整数的整数集合的最小大小。<br><strong>Example</strong><br>示例 1：<br>输入：arr = [3,3,3,3,5,5,5,2,2,7]<br>输出：2<br>解释：选择 {3,7} 使得结果数组为 [5,5,5,2,2]、长度为 5（原数组长度的一半）。<br>大小为 2 的可行集合有 {3,5},{3,2},{5,2}。<br>选择 {2,7} 是不可行的，它的结果数组为 [3,3,3,3,5,5,5]，新数组长度大于原数组的二分之一。</p>
<p>示例 2：<br>输入：arr = [7,7,7,7,7,7]<br>输出：1<br>解释：我们只能选择集合 {7}，结果数组为空。</p>
<p>示例 3：<br>输入：arr = [1,9]<br>输出：1</p>
<p>示例 4：<br>输入：arr = [1000,1000,3,7]<br>输出：1</p>
<p>示例 5：<br>输入：arr = [1,2,3,4,5,6,7,8,9,10]<br>输出：5</p>
<p>提示：<br>1 &lt;= arr.length &lt;= 10^5<br>arr.length 为偶数<br>1 &lt;= arr[i] &lt;= 10^5<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSetSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>{</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) m[arr[i]]++;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">for</span>(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; x:m) vec.push_back(x.second);</span><br><span class="line">        sort(vec.begin(), vec.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size();i++){</span><br><span class="line">            ans+=vec[i];</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(ans&gt;=n/<span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738. 单调递增的数字"></a>738. 单调递增的数字</h2><p><strong>Description</strong><br>给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。<br>（当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y 时，我们称这个整数是单调递增的。）<br><strong>Example</strong><br>示例 1:<br>输入: N = 10<br>输出: 9</p>
<p>示例 2:<br>输入: N = 1234<br>输出: 1234</p>
<p>示例 3:<br>输入: N = 332<br>输出: 299<br>说明: N 是在 [0, 10^9] 范围内的一个整数。<br><strong>Program</strong><br>贪心算法，遍历数字每一位，当前位的数字比下一位的数字大，则将该位数字减小1，然后之后位的数字全部变为9。<br>例如，如果 n=432543654，我们总是可以得到至少 39999999 的答案。<br>第一个下降点减1，后面全变9，而返回至下降点前一个点继续，因为存在相等连续相邻的数字。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">        <span class="keyword">while</span>(N!=<span class="number">0</span>){</span><br><span class="line">            dq.push_front(N%<span class="number">10</span>);</span><br><span class="line">            N/=<span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dq.size()<span class="number">-1</span>;i++){</span><br><span class="line">            <span class="keyword">if</span>(dq[i]&gt;dq[i+<span class="number">1</span>]){</span><br><span class="line">                dq[i]--;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;dq.size();j++) dq[j]=<span class="number">9</span>;</span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span>) i-=<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> i=<span class="number">-1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dq.size();i++) res=res*<span class="number">10</span>+dq[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1353-最多可以参加的会议数目"><a href="#1353-最多可以参加的会议数目" class="headerlink" title="1353. 最多可以参加的会议数目"></a>1353. 最多可以参加的会议数目</h2><p><strong>Description</strong><br>给你一个数组 events，其中 events[i] = [startDayi, endDayi] ，表示会议 i 开始于 startDayi ，结束于 endDayi 。<br>你可以在满足 startDayi &lt;= d &lt;= endDayi 中的任意一天 d 参加会议 i 。注意，一天只能参加一个会议。<br>请你返回你可以参加的 最大 会议数目。<br><strong>Example</strong><br>示例 1：<br>输入：events = [[1,2],[2,3],[3,4]]<br>输出：3<br>解释：你可以参加所有的三个会议。<br><img src="/assets/img/algorithm/1353_example_1.png" alt="image"><br>安排会议的一种方案如上图。<br>第 1 天参加第一个会议。<br>第 2 天参加第二个会议。<br>第 3 天参加第三个会议。</p>
<p>示例 2：<br>输入：events= [[1,2],[2,3],[3,4],[1,2]]<br>输出：4</p>
<p>示例 3：<br>输入：events = [[1,4],[4,4],[2,2],[3,4],[1,1]]<br>输出：4</p>
<p>示例 4：<br>输入：events = [[1,100000]]<br>输出：1</p>
<p>示例 5：<br>输入：events = [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7]]<br>输出：7</p>
<p>提示：<br>1 &lt;= events.length &lt;= 10^5<br>events[i].length == 2<br>1 &lt;= events[i][0] &lt;= events[i][1] &lt;= 10^5</p>
<p><strong>Program</strong><br>贪心的思想，对于第 i 天，如果有若干的会议都可以在这一天开，那么我们肯定是让 endDay 小的会议先在这一天开才会使答案最优，因为 endDay 大的会议可选择的空间是比 endDay 小的多的，所以在满足条件的会议需要让 endDay 小的先开。</p>
<p>我们开两个数组和一个 setset：</p>
<p>in[i]：表示在第 i 天开始的会议<br>out[i]：表示在第 i 天有些会议结束了，注意endDay结束的会议，endDay+1才会被撤出<br>multiset<in> s:记录当前第i天有哪些会议开始。</in></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100002</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEvents</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; events)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in[N], out[N];  <span class="comment">//记录第i天开始和结束的所有会议</span></span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; multi_s;</span><br><span class="line">        <span class="keyword">int</span> mx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;events.size();i++){</span><br><span class="line">            <span class="keyword">int</span> start=events[i][<span class="number">0</span>], end=events[i][<span class="number">1</span>];</span><br><span class="line">            in[start].push_back(i);    <span class="comment">//第start天召开第i个会议</span></span><br><span class="line">            out[end+<span class="number">1</span>].push_back(i);   <span class="comment">//第end+1天第i个会议失效</span></span><br><span class="line">            mx=max(mx, end);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x:in[i]) multi_s.insert(events[x][<span class="number">1</span>]);  <span class="comment">//加入第i天的所有会议</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x:out[i]){   <span class="comment">//撤销所有第i天失效的会议</span></span><br><span class="line">                <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator it=multi_s.find(events[x][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(it!=multi_s.end()) multi_s.erase(it);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(!multi_s.empty()){  <span class="comment">//参加endDay最早的会议</span></span><br><span class="line">                multi_s.erase(multi_s.begin());</span><br><span class="line">                ans++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a>763. 划分字母区间</h2><p><strong>Description</strong><br>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。<br><strong>Example</strong><br>示例 1:<br>输入: S = “ababcbacadefegdehijhklij”<br>输出: [9,7,8]<br>解释:<br>划分结果为 “ababcbaca”, “defegde”, “hijhklij”。<br>每个字母最多出现在一个片段中。<br>像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。</p>
<p>注意:<br>S的长度在[1, 500]之间。<br>S只包含小写字母’a’到’z’。<br><strong>Program</strong><br>策略就是不断地选择从最左边起最小的区间。可以从第一个字母开始分析，假设第一个字母是 ‘a’，那么第一个区间一定包含最后一次出现的 ‘a’。但第一个出现的 ‘a’ 和最后一个出现的 ‘a’ 之间可能还有其他字母，这些字母会让区间变大。举个例子，在 “abccaddbeffe” 字符串中，第一个最小的区间是 “abccaddb”。<br>通过以上的分析，我们可以得出一个算法：对于遇到的每一个字母，去找这个字母最后一次出现的位置，用来更新当前的最小区间</p>
<p>很容易发现必须记录每个字母的最大区间，而最后需要合并那些区间有重叠的字母来获得最大区间，因为有重叠的两个字母对应的区间可能会更新成更大的区间。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; partitionLabels(<span class="built_in">string</span> S) {</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.length();i++) m[S[i]-<span class="string">'a'</span>]=i;</span><br><span class="line">        <span class="keyword">int</span> start, end;</span><br><span class="line">        start=end=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.length();i++){</span><br><span class="line">            end=max(end, m[S[i]-<span class="string">'a'</span>]);   <span class="comment">//更新区间右值</span></span><br><span class="line">            <span class="keyword">if</span>(i==end){ <span class="comment">//获得最大区间</span></span><br><span class="line">                res.push_back(end-start+<span class="number">1</span>);</span><br><span class="line">                start=i+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="767-重构字符串"><a href="#767-重构字符串" class="headerlink" title="767. 重构字符串"></a>767. 重构字符串</h2><p><strong>Description</strong><br>给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。<br>若可行，输出任意可行的结果。若不可行，返回空字符串。<br><strong>Example</strong><br>示例 1:<br>输入: S = “aab”<br>输出: “aba”</p>
<p>示例 2:<br>输入: S = “aaab”<br>输出: “”<br>注意:<br>S 只包含小写字母并且长度在[1, 500]区间内。<br><strong>Program</strong><br><strong>桶排序：</strong><br>1.根据每种字母出现的次数高低排序，先排次数高的字母<br>2.优先加入长度短的队列</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Cmp</span>{</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;&amp; a,<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt;&amp; b)</span> <span class="keyword">const</span></span>{</span><br><span class="line">            <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ICMP</span>{</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; a,<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; b)</span> <span class="keyword">const</span></span>{</span><br><span class="line">            <span class="keyword">return</span> a.second&gt;b.second;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reorganizeString</span><span class="params">(<span class="built_in">string</span> S)</span> </span>{</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt;&gt;, Cmp&gt; pq;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:S){</span><br><span class="line">            m[ch]++;</span><br><span class="line">            <span class="keyword">if</span>(m[ch]&gt;(S.size()+<span class="number">1</span>)/<span class="number">2</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:m) pq.push({x.second, x.first});</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; top=pq.top();pq.pop();</span><br><span class="line">        <span class="keyword">int</span> len=top.first;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; series[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) series[i].push_back(top.second);</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty()){</span><br><span class="line">            top=pq.top();pq.pop();</span><br><span class="line">            priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;, ICMP&gt; tmpPQ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) tmpPQ.push({i, series[i].size()});</span><br><span class="line">            <span class="keyword">while</span>(!tmpPQ.empty()){</span><br><span class="line">                pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; now=tmpPQ.top();tmpPQ.pop();</span><br><span class="line">                <span class="keyword">int</span> idx=now.first;</span><br><span class="line">                <span class="keyword">if</span>(series[idx][series[idx].size()<span class="number">-1</span>]!=top.second){</span><br><span class="line">                    series[idx].push_back(top.second);</span><br><span class="line">                    top.first--;</span><br><span class="line">                    <span class="keyword">if</span>(top.first&gt;<span class="number">0</span>) pq.push({top.first, top.second});</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">string</span> str=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;series[i].size();j++){</span><br><span class="line">                str+=series[i][j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length()<span class="number">-1</span>;i++){</span><br><span class="line">            <span class="keyword">if</span>(str[i]==str[i+<span class="number">1</span>]) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>技巧</strong><br>隔位排列。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reorganizeString</span><span class="params">(<span class="built_in">string</span> S)</span> </span>{</span><br><span class="line">      <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; maps;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> c : S){</span><br><span class="line">        maps[c]++;</span><br><span class="line">        <span class="keyword">if</span>(maps[c] &gt; (S.size() + <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">      }</span><br><span class="line">      priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;&gt;&gt; q;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> m : maps){</span><br><span class="line">        q.push({m.second, m.first});</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="built_in">string</span> res = S;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">        <span class="keyword">char</span> c = q.top().second;</span><br><span class="line">        <span class="keyword">int</span> cnt = q.top().first;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">while</span>(cnt--){</span><br><span class="line">          i = i &gt;= S.size() ? <span class="number">1</span> : i;</span><br><span class="line">          res[i] = c;</span><br><span class="line">          i = i + <span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1217-玩筹码"><a href="#1217-玩筹码" class="headerlink" title="1217. 玩筹码"></a>1217. 玩筹码</h2><p><strong>Description</strong><br>数轴上放置了一些筹码，每个筹码的位置存在数组 chips 当中。<br>你可以对 任何筹码 执行下面两种操作之一（不限操作次数，0 次也可以）：</p>
<ul>
<li>将第 i 个筹码向左或者右移动 2 个单位，代价为 0。</li>
<li>将第 i 个筹码向左或者右移动 1 个单位，代价为 1。<br>最开始的时候，同一位置上也可能放着两个或者更多的筹码。<br>返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。</li>
</ul>
<p><strong>Example</strong><br>示例 1：<br>输入：chips = [1,2,3]<br>输出：1<br>解释：第二个筹码移动到位置三的代价是 1，第一个筹码移动到位置三的代价是 0，总代价为 1。</p>
<p>示例 2：<br>输入：chips = [2,2,2,3,3]<br>输出：2<br>解释：第四和第五个筹码移动到位置二的代价都是 1，所以最小总代价为 2。</p>
<p>提示：<br>1 &lt;= chips.length &lt;= 100<br>1 &lt;= chips[i] &lt;= 10^9<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostToMoveChips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; chips)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> evenOrodd[<span class="number">2</span>]={<span class="number">0</span>};</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:chips) evenOrodd[x%<span class="number">2</span>]++;</span><br><span class="line">        <span class="keyword">return</span> min(evenOrodd[<span class="number">0</span>], evenOrodd[<span class="number">1</span>]);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="306-累加数"><a href="#306-累加数" class="headerlink" title="306. 累加数"></a>306. 累加数</h2><p><strong>Description</strong><br>累加数是一个字符串，组成它的数字可以形成累加序列。<br>一个有效的累加序列必须至少包含 3 个数。除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。<br>给定一个只包含数字 ‘0’-‘9’ 的字符串，编写一个算法来判断给定输入是否是累加数。<br>说明: 累加序列里的数不会以 0 开头，所以不会出现 1, 2, 03 或者 1, 02, 3 的情况。<br><strong>Example</strong><br>示例 1:<br>输入: “112358”<br>输出: true<br>解释: 累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8</p>
<p>示例 2:<br>输入: “199100199”<br>输出: true<br>解释: 累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199<br><strong>Program</strong><br>i,j,k分别表示三个子串的起点，先得到前两个子串str[j-i], str[k-j]，求其和的字符串str_sum：<br>①如果str_sum的长度大于整个字符串或str_sum与str[str_sum.length-k]不符，返回false；<br>②否则，如果str_sum的长度满足要求且str_sum与str[str_sum.length-k]相符，返回true；<br>③否则，继续递归dfs(j,k,k+str_sum.leng);</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; a, <span class="keyword">const</span> <span class="built_in">string</span>&amp; b)</span></span>{</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> idx_a=a.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> idx_b=b.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx_a&gt;=<span class="number">0</span>||idx_b&gt;=<span class="number">0</span>||carry!=<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">int</span> x=idx_a&gt;=<span class="number">0</span>?a[idx_a--]-<span class="string">'0'</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y=idx_b&gt;=<span class="number">0</span>?b[idx_b--]-<span class="string">'0'</span>:<span class="number">0</span>;</span><br><span class="line">            res+=(x+y+carry)%<span class="number">10</span>+<span class="string">'0'</span>;</span><br><span class="line">            carry=(x+y+carry)/<span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; str, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>((str[i]==<span class="string">'0'</span>&amp;&amp;j-i&gt;<span class="number">1</span>)||(str[j]==<span class="string">'0'</span>&amp;&amp;k-j&gt;<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//累加序列里的数以0开头</span></span><br><span class="line">        <span class="built_in">string</span> a = str.substr(i,j-i);</span><br><span class="line">        <span class="built_in">string</span> b = str.substr(j, k-j);</span><br><span class="line">        <span class="built_in">string</span> sum=add(a, b);</span><br><span class="line">        <span class="keyword">int</span> n=sum.size();</span><br><span class="line">        <span class="keyword">if</span>(k+n<span class="number">-1</span>&gt;str.length()<span class="number">-1</span>||sum!=str.substr(k, n)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(k+n<span class="number">-1</span>==str.length()<span class="number">-1</span>&amp;&amp;sum==str.substr(k, n)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(str, j, k, k+n);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAdditiveNumber</span><span class="params">(<span class="built_in">string</span> num)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;num.size();j++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;num.size();k++){</span><br><span class="line">                <span class="keyword">if</span>(dfs(num, i, j ,k)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="842-将数组拆分成斐波那契序列"><a href="#842-将数组拆分成斐波那契序列" class="headerlink" title="842. 将数组拆分成斐波那契序列"></a>842. 将数组拆分成斐波那契序列</h2><p><strong>Description</strong><br>给定一个数字字符串 S，比如 S = “123456579”，我们可以将它分成斐波那契式的序列 [123, 456, 579]。<br>形式上，斐波那契式序列是一个非负整数列表 F，且满足：</p>
<ul>
<li>0 &lt;= F[i] &lt;= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）；</li>
<li>F.length &gt;= 3；</li>
<li>对于所有的0 &lt;= i &lt; F.length - 2，都有 F[i] + F[i+1] = F[i+2] 成立。</li>
<li>另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。<br>返回从 S 拆分出来的所有斐波那契式的序列块，如果不能拆分则返回 []。</li>
</ul>
<p>示例 1：<br>输入：”123456579”<br>输出：[123,456,579]</p>
<p>示例 2：<br>输入: “11235813”<br>输出: [1,1,2,3,5,8,13]</p>
<p>示例 3：<br>输入: “112358130”<br>输出: []<br>解释: 这项任务无法完成。</p>
<p>示例 4：<br>输入：”0123”<br>输出：[]<br>解释：每个块的数字不能以零开头，因此 “01”，”2”，”3” 不是有效答案。</p>
<p>示例 5：<br>输入: “1101111”<br>输出: [110, 1, 111]<br>解释: 输出 [11,0,11,11] 也同样被接受。<br>提示：<br>1 &lt;= S.length &lt;= 200<br>字符串 S 中只含有数字。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; a, <span class="keyword">const</span> <span class="built_in">string</span>&amp; b)</span></span>{</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> idx_a=a.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> idx_b=b.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx_a&gt;=<span class="number">0</span>||idx_b&gt;=<span class="number">0</span>||carry!=<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">int</span> x=idx_a&gt;=<span class="number">0</span>?a[idx_a--]-<span class="string">'0'</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y=idx_b&gt;=<span class="number">0</span>?b[idx_b--]-<span class="string">'0'</span>:<span class="number">0</span>;</span><br><span class="line">            res+=(x+y+carry)%<span class="number">10</span>+<span class="string">'0'</span>;</span><br><span class="line">            carry=(x+y+carry)/<span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; str, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; result, <span class="keyword">bool</span> bFirst, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>((str[i]==<span class="string">'0'</span>&amp;&amp;j-i&gt;<span class="number">1</span>)||(str[j]==<span class="string">'0'</span>&amp;&amp;k-j&gt;<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//累加序列里的数以0开头</span></span><br><span class="line">        <span class="built_in">string</span> a = str.substr(i,j-i);</span><br><span class="line">        <span class="built_in">string</span> b = str.substr(j, k-j);</span><br><span class="line">        <span class="built_in">string</span> sum = add(a, b);</span><br><span class="line">        <span class="keyword">if</span>(bFirst){</span><br><span class="line">            <span class="keyword">int</span> x,y;</span><br><span class="line">            <span class="keyword">if</span>(!toInt(a, x)||!toInt(b, y)) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//超过范围</span></span><br><span class="line">            result.push_back(x);</span><br><span class="line">            result.push_back(y);</span><br><span class="line">            bFirst=<span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> z;</span><br><span class="line">        <span class="keyword">if</span>(!toInt(sum, z)) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//超过范围</span></span><br><span class="line">        result.push_back(z);</span><br><span class="line">        <span class="keyword">int</span> n=sum.size();</span><br><span class="line">        <span class="keyword">if</span>(k+n<span class="number">-1</span>&gt;str.length()<span class="number">-1</span>||sum!=str.substr(k, n)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(k+n<span class="number">-1</span>==str.length()<span class="number">-1</span>&amp;&amp;sum==str.substr(k, n)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(str, result, bFirst, j, k, k+n);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">toInt</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span>&amp; cb)</span></span>{</span><br><span class="line">        <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++){</span><br><span class="line">            res=res*<span class="number">10</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(res&gt;INT_MAX) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        cb=res;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; splitIntoFibonacci(<span class="built_in">string</span> num) {</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;num.length();j++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;num.length();k++){</span><br><span class="line">                result.clear();</span><br><span class="line">                <span class="keyword">if</span>(dfs(num, result, <span class="literal">true</span>, i, j ,k)){</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> {};</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; splitIntoFibonacci(<span class="built_in">string</span> S) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        dfs(<span class="number">0</span>,S.size()<span class="number">-1</span>,S,tmp);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    }</span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="built_in">string</span> num, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;tmp)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">long</span>  n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(tmp.size() &gt; <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; ++i)</span><br><span class="line">        {</span><br><span class="line">            n = n * <span class="number">10</span> + (num[i] - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span>(n &gt; INT_MAX)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(tmp.size() &lt; <span class="number">2</span>)</span><br><span class="line">            {</span><br><span class="line">                tmp.push_back(n);</span><br><span class="line">                <span class="keyword">if</span>(dfs(i + <span class="number">1</span>, right, num, tmp))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">long</span>  num1 = tmp[tmp.size()<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">long</span>  num2 = tmp[tmp.size()<span class="number">-2</span>];</span><br><span class="line">                <span class="keyword">long</span>  sum = num1 + num2;</span><br><span class="line">                <span class="keyword">if</span>(sum &lt; n)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(n == sum)</span><br><span class="line">                {</span><br><span class="line">                    tmp.push_back(n);</span><br><span class="line">                    <span class="keyword">if</span>(dfs(i + <span class="number">1</span>, right, num, tmp))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    tmp.pop_back();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(num[left] == <span class="string">'0'</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1400-构造-K-个回文字符串"><a href="#1400-构造-K-个回文字符串" class="headerlink" title="1400. 构造 K 个回文字符串"></a>1400. 构造 K 个回文字符串</h2><p><strong>Description</strong><br>给你一个字符串 s 和一个整数 k 。请你用 s 字符串中 所有字符 构造 k 个非空 回文串 。<br>如果你可以用 s 中所有字符构造 k 个回文字符串，那么请你返回 True ，否则返回 False 。<br><strong>Example</strong><br>示例 1：<br>输入：s = “annabelle”, k = 2<br>输出：true<br>解释：可以用 s 中所有字符构造 2 个回文字符串。<br>一些可行的构造方案包括：”anna” + “elble”，”anbna” + “elle”，”anellena” + “b”</p>
<p>示例 2：<br>输入：s = “leetcode”, k = 3<br>输出：false<br>解释：无法用 s 中所有字符构造 3 个回文串。</p>
<p>示例 3：<br>输入：s = “true”, k = 4<br>输出：true<br>解释：唯一可行的方案是让 s 中每个字符单独构成一个字符串。</p>
<p>示例 4：<br>输入：s = “yzyzyzyzyzyzyzy”, k = 2<br>输出：true<br>解释：你只需要将所有的 z 放在一个字符串中，所有的 y 放在另一个字符串中。那么两个字符串都是回文串。</p>
<p>示例 5：<br>输入：s = “cr”, k = 7<br>输出：false<br>解释：我们没有足够的字符去构造 7 个回文串。</p>
<p>提示：<br>1 &lt;= s.length &lt;= 10^5<br>s 中所有字符都是小写英文字母。<br>1 &lt;= k &lt;= 10^5<br><strong>Program</strong><br>先安排落单的字母，然后判断成对个数是否满足，特别要判断的是odd+even&lt;k的情况，也有可能成立！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(s.length()==k) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//全部的单个字母</span></span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;k) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//一定不成立</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:s) vec[ch-<span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">int</span> even=<span class="number">0</span>, odd=<span class="number">0</span>;  <span class="comment">//成对个数，单个的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:vec){</span><br><span class="line">            even+=x/<span class="number">2</span>;</span><br><span class="line">            odd+=x%<span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(odd&gt;k) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//单个的个数不满足</span></span><br><span class="line">        <span class="keyword">if</span>(odd==k||odd+even&gt;=k||(s.length()-odd)%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;(even&gt;=(s.length()-odd)/<span class="number">2</span>)) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//单个的个数为k，无论成对个数几何都成立||单个的个数小于k，但成对个数可以补足||单个个数小于k，但部分成对字母可以拆成</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860. 柠檬水找零"></a>860. 柠檬水找零</h2><p><strong>Description</strong><br>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。<br>顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。<br>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。<br>注意，一开始你手头没有任何零钱。<br>如果你能给每位顾客正确找零，返回 true ，否则返回 false 。<br><strong>Example</strong><br>示例 1：<br>输入：[5,5,5,10,20]<br>输出：true<br>解释：<br>前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。<br>第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。<br>第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。<br>由于所有客户都得到了正确的找零，所以我们输出 true。</p>
<p>示例 2：<br>输入：[5,5,10]<br>输出：true</p>
<p>示例 3：<br>输入：[10,10]<br>输出：false</p>
<p>示例 4：<br>输入：[5,5,10,10,20]<br>输出：false<br>解释：<br>前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。<br>对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。<br>对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。<br>由于不是每位顾客都得到了正确的找零，所以答案是 false。</p>
<p>提示：<br>0 &lt;= bills.length &lt;= 10000<br>bills[i] 不是 5 就是 10 或是 20<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dollars[<span class="number">3</span>]={<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dollar[<span class="number">3</span>]={<span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>};</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> res, <span class="keyword">int</span> idx)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(res&gt;=dollar[idx]&amp;&amp;dollars[idx]&gt;<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">int</span> n=res/dollar[idx];</span><br><span class="line">            <span class="keyword">if</span>(n&gt;<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(n&gt;=dollars[idx]){</span><br><span class="line">                    res-=dollar[idx]*dollars[idx];</span><br><span class="line">                    dollars[idx]=<span class="number">0</span>;</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    res-=dollar[idx]*n;</span><br><span class="line">                    dollars[idx]-=n;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// while(res&gt;=dollar[idx]){</span></span><br><span class="line">        <span class="comment">//     if(dollars[idx]&gt;0){</span></span><br><span class="line">        <span class="comment">//         res-=dollar[idx];</span></span><br><span class="line">        <span class="comment">//         dollars[idx]--;</span></span><br><span class="line">        <span class="comment">//     }else break;</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lemonadeChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bills)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:bills){</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="number">5</span>){</span><br><span class="line">                dollars[<span class="number">0</span>]++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">int</span> res=x<span class="number">-5</span>;</span><br><span class="line">            res = cal(res, <span class="number">1</span>);</span><br><span class="line">            res = cal(res ,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(res&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="number">10</span>) dollars[<span class="number">1</span>]++;</span><br><span class="line">            <span class="keyword">else</span> dollars[<span class="number">2</span>]++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="861-翻转矩阵后的得分"><a href="#861-翻转矩阵后的得分" class="headerlink" title="861. 翻转矩阵后的得分"></a>861. 翻转矩阵后的得分</h2><p><strong>Description</strong><br>有一个二维矩阵 A 其中每个元素的值为 0 或 1 。<br>移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。<br>在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。<br>返回尽可能高的分数。<br><strong>Example</strong><br>示例：<br>输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]<br>输出：39<br>解释：<br>转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]<br>0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39</p>
<p>提示：<br>1 &lt;= A.length &lt;= 20<br>1 &lt;= A[0].length &lt;= 20<br>A[i][j] 是 0 或 1<br><strong>Program</strong><br>贪心：高位优先翻转成1<br>可以发现第一列一定能且一定要全成1，而后每列判断是否需要翻转。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flipRow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, <span class="keyword">int</span> nCol, <span class="keyword">int</span> row)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;nCol;col++){</span><br><span class="line">            A[row][col]=<span class="number">1</span>-A[row][col];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flipCol</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, <span class="keyword">int</span> nRow, <span class="keyword">int</span> col)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;nRow;row++){</span><br><span class="line">            A[row][col]=<span class="number">1</span>-A[row][col];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getBinaryScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=vec.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            ans+=vec[i]*(<span class="number">1</span>&lt;&lt;(n-i<span class="number">-1</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calColZeros</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, <span class="keyword">int</span> nRow, <span class="keyword">int</span> col)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;nRow;row++){</span><br><span class="line">            <span class="keyword">if</span>(A[row][col]==<span class="number">0</span>) ans++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">matrixScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nRow=A.size();</span><br><span class="line">        <span class="keyword">int</span> nCol=A[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;nRow;row++){</span><br><span class="line">            <span class="keyword">if</span>(A[row][<span class="number">0</span>]==<span class="number">0</span>) flipRow(A, nCol, row);  <span class="comment">//该行最高位为0，翻转</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">1</span>; col&lt;nCol;col++){</span><br><span class="line">            <span class="keyword">int</span> zeros=calColZeros(A, nRow, col);</span><br><span class="line">            <span class="keyword">if</span>(nRow/<span class="number">2</span>&lt;zeros) flipCol(A, nRow, col); <span class="comment">//该列0个数过多，翻转</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;nRow;row++){</span><br><span class="line">            ans+=getBinaryScore(A[row]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1414-和为-K-的最少斐波那契数字数目"><a href="#1414-和为-K-的最少斐波那契数字数目" class="headerlink" title="1414. 和为 K 的最少斐波那契数字数目"></a>1414. 和为 K 的最少斐波那契数字数目</h2><p><strong>Description</strong><br>给你数字 k ，请你返回和为 k 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。<br>斐波那契数字定义为：<br>F1 = 1<br>F2 = 1<br>Fn = Fn-1 + Fn-2 ， 其中 n &gt; 2 。<br>数据保证对于给定的 k ，一定能找到可行解。<br><strong>Example</strong><br>示例 1：<br>输入：k = 7<br>输出：2<br>解释：斐波那契数字为：1，1，2，3，5，8，13，……<br>对于 k = 7 ，我们可以得到 2 + 5 = 7 。</p>
<p>示例 2：<br>输入：k = 10<br>输出：2<br>解释：对于 k = 10 ，我们可以得到 2 + 8 = 10 。</p>
<p>示例 3：<br>输入：k = 19<br>输出：3<br>解释：对于 k = 19 ，我们可以得到 1 + 5 + 13 = 19 。</p>
<p>提示：<br>1 &lt;= k &lt;= 10^9<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; funcion(<span class="keyword">int</span> count){</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        res.push_back(a);</span><br><span class="line">        res.push_back(b);</span><br><span class="line">        <span class="keyword">while</span>(idx&lt;count){</span><br><span class="line">            <span class="keyword">int</span> c=a+b;</span><br><span class="line">            res.push_back(c);</span><br><span class="line">            a=b;</span><br><span class="line">            b=c;</span><br><span class="line">            idx++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinFibonacciNumbers</span><span class="params">(<span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec=funcion(<span class="number">42</span>);</span><br><span class="line">        <span class="keyword">int</span> idx=vec.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">while</span>(vec[idx]&lt;=k){</span><br><span class="line">                k-=vec[idx];</span><br><span class="line">                res++;</span><br><span class="line">            }</span><br><span class="line">            idx--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="870-优势洗牌"><a href="#870-优势洗牌" class="headerlink" title="870. 优势洗牌"></a>870. 优势洗牌</h2><p><strong>Description</strong><br>给定两个大小相等的数组 A 和 B，A 相对于 B 的优势可以用满足 A[i] &gt; B[i] 的索引 i 的数目来描述。<br>返回 A 的任意排列，使其相对于 B 的优势最大化。<br><strong>Example</strong><br>示例 1：<br>输入：A = [2,7,11,15], B = [1,10,4,11]<br>输出：[2,11,7,15]</p>
<p>示例 2：<br>输入：A = [12,24,8,32], B = [13,25,32,11]<br>输出：[24,32,8,12]</p>
<p>提示：<br>1 &lt;= A.length = B.length &lt;= 10000<br>0 &lt;= A[i] &lt;= 10^9<br>0 &lt;= B[i] &lt;= 10^9<br><strong>Program</strong><br>贪心的思想就是，两个数组排序，不同的是B数组需要保留原位置，然后A数组尽可能小的数与B尽可能大的数匹配，才能使A中更大的数匹配更多B中的元素。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> idx;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> Val, <span class="keyword">int</span> Idx):val(Val), idx(Idx){}</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node&amp; a, <span class="keyword">const</span> Node&amp; b)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; advantageCount(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B) {</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        sort(A.begin(), A.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; vecB;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            vecB.push_back(Node(B[i], i));</span><br><span class="line">        }</span><br><span class="line">        sort(vecB.begin(), vecB.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> idxA=<span class="number">0</span>, idxB=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; restA;</span><br><span class="line">        <span class="keyword">while</span>(idxA&lt;n){</span><br><span class="line">            <span class="keyword">if</span>(vecB[idxB].val&lt;A[idxA]){</span><br><span class="line">                <span class="keyword">int</span> idx=vecB[idxB].idx;</span><br><span class="line">                res[idx]=A[idxA];</span><br><span class="line">                idxB++;</span><br><span class="line">            }<span class="keyword">else</span> restA.push_back(A[idxA]);</span><br><span class="line">            idxA++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(res[i]==<span class="number">-1</span>){</span><br><span class="line">                res[i]=restA[idx++];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1386-安排电影院座位"><a href="#1386-安排电影院座位" class="headerlink" title="1386. 安排电影院座位"></a>1386. 安排电影院座位</h2><p><strong>Description</strong><br><img src="/assets/img/algorithm/cinema_seats_1.png" alt="image"><br>如上图所示，电影院的观影厅中有 n 行座位，行编号从 1 到 n ，且每一行内总共有 10 个座位，列编号从 1 到 10 。<br>给你数组 reservedSeats ，包含所有已经被预约了的座位。比如说，researvedSeats[i]=[3,8] ，它表示第 3 行第 8 个座位被预约了。<br>请你返回 最多能安排多少个 4 人家庭 。4 人家庭要占据 同一行内连续 的 4 个座位。隔着过道的座位（比方说 [3,3] 和 [3,4]）不是连续的座位，但是如果你可以将 4 人家庭拆成过道两边各坐 2 人，这样子是允许的。<br><strong>Example</strong><br>示例 1：<br><img src="/assets/img/algorithm/cinema_seats_2.png" alt="image"><br>输入：n = 3, reservedSeats = [[1,2],[1,3],[1,8],[2,6],[3,1],[3,10]]<br>输出：4<br>解释：上图所示是最优的安排方案，总共可以安排 4 个家庭。蓝色的叉表示被预约的座位，橙色的连续座位表示一个 4 人家庭。</p>
<p>示例 2：<br>输入：n = 2, reservedSeats = [[2,1],[1,8],[2,6]]<br>输出：2</p>
<p>示例 3：<br>输入：n = 4, reservedSeats = [[4,3],[1,4],[4,6],[1,7]]<br>输出：4</p>
<p>提示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= n &lt;= 10^9</span><br><span class="line">1 &lt;=&nbsp;reservedSeats.length &lt;= min(10*n, 10^4)</span><br><span class="line">reservedSeats[i].length == 2</span><br><span class="line">1&nbsp;&lt;=&nbsp;reservedSeats[i][0] &lt;= n</span><br><span class="line">1 &lt;=&nbsp;reservedSeats[i][1] &lt;= 10</span><br><span class="line">所有&nbsp;reservedSeats[i] 都是互不相同的。</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong><br>贪心：n的范围决定了不能开数组，因为绝对超时。那么看reservedSeats长度不超过$10^4$，所以按照行号对reservedSeats排序，left,mid,right记录每行三个满足题意的可能位置，每次换行就可以开始计算上一行的满足题意的方案数，<strong>注意新行与旧行不相邻，也就是跳行，那么中间的几行全部加2；其次最后一个计算的行需要下一次计算该行方案数，记得补上判断</strong>，最后就是剩余行数的问题了。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>]!=b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>]&lt;b[<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNumberOfFamilies</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; reservedSeats)</span> </span>{</span><br><span class="line">        sort(reservedSeats.begin(), reservedSeats.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> preRow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, mid=<span class="number">0</span>, right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len=reservedSeats.size();</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++){</span><br><span class="line">            <span class="keyword">int</span> nowRow=reservedSeats[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> nowCol=reservedSeats[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nowRow!=preRow){     <span class="comment">//新的一行</span></span><br><span class="line">                <span class="keyword">if</span>(left==<span class="number">1</span>&amp;&amp;right==<span class="number">1</span>) ans+=<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(left==<span class="number">0</span>&amp;&amp;(mid==<span class="number">1</span>||right==<span class="number">1</span>)) ans+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(right==<span class="number">0</span>&amp;&amp;(mid==<span class="number">1</span>||left==<span class="number">1</span>)) ans+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(nowRow-preRow!=<span class="number">1</span>) ans+=<span class="number">2</span>*(nowRow-preRow<span class="number">-1</span>); <span class="comment">//跳行</span></span><br><span class="line">                preRow=nowRow;</span><br><span class="line">                left=mid=right=<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(nowCol==<span class="number">2</span>||nowCol==<span class="number">3</span>||nowCol==<span class="number">4</span>||nowCol==<span class="number">5</span>) left=<span class="number">0</span>;   <span class="comment">//左位点不满足</span></span><br><span class="line">            <span class="keyword">if</span>(nowCol==<span class="number">4</span>||nowCol==<span class="number">5</span>||nowCol==<span class="number">6</span>||nowCol==<span class="number">7</span>) mid=<span class="number">0</span>;    <span class="comment">//中位点不满足</span></span><br><span class="line">            <span class="keyword">if</span>(nowCol==<span class="number">6</span>||nowCol==<span class="number">7</span>||nowCol==<span class="number">8</span>||nowCol==<span class="number">9</span>) right=<span class="number">0</span>;  <span class="comment">//右位点不满足</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//最后出现的一行</span></span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">1</span>&amp;&amp;right==<span class="number">1</span>) ans+=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left==<span class="number">0</span>&amp;&amp;(mid==<span class="number">1</span>||right==<span class="number">1</span>)) ans+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(right==<span class="number">0</span>&amp;&amp;(mid==<span class="number">1</span>||left==<span class="number">1</span>)) ans+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(preRow&lt;n){</span><br><span class="line">            ans+=<span class="number">2</span>*(n-preRow);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1403-非递增顺序的最小子序列"><a href="#1403-非递增顺序的最小子序列" class="headerlink" title="1403. 非递增顺序的最小子序列"></a>1403. 非递增顺序的最小子序列</h2><p><strong>Description</strong><br>给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。<br>如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。<br>与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。<br>注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。<br><strong>Example</strong><br>示例 1：<br>输入：nums = [4,3,10,9,8]<br>输出：[10,9]<br>解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。 </p>
<p>示例 2：<br>输入：nums = [4,4,7,6,7]<br>输出：[7,7,6]<br>解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。<br>示例 3：<br>输入：nums = [6]<br>输出：[6]</p>
<p>提示：<br>1 &lt;= nums.length &lt;= 500<br>1 &lt;= nums[i] &lt;= 100<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minSubsequence(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums) sum+=x;</span><br><span class="line">        sort(nums.begin(), nums.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> nowSum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums){</span><br><span class="line">            nowSum+=x;</span><br><span class="line">            res.push_back(x);</span><br><span class="line">            <span class="keyword">if</span>(nowSum&gt;sum-nowSum) <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="874-模拟行走机器人"><a href="#874-模拟行走机器人" class="headerlink" title="874. 模拟行走机器人"></a>874. 模拟行走机器人</h2><p><strong>Description</strong><br>机器人在一个无限大小的网格上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令：<br>-2：向左转 90 度<br>-1：向右转 90 度<br>1 &lt;= x &lt;= 9：向前移动 x 个单位长度<br>在网格上有一些格子被视为障碍物。<br>第 i 个障碍物位于网格点  (obstacles[i][0], obstacles[i][1])<br>机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续该路线的其余部分。<br>返回从原点到机器人的最大欧式距离的平方。<br><strong>Example</strong><br>示例 1：<br>输入: commands = [4,-1,3], obstacles = []<br>输出: 25<br>解释: 机器人将会到达 (3, 4)</p>
<p>示例 2：<br>输入: commands = [4,-1,4,-2,4], obstacles = [[2,4]]<br>输出: 65<br>解释: 机器人在左转走到 (1, 8) 之前将被困在 (1, 4) 处</p>
<p>提示：<br>0 &lt;= commands.length &lt;= 10000<br>0 &lt;= obstacles.length &lt;= 10000<br>-30000 &lt;= obstacle[i][0] &lt;= 30000<br>-30000 &lt;= obstacle[i][1] &lt;= 30000<br>答案保证小于 2 ^ 31<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> steps[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">-1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">robotSim</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; commands, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacles)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> oriented=<span class="number">0</span>; <span class="comment">//北面开始顺时针，0,1,2,3</span></span><br><span class="line">        <span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; obs:obstacles){</span><br><span class="line">            x=obs[<span class="number">0</span>];</span><br><span class="line">            y=obs[<span class="number">1</span>];</span><br><span class="line">            st.insert({x, y});</span><br><span class="line">        }</span><br><span class="line">        x=y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> cmd:commands){</span><br><span class="line">            <span class="keyword">if</span>(cmd==<span class="number">-2</span>) oriented=(oriented<span class="number">-1</span>+<span class="number">4</span>)%<span class="number">4</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cmd==<span class="number">-1</span>) oriented=(oriented+<span class="number">1</span>+<span class="number">4</span>)%<span class="number">4</span>;</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cmd;i++){</span><br><span class="line">                    <span class="keyword">int</span> new_x=x+steps[oriented][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">int</span> new_y=y+steps[oriented][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">if</span>(st.find(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(new_x, new_y))!=st.end()) <span class="keyword">break</span>;<span class="comment">//注意不能用{}，否则找不到</span></span><br><span class="line">                    x=new_x;</span><br><span class="line">                    y=new_y;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            ans=max(ans, x*x+y*y);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="881-救生艇"><a href="#881-救生艇" class="headerlink" title="881. 救生艇"></a>881. 救生艇</h2><p><strong>Description</strong><br>第 i 个人的体重为 people[i]，每艘船可以承载的最大重量为 limit。<br>每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。<br>返回载到每一个人所需的最小船数。(保证每个人都能被船载)。<br><strong>Example</strong><br>示例 1：<br>输入：people = [1,2], limit = 3<br>输出：1<br>解释：1 艘船载 (1, 2)</p>
<p>示例 2：<br>输入：people = [3,2,2,1], limit = 3<br>输出：3<br>解释：3 艘船分别载 (1, 2), (2) 和 (3)</p>
<p>示例 3：<br>输入：people = [3,5,3,4], limit = 5<br>输出：4<br>解释：4 艘船分别载 (3), (3), (4), (5)<br>提示：<br>1 &lt;= people.length &lt;= 50000<br>1 &lt;= people[i] &lt;= limit &lt;= 30000<br><strong>Program</strong><br>贪心：一般思路，(最)较重的要与尽可能大的组合，然而这样做代码难写，反而换个思路，最轻的要与尽可能大的组合一个道理，那么最重和最小的组合，如果满足题意就一艘船，否则最重的单独一艘船。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRescueBoats</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; people, <span class="keyword">int</span> limit)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=people.size();</span><br><span class="line">        sort(people.begin(), people.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j){</span><br><span class="line">            <span class="keyword">if</span>(people[i]+people[j]&lt;=limit)j--;</span><br><span class="line">            i++;</span><br><span class="line">            ans++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1405-最长快乐字符串"><a href="#1405-最长快乐字符串" class="headerlink" title="1405. 最长快乐字符串"></a>1405. 最长快乐字符串</h2><p><strong>Description</strong><br>如果字符串中不含有任何 ‘aaa’，’bbb’ 或 ‘ccc’ 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。<br>给你三个整数 a，b ，c，请你返回 任意一个 满足下列全部条件的字符串 s：<br>s 是一个尽可能长的快乐字符串。<br>s 中 最多 有a 个字母 ‘a’、b 个字母 ‘b’、c 个字母 ‘c’ 。<br>s 中只含有 ‘a’、’b’ 、’c’ 三种字母。<br>如果不存在这样的字符串 s ，请返回一个空字符串 “”。<br><strong>Example</strong><br>示例 1：<br>输入：a = 1, b = 1, c = 7<br>输出：”ccaccbcc”<br>解释：”ccbccacc” 也是一种正确答案。</p>
<p>示例 2：<br>输入：a = 2, b = 2, c = 1<br>输出：”aabbc”</p>
<p>示例 3：<br>输入：a = 7, b = 1, c = 0<br>输出：”aabaa”<br>解释：这是该测试用例的唯一正确答案。</p>
<p>提示：<br>0 &lt;= a, b, c &lt;= 100<br>a + b + c &gt; 0<br><strong>Program</strong><br>贪心：一个个字符排列（两个两个排是错的），优先排列次数多的，如果当前次数最多的字符与前两个以排字符相同，则排列次多的字符。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">    };</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Cmp</span>{</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> Node&amp; a, <span class="keyword">const</span> Node&amp; b)</span> <span class="keyword">const</span></span>{</span><br><span class="line">            <span class="keyword">return</span> a.count&lt;b.count;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestDiverseString</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>{</span><br><span class="line">        Node node[<span class="number">3</span>];</span><br><span class="line">        node[<span class="number">0</span>].count=a;node[<span class="number">0</span>].ch=<span class="string">'a'</span>;</span><br><span class="line">        node[<span class="number">1</span>].count=b;node[<span class="number">1</span>].ch=<span class="string">'b'</span>;</span><br><span class="line">        node[<span class="number">2</span>].count=c;node[<span class="number">2</span>].ch=<span class="string">'c'</span>;</span><br><span class="line">        priority_queue&lt;Node, <span class="built_in">vector</span>&lt;Node&gt;, Cmp&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) <span class="keyword">if</span>(node[i].count&gt;<span class="number">0</span>) pq.push(node[i]);</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty()){</span><br><span class="line">            Node now=pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            <span class="keyword">if</span>(res.length()&gt;=<span class="number">2</span>&amp;&amp;now.ch==res[res.length()<span class="number">-1</span>]&amp;&amp;now.ch==res[res.length()<span class="number">-2</span>]){</span><br><span class="line">                <span class="keyword">if</span>(pq.size()==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                Node next=pq.top(); pq.pop();</span><br><span class="line">                res+=next.ch;</span><br><span class="line">                next.count--;</span><br><span class="line">                <span class="keyword">if</span>(next.count&gt;<span class="number">0</span>)pq.push(next);</span><br><span class="line">                pq.push(now);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                res+=now.ch;</span><br><span class="line">                now.count--;</span><br><span class="line">                <span class="keyword">if</span>(now.count&gt;<span class="number">0</span>) pq.push(now);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1221-分割平衡字符串"><a href="#1221-分割平衡字符串" class="headerlink" title="1221. 分割平衡字符串"></a>1221. 分割平衡字符串</h2><p><strong>Description</strong><br>在一个「平衡字符串」中，’L’ 和 ‘R’ 字符的数量是相同的。<br>给出一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。<br>返回可以通过分割得到的平衡字符串的最大数量。<br><strong>Example</strong><br>示例 1：<br>输入：s = “RLRRLLRLRL”<br>输出：4<br>解释：s 可以分割为 “RL”, “RRLL”, “RL”, “RL”, 每个子字符串中都包含相同数量的 ‘L’ 和 ‘R’。</p>
<p>示例 2：<br>输入：s = “RLLLLRRRLR”<br>输出：3<br>解释：s 可以分割为 “RL”, “LLLRRR”, “LR”, 每个子字符串中都包含相同数量的 ‘L’ 和 ‘R’。</p>
<p>示例 3：<br>输入：s = “LLLLRRRR”<br>输出：1<br>解释：s 只能保持原样 “LLLLRRRR”.</p>
<p>提示：<br>1 &lt;= s.length &lt;= 1000<br>s[i] = ‘L’ 或 ‘R’<br>分割得到的每个字符串都必须是平衡字符串。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">balancedStringSplit</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>, l=<span class="number">0</span>, r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch: s){</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">'L'</span>) l++;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">'R'</span>) r++;</span><br><span class="line">            <span class="keyword">if</span>(l==r){</span><br><span class="line">                ans++;</span><br><span class="line">                l=r=<span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="402-移掉K位数字"><a href="#402-移掉K位数字" class="headerlink" title="402. 移掉K位数字"></a>402. 移掉K位数字</h2><p><strong>Description</strong><br>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。<br>注意:<br>num 的长度小于 10002 且 ≥ k。<br>num 不会包含任何前导零。<br><strong>Example</strong><br>示例 1 :<br>输入: num = “1432219”, k = 3<br>输出: “1219”<br>解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。</p>
<p>示例 2 :<br>输入: num = “10200”, k = 1<br>输出: “200”<br>解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</p>
<p>示例 3 :<br>输入: num = “10”, k = 2<br>输出: “0”<br>解释: 从原数字移除所有的数字，剩余为空就是0。<br><strong>Program</strong><br>贪心：移出k个数字，也就是保存resCount=n-k个数字，使其最小。那么每次选择结果字符串的第i个数字的时候，从除了末尾resCount-1个数字外，选择当前最小的数字作为结果的第i个数字即可。<br>例如：<br>1432219, k=3<br>①保留后n-k-1=3位，从下标0开始，1432中选择最小的数字1,原字符串下标0；<br>②保留后n-k-2=2位，从下标0+1开始，即4322中选择最小的数字2，原字符串下标3;<br>③保留后n-k-3=1位，从下标3+1开始，即21中选择最小的数字1，原字符串下标5;<br>④保留后n-k-4=0位，从下标5+1开始，即9中选择最小的数字9，原字符串下标6，结束，res字符串长度满足要求n-k。<br>时间复杂度：$O((k+1)(n-k))$，当k=(n-1)/2时，时间复杂度最高，约$2.5×10^7$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findMinChar</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> &amp;idx)</span></span>{</span><br><span class="line">        <span class="keyword">char</span> ch=str[<span class="number">0</span>];</span><br><span class="line">        idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;str.length();i++){</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">'0'</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(str[i]&lt;ch){</span><br><span class="line">                ch=str[i];</span><br><span class="line">                idx=i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ch;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(num.length()==k) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">int</span> n=num.length();</span><br><span class="line">        <span class="keyword">int</span> resCount=n-k;</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(res.length()!=n-k){</span><br><span class="line">            <span class="keyword">int</span> tmpIdx=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">string</span> str=num.substr(idx+<span class="number">1</span>,n-(resCount<span class="number">-1</span>)-idx<span class="number">-1</span>); <span class="comment">//选择从上次所选数字下一位开始的，保留原字符串后resCount-1个数字，剩余的字符串，选择数字最小的</span></span><br><span class="line">            res+=findMinChar(str, tmpIdx);</span><br><span class="line">            resCount--;</span><br><span class="line">            idx=idx+<span class="number">1</span>+tmpIdx;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(res[<span class="number">0</span>]==<span class="string">'0'</span>&amp;&amp;res.length()&gt;<span class="number">1</span>) res.erase(res.begin()); <span class="comment">//去掉前导零</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>算法：<br>上述的规则使得我们通过一个接一个的删除数字，逐步的接近最优解。<br>这个问题可以用贪心算法来解决。上述规则阐明了我们如何接近最终答案的基本逻辑。一旦我们从序列中删除一个数字，剩下的数字就形成了一个新的问题，我们可以继续使用这个规则。<br>我们会注意到，在某些情况下，规则对任意数字都不适用，即单调递增序列。在这种情况下，我们只需要删除末尾的数字来获得最小数。<br>我们可以利用栈来实现上述算法，存储当前迭代数字之前的数字。</p>
<ul>
<li>对于每个数字，如果该数字小于栈顶部，即该数字的左邻居，则弹出堆栈，即删除左邻居。否则，我们把数字推到栈上。</li>
<li>我们重复上述步骤（1），直到任何条件不再适用，例如堆栈为空（不再保留数字）。或者我们已经删除了 k 位数字。<br><img src="/assets/img/algorithm/402_example_01.png" alt="image"><br>我们在上图中演示了该算法的工作原理。给定输入序列 [1，2，3，4，5，2，6，4] 和 k=4，规则在 5 触发。删除数字 5 后，规则将在数字 4 处再次触发，直到数字 3。然后，在数字 6 处，规则也被触发。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(num.length()==k) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">int</span> n=num.length();</span><br><span class="line">        <span class="keyword">int</span> m=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">char</span>&gt; dq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:num){</span><br><span class="line">            <span class="keyword">while</span>(!dq.empty()&amp;&amp;ch&lt;dq.back()&amp;&amp;m&lt;k){</span><br><span class="line">                dq.pop_back();</span><br><span class="line">                m++;</span><br><span class="line">            }</span><br><span class="line">            dq.push_back(ch);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">string</span> str=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>(!dq.empty()){</span><br><span class="line">            <span class="keyword">if</span>(m&lt;k){</span><br><span class="line">                 m++;</span><br><span class="line">                 dq.pop_back();</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">if</span>(str.length()==<span class="number">0</span>&amp;&amp;dq.front()==<span class="string">'0'</span>) {dq.pop_front();<span class="keyword">continue</span>;}</span><br><span class="line">                str+=dq.front();</span><br><span class="line">                dq.pop_front();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> str==<span class="string">""</span>?<span class="string">"0"</span>:str;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a>406. 根据身高重建队列</h2><p><strong>Description</strong><br>假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。<br>注意：<br>总人数少于1100人。<br><strong>Example</strong><br>示例<br>输入:<br>[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]<br>输出:<br>[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]<br><strong>Program</strong><br>贪心：优先安排高的而非矮的，因为要满足无后效性，即安排较高的，之前已排列的都是身高大于等于当前的，确定了插入位置，对其后面的不产生影响。可以试试优先安排矮的，会发现每次插入教高的时候，插入位置后面如果还有比当前更矮的就得重新计算，即先前排列相对位置。其次，频繁插入用链表更合适，数组需要移动元素不方便。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>{</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">        LinkNode* next;</span><br><span class="line">        LinkNode(){}</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; reconstructQueue(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; people) {</span><br><span class="line">        sort(people.begin(), people.end(), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;b){</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>]!=b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">0</span>]&gt;b[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>]&lt;b[<span class="number">1</span>];</span><br><span class="line">        });</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        LinkNode* root=<span class="keyword">new</span> LinkNode(); <span class="comment">//头结点</span></span><br><span class="line">        root-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec:people){</span><br><span class="line">            <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">            LinkNode* p=root-&gt;next;</span><br><span class="line">            LinkNode* pre=root;</span><br><span class="line">            <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;count&lt;vec[<span class="number">1</span>]){</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;data[<span class="number">0</span>]&gt;=vec[<span class="number">0</span>]) count++;</span><br><span class="line">                pre=p;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            LinkNode* node=<span class="keyword">new</span> LinkNode();</span><br><span class="line">            node-&gt;data=vec;</span><br><span class="line">            node-&gt;next=p;</span><br><span class="line">            pre-&gt;next=node;</span><br><span class="line">        }</span><br><span class="line">        root=root-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">NULL</span>){</span><br><span class="line">            res.push_back(root-&gt;data);</span><br><span class="line">            root=root-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; reconstructQueue(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; people) {</span><br><span class="line">        sort(people.begin(), people.end(), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;b){</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>]!=b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">0</span>]&gt;b[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>]&lt;b[<span class="number">1</span>];</span><br><span class="line">        });</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ls;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec:people){</span><br><span class="line">            <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">list</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;::iterator it=ls.begin();</span><br><span class="line">            advance(it, vec[<span class="number">1</span>]);</span><br><span class="line">            ls.insert(it, vec);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(ls.begin(), ls.end());</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="910-最小差值-II"><a href="#910-最小差值-II" class="headerlink" title="910. 最小差值 II"></a>910. 最小差值 II</h2><p><strong>Description</strong><br>给定一个整数数组 A，对于每个整数 A[i]，我们可以选择 x = -K 或是 x = K，并将 x 加到 A[i] 中。<br>在此过程之后，我们得到一些数组 B。<br>返回 B 的最大值和 B 的最小值之间可能存在的最小差值。<br><strong>Example</strong><br>示例 1：<br>输入：A = [1], K = 0<br>输出：0<br>解释：B = [1]</p>
<p>示例 2：<br>输入：A = [0,10], K = 2<br>输出：6<br>解释：B = [2,8]</p>
<p>示例 3：<br>输入：A = [1,3,6], K = 3<br>输出：3<br>解释：B = [4,6,3]</p>
<p>提示：<br>1 &lt;= A.length &lt;= 10000<br>0 &lt;= A[i] &lt;= 10000<br>0 &lt;= K &lt;= 10000<br><strong>Program</strong><br><img src="/assets/img/algorithm/910_example_01.png" alt="image"><br>当我们选择在 i 这一点“切一刀”的时候，也就是 A[0] ~ A[i] 的元素都上移，A[i + 1] ~ A[A.length - 1] 的元素都下移。<br>此时 B 点的值是 A[i] + K，D 点的值是 A[A.length - 1] - K。<br>新数组的最大值要么是 B 点要么是 D 点，也就是说新数组的最大值是 $Max(A[i] + K, A[A.length - 1] - K)$。</p>
<p>同样道理，此时 A 点的值是 A[0] + K，C 点的值是 A[i + 1] - K。<br>新数组的最小值要么是 A 点要么是 C 点，也就是说新数组的最小值是 $Min(A[0] + K, A[i + 1] - K)$。</p>
<p>因此，题目需要的“新数组的最大值和最小值的差值”，就是 $Max(A[i] + K, A[A.length - 1] - K) - Min(A[0] + K, A[i + 1] - K)$。<br>K 的值是题目给出的固定值，因此如果我们想让上面这个算式的结果尽可能小的话，就要靠改变 i 的值，也就是思考究竟要在哪里“切这一刀”。因此我们挨个遍历一下所有可能的 i 的值，然后取上面算式的最小值即可。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">smallestRangeII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>{</span><br><span class="line">        sort(A.begin(), A.end());</span><br><span class="line">        <span class="keyword">int</span> ans=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();i++){</span><br><span class="line">            <span class="keyword">int</span> mx=max(A[i]+K, A[A.size()<span class="number">-1</span>]-K);</span><br><span class="line">            <span class="keyword">int</span> mn=(i+<span class="number">1</span>&gt;=A.size())?A[<span class="number">0</span>]+K:min(A[<span class="number">0</span>]+K, A[i+<span class="number">1</span>]-K);</span><br><span class="line">            ans=min(ans, mx-mn);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="921-使括号有效的最少添加"><a href="#921-使括号有效的最少添加" class="headerlink" title="921. 使括号有效的最少添加"></a>921. 使括号有效的最少添加</h2><p><strong>Description</strong><br>给定一个由’(‘ 和 ‘)’括号组成的字符串 S，我们需要添加最少的括号（ ‘(‘ 或是 ‘)’，可以在任何位置），以使得到的括号字符串有效。<br>从形式上讲，只有满足下面几点之一，括号字符串才是有效的：它是一个空字符串，或者它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者<br>它可以被写作 (A)，其中 A 是有效字符串。给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。<br><strong>Example</strong><br>示例 1：<br>输入：”())”<br>输出：1</p>
<p>示例 2：<br>输入：”(((“<br>输出：3</p>
<p>示例 3：<br>输入：”()”<br>输出：0</p>
<p>示例 4：<br>输入：”()))((“<br>输出：4</p>
<p>提示：<br>S.length &lt;= 1000<br>S 只包含 ‘(‘ 和 ‘)’ 字符。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAddToMakeValid</span><span class="params">(<span class="built_in">string</span> S)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:S){</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">'('</span>) l++; <span class="comment">//进栈</span></span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">if</span>(l&gt;<span class="number">0</span>) l--; <span class="comment">//出栈</span></span><br><span class="line">                <span class="keyword">else</span> r++; <span class="comment">//进栈</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> l+r;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a>435. 无重叠区间</h2><p><strong>Description</strong><br>给定个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。<br>注意:</p>
<ul>
<li>可以认为区间的终点总是大于它的起点。</li>
<li>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</li>
</ul>
<p><strong>Example</strong><br>示例 1:<br>输入: [ [1,2], [2,3], [3,4], [1,3] ]<br>输出: 1<br>解释: 移除 [1,3] 后，剩下的区间没有重叠。</p>
<p>示例 2:<br>输入: [ [1,2], [1,2], [1,2] ]<br>输出: 2<br>解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</p>
<p>示例 3:<br>输入: [ [1,2], [2,3] ]<br>输出: 0<br>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。<br><strong>Program</strong><br>正确的思路其实很简单，可以分为以下三步：</p>
<ul>
<li>从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中结束最早的（end 最小）。</li>
<li>把所有与 x 区间相交的区间从区间集合 intvs 中删除。</li>
<li>重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(intervals.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b){</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>]&lt;b[<span class="number">1</span>];</span><br><span class="line">        });</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre=intervals[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;intervals.size();i++){</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur=intervals[i];</span><br><span class="line">            <span class="keyword">if</span>(cur[<span class="number">0</span>]&gt;=pre[<span class="number">1</span>]){</span><br><span class="line">                ans++;</span><br><span class="line">                pre=cur;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> intervals.size()-ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h2></li>
</ul>
<p><strong>Description</strong><br>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。<br>一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。<br><strong>Example</strong><br>输入:<br>[[10,16], [2,8], [1,6], [7,12]]<br>输出:<br>2</p>
<p>解释:<br>对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。<br><strong>Program</strong><br>贪心：无重叠区间个数！！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(points.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sort(points.begin(), points.end(), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b){</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>]&lt;b[<span class="number">1</span>];</span><br><span class="line">        });</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre=points[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;points.size();i++){</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur=points[i];</span><br><span class="line">            <span class="keyword">if</span>(pre[<span class="number">1</span>]&lt;cur[<span class="number">0</span>]){</span><br><span class="line">                ans++;</span><br><span class="line">                pre=cur;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1433-检查一个字符串是否可以打破另一个字符串"><a href="#1433-检查一个字符串是否可以打破另一个字符串" class="headerlink" title="1433. 检查一个字符串是否可以打破另一个字符串"></a>1433. 检查一个字符串是否可以打破另一个字符串</h2><p><strong>Description</strong><br>给你两个字符串 s1 和 s2 ，它们长度相等，请你检查是否存在一个 s1  的排列可以打破 s2 的一个排列，或者是否存在一个 s2 的排列可以打破 s1 的一个排列。<br>字符串 x 可以打破字符串 y （两者长度都为 n ）需满足对于所有 i（在 0 到 n - 1 之间）都有 x[i] &gt;= y[i]（字典序意义下的顺序）。<br><strong>Example</strong><br>示例 1：<br>输入：s1 = “abc”, s2 = “xya”<br>输出：true<br>解释：”ayx” 是 s2=”xya” 的一个排列，”abc” 是字符串 s1=”abc” 的一个排列，且 “ayx” 可以打破 “abc” 。</p>
<p>示例 2：<br>输入：s1 = “abe”, s2 = “acd”<br>输出：false<br>解释：s1=”abe” 的所有排列包括：”abe”，”aeb”，”bae”，”bea”，”eab” 和 “eba” ，s2=”acd” 的所有排列包括：”acd”，”adc”，”cad”，”cda”，”dac” 和 “dca”。然而没有任何 s1 的排列可以打破 s2 的排列。也没有 s2 的排列能打破 s1 的排列。</p>
<p>示例 3：<br>输入：s1 = “leetcodee”, s2 = “interview”<br>输出：true</p>
<p>提示：<br>s1.length == n<br>s2.length == n<br>1 &lt;= n &lt;= 10^5<br>所有字符串都只包含小写英文字母。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkIfCanBreak</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>{</span><br><span class="line">        sort(s1.begin(), s1.end());</span><br><span class="line">        sort(s2.begin(), s2.end());</span><br><span class="line">        <span class="comment">//cout&lt;&lt;s1&lt;&lt;endl&lt;&lt;s2&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>, b=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s1.length();i++){</span><br><span class="line">            <span class="keyword">if</span>(s1[i]&lt;=s2[i]) b++;</span><br><span class="line">            <span class="keyword">if</span>(s1[i]&gt;=s2[i]) a++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> b==s1.length()||a==s1.length();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>cnt数组合理的情况应该是这样的（不考虑0）：<br>①–++<br>②++–<br>③-+-+<br>④+-+-<br>不可能的是：+–+/-++-，即sum在整个过程中不能变号！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkIfCanBreak</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">26</span>] = { <span class="number">0</span> };</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.size(); ++i) {</span><br><span class="line">            --cnt[s1[i] - <span class="string">'a'</span>];</span><br><span class="line">            ++cnt[s2[i] - <span class="string">'a'</span>];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> big1 = <span class="literal">true</span>, big2 = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">25</span>; i &gt;= <span class="number">0</span>; --i) {</span><br><span class="line">            sum += cnt[i];</span><br><span class="line">            <span class="keyword">if</span> (big1 &amp;&amp; sum &gt; <span class="number">0</span>) big1 = <span class="literal">false</span>;  <span class="comment">//如果s1更大，sum在整个过程中&lt;=0</span></span><br><span class="line">            <span class="keyword">if</span> (big2 &amp;&amp; sum &lt; <span class="number">0</span>) big2 = <span class="literal">false</span>;  <span class="comment">//如果s2更大，sum在整个过程中&gt;=0</span></span><br><span class="line">            <span class="keyword">if</span> (!big1 &amp;&amp; !big2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum==<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkIfCanBreak</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">26</span>] = { <span class="number">0</span> };</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.size(); ++i) {</span><br><span class="line">            --cnt[s1[i] - <span class="string">'a'</span>];</span><br><span class="line">            ++cnt[s2[i] - <span class="string">'a'</span>];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> label=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> big1 = <span class="literal">true</span>, big2 = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">26</span>; i++) {</span><br><span class="line">            sum += cnt[i];</span><br><span class="line">            <span class="keyword">if</span>(flag&amp;&amp;sum!=<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;<span class="number">0</span>) label=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>) label=<span class="number">-1</span>;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(!flag&amp;&amp;sum!=<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;<span class="number">0</span>&amp;&amp;label==<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//sum变号</span></span><br><span class="line">                <span class="keyword">if</span>(sum&lt;<span class="number">0</span>&amp;&amp;label==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//sum变号</span></span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// if (big1 &amp;&amp; sum &gt; 0) big1 = false;  //如果s1更大，sum在整个过程中&lt;=0</span></span><br><span class="line">            <span class="comment">// if (big2 &amp;&amp; sum &lt; 0) big2 = false;  //如果s2更大，sum在整个过程中&gt;=0</span></span><br><span class="line">            <span class="comment">// if (!big1 &amp;&amp; !big2) return false;</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="944-删列造序"><a href="#944-删列造序" class="headerlink" title="944. 删列造序"></a>944. 删列造序</h2><p><strong>Description</strong><br>给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。<br>你需要选出一组要删掉的列 D，对 A 执行删除操作，使 A 中剩余的每一列都是 非降序 排列的，然后请你返回 D.length 的最小可能值。<br>删除 操作的定义是：选出一组要删掉的列，删去 A 中对应列中的所有字符，形式上，第 n 列为 [A[0][n], A[1][n], …, A[A.length-1][n]]）。<br>比如，有 A = [“abcdef”, “uvwxyz”]，<br><img src="/assets/img/algorithm/944_1.png" alt="image"><br>要删掉的列为 {0, 2, 3}，删除后 A 为[“bef”, “vyz”]， A 的列分别为[“b”,”v”], [“e”,”y”], [“f”,”z”]。<br><img src="/assets/img/algorithm/944_2.png" alt="image"><br><strong>Example</strong><br>示例 1：<br>输入：[“cba”, “daf”, “ghi”]<br>输出：1<br>解释：<br>当选择 D = {1}，删除后 A 的列为：[“c”,”d”,”g”] 和 [“a”,”f”,”i”]，均为非降序排列。<br>若选择 D = {}，那么 A 的列 [“b”,”a”,”h”] 就不是非降序排列了。</p>
<p>示例 2：<br>输入：[“a”, “b”]<br>输出：0<br>解释：D = {}</p>
<p>示例 3：<br>输入：[“zyx”, “wvu”, “tsr”]<br>输出：3<br>解释：D = {0, 1, 2}</p>
<p>提示：<br>1 &lt;= A.length &lt;= 100<br>1 &lt;= A[i].length &lt;= 1000<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDeletionSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(A.size()==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rows=A.size();</span><br><span class="line">        <span class="keyword">int</span> cols=A[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;cols;col++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;rows<span class="number">-1</span>;row++){</span><br><span class="line">                <span class="keyword">if</span>(A[row][col]&gt;A[row+<span class="number">1</span>][col]){</span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1247-交换字符使得字符串相同"><a href="#1247-交换字符使得字符串相同" class="headerlink" title="1247. 交换字符使得字符串相同"></a>1247. 交换字符使得字符串相同</h2><p><strong>Description</strong><br>有两个长度相同的字符串 s1 和 s2，且它们其中 只含有 字符 “x” 和 “y”，你需要通过「交换字符」的方式使这两个字符串相同。<br>每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。<br>交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 s1[i] 和 s2[j]，但不能交换 s1[i] 和 s1[j]。<br>最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1 。<br><strong>Example</strong><br>示例 1：<br>输入：s1 = “xx”, s2 = “yy”<br>输出：1<br>解释：<br>交换 s1[0] 和 s2[1]，得到 s1 = “yx”，s2 = “yx”。</p>
<p>示例 2：<br>输入：s1 = “xy”, s2 = “yx”<br>输出：2<br>解释：<br>交换 s1[0] 和 s2[0]，得到 s1 = “yy”，s2 = “xx” 。<br>交换 s1[0] 和 s2[1]，得到 s1 = “xy”，s2 = “xy” 。<br>注意，你不能交换 s1[0] 和 s1[1] 使得 s1 变成 “yx”，因为我们只能交换属于两个不同字符串的字符。</p>
<p>示例 3：<br>输入：s1 = “xx”, s2 = “xy”<br>输出：-1</p>
<p>示例 4：<br>输入：s1 = “xxyyxyxyxx”, s2 = “xyyxyxxxyx”<br>输出：4</p>
<p>提示：<br>1 &lt;= s1.length, s2.length &lt;= 1000<br>s1, s2 只包含 ‘x’ 或 ‘y’。<br><strong>Program</strong><br>解题思路<br>1.拿到这个题第一念头是把字符串扫一遍，把差异项识别出来；稍微纸上画画就不难发现下面的规律：</p>
<ul>
<li>‘xx’与’yy’、’yy’与’xx’，他们之间仅需要1步即可完成满足题面的交换</li>
<li>‘xy’与’yx’、’yx’与’xy’，他们之间需要2步即可完成满足题面的交换</li>
</ul>
<p>2.假设我们把1中两种情况分开记录，当遇到s1[i] = ‘x’，s2[i] = ‘y’，我们记录到xyCnt中；当遇到s1[i] = ‘y’，s2[i] = ‘x’，我们记录到yxCnt中，那么我们只需要统计xyCnt和yxCnt的个数即可完成计算。<br>3.具体计算的规则：</p>
<ul>
<li>如果xyCnt+yxCnt是个奇数，那肯定是要返回-1的，因为肯定最右有两个字符是无法通过对调匹配的；</li>
<li>排除上面的条件后，xyCnt+yxCnt肯定是个偶数，那么又分两种情况，即“奇数+奇数”和“偶数+偶数”；</li>
<li>基于上面的分析，可以发现每2个xyCnt或yxCnt对应一次移动，1个xyCnt与1个yxCnt对应两次移动，详见代码中注释下面那段代码；<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumSwap</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> xyCnt=<span class="number">0</span>, yxCnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s1.length();i++){</span><br><span class="line">            <span class="keyword">if</span>(s1[i]==<span class="string">'x'</span>&amp;&amp;s2[i]==<span class="string">'y'</span>) xyCnt++;</span><br><span class="line">            <span class="keyword">if</span>(s1[i]==<span class="string">'y'</span>&amp;&amp;s2[i]==<span class="string">'x'</span>) yxCnt++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>((xyCnt+yxCnt)%<span class="number">2</span>!=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ans+=xyCnt/<span class="number">2</span>;</span><br><span class="line">        ans+=yxCnt/<span class="number">2</span>;</span><br><span class="line">        xyCnt%=<span class="number">2</span>;</span><br><span class="line">        yxCnt%=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(xyCnt!=<span class="number">0</span>) ans+=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="948-令牌放置"><a href="#948-令牌放置" class="headerlink" title="948. 令牌放置"></a>948. 令牌放置</h2></li>
</ul>
<p><strong>Description</strong><br>你的初始能量为 P，初始分数为 0，只有一包令牌。<br>令牌的值为 token[i]，每个令牌最多只能使用一次，可能的两种使用方法如下：<br>如果你至少有 token[i] 点能量，可以将令牌置为正面朝上，失去 token[i] 点能量，并得到 1 分。<br>如果我们至少有 1 分，可以将令牌置为反面朝上，获得 token[i] 点能量，并失去 1 分。<br>在使用任意数量的令牌后，返回我们可以得到的最大分数。<br><strong>Example</strong><br>示例 1：<br>输入：tokens = [100], P = 50<br>输出：0</p>
<p>示例 2：<br>输入：tokens = [100,200], P = 150<br>输出：1</p>
<p>示例 3：<br>输入：tokens = [100,200,300,400], P = 200<br>输出：2</p>
<p>提示：<br>tokens.length &lt;= 1000<br>0 &lt;= tokens[i] &lt; 10000<br>0 &lt;= P &lt; 10000<br><strong>Program</strong><br>贪心：从小到大尽可能获取分数，否则从大到小尽可能获取能量！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bagOfTokensScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tokens, <span class="keyword">int</span> P)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=tokens.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> scores=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        sort(tokens.begin(), tokens.end());</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right){</span><br><span class="line">            <span class="keyword">if</span>(P&gt;=tokens[left]){</span><br><span class="line">                P-=tokens[left++];</span><br><span class="line">                scores++;</span><br><span class="line">                ans=max(ans, scores);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">if</span>(scores&lt;=<span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">                P+=tokens[right--];</span><br><span class="line">                scores--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a>455. 分发饼干</h2><p><strong>Description</strong><br>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。<br>注意：<br>你可以假设胃口值为正。<br>一个小朋友最多只能拥有一块饼干。<br><strong>Example</strong><br>示例 1:<br>输入: [1,2,3], [1,1]<br>输出: 1</p>
<p>解释:<br>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>所以你应该输出1。</p>
<p>示例 2:<br>输入: [1,2], [1,2,3]<br>输出: 2</p>
<p>解释:<br>你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。<br>你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>所以你应该输出2.<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>{</span><br><span class="line">        sort(g.begin(), g.end());</span><br><span class="line">        sort(s.begin(), s.end());</span><br><span class="line">        <span class="keyword">int</span> gIdx=<span class="number">0</span>, sIdx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> gLen=g.size(), sLen=s.size();</span><br><span class="line">        <span class="keyword">while</span>(gIdx&lt;gLen&amp;&amp;sIdx&lt;sLen){</span><br><span class="line">            <span class="keyword">if</span>(s[sIdx]&gt;=g[gIdx]){</span><br><span class="line">                sIdx++;</span><br><span class="line">                gIdx++;</span><br><span class="line">            }<span class="keyword">else</span> sIdx++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> gIdx;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="955-删列造序-II"><a href="#955-删列造序-II" class="headerlink" title="955. 删列造序 II"></a>955. 删列造序 II</h2><p><strong>Description</strong><br>给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。<br>选取一个删除索引序列，对于 A 中的每个字符串，删除对应每个索引处的字符。<br>比如，有 A = [“abcdef”, “uvwxyz”]，删除索引序列 {0, 2, 3}，删除后 A 为[“bef”, “vyz”]。<br>假设，我们选择了一组删除索引 D，那么在执行删除操作之后，最终得到的数组的元素是按 字典序（A[0] &lt;= A[1] &lt;= A[2] … &lt;= A[A.length - 1]）排列的，然后请你返回 D.length 的最小可能值。<br><strong>Example</strong><br>示例 1：<br>输入：[“ca”,”bb”,”ac”]<br>输出：1<br>解释：<br>删除第一列后，A = [“a”, “b”, “c”]。<br>现在 A 中元素是按字典排列的 (即，A[0] &lt;= A[1] &lt;= A[2])。<br>我们至少需要进行 1 次删除，因为最初 A 不是按字典序排列的，所以答案是 1。</p>
<p>示例 2：<br>输入：[“xc”,”yb”,”za”]<br>输出：0<br>解释：<br>A 的列已经是按字典序排列了，所以我们不需要删除任何东西。<br>注意 A 的行不需要按字典序排列。<br>也就是说，A[0][0] &lt;= A[0][1] &lt;= … 不一定成立。</p>
<p>示例 3：<br>输入：[“zyx”,”wvu”,”tsr”]<br>输出：3<br>解释：<br>我们必须删掉每一列。</p>
<p>提示：<br>1 &lt;= A.length &lt;= 100<br>1 &lt;= A[i].length &lt;= 100<br><strong>Program</strong><br>贪心：很容易分析出，两个相邻子串靠前一个字符如果满足要求，那么有两种情况：</p>
<ul>
<li>①两字符相等，则必须继续比较两字符串后面的字符是否满足要求；</li>
<li>②前一个字符串的字符比后一个严格小，则不用继续比较后面的字符了！</li>
</ul>
<p><strong>问题在于如何代码表示这种情况。</strong><br>开一个表示各行字符串是否继续比较的数组，先按列判断每行是否升序，如果升序，再确定哪些行可以不用再比较后面的字符。<br>例如：<br>abx<br>agz<br>bgc<br>bfc<br>①比较第一列，满足升序，再确定哪些行不用再次比对后续字符，可以发现第二行和第三行不用继续比对了！记录vis[2]=false即可<br>②比较第二列，不满足升序，继续下一列比较；<br>③比较第三列，满足升序，现需要继续比较12,34行，确定不用再次对比行，发现第12行不用继续比对了！记录vis[1]=false即可<br>当所有行不用比较或所有列对比完了结束。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDeletionSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> rows=A.size();</span><br><span class="line">        <span class="keyword">int</span> cols=A[<span class="number">0</span>].length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis(rows, <span class="literal">true</span>); <span class="comment">//记录哪些行需要进一步比较</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;cols;col++){</span><br><span class="line">            <span class="keyword">bool</span> bPass=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;rows<span class="number">-1</span>;row++){</span><br><span class="line">                <span class="keyword">if</span>(vis[row]&amp;&amp;A[row][col]&gt;A[row+<span class="number">1</span>][col]){</span><br><span class="line">                    ans++;</span><br><span class="line">                    bPass=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(!bPass) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;rows<span class="number">-1</span>;row++){</span><br><span class="line">                <span class="keyword">if</span>(A[row][col]&lt;A[row+<span class="number">1</span>][col]){</span><br><span class="line">                    vis[row]=<span class="literal">false</span>; <span class="comment">//该行比下一行第一个字符严格小，不用再次比较</span></span><br><span class="line">                    cnt++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(cnt==rows<span class="number">-1</span>){</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="984-不含-AAA-或-BBB-的字符串"><a href="#984-不含-AAA-或-BBB-的字符串" class="headerlink" title="984. 不含 AAA 或 BBB 的字符串"></a>984. 不含 AAA 或 BBB 的字符串</h2><p><strong>Description</strong><br>给定两个整数 A 和 B，返回任意字符串 S，要求满足：</p>
<ul>
<li>S 的长度为 A + B，且正好包含 A 个 ‘a’ 字母与 B 个 ‘b’ 字母；</li>
<li>子串 ‘aaa’ 没有出现在 S 中；</li>
<li>子串 ‘bbb’ 没有出现在 S 中。</li>
</ul>
<p><strong>Example</strong><br>示例 1：<br>输入：A = 1, B = 2<br>输出：”abb”<br>解释：”abb”, “bab” 和 “bba” 都是正确答案。</p>
<p>示例 2：<br>输入：A = 4, B = 1<br>输出：”aabaa”</p>
<p>提示：<br>0 &lt;= A &lt;= 100<br>0 &lt;= B &lt;= 100<br>对于给定的 A 和 B，保证存在满足要求的 S。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">char</span> Ch, <span class="keyword">int</span> Count):ch(Ch),count(Count){}</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; tmp) <span class="keyword">const</span>{</span><br><span class="line">            <span class="keyword">return</span> count&lt;tmp.count;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">strWithout3a3b</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>{</span><br><span class="line">        <span class="function">Node <span class="title">a</span><span class="params">(<span class="string">'a'</span>, A)</span></span>;</span><br><span class="line">        <span class="function">Node <span class="title">b</span><span class="params">(<span class="string">'b'</span>, B)</span></span>;</span><br><span class="line">        priority_queue&lt;Node&gt; pq;</span><br><span class="line">        pq.push(a);pq.push(b);</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty()){</span><br><span class="line">            Node now=pq.top();pq.pop();</span><br><span class="line">            <span class="keyword">int</span> len=res.length();</span><br><span class="line">            <span class="keyword">if</span>(len&gt;=<span class="number">2</span>&amp;&amp;res[len<span class="number">-1</span>]==res[len<span class="number">-2</span>]&amp;&amp;res[len<span class="number">-1</span>]==now.ch){</span><br><span class="line">                <span class="keyword">if</span>(pq.empty()) <span class="keyword">break</span>;</span><br><span class="line">                Node next=pq.top();pq.pop();</span><br><span class="line">                res+=next.ch;</span><br><span class="line">                next.count--;</span><br><span class="line">                <span class="keyword">if</span>(next.count&gt;<span class="number">0</span>) pq.push(next);</span><br><span class="line">                pq.push(now);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                res+=now.ch;</span><br><span class="line">                now.count--;</span><br><span class="line">                <span class="keyword">if</span>(now.count&gt;<span class="number">0</span>) pq.push(now);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//cout&lt;&lt;res&lt;&lt;endl;</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="991-坏了的计算器"><a href="#991-坏了的计算器" class="headerlink" title="991. 坏了的计算器"></a>991. 坏了的计算器</h2><p><strong>Description</strong><br>在显示着数字的坏计算器上，我们可以执行以下两种操作：</p>
<ul>
<li>双倍（Double）：将显示屏上的数字乘 2；</li>
<li>递减（Decrement）：将显示屏上的数字减 1 。<br>最初，计算器显示数字 X。</li>
</ul>
<p>返回显示数字 Y 所需的最小操作数。<br><strong>Example</strong><br>示例 1：<br>输入：X = 2, Y = 3<br>输出：2<br>解释：先进行双倍运算，然后再进行递减运算 {2 -&gt; 4 -&gt; 3}.</p>
<p>示例 2：<br>输入：X = 5, Y = 8<br>输出：2<br>解释：先递减，再双倍 {5 -&gt; 4 -&gt; 8}.</p>
<p>示例 3：<br>输入：X = 3, Y = 10<br>输出：3<br>解释：先双倍，然后递减，再双倍 {3 -&gt; 6 -&gt; 5 -&gt; 10}.</p>
<p>示例 4：<br>输入：X = 1024, Y = 1<br>输出：1023<br>解释：执行递减运算 1023 次</p>
<p>提示：<br>1 &lt;= X &lt;= 10^9<br>1 &lt;= Y &lt;= 10^9<br><strong>Program</strong><br>思路<br>除了对 X 执行乘 2 或 减 1 操作之外，我们也可以对 Y 执行除 2（当 Y 是偶数时）或者加 1 操作。<br>这样做的动机是我们可以总是贪心地执行除 2 操作：</p>
<ul>
<li>当 Y 是偶数，如果先执行 2 次加法操作，再执行 1 次除法操作，我们可以通过先执行 1 次除法操作，再执行 1 次加法操作以使用更少的操作次数得到相同的结果 [(Y+2) / 2 vs Y/2 + 1]。</li>
<li>当 Y 是奇数，如果先执行 3 次加法操作，再执行 1 次除法操作，我们可以将其替代为顺次执行加法、除法、加法操作以使用更少的操作次数得到相同的结果 [(Y+3) / 2 vs (Y+1) / 2 + 1]。<br>算法<br>当 Y 大于 X 时，如果它是奇数，我们执行加法操作，否则执行除法操作。之后，我们需要执行 X - Y 次加法操作以得到 X。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">brokenCalc</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Y)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(Y&gt;X){</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">if</span>((Y&amp;<span class="number">1</span>)==<span class="number">0</span>){</span><br><span class="line">                Y/=<span class="number">2</span>;</span><br><span class="line">            }<span class="keyword">else</span> Y++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans+X-Y;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1276-不浪费原料的汉堡制作方案"><a href="#1276-不浪费原料的汉堡制作方案" class="headerlink" title="1276. 不浪费原料的汉堡制作方案"></a>1276. 不浪费原料的汉堡制作方案</h2><p><strong>Description</strong><br>圣诞活动预热开始啦，汉堡店推出了全新的汉堡套餐。为了避免浪费原料，请你帮他们制定合适的制作计划。<br>给你两个整数 tomatoSlices 和 cheeseSlices，分别表示番茄片和奶酪片的数目。不同汉堡的原料搭配如下：</p>
<ul>
<li>巨无霸汉堡：4 片番茄和 1 片奶酪</li>
<li>小皇堡：2 片番茄和 1 片奶酪<br>请你以 [total_jumbo, total_small]（[巨无霸汉堡总数，小皇堡总数]）的格式返回恰当的制作方案，使得剩下的番茄片 tomatoSlices 和奶酪片 cheeseSlices 的数量都是 0。</li>
</ul>
<p>如果无法使剩下的番茄片 tomatoSlices 和奶酪片 cheeseSlices 的数量为 0，就请返回 []。<br><strong>Example</strong><br>示例 1：<br>输入：tomatoSlices = 16, cheeseSlices = 7<br>输出：[1,6]<br>解释：制作 1 个巨无霸汉堡和 6 个小皇堡需要 4<em>1 + 2</em>6 = 16 片番茄和 1 + 6 = 7 片奶酪。不会剩下原料。</p>
<p>示例 2：<br>输入：tomatoSlices = 17, cheeseSlices = 4<br>输出：[]<br>解释：只制作小皇堡和巨无霸汉堡无法用光全部原料。</p>
<p>示例 3：<br>输入：tomatoSlices = 4, cheeseSlices = 17<br>输出：[]<br>解释：制作 1 个巨无霸汉堡会剩下 16 片奶酪，制作 2 个小皇堡会剩下 15 片奶酪。</p>
<p>示例 4：<br>输入：tomatoSlices = 0, cheeseSlices = 0<br>输出：[0,0]</p>
<p>示例 5：<br>输入：tomatoSlices = 2, cheeseSlices = 1<br>输出：[0,1]</p>
<p>提示：<br>0 &lt;= tomatoSlices &lt;= 10^7<br>0 &lt;= cheeseSlices &lt;= 10^7<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numOfBurgers(<span class="keyword">int</span> tomatoSlices, <span class="keyword">int</span> cheeseSlices) {</span><br><span class="line">        <span class="keyword">if</span>(tomatoSlices%<span class="number">2</span>!=<span class="number">0</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="keyword">int</span> x=tomatoSlices/<span class="number">2</span>-cheeseSlices;</span><br><span class="line">        <span class="keyword">int</span> y=<span class="number">2</span>*cheeseSlices-tomatoSlices/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;y&gt;=<span class="number">0</span>) <span class="keyword">return</span> {x, y};</span><br><span class="line">        <span class="keyword">return</span> {};</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1253-重构-2-行二进制矩阵"><a href="#1253-重构-2-行二进制矩阵" class="headerlink" title="1253. 重构 2 行二进制矩阵"></a>1253. 重构 2 行二进制矩阵</h2><p><strong>Description</strong><br>给你一个 2 行 n 列的二进制数组：</p>
<ul>
<li>矩阵是一个二进制矩阵，这意味着矩阵中的每个元素不是 0 就是 1。</li>
<li>第 0 行的元素之和为 upper。</li>
<li>第 1 行的元素之和为 lower。</li>
<li>第 i 列（从 0 开始编号）的元素之和为 colsum[i]，colsum 是一个长度为 n 的整数数组。<br>你需要利用 upper，lower 和 colsum 来重构这个矩阵，并以二维整数数组的形式返回它。<br>如果有多个不同的答案，那么任意一个都可以通过本题。<br>如果不存在符合要求的答案，就请返回一个空的二维数组。</li>
</ul>
<p><strong>Example</strong><br>示例 1：<br>输入：upper = 2, lower = 1, colsum = [1,1,1]<br>输出：[[1,1,0],[0,0,1]]<br>解释：[[1,0,1],[0,1,0]] 和 [[0,1,1],[1,0,0]] 也是正确答案。</p>
<p>示例 2：<br>输入：upper = 2, lower = 3, colsum = [2,2,1,1]<br>输出：[]</p>
<p>示例 3：<br>输入：upper = 5, lower = 5, colsum = [2,1,2,0,1,0,1,2,0,1]<br>输出：[[1,1,1,0,1,0,0,1,0,0],[1,0,1,0,0,0,1,1,0,1]]</p>
<p>提示：<br>1 &lt;= colsum.length &lt;= 10^5<br>0 &lt;= upper, lower &lt;= colsum.length<br>0 &lt;= colsum[i] &lt;= 2<br><strong>Program</strong><br>先安排colsum[i]=2的位置，而后安排colsum[i]=1的位置。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; reconstructMatrix(<span class="keyword">int</span> upper, <span class="keyword">int</span> lower, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; colsum) {</span><br><span class="line">        <span class="keyword">int</span> cols=colsum.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cols, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nTwo=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis(cols, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cols;i++){</span><br><span class="line">            sum+=colsum[i];</span><br><span class="line">            <span class="keyword">if</span>(colsum[i]==<span class="number">2</span>){</span><br><span class="line">                res[<span class="number">0</span>][i]=res[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">                nTwo++;</span><br><span class="line">                vis[i]=<span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(sum!=upper+lower) <span class="keyword">return</span> {};</span><br><span class="line">        upper-=nTwo;</span><br><span class="line">        lower-=nTwo;</span><br><span class="line">        <span class="keyword">if</span>(upper&lt;<span class="number">0</span>||lower&lt;<span class="number">0</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cols;i++){</span><br><span class="line">            <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(colsum[i]==<span class="number">1</span>){</span><br><span class="line">                <span class="keyword">if</span>(upper&gt;<span class="number">0</span>){</span><br><span class="line">                    res[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">                    upper--;</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span>(lower&gt;<span class="number">0</span>){</span><br><span class="line">                    res[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">                    lower--;</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">return</span> {};</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1005-K-次取反后最大化的数组和"><a href="#1005-K-次取反后最大化的数组和" class="headerlink" title="1005. K 次取反后最大化的数组和"></a>1005. K 次取反后最大化的数组和</h2><p><strong>Description</strong><br>给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）<br>以这种方式修改数组后，返回数组可能的最大和。<br><strong>Example</strong><br>示例 1：<br>输入：A = [4,2,3], K = 1<br>输出：5<br>解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。</p>
<p>示例 2：<br>输入：A = [3,-1,0,2], K = 3<br>输出：6<br>解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。</p>
<p>示例 3：<br>输入：A = [2,-3,-1,5,-4], K = 2<br>输出：13<br>解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。</p>
<p>提示：<br>1 &lt;= A.length &lt;= 10000<br>1 &lt;= K &lt;= 10000<br>-100 &lt;= A[i] &lt;= 100<br><strong>Program</strong><br>设负数个数为nF,零个数为nZ：<br>①nF==0，选择最小值操作K-nF次；<br>②nF&lt;K，且nZ=0，选择最小的nF个负数进行操作，选择绝对值最小的数进行剩余K-nF次操作；<br>③nF&lt;K，且nZ&gt;0，选择最小的nF个负数进行操作，对0进行K-nF操作，数组全正数；<br>③nF=K，选择最小的nF个负数进行操作，数组全正数；<br>④nF&gt;K，选择最小的nF个负数进行操作。<br>综上：只需要对数组从小到大排序，对前min(nF,K)进行操作，判断数组中零的个数，以及记录绝对值最小的位置。<br>判断K-nF大小，若K-nF&gt;0且nZ！=0就要对绝对值最小的值进行剩余K-nF次操作。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>{</span><br><span class="line">        sort(A.begin(), A.end());</span><br><span class="line">        <span class="keyword">int</span> nZero=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minAbs=INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> minIdx=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(A[i]&lt;<span class="number">0</span>&amp;&amp;K&gt;<span class="number">0</span>){</span><br><span class="line">                A[i]=-A[i];</span><br><span class="line">                 K--;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(A[i]==<span class="number">0</span>) nZero++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(A[i])&lt;minAbs){</span><br><span class="line">                minAbs=<span class="built_in">abs</span>(A[i]);</span><br><span class="line">                minIdx=i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(K&gt;<span class="number">0</span>&amp;&amp;nZero==<span class="number">0</span>){</span><br><span class="line">            A[minIdx]=A[minIdx]*((<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">-1</span>, K%<span class="number">2</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();i++) sum+=A[i];</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>


<h2 id="537-复数乘法"><a href="#537-复数乘法" class="headerlink" title="537. 复数乘法"></a>537. 复数乘法</h2><p><strong>Description</strong><br>给定两个表示复数的字符串。<br>返回表示它们乘积的字符串。注意，根据定义 i2 = -1 。<br><strong>Example</strong><br>示例 1:<br>输入: “1+1i”, “1+1i”<br>输出: “0+2i”<br>解释: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i ，你需要将它转换为 0+2i 的形式。</p>
<p>示例 2:<br>输入: “1+-1i”, “1+-1i”<br>输出: “0+-2i”<br>解释: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i ，你需要将它转换为 0+-2i 的形式。</p>
<p>注意:<br>输入字符串不包含额外的空格。<br>输入字符串将以 a+bi 的形式给出，其中整数 a 和 b 的范围均在 [-100, 100] 之间。输出也应当符合这种形式。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sToi</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++){</span><br><span class="line">            ans=ans*<span class="number">10</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">iTos</span><span class="params">(<span class="keyword">int</span> a)</span></span>{</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;<span class="number">0</span>) {flag=<span class="number">-1</span>;a=-a;}</span><br><span class="line">        <span class="keyword">while</span>(a!=<span class="number">0</span>){</span><br><span class="line">            res+=a%<span class="number">10</span>+<span class="string">'0'</span>;</span><br><span class="line">            a/=<span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">-1</span>) res=<span class="string">"-"</span>+res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; process(<span class="built_in">string</span> str){</span><br><span class="line">        <span class="keyword">int</span> idx=str.find(<span class="string">'+'</span>);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;idx&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">string</span> sa=str.substr(<span class="number">0</span>, idx);</span><br><span class="line">        <span class="built_in">string</span> sb=str.substr(idx+<span class="number">1</span>, str.length()-idx<span class="number">-2</span>);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;sa&lt;&lt;" "&lt;&lt;sb&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">int</span> flagA=<span class="number">1</span>,flagB=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(sa[<span class="number">0</span>]==<span class="string">'-'</span>){flagA=<span class="number">-1</span>; sa=sa.substr(<span class="number">1</span>);}</span><br><span class="line">        <span class="keyword">if</span>(sb[<span class="number">0</span>]==<span class="string">'-'</span>){flagB=<span class="number">-1</span>; sb=sb.substr(<span class="number">1</span>);}</span><br><span class="line">        <span class="keyword">int</span> a=sToi(sa);</span><br><span class="line">        <span class="keyword">int</span> b=sToi(sb);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;a*flagA&lt;&lt;" "&lt;&lt;b*flagB&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span> {a*flagA, b*flagB};</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">complexNumberMultiply</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>{</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pa=process(a);</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pb=process(b);</span><br><span class="line">        <span class="keyword">int</span> aa=pa.first*pb.first-pa.second*pb.second;</span><br><span class="line">        <span class="keyword">int</span> bb=pa.first*pb.second+pa.second*pb.first;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;aa&lt;&lt;":"&lt;&lt;bb&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        res=iTos(aa)+<span class="string">"+"</span>+iTos(bb)+<span class="string">"i"</span>;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;res&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// int sToi(string str){</span></span><br><span class="line">    <span class="comment">//     int ans=0;</span></span><br><span class="line">    <span class="comment">//     for(int i=0;i&lt;str.length();i++){</span></span><br><span class="line">    <span class="comment">//         ans=ans*10+str[i]-'0';</span></span><br><span class="line">    <span class="comment">//     }</span></span><br><span class="line">    <span class="comment">//     return ans;</span></span><br><span class="line">    <span class="comment">// }</span></span><br><span class="line">    <span class="comment">// string iTos(int a){</span></span><br><span class="line">    <span class="comment">//     string res="";</span></span><br><span class="line">    <span class="comment">//     int flag=1;</span></span><br><span class="line">    <span class="comment">//     if(a==0) return "0";</span></span><br><span class="line">    <span class="comment">//     if(a&lt;0) {flag=-1;a=-a;}</span></span><br><span class="line">    <span class="comment">//     while(a!=0){</span></span><br><span class="line">    <span class="comment">//         res+=a%10+'0';</span></span><br><span class="line">    <span class="comment">//         a/=10;</span></span><br><span class="line">    <span class="comment">//     }</span></span><br><span class="line">    <span class="comment">//     reverse(res.begin(), res.end());</span></span><br><span class="line">    <span class="comment">//     if(flag==-1) res="-"+res;</span></span><br><span class="line">    <span class="comment">//     return res;</span></span><br><span class="line">    <span class="comment">// }</span></span><br><span class="line">    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; process(<span class="built_in">string</span> str){</span><br><span class="line">        <span class="keyword">int</span> idx=str.find(<span class="string">'+'</span>);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;idx&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">string</span> sa=str.substr(<span class="number">0</span>, idx);</span><br><span class="line">        <span class="built_in">string</span> sb=str.substr(idx+<span class="number">1</span>, str.length()-idx<span class="number">-2</span>);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;sa&lt;&lt;" "&lt;&lt;sb&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">int</span> flagA=<span class="number">1</span>,flagB=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(sa[<span class="number">0</span>]==<span class="string">'-'</span>){flagA=<span class="number">-1</span>; sa=sa.substr(<span class="number">1</span>);}</span><br><span class="line">        <span class="keyword">if</span>(sb[<span class="number">0</span>]==<span class="string">'-'</span>){flagB=<span class="number">-1</span>; sb=sb.substr(<span class="number">1</span>);}</span><br><span class="line">        <span class="keyword">int</span> a=stoi(sa);</span><br><span class="line">        <span class="keyword">int</span> b=stoi(sb);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;a*flagA&lt;&lt;" "&lt;&lt;b*flagB&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span> {a*flagA, b*flagB};</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">complexNumberMultiply</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>{</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pa=process(a);</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pb=process(b);</span><br><span class="line">        <span class="keyword">int</span> aa=pa.first*pb.first-pa.second*pb.second;</span><br><span class="line">        <span class="keyword">int</span> bb=pa.first*pb.second+pa.second*pb.first;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;aa&lt;&lt;":"&lt;&lt;bb&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        res=to_string(aa)+<span class="string">"+"</span>+to_string(bb)+<span class="string">"i"</span>;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;res&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1154-一年中的第几天"><a href="#1154-一年中的第几天" class="headerlink" title="1154. 一年中的第几天"></a>1154. 一年中的第几天</h2><p><strong>Description</strong><br>给你一个按 YYYY-MM-DD 格式表示日期的字符串 date，请你计算并返回该日期是当年的第几天。<br>通常情况下，我们认为 1 月 1 日是每年的第 1 天，1 月 2 日是每年的第 2 天，依此类推。每个月的天数与现行公元纪年法（格里高利历）一致。<br><strong>Example</strong><br>示例 1：<br>输入：date = “2019-01-09”<br>输出：9</p>
<p>示例 2：<br>输入：date = “2019-02-10”<br>输出：41</p>
<p>示例 3：<br>输入：date = “2003-03-01”<br>输出：60</p>
<p>示例 4：<br>输入：date = “2004-03-01”<br>输出：61</p>
<p>提示：<br>date.length == 10<br>date[4] == date[7] == ‘-‘，其他的 date[i] 都是数字。<br>date 表示的范围从 1900 年 1 月 1 日至 2019 年 12 月 31 日。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> month_days[<span class="number">2</span>][<span class="number">12</span>]={</span><br><span class="line">        <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>,</span><br><span class="line">        <span class="number">31</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>,</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLeepYear</span><span class="params">(<span class="keyword">int</span> year)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>((year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>)||(year%<span class="number">400</span>==<span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dayOfYear</span><span class="params">(<span class="built_in">string</span> date)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> idx1=date.find(<span class="string">'-'</span>);</span><br><span class="line">        <span class="keyword">int</span> year=stoi(date.substr(<span class="number">0</span>, idx1));</span><br><span class="line">        <span class="keyword">int</span> idx2=date.find(<span class="string">'-'</span>, idx1+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> month=stoi(date.substr(idx1+<span class="number">1</span>,idx2-idx1<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">int</span> day=stoi(date.substr(idx2+<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//cout&lt;&lt;year&lt;&lt;" "&lt;&lt;month&lt;&lt;" "&lt;&lt;day&lt;&lt;endl;</span></span><br><span class="line">        year=isLeepYear(year)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;month<span class="number">-1</span>;m++){</span><br><span class="line">            ans+=month_days[year][m];</span><br><span class="line">        }</span><br><span class="line">        ans+=day;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="976-三角形的最大周长"><a href="#976-三角形的最大周长" class="headerlink" title="976. 三角形的最大周长"></a>976. 三角形的最大周长</h2><p><strong>Description</strong><br>给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。<br>如果不能形成任何面积不为零的三角形，返回 0。<br><strong>Example</strong><br>示例 1：<br>输入：[2,1,2]<br>输出：5</p>
<p>示例 2：<br>输入：[1,2,1]<br>输出：0</p>
<p>示例 3：<br>输入：[3,2,3,4]<br>输出：10</p>
<p>示例 4：<br>输入：[3,6,2,3]<br>输出：8</p>
<p>提示：<br>3 &lt;= A.length &lt;= 10000<br>1 &lt;= A[i] &lt;= 10^6<br><strong>Program</strong><br>三角形中，较短的两条边之和必须大于第三条边。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>{</span><br><span class="line">        sort(A.begin(), A.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size()<span class="number">-2</span>;i++){</span><br><span class="line">            <span class="keyword">if</span>(A[i+<span class="number">2</span>]+A[i+<span class="number">1</span>]&gt;A[i]) <span class="keyword">return</span> A[i]+A[i+<span class="number">1</span>]+A[i+<span class="number">2</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="400-第N个数字"><a href="#400-第N个数字" class="headerlink" title="400. 第N个数字"></a>400. 第N个数字</h2><p><strong>Description</strong><br>在无限的整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …中找到第 n 个数字。<br>注意:<br>n 是正数且在32位整数范围内 ($n &lt; 2^{31}$)。<br><strong>Example</strong><br>示例 1:<br>输入:<br>3<br>输出:<br>3</p>
<p>示例 2:<br>输入:<br>11<br>输出:<br>0</p>
<p>说明:<br>第11个数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, … 里是0，它是10的一部分。<br><strong>Program</strong><br>$[0, 9]$ 这个区间，长度为9，每个数字只有1位，共有 $9 * 1$ 个数字<br>$[10, 99]$ 这个区间，长度为90，每个数字只有2位，共有 $90 * 2$ 个数字<br>$[100, 999]$ 这个区间，长度为900，每个数字只有3位，共有 $900 * 3$ 个数字<br>因此本题可以先得到数字所在的区间，然后再根据n和bit的关系找到具体的数字，最后在这个数字中找特定的那一位。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> bit=<span class="number">1</span>, count=<span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span>(n-bit*count&gt;<span class="number">0</span>){</span><br><span class="line">            n-=bit*count;</span><br><span class="line">            bit++;</span><br><span class="line">            count*=<span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> num=(<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">10</span>, bit<span class="number">-1</span>) + (n<span class="number">-1</span>)/bit;  <span class="comment">//n所在的数字</span></span><br><span class="line">        <span class="keyword">int</span> pos=(n<span class="number">-1</span>)%bit;  <span class="comment">//n所在该数字中的位置</span></span><br><span class="line">        <span class="built_in">string</span> str=to_string(num);</span><br><span class="line">        <span class="keyword">return</span> str[pos] - <span class="string">'0'</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="面试题67-把字符串转换成整数"><a href="#面试题67-把字符串转换成整数" class="headerlink" title="面试题67. 把字符串转换成整数"></a>面试题67. 把字符串转换成整数</h2><p><strong>Description</strong><br>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。<br>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。<br>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。<br>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 $[−2^{31},  2^{31} − 1]$。如果数值超过这个范围，请返回  INT_MAX ($2^{31} − 1$) 或 INT_MIN ($−2^{31}$) 。<br><strong>Example</strong><br>示例 1:<br>输入: “42”<br>输出: 42</p>
<p>示例 2:<br>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p>
<p>示例 3:<br>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p>
<p>示例 4:<br>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。</p>
<p>示例 5:<br>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN ($−2^{31}$) 。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">-1</span>, end=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[<span class="number">0</span>]==<span class="string">' '</span>) str.erase(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">//去掉前缀空格</span></span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">0</span>||!(str[<span class="number">0</span>]==<span class="string">'+'</span>||str[<span class="number">0</span>]==<span class="string">'-'</span>||(str[<span class="number">0</span>]&gt;=<span class="string">'0'</span>&amp;&amp;str[<span class="number">0</span>]&lt;=<span class="string">'9'</span>))) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'+'</span>) str.erase(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'-'</span>){flag=<span class="number">-1</span>;str.erase(<span class="number">0</span>, <span class="number">1</span>);}</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[idx]&gt;=<span class="string">'0'</span>&amp;&amp;str[idx]&lt;=<span class="string">'9'</span>){</span><br><span class="line">            <span class="keyword">if</span>(start==<span class="number">-1</span>){</span><br><span class="line">                start=idx;</span><br><span class="line">                end=idx;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                end++;</span><br><span class="line">            }</span><br><span class="line">            idx++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(start==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        str = str.substr(start, end-start+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++){</span><br><span class="line">            ans=ans*<span class="number">10</span>+flag*(str[i]-<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span>(ans&lt;INT_MIN) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            <span class="keyword">if</span>(ans&gt;INT_MAX) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="面试题-16-05-阶乘尾数"><a href="#面试题-16-05-阶乘尾数" class="headerlink" title="面试题 16.05. 阶乘尾数"></a>面试题 16.05. 阶乘尾数</h2><p><strong>Description</strong><br>设计一个算法，算出 n 阶乘有多少个尾随零。<br><strong>Example</strong><br>示例 1:<br>输入: 3<br>输出: 0<br>解释: 3! = 6, 尾数中没有零。</p>
<p>示例 2:<br>输入: 5<br>输出: 1<br>解释: 5! = 120, 尾数中有 1 个零.<br>说明: 你算法的时间复杂度应为 $O(log n)$ 。<br><strong>Program</strong><br>1、最初想到先把阶乘计算出来，再对结果进行处理，从而得到0的个数，但当计算完阶乘后，发现0的个数并不好获取。<br>2、之后考虑到，哪些数相乘会有零出现，也就是哪些数相乘会是10或10的倍数。也就得到2x5、4x5、6x5……会是10或10的倍数,也就是5和一个偶数相乘会得到10或10的倍数。<br>3、在数的阶乘中，偶数的个数明显多于5的个数，所以只要计算出阶乘中每个数的因数中5的个数，即可得到0的个数<br>4、所以只要计算在阶乘中是5的倍数的个数（包含一个5）、25的倍数的个数（包含两个5）、125的倍数的个数（包含3个5)…</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=n;i++){</span></span><br><span class="line">        <span class="comment">//     int x=i;</span></span><br><span class="line">        <span class="comment">//     while(x%5==0){</span></span><br><span class="line">        <span class="comment">//         ans++;</span></span><br><span class="line">        <span class="comment">//         x/=5;</span></span><br><span class="line">        <span class="comment">//     }</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>){</span><br><span class="line">            ans+=n/<span class="number">5</span>;</span><br><span class="line">            n/=<span class="number">5</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="面试题17-打印从1到最大的n位数"><a href="#面试题17-打印从1到最大的n位数" class="headerlink" title="面试题17. 打印从1到最大的n位数"></a>面试题17. 打印从1到最大的n位数</h2><p><strong>Description</strong><br>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。<br><strong>Example</strong><br>示例 1:<br>输入: n = 1<br>输出: [1,2,3,4,5,6,7,8,9]</p>
<p>说明：<br>用返回一个整数列表来代替打印<br>n 为正整数<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printNumbers(<span class="keyword">int</span> n) {</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">		<span class="comment">//打印到数组中</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,max=<span class="built_in">pow</span>(<span class="number">10</span>,n);i&lt;max;i++)</span><br><span class="line">		{</span><br><span class="line">			res.push_back(i);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="593-有效的正方形"><a href="#593-有效的正方形" class="headerlink" title="593. 有效的正方形"></a>593. 有效的正方形</h2><p><strong>Description</strong><br>给定二维空间中四点的坐标，返回四点是否可以构造一个正方形。<br>一个点的坐标（x，y）由一个有两个整数的整数数组表示。<br><strong>Example</strong><br>示例:<br>输入: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]<br>输出: True</p>
<p>注意:<br>所有输入整数都在 [-10000，10000] 范围内。<br>一个有效的正方形有四个等长的正长和四个等角（90度角）。<br>输入点没有顺序。<br><strong>Program</strong><br>有效的正方形，四条边相等，两条对角线长度也相等。计算这六个的长度，如果长度出现第三个不同值就说明不是正方形！当然也注意重点的情况！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calDis</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> (a[<span class="number">0</span>]-b[<span class="number">0</span>])*(a[<span class="number">0</span>]-b[<span class="number">0</span>])+(a[<span class="number">1</span>]-b[<span class="number">1</span>])*(a[<span class="number">1</span>]-b[<span class="number">1</span>]);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; p1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; p2, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; p3, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; p4)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">        vec.push_back(p1);</span><br><span class="line">        vec.push_back(p2);</span><br><span class="line">        vec.push_back(p3);</span><br><span class="line">        vec.push_back(p4);</span><br><span class="line">        <span class="comment">//可以是旋转的正方形！，所以比较坐标的方式不行</span></span><br><span class="line">        <span class="comment">// sort(vec.begin(), vec.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b){</span></span><br><span class="line">        <span class="comment">//     if(a[0]!=b[0]) return a[0]&lt;b[0];</span></span><br><span class="line">        <span class="comment">//     return a[1]&lt;b[1];</span></span><br><span class="line">        <span class="comment">// });</span></span><br><span class="line">        <span class="comment">// //两两点横坐标不相等</span></span><br><span class="line">        <span class="comment">// if(vec[0][0]!=vec[1][0]||vec[2][0]!=vec[3][0]) return false;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// if((vec[0][1]-vec[1][1])!=(vec[2][1]-vec[3][1])||(vec[0][0]-vec[2][0])!=(vec[1][0]-vec[3][0])) return false;</span></span><br><span class="line">        <span class="comment">// return true;</span></span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;<span class="number">4</span>;j++){</span><br><span class="line">                <span class="comment">//cout&lt;&lt;calDis(vec[i], vec[j])&lt;&lt;endl;</span></span><br><span class="line">                <span class="keyword">int</span> dis=calDis(vec[i], vec[j]);</span><br><span class="line">                <span class="keyword">if</span>(dis==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//有重合点！</span></span><br><span class="line">                s.insert(dis);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(s.size()&gt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="553-最优除法"><a href="#553-最优除法" class="headerlink" title="553. 最优除法"></a>553. 最优除法</h2><p><strong>Description</strong><br>给定一组正整数，相邻的整数之间将会进行浮点除法操作。例如， [2,3,4] -&gt; 2 / 3 / 4 。<br>但是，你可以在任意位置添加任意数目的括号，来改变算数的优先级。你需要找出怎么添加括号，才能得到最大的结果，并且返回相应的字符串格式的表达式。你的表达式不应该含有冗余的括号。<br><strong>Example</strong><br>示例：<br>输入: [1000,100,10,2]<br>输出: “1000/(100/10/2)”<br>解释:<br>1000/(100/10/2) = 1000/((100/10)/2) = 200<br>但是，以下加粗的括号 “1000/((100/10)/2)” 是冗余的，<br>因为他们并不影响操作的优先级，所以你需要返回 “1000/(100/10/2)”。<br>其他用例:<br>1000/(100/10)/2 = 50<br>1000/(100/(10/2)) = 50<br>1000/100/10/2 = 0.5<br>1000/100/(10/2) = 2</p>
<p>说明:<br>输入数组的长度在 [1, 10] 之间。<br>数组中每个元素的大小都在 [2, 1000] 之间。<br>每个测试用例只有一个最优除法解。<br><strong>Program</strong><br>分子不能变了，那么希望分母越小越好，当然是除了第一个外都整体做分子更好啦！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">optimalDivision</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(nums.size()&gt;<span class="number">2</span>&amp;&amp;i==<span class="number">1</span>) res+=<span class="string">'('</span>;</span><br><span class="line">            res=res+to_string(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i!=nums.size()<span class="number">-1</span>) res+=<span class="string">'/'</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums.size()&gt;<span class="number">2</span>&amp;&amp;i==nums.size()<span class="number">-1</span>) res+=<span class="string">')'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1362-最接近的因数"><a href="#1362-最接近的因数" class="headerlink" title="1362. 最接近的因数"></a>1362. 最接近的因数</h2><p><strong>Description</strong><br>给你一个整数 num，请你找出同时满足下面全部要求的两个整数：<br>两数乘积等于  num + 1 或 num + 2<br>以绝对差进行度量，两数大小最接近<br>你可以按任意顺序返回这两个整数。<br><strong>Example</strong><br>示例 1：<br>输入：num = 8<br>输出：[3,3]<br>解释：对于 num + 1 = 9，最接近的两个因数是 3 &amp; 3；对于 num + 2 = 10, 最接近的两个因数是 2 &amp; 5，因此返回 3 &amp; 3 。</p>
<p>示例 2：<br>输入：num = 123<br>输出：[5,25]</p>
<p>示例 3：<br>输入：num = 999<br>输出：[40,25]</p>
<p>提示：<br>1 &lt;= num &lt;= 10^9<br><strong>Program</strong><br>$[1,\sqrt{n}],[\sqrt{n}, n]$从$\sqrt{n}$开始搜索，一旦找到即是最小差的数！<br>注意：从$\sqrt{n}$到$1$开始搜索更好，因为$\frac{num}{\sqrt{n}}$不一定小于等于$\sqrt{n}$，例如1,2,3，如果从$\sqrt{n}$到$n$搜索，就会出问题。相反，从$\sqrt{n}$到$1$开始搜索，$\frac{num}{\sqrt{n}}$一定大于等于$\sqrt{n}$。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; calFactors(<span class="keyword">int</span> num){</span><br><span class="line">        <span class="keyword">int</span> sqt=(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(num);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=sqt;i&gt;<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">if</span>(num%i==<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">return</span> {i, num/i};</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> {};</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; closestDivisors(<span class="keyword">int</span> num) {</span><br><span class="line">        <span class="keyword">int</span> x=num+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y=num+<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1=calFactors(x);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec2=calFactors(y);</span><br><span class="line">        <span class="keyword">if</span>(vec1[<span class="number">1</span>]-vec1[<span class="number">0</span>]&gt;vec2[<span class="number">1</span>]-vec2[<span class="number">0</span>]) <span class="keyword">return</span> vec2;</span><br><span class="line">        <span class="keyword">return</span> vec1;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="775-全局倒置与局部倒置"><a href="#775-全局倒置与局部倒置" class="headerlink" title="775. 全局倒置与局部倒置"></a>775. 全局倒置与局部倒置</h2><p><strong>Description</strong><br>数组 A 是 [0, 1, …, N - 1] 的一种排列，N 是数组 A 的长度。全局倒置指的是 i,j 满足 $0 &lt;= i &lt; j &lt; N$ 并且 A[i] &gt; A[j] ，局部倒置指的是 i 满足 $0 &lt;= i &lt; N$ 并且 A[i] &gt; A[i+1] 。<br>当数组 A 中全局倒置的数量等于局部倒置的数量时，返回 true 。<br><strong>Example</strong><br>示例 1:<br>输入: A = [1,0,2]<br>输出: true<br>解释: 有 1 个全局倒置，和 1 个局部倒置。</p>
<p>示例 2:<br>输入: A = [1,2,0]<br>输出: false<br>解释: 有 2 个全局倒置，和 1 个局部倒置。<br>注意:<br>A 是 [0, 1, …, A.length - 1] 的一种排列<br>A 的长度在 [1, 5000]之间<br>这个问题的时间限制已经减少了。<br><strong>Program</strong><br><strong>①逆序对个数</strong><br>全局倒置就是逆序对个数，用树状数组来求即可。<br>时间复杂度$O(n\log{n})$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> C[<span class="number">5001</span>]={<span class="number">0</span>};</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;<span class="number">0</span>;i-=lowbit(i)){</span><br><span class="line">            sum+=C[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;<span class="number">5001</span>;i+=lowbit(i)) C[i]+=v;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIdealPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> globalAns=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> regionAns=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;A[i<span class="number">-1</span>]&gt;A[i]) regionAns++;</span><br><span class="line">            update(A[i]+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            globalAns+=getSum(A[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> regionAns==globalAns;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>②分析</strong><br>全局倒置一定是局部倒置，反之不是。所以当数组中的数大于自身的索引+1或者小于自身的所以-1时就会出现2个以上的全局倒置，就不可能和局部倒置相等了</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIdealPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(A[i]&lt;i<span class="number">-1</span>||A[i]&gt;i+<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="892-三维形体的表面积"><a href="#892-三维形体的表面积" class="headerlink" title="892. 三维形体的表面积"></a>892. 三维形体的表面积</h2><p><strong>Description</strong><br>在 N * N 的网格上，我们放置一些 1 * 1 * 1  的立方体。<br>每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。<br>请你返回最终形体的表面积。<br><strong>Example</strong><br>示例 1：<br>输入：[[2]]<br>输出：10</p>
<p>示例 2：<br>输入：[[1,2],[3,4]]<br>输出：34</p>
<p>示例 3：<br>输入：[[1,0],[0,2]]<br>输出：16</p>
<p>示例 4：<br>输入：[[1,1,1],[1,0,1],[1,1,1]]<br>输出：32</p>
<p>示例 5：<br>输入：[[2,2,2],[2,1,2],[2,2,2]]<br>输出：46</p>
<p>提示：<br>1 &lt;= N &lt;= 50<br>0 &lt;= grid[i][j] &lt;= 50<br><strong>Program</strong><br>思路：遍历每个位置的方块数，可以算出该柱体的表面积上下底+4*方块数，当然要减去重叠区面积，假设当前为(i,j)位置，则(i-1,j)和(i,j-1)已知，减去重叠区面积即可，那么(i+1,j)和(i,j+1)怎么办？其实也是已知的对应位置数量的，但是如果有重叠减一次就可以了，如果这两个位置都减去了重叠面积，那么后面计算的时候回重复减！所以只需要减(i-1,j)和(i,j-1)即可。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">surfaceArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=grid.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">int</span> count=grid[i][j];</span><br><span class="line">                <span class="keyword">if</span>(count&gt;<span class="number">0</span>){</span><br><span class="line">                    ans+=count*<span class="number">4</span>+<span class="number">2</span>;</span><br><span class="line">                    ans-=i<span class="number">-1</span>&gt;=<span class="number">0</span>?min(count,grid[i<span class="number">-1</span>][j]) * <span class="number">2</span>:<span class="number">0</span>;</span><br><span class="line">                    ans-=j<span class="number">-1</span>&gt;=<span class="number">0</span>?min(count,grid[i][j<span class="number">-1</span>]) * <span class="number">2</span>:<span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1317-将整数转换为两个无零整数的和"><a href="#1317-将整数转换为两个无零整数的和" class="headerlink" title="1317. 将整数转换为两个无零整数的和"></a>1317. 将整数转换为两个无零整数的和</h2><p><strong>Description</strong><br>「无零整数」是十进制表示中 不含任何 0 的正整数。<br>给你一个整数 n，请你返回一个 由两个整数组成的列表 [A, B]，满足：</p>
<ul>
<li>A 和 B 都是无零整数</li>
<li>A + B = n<br>题目数据保证至少有一个有效的解决方案。<br>如果存在多个有效解决方案，你可以返回其中任意一个。</li>
</ul>
<p><strong>Example</strong><br>示例 1：<br>输入：n = 2<br>输出：[1,1]<br>解释：A = 1, B = 1. A + B = n 并且 A 和 B 的十进制表示形式都不包含任何 0 。</p>
<p>示例 2：<br>输入：n = 11<br>输出：[2,9]</p>
<p>示例 3：<br>输入：n = 10000<br>输出：[1,9999]</p>
<p>示例 4：<br>输入：n = 69<br>输出：[1,68]</p>
<p>示例 5：<br>输入：n = 1010<br>输出：[11,999]</p>
<p>提示：<br>2 &lt;= n &lt;= 10^4<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getNoZeroIntegers(<span class="keyword">int</span> n) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="built_in">string</span> a=to_string(i);</span><br><span class="line">            <span class="built_in">string</span> b=to_string(n-i);</span><br><span class="line">            <span class="keyword">if</span>(a.find(<span class="string">'0'</span>)==<span class="built_in">string</span>::npos&amp;&amp;b.find(<span class="string">'0'</span>)==<span class="built_in">string</span>::npos){</span><br><span class="line">                <span class="keyword">return</span> {i, n-i};</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> {};</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="面试题49-丑数"><a href="#面试题49-丑数" class="headerlink" title="面试题49. 丑数"></a>面试题49. 丑数</h2><p><strong>Description</strong><br>我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。<br><strong>Example</strong><br>示例:<br>输入: n = 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</p>
<p>说明:<br>1 是丑数。<br>n 不超过1690。<br><strong>Program</strong><br><strong>动态规划</strong><br>已知DP[1]…DP[i-1],求DP[i]，前i-1个丑数是严格递增的，那么DP[i]为前i-1个丑数分别乘以2,3,5后得到的最小值！当然需要记录已存的值！<br>然而很遗憾超时了！！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; DP(n,<span class="number">0</span>);</span><br><span class="line">        DP[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> minValue=LONG_LONG_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++){</span><br><span class="line">                <span class="keyword">if</span>(s.find(DP[j] * <span class="number">2</span>)==s.end()) minValue=minValue&gt;(DP[j] * <span class="number">2</span>)?DP[j] * <span class="number">2</span>:minValue;</span><br><span class="line">                <span class="keyword">if</span>(s.find(DP[j] * <span class="number">3</span>)==s.end()) minValue=minValue&gt;(DP[j] * <span class="number">3</span>)?DP[j] * <span class="number">3</span>:minValue;</span><br><span class="line">                <span class="keyword">if</span>(s.find(DP[j] * <span class="number">5</span>)==s.end()) minValue=minValue&gt;(DP[j] * <span class="number">5</span>)?DP[j] * <span class="number">5</span>:minValue;</span><br><span class="line">            }</span><br><span class="line">            s.insert(minValue);</span><br><span class="line">            DP[i]=minValue;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>进一步分析，很多重复计算！<br>比如已有1,2,3,4,5，计算下一个丑数的时候，需要都从1,2,3,4,5都乘2,3,5求最小值吗？<br>1×2,2×2,<br>1×3,<br>1×5<br>都已经在序列里了！重复计算了，当序列越来越长，重复计算将会更多。我们需要不重复且所得尽可能小的数！<br>对于因子2而言，就需要从3开始计算，<br>对于因子3而言，就需要从2开始计算，<br>对于因子5而言，就需要从2开始计算，<br>得到下一个丑数6<br>3×2==6，所以下一次对于因子2，将从4开始计算<br>2×3==6,所以下一次对于因子3，将从3开始计算，<br>2×5!=6,所以下一次对于因子5，还是从2开始计算。<br>采用三个索引p2,p3,p5<br>记录DP[p2]×2,DP[p3]×3,DP[p5]×5中最小的值minValue,其中DP[px] * x==minValue的索引自增！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP(n,<span class="number">0</span>);</span><br><span class="line">        DP[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2, p3, p5;</span><br><span class="line">        p2=p3=p5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> mVal=min(DP[p2]*<span class="number">2</span>, min(DP[p3]*<span class="number">3</span>, DP[p5]*<span class="number">5</span>));</span><br><span class="line">            <span class="keyword">if</span>(mVal==DP[p2]*<span class="number">2</span>) p2++;</span><br><span class="line">            <span class="keyword">if</span>(mVal==DP[p3]*<span class="number">3</span>) p3++;</span><br><span class="line">            <span class="keyword">if</span>(mVal==DP[p5]*<span class="number">5</span>) p5++;</span><br><span class="line">            DP[i]=mVal;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="869-重新排序得到-2-的幂"><a href="#869-重新排序得到-2-的幂" class="headerlink" title="869. 重新排序得到 2 的幂"></a>869. 重新排序得到 2 的幂</h2><p><strong>Description</strong><br>给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。<br>如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回 false。<br><strong>Example</strong><br>示例 1：<br>输入：1<br>输出：true</p>
<p>示例 2：<br>输入：10<br>输出：false</p>
<p>示例 3：<br>输入：16<br>输出：true</p>
<p>示例 4：<br>输入：24<br>输出：false</p>
<p>示例 5：<br>输入：46<br>输出：true</p>
<p>提示：<br>1 &lt;= N &lt;= 10^9<br><strong>Program</strong><br>如果排列组合的话复杂度太高肯定超时，反过来如果枚举int范围的2的幂次，只有31个数，只需要比较十进制0~9每个数字的个数是否完全一样即可。<br>进一步来说，这31个数只有其十进制数的位数与N的位数相等才有可能满足！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> str, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:str){</span><br><span class="line">            v[ch-<span class="string">'0'</span>]++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++){</span><br><span class="line">            <span class="keyword">if</span>(v[i]!=vec[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">reorderedPowerOf2</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">string</span> str=to_string(N);</span><br><span class="line">        <span class="keyword">int</span> len=str.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:str){</span><br><span class="line">            <span class="keyword">int</span> i=ch-<span class="string">'0'</span>;</span><br><span class="line">            vec[i]++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">31</span>;i++){</span><br><span class="line">            <span class="keyword">int</span> count=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            <span class="built_in">string</span> s=to_string(count);</span><br><span class="line">            <span class="keyword">if</span>(s.length()==len){</span><br><span class="line">                <span class="keyword">if</span>(cmp(s, vec)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1009-十进制整数的反码"><a href="#1009-十进制整数的反码" class="headerlink" title="1009. 十进制整数的反码"></a>1009. 十进制整数的反码</h2><p><strong>Description</strong><br>每个非负整数 N 都有其二进制表示。例如， 5 可以被表示为二进制 “101”，11 可以用二进制 “1011” 表示，依此类推。注意，除 N = 0 外，任何二进制表示中都不含前导零。<br>二进制的反码表示是将每个 1 改为 0 且每个 0 变为 1。例如，二进制数 “101” 的二进制反码为 “010”。<br>给你一个十进制数 N，请你返回其二进制表示的反码所对应的十进制整数。<br><strong>Example</strong><br>示例 1：<br>输入：5<br>输出：2<br>解释：5 的二进制表示为 “101”，其二进制反码为 “010”，也就是十进制中的 2 。</p>
<p>示例 2：<br>输入：7<br>输出：0<br>解释：7 的二进制表示为 “111”，其二进制反码为 “000”，也就是十进制中的 0 。</p>
<p>示例 3：<br>输入：10<br>输出：5<br>解释：10 的二进制表示为 “1010”，其二进制反码为 “0101”，也就是十进制中的 5 。</p>
<p>提示：<br>0 &lt;= N &lt; 10^9<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bitwiseComplement</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> isFirst=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">if</span>(isFirst&amp;&amp;((N&gt;&gt;i)&amp;<span class="number">1</span>)==<span class="number">1</span>){</span><br><span class="line">                isFirst=<span class="literal">false</span>;</span><br><span class="line">                N^=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(!isFirst) N^=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bitwiseComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> upbit=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">if</span>((num&amp;upbit)!=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            upbit&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">16</span>;i*=<span class="number">2</span>) upbit|=(upbit&gt;&gt;i);</span><br><span class="line">        <span class="keyword">return</span> (upbit^num);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1237-找出给定方程的正整数解"><a href="#1237-找出给定方程的正整数解" class="headerlink" title="1237. 找出给定方程的正整数解"></a>1237. 找出给定方程的正整数解</h2><p><strong>Description</strong><br>给出一个函数  f(x, y) 和一个目标结果 z，请你计算方程 f(x,y) == z 所有可能的正整数 数对 x 和 y。<br>给定函数是严格单调的，也就是说：</p>
<ul>
<li>f(x, y) &lt; f(x + 1, y)</li>
<li>f(x, y) &lt; f(x, y + 1)<br>函数接口定义如下：<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface CustomFunction {</span><br><span class="line">public:</span><br><span class="line">&nbsp; // Returns positive integer f(x, y) for any given positive integer x and y.</span><br><span class="line">&nbsp; int f(int x, int y);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
如果你想自定义测试，你可以输入整数 function_id 和一个目标结果 z 作为输入，其中 function_id 表示一个隐藏函数列表中的一个函数编号，题目只会告诉你列表中的 2 个函数。<br>你可以将满足条件的 结果数对 按任意顺序返回。</li>
</ul>
<p><strong>Example</strong><br>示例 1：<br>输入：function_id = 1, z = 5<br>输出：[[1,4],[2,3],[3,2],[4,1]]<br>解释：function_id = 1 表示 f(x, y) = x + y</p>
<p>示例 2：<br>输入：function_id = 2, z = 5<br>输出：[[1,5],[5,1]]<br>解释：function_id = 2 表示 f(x, y) = x * y</p>
<p>提示：<br>1 &lt;= function_id &lt;= 9<br>1 &lt;= z &lt;= 100<br>题目保证 f(x, y) == z 的解处于 1 &lt;= x, y &lt;= 1000 的范围内。<br>在 1 &lt;= x, y &lt;= 1000 的前提下，题目保证 f(x, y) 是一个 32 位有符号整数。<br><strong>Program</strong><br><strong>暴力</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * // This is the custom function interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class CustomFunction {</span></span><br><span class="line"><span class="comment"> * public:</span></span><br><span class="line"><span class="comment"> *     // Returns f(x, y) for any given positive integers x and y.</span></span><br><span class="line"><span class="comment"> *     // Note that f(x, y) is increasing with respect to both x and y.</span></span><br><span class="line"><span class="comment"> *     // i.e. f(x, y) &lt; f(x + 1, y), f(x, y) &lt; f(x, y + 1)</span></span><br><span class="line"><span class="comment"> *     int f(int x, int y);</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findSolution(CustomFunction&amp; customfunction, <span class="keyword">int</span> z) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=z;x++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">1</span>;y&lt;=z;y++){</span><br><span class="line">                <span class="keyword">if</span>(customfunction.f(x,y)==z){</span><br><span class="line">                    res.push_back({x, y});</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">//f(x,y)&lt;f(x, y+1)</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>伪双指针法</strong><br>最后发现和两层循环没啥区别！每组xy都被考虑。。。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * // This is the custom function interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class CustomFunction {</span></span><br><span class="line"><span class="comment"> * public:</span></span><br><span class="line"><span class="comment"> *     // Returns f(x, y) for any given positive integers x and y.</span></span><br><span class="line"><span class="comment"> *     // Note that f(x, y) is increasing with respect to both x and y.</span></span><br><span class="line"><span class="comment"> *     // i.e. f(x, y) &lt; f(x + 1, y), f(x, y) &lt; f(x, y + 1)</span></span><br><span class="line"><span class="comment"> *     int f(int x, int y);</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findSolution(CustomFunction&amp; customfunction, <span class="keyword">int</span> z) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">1</span>,y=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> min_x=<span class="number">1</span>,min_y=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">2</span>; <span class="comment">//1表示x移动，2表示y移动</span></span><br><span class="line">        <span class="keyword">while</span>(min_x&lt;=z&amp;&amp;min_y&lt;=z){</span><br><span class="line">            <span class="comment">//cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(x==z+<span class="number">1</span>||y==z+<span class="number">1</span>){</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">1</span>){min_y++;flag=<span class="number">2</span>;}</span><br><span class="line">                <span class="keyword">else</span>{min_x++;flag=<span class="number">1</span>;}</span><br><span class="line">                x=min_x;</span><br><span class="line">                y=min_y;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(customfunction.f(x,y)==z){</span><br><span class="line">                res.push_back({x, y});</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">1</span>){min_y++;flag=<span class="number">2</span>;}</span><br><span class="line">                <span class="keyword">else</span>{min_x++;flag=<span class="number">1</span>;}</span><br><span class="line">                x=min_x;</span><br><span class="line">                y=min_y;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">1</span>) x++;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">2</span>) y++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>双指针法</strong><br>根据严格单调的特性：<br>令x=1,y=1000，<br>若f(x,y)&lt;z，则计算f(x+1,,y)<br>若f(x,y)&gt;z，则计算f(x,y-1)<br>若f(x,y)==z，则计算f(x+1,y-1)<br>时间复杂度：$O(m+n)$</p>
<p>确实巧妙，想了下这个算法的关键是找到合适的遍历起点，这个点肯定具有某种特殊性，这个二维矩阵，四个角就是四个特殊点，但他们的特点不同，左上和右下分别是矩阵的最小和最大值，左下和右上具有两面性，如果是所在行最大值那么就是所在列的最小值，反过来也一样。左上和右下与目标值比较不相等时，下一步既可以遍历行也可以遍历列是不确定的，而左下和右上是可以确定的，因为自身值的特点可以排除一个方向的路径，只有一个遍历路径。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * // This is the custom function interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class CustomFunction {</span></span><br><span class="line"><span class="comment"> * public:</span></span><br><span class="line"><span class="comment"> *     // Returns f(x, y) for any given positive integers x and y.</span></span><br><span class="line"><span class="comment"> *     // Note that f(x, y) is increasing with respect to both x and y.</span></span><br><span class="line"><span class="comment"> *     // i.e. f(x, y) &lt; f(x + 1, y), f(x, y) &lt; f(x, y + 1)</span></span><br><span class="line"><span class="comment"> *     int f(int x, int y);</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findSolution(CustomFunction&amp; customfunction, <span class="keyword">int</span> z) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y=<span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;=<span class="number">1000</span>&amp;&amp;y&gt;=<span class="number">1</span>){</span><br><span class="line">            <span class="keyword">int</span> tmp=customfunction.f(x, y);</span><br><span class="line">            <span class="keyword">if</span>(tmp==z){</span><br><span class="line">                res.push_back({x,y});</span><br><span class="line">                x++;y--;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(tmp&gt;z) y--;</span><br><span class="line">            <span class="keyword">else</span> x++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="面试题20-表示数值的字符串"><a href="#面试题20-表示数值的字符串" class="headerlink" title="面试题20. 表示数值的字符串"></a>面试题20. 表示数值的字符串</h2><p><strong>Description</strong><br>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”、”-1E-16”及”12e+5.4”都不是。<br><strong>Program</strong><br><img src="/assets/img/algorithm/interview_20.jpg" alt="image"><br>如图，首先画图整个合法可能的数值字符串的最长状态（最长的那条直线轴），注意3和8：<br>（1）3为数字后有小数点<br>（2）8为小数点后前没有数字<br>（3）两种情况需要注意，因为3是合法的，8是不合法的！所以不能舍去8，直接连到3！<br>各个数字的状态：<br>0. 开始的空格</p>
<ol>
<li>幂符号前的正负号</li>
<li>小数点前的数字</li>
<li>数字后的小数点或小数</li>
<li>数字后的e</li>
<li>e后的正负号</li>
<li>e后的数字</li>
<li>结尾的空格</li>
<li>数字前的小数点<br>详细说明请参考<a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/mian-shi-ti-20-biao-shi-shu-zhi-de-zi-fu-chuan-y-2/" target="_blank" rel="noopener">讲解</a><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;&gt; states;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; legalStates;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line">        states.resize(<span class="number">9</span>);</span><br><span class="line">        states[<span class="number">0</span>][<span class="string">' '</span>]=<span class="number">0</span>; states[<span class="number">0</span>][<span class="string">'d'</span>]=<span class="number">2</span>;states[<span class="number">0</span>][<span class="string">'s'</span>]=<span class="number">1</span>;states[<span class="number">0</span>][<span class="string">'.'</span>]=<span class="number">8</span>;</span><br><span class="line">        states[<span class="number">1</span>][<span class="string">'.'</span>]=<span class="number">8</span>;states[<span class="number">1</span>][<span class="string">'d'</span>]=<span class="number">2</span>;</span><br><span class="line">        states[<span class="number">2</span>][<span class="string">'d'</span>]=<span class="number">2</span>;states[<span class="number">2</span>][<span class="string">'.'</span>]=<span class="number">3</span>;states[<span class="number">2</span>][<span class="string">'e'</span>]=<span class="number">4</span>;states[<span class="number">2</span>][<span class="string">' '</span>]=<span class="number">7</span>;</span><br><span class="line">        states[<span class="number">3</span>][<span class="string">'d'</span>]=<span class="number">3</span>;states[<span class="number">3</span>][<span class="string">'e'</span>]=<span class="number">4</span>;states[<span class="number">3</span>][<span class="string">' '</span>]=<span class="number">7</span>;</span><br><span class="line">        states[<span class="number">4</span>][<span class="string">'s'</span>]=<span class="number">5</span>;states[<span class="number">4</span>][<span class="string">'d'</span>]=<span class="number">6</span>;</span><br><span class="line">        states[<span class="number">5</span>][<span class="string">'d'</span>]=<span class="number">6</span>;</span><br><span class="line">        states[<span class="number">6</span>][<span class="string">'d'</span>]=<span class="number">6</span>;states[<span class="number">6</span>][<span class="string">' '</span>]=<span class="number">7</span>;</span><br><span class="line">        states[<span class="number">7</span>][<span class="string">' '</span>]=<span class="number">7</span>;</span><br><span class="line">        states[<span class="number">8</span>][<span class="string">'d'</span>]=<span class="number">3</span>;</span><br><span class="line">        legalStates.insert(<span class="number">2</span>);</span><br><span class="line">        legalStates.insert(<span class="number">3</span>);</span><br><span class="line">        legalStates.insert(<span class="number">6</span>);</span><br><span class="line">        legalStates.insert(<span class="number">7</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">0</span>; <span class="comment">//当前状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:s){</span><br><span class="line">            <span class="keyword">if</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>) ch=<span class="string">'d'</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">'+'</span>||ch==<span class="string">'-'</span>) ch=<span class="string">'s'</span>;</span><br><span class="line">            <span class="comment">// else ch=ch; //空格、dot、e以及其他非法字符</span></span><br><span class="line">            <span class="keyword">if</span>(states[p].find(ch)==states[p].end()) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//出现非法字符</span></span><br><span class="line">            p = states[p][ch];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> (legalStates.find(p)!=legalStates.end());</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h2 id="908-最小差值-I"><a href="#908-最小差值-I" class="headerlink" title="908. 最小差值 I"></a>908. 最小差值 I</h2><p><strong>Description</strong><br>给你一个整数数组 A，对于每个整数 A[i]，我们可以选择处于区间 [-K, K] 中的任意数 x ，将 x 与 A[i] 相加，结果存入 A[i] 。<br>在此过程之后，我们得到一些数组 B。<br>返回 B 的最大值和 B 的最小值之间可能存在的最小差值。<br><strong>Example</strong><br>示例 1：<br>输入：A = [1], K = 0<br>输出：0<br>解释：B = [1]</p>
<p>示例 2：<br>输入：A = [0,10], K = 2<br>输出：6<br>解释：B = [2,8]</p>
<p>示例 3：<br>输入：A = [1,3,6], K = 3<br>输出：0<br>解释：B = [3,3,3] 或 B = [4,4,4]</p>
<p>提示：<br>1 &lt;= A.length &lt;= 10000<br>0 &lt;= A[i] &lt;= 10000<br>0 &lt;= K &lt;= 10000<br><strong>Program</strong><br>思路：将数组排序，记最大值与最小值之间的差D，<br>如果D/2&lt;=K，那么可以使得数组元素全相等！最小差值为0。因为任意选择[-K,K]区间的数进行加法，既然最大值/最小值都能够减/加上特定的数(这个数一定小于等于K)使二者相等，那么其他元素可以选择$[0,|K|]$中的数进行<br>如果D/2&gt;K，则最小差值为D-2K。<br>所以answer=max(0,D-2K);</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">smallestRangeI</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> minValue=INT_MAX,maxValue=-INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:A){</span><br><span class="line">            minValue=min(minValue, x);</span><br><span class="line">            maxValue=max(maxValue, x);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max(<span class="number">0</span>,maxValue-minValue<span class="number">-2</span>*K);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1447-最简分数"><a href="#1447-最简分数" class="headerlink" title="1447. 最简分数"></a>1447. 最简分数</h2><p><strong>Description</strong><br>给你一个整数 n ，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于  n 的 最简 分数 。分数可以以 任意 顺序返回。<br><strong>Example</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n = 2</span><br><span class="line">输出：["1/2"]</span><br><span class="line">解释："1/2" 是唯一一个分母小于等于 2 的最简分数。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n = 3</span><br><span class="line">输出：["1/2","1/3","2/3"]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：n = 4</span><br><span class="line">输出：["1/2","1/3","1/4","2/3","3/4"]</span><br><span class="line">解释："2/4" 不是最简分数，因为它可以化简为 "1/2" 。</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：n = 1</span><br><span class="line">输出：[]</span><br><span class="line">&nbsp;</span><br><span class="line">提示：</span><br><span class="line">1 &lt;= n &lt;= 100</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fraction</span>{</span></span><br><span class="line">        <span class="keyword">int</span> up,down;</span><br><span class="line">        Fraction(){}</span><br><span class="line">        Fraction(<span class="keyword">int</span> u, <span class="keyword">int</span> d):up(u), down(d){}</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">toString</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="built_in">string</span> str=<span class="string">""</span>;</span><br><span class="line">            str+=to_string(up);</span><br><span class="line">            str+=<span class="string">'/'</span>;</span><br><span class="line">            str+=to_string(down);</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> y==<span class="number">0</span>?x:gcd(y,x%y);</span><br><span class="line">    }</span><br><span class="line">    <span class="function">Fraction <span class="title">reduction</span><span class="params">(Fraction fraction)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(fraction.down&lt;<span class="number">0</span>){</span><br><span class="line">            fraction.up=-fraction.up;</span><br><span class="line">            fraction.down=-fraction.down;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(fraction.up==<span class="number">0</span>){</span><br><span class="line">            fraction.down=<span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">int</span> gd=gcd(fraction.up, fraction.down);</span><br><span class="line">            fraction.up/=gd;</span><br><span class="line">            fraction.down/=gd;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> fraction;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; simplifiedFractions(<span class="keyword">int</span> n) {</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> down=<span class="number">2</span>;down&lt;=n;down++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> up=<span class="number">1</span>;up&lt;down;up++){</span><br><span class="line">                <span class="function">Fraction <span class="title">fraction</span><span class="params">(up, down)</span></span>;</span><br><span class="line">                fraction = reduction(fraction);</span><br><span class="line">                s.insert(fraction.toString());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(s.begin(), s.end());</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="868-二进制间距"><a href="#868-二进制间距" class="headerlink" title="868. 二进制间距"></a>868. 二进制间距</h2><p><strong>Description</strong><br>给定一个正整数 N，找到并返回 N 的二进制表示中两个连续的 1 之间的最长距离。<br>如果没有两个连续的 1，返回 0 。<br><strong>Example</strong><br>示例 1：<br>输入：22<br>输出：2<br>解释：<br>22 的二进制是 0b10110 。<br>在 22 的二进制表示中，有三个 1，组成两对连续的 1 。<br>第一对连续的 1 中，两个 1 之间的距离为 2 。<br>第二对连续的 1 中，两个 1 之间的距离为 1 。<br>答案取两个距离之中最大的，也就是 2 。</p>
<p>示例 2：<br>输入：5<br>输出：2<br>解释：<br>5 的二进制是 0b101 。</p>
<p>示例 3：<br>输入：6<br>输出：1<br>解释：<br>6 的二进制是 0b110 。</p>
<p>示例 4：<br>输入：8<br>输出：0<br>解释：<br>8 的二进制是 0b1000 。<br>在 8 的二进制表示中没有连续的 1，所以返回 0 。</p>
<p>提示：<br>1 &lt;= N &lt;= 10^9<br><strong>Program</strong><br>两个连续1，是指二进制从低位到高位两个相邻1的距离！题目描述的恶心人。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binaryGap</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; record;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">30</span>;i++){</span><br><span class="line">            <span class="keyword">if</span>(((N&gt;&gt;i)&amp;<span class="number">1</span>)==<span class="number">1</span>){</span><br><span class="line">                record.push_back(i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;record.size()<span class="number">-1</span>;i++){</span><br><span class="line">            ans=max(ans, record[i+<span class="number">1</span>] - record[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="598-范围求和-II"><a href="#598-范围求和-II" class="headerlink" title="598. 范围求和 II"></a>598. 范围求和 II</h2><p><strong>Description</strong><br>给定一个初始元素全部为 0，大小为 m * n 的矩阵 M 以及在 M 上的一系列更新操作。<br>操作用二维数组表示，其中的每个操作用一个含有两个正整数 a 和 b 的数组表示，含义是将所有符合 $0 &lt;= i &lt; a$ 以及 $0 &lt;= j &lt; b$ 的元素 M[i][j] 的值都增加 1。<br>在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。<br><strong>Example</strong><br>示例 1:<br>输入:<br>m = 3, n = 3<br>operations = [[2,2],[3,3]]<br>输出: 4<br>解释:<br>初始状态, M =<br>[[0, 0, 0],<br> [0, 0, 0],<br> [0, 0, 0]]<br>执行完操作 [2,2] 后, M =<br>[[1, 1, 0],<br> [1, 1, 0],<br> [0, 0, 0]]<br>执行完操作 [3,3] 后, M =<br>[[2, 2, 1],<br> [2, 2, 1],<br> [1, 1, 1]]</p>
<p>M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。<br>注意:<br>m 和 n 的范围是 [1,40000]。<br>a 的范围是 [1,m]，b 的范围是 [1,n]。<br>操作数目不超过 10000。<br><strong>Program</strong><br><strong>二维树状数组</strong><br>根据数据范围，二维树状数组和还是会超时</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; C;</span><br><span class="line">    <span class="keyword">int</span> M,N;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;<span class="number">0</span>;i-=lowbit(i)){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=y;j&gt;<span class="number">0</span>;j-=lowbit(j)){</span><br><span class="line">                C[i][j]+=v;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=M;i+=lowbit(i)){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=y;j&lt;=N;j+=lowbit(j)){</span><br><span class="line">                sum+=C[i][j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ops)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(ops.size()==<span class="number">0</span>) <span class="keyword">return</span> m*n;</span><br><span class="line">        C.resize(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        M=n,N=n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; op:ops){</span><br><span class="line">            update(op[<span class="number">0</span>], op[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nCount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line">                <span class="keyword">int</span> tmp=getSum(i, j);</span><br><span class="line">                <span class="keyword">if</span>(tmp&gt;ans){</span><br><span class="line">                    ans=tmp;</span><br><span class="line">                    nCount=<span class="number">1</span>;</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span>(tmp==ans){</span><br><span class="line">                    nCount++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nCount;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>短板效应</strong><br>其实题意转化一下，就是：求重叠部分的面积。阴影部分面积取决于宽度最小的和长度最小的<br><img src="/assets/img/algorithm/598_example_01.png" alt="image"></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ops)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (ops.empty())</span><br><span class="line">            <span class="keyword">return</span> m * n;</span><br><span class="line">        <span class="keyword">int</span> a = INT_MAX, b = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ops.size(); i++) {</span><br><span class="line">            a = min(a, ops[i][<span class="number">0</span>]);</span><br><span class="line">            b = min(b, ops[i][<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1037-有效的回旋镖"><a href="#1037-有效的回旋镖" class="headerlink" title="1037. 有效的回旋镖"></a>1037. 有效的回旋镖</h2><p><strong>Description</strong><br>回旋镖定义为一组三个点，这些点各不相同且不在一条直线上。<br>给出平面上三个点组成的列表，判断这些点是否可以构成回旋镖。<br><strong>Example</strong><br>示例 1：<br>输入：[[1,1],[2,3],[3,2]]<br>输出：true</p>
<p>示例 2：<br>输入：[[1,1],[2,2],[3,3]]<br>输出：false</p>
<p>提示：<br>points.length == 3<br>points[i].length == 2<br>0 &lt;= points[i][j] &lt;= 100<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p2)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> p1[<span class="number">0</span>]==p2[<span class="number">0</span>]&amp;&amp;p1[<span class="number">1</span>]==p2[<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBoomerang</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(isSame(points[<span class="number">0</span>], points[<span class="number">1</span>])||isSame(points[<span class="number">0</span>], points[<span class="number">2</span>])||isSame(points[<span class="number">1</span>], points[<span class="number">2</span>]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> y1=points[<span class="number">1</span>][<span class="number">1</span>]-points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x1=points[<span class="number">1</span>][<span class="number">0</span>]-points[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y2=points[<span class="number">2</span>][<span class="number">1</span>]-points[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x2=points[<span class="number">2</span>][<span class="number">0</span>]-points[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(x1==x2&amp;&amp;x1==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(x1==<span class="number">0</span>&amp;&amp;x2!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(x1!=<span class="number">0</span>&amp;&amp;x2==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">double</span>)y1/x1)!=((<span class="keyword">double</span>)y2/x2);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBoomerang</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> y1=points[<span class="number">1</span>][<span class="number">1</span>]-points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x1=points[<span class="number">1</span>][<span class="number">0</span>]-points[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y2=points[<span class="number">2</span>][<span class="number">1</span>]-points[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x2=points[<span class="number">2</span>][<span class="number">0</span>]-points[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> y2*x1!=y1*x2; <span class="comment">//避免分母为0，同时重合点也排除了！</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1017-负二进制转换"><a href="#1017-负二进制转换" class="headerlink" title="1017. 负二进制转换"></a>1017. 负二进制转换</h2><p><strong>Description</strong><br>给出数字 N，返回由若干 “0” 和 “1”组成的字符串，该字符串为 N 的负二进制（base -2）表示。<br>除非字符串就是 “0”，否则返回的字符串中不能含有前导零。<br><strong>Example</strong><br>示例 1：<br>输入：2<br>输出：”110”<br>解释：(-2) ^ 2 + (-2) ^ 1 = 2</p>
<p>示例 2：<br>输入：3<br>输出：”111”<br>解释：(-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 = 3</p>
<p>示例 3：<br>输入：4<br>输出：”100”<br>解释：(-2) ^ 2 = 4</p>
<p>提示：<br>0 &lt;= N &lt;= 10^9<br><strong>Program</strong><br>一般基数为正数的方法，但需要特殊处理。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; convert_baseK(<span class="keyword">int</span> N, <span class="keyword">int</span> K){</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">0</span>) <span class="keyword">return</span> {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(N!=<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">int</span> r=(N%K+<span class="built_in">abs</span>(K))%<span class="built_in">abs</span>(K); <span class="comment">//-1%-3为-1转成2，-5%-3为-2转成1</span></span><br><span class="line">            res.push_back(r);</span><br><span class="line">            N-=r;   <span class="comment">//K为正数可省略，但K为负数需要进位。例如N=-5,K=-3 将会计算N=-1, r=2,N-r=-1-2=-3，N/K=-3/-3=1。如果直接跳过N-=r,则N/K=-1/-3=0，缺了进位。</span></span><br><span class="line">            N/=K;</span><br><span class="line">        }</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">baseNeg2</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res=convert_baseK(N, <span class="number">-2</span>);</span><br><span class="line">        <span class="built_in">string</span> str=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:res){</span><br><span class="line">            str+=to_string(x);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a>54. 螺旋矩阵</h2><p><strong>Description</strong><br>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。<br><strong>Example</strong><br>示例 1:<br>输入:<br>[<br> [ 1, 2, 3 ],<br> [ 4, 5, 6 ],<br> [ 7, 8, 9 ]<br>]<br>输出: [1,2,3,6,9,8,7,4,5]</p>
<p>示例 2:<br>输入:<br>[<br>  [1, 2, 3, 4],<br>  [5, 6, 7, 8],<br>  [9,10,11,12]<br>]<br>输出: [1,2,3,4,8,12,11,10,9,5,6,7]<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) {</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="keyword">int</span> m=matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> nCount=m*n;</span><br><span class="line">        <span class="keyword">int</span> rowStart=<span class="number">0</span>, rowEnd=m<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> colStart=<span class="number">0</span>, colEnd=n<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(res.size()&lt;nCount){</span><br><span class="line">            <span class="comment">//上行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=colStart;col&lt;=colEnd;col++) res.push_back(matrix[rowStart][col]);</span><br><span class="line">            rowStart++;</span><br><span class="line">            <span class="keyword">if</span>(res.size()==nCount) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//右列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> row=rowStart;row&lt;=rowEnd;row++) res.push_back(matrix[row][colEnd]);</span><br><span class="line">            colEnd--;</span><br><span class="line">            <span class="keyword">if</span>(res.size()==nCount) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//下行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=colEnd;col&gt;=colStart;col--) res.push_back(matrix[rowEnd][col]);</span><br><span class="line">            rowEnd--;</span><br><span class="line">            <span class="keyword">if</span>(res.size()==nCount) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//左列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> row=rowEnd;row&gt;=rowStart;row--) res.push_back(matrix[row][colStart]);</span><br><span class="line">            colStart++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="885-螺旋矩阵-III"><a href="#885-螺旋矩阵-III" class="headerlink" title="885. 螺旋矩阵 III"></a>885. 螺旋矩阵 III</h2><p><strong>Description</strong><br>在 R 行 C 列的矩阵上，我们从 (r0, c0) 面朝东面开始<br>这里，网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。<br>现在，我们以顺时针按螺旋状行走，访问此网格中的每个位置。<br>每当我们移动到网格的边界之外时，我们会继续在网格之外行走（但稍后可能会返回到网格边界）。<br>最终，我们到过网格的所有 R * C 个空间。<br>按照访问顺序返回表示网格位置的坐标列表。<br><strong>Example</strong><br>示例 1：<br>输入：R = 1, C = 4, r0 = 0, c0 = 0<br>输出：[[0,0],[0,1],[0,2],[0,3]]</p>
<p>示例 2：<br>输入：R = 5, C = 6, r0 = 1, c0 = 4<br>输出：[[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]</p>
<p>提示：<br>1 &lt;= R &lt;= 100<br>1 &lt;= C &lt;= 100<br>0 &lt;= r0 &lt; R<br>0 &lt;= c0 &lt; C<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(row&gt;=<span class="number">0</span>&amp;&amp;row&lt;rows&amp;&amp;col&gt;=<span class="number">0</span>&amp;&amp;col&lt;cols) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; spiralMatrixIII(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) {</span><br><span class="line">        rows=R, cols=C;</span><br><span class="line">        <span class="keyword">int</span> nCount=R*C;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line">        res.push_back({r0, c0});</span><br><span class="line">        <span class="keyword">int</span> nowRow=r0;</span><br><span class="line">        <span class="keyword">int</span> nowCol=c0;</span><br><span class="line">        <span class="keyword">while</span>(res.size()&lt;nCount){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=nowCol+<span class="number">1</span>;col&lt;=nowCol+len;col++){</span><br><span class="line">                <span class="keyword">if</span>(judge(nowRow, col)) res.push_back({nowRow, col});</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(res.size()==nCount) <span class="keyword">break</span>;</span><br><span class="line">            nowCol+=len;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> row=nowRow+<span class="number">1</span>;row&lt;=nowRow+len;row++){</span><br><span class="line">                <span class="keyword">if</span>(judge(row, nowCol)) res.push_back({row, nowCol});</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(res.size()==nCount) <span class="keyword">break</span>;</span><br><span class="line">            nowRow+=len;</span><br><span class="line">            len++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=nowCol<span class="number">-1</span>;col&gt;=nowCol-len;col--){</span><br><span class="line">                <span class="keyword">if</span>(judge(nowRow, col)) res.push_back({nowRow, col});</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(res.size()==nCount) <span class="keyword">break</span>;</span><br><span class="line">            nowCol-=len;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> row=nowRow<span class="number">-1</span>;row&gt;=nowRow-len;row--){</span><br><span class="line">                <span class="keyword">if</span>(judge(row, nowCol)) res.push_back({row, nowCol});</span><br><span class="line">            }</span><br><span class="line">            nowRow-=len;</span><br><span class="line">            len++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> steps[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(row&gt;=<span class="number">0</span>&amp;&amp;row&lt;rows&amp;&amp;col&gt;=<span class="number">0</span>&amp;&amp;col&lt;cols) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; spiralMatrixIII(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) {</span><br><span class="line">        rows=R, cols=C;</span><br><span class="line">        <span class="keyword">int</span> nCount=R*C;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line">        res.push_back({r0, c0});</span><br><span class="line">        <span class="keyword">int</span> nowRow=r0;</span><br><span class="line">        <span class="keyword">int</span> nowCol=c0;</span><br><span class="line">        <span class="keyword">while</span>(res.size()&lt;nCount){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;<span class="number">4</span>;s++){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=len;l++){</span><br><span class="line">                    <span class="keyword">int</span> row=nowRow+l*steps[s][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> col=nowCol+l*steps[s][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(judge(row, col)) res.push_back({row, col});</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(s==<span class="number">0</span>) nowCol+=len;</span><br><span class="line">                <span class="keyword">if</span>(s==<span class="number">1</span>) nowRow+=len;</span><br><span class="line">                <span class="keyword">if</span>(s==<span class="number">2</span>) nowCol-=len;</span><br><span class="line">                <span class="keyword">if</span>(s==<span class="number">3</span>) nowRow-=len;</span><br><span class="line">                <span class="keyword">if</span>(s%<span class="number">2</span>==<span class="number">1</span>) len++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="789-逃脱阻碍者"><a href="#789-逃脱阻碍者" class="headerlink" title="789. 逃脱阻碍者"></a>789. 逃脱阻碍者</h2><p><strong>Description</strong><br>你在进行一个简化版的吃豆人游戏。你从 (0, 0) 点开始出发，你的目的地是 (target[0], target[1]) 。地图上有一些阻碍者，第 i 个阻碍者从 (ghosts[i][0], ghosts[i][1]) 出发。<br>每一回合，你和阻碍者们<em>可以</em>同时向东，西，南，北四个方向移动，每次可以移动到距离原位置1个单位的新位置。<br>如果你可以在任何阻碍者抓住你之前到达目的地（阻碍者可以采取任意行动方式），则被视为逃脱成功。如果你和阻碍者同时到达了一个位置（包括目的地）都不算是逃脱成功。<br>当且仅当你有可能成功逃脱时，输出 True。<br><strong>Example</strong><br>示例 1:<br>输入：<br>ghosts = [[1, 0], [0, 3]]<br>target = [0, 1]<br>输出：true<br>解释：<br>你可以直接一步到达目的地(0,1)，在(1, 0)或者(0, 3)位置的阻碍者都不可能抓住你。</p>
<p>示例 2:<br>输入：<br>ghosts = [[1, 0]]<br>target = [2, 0]<br>输出：false<br>解释：<br>你需要走到位于(2, 0)的目的地，但是在(1, 0)的阻碍者位于你和目的地之间。</p>
<p>示例 3:<br>输入：<br>ghosts = [[2, 0]]<br>target = [1, 0]<br>输出：false<br>解释：<br>阻碍者可以和你同时达到目的地。</p>
<p>说明：<br>所有的点的坐标值的绝对值 &lt;= 10000。<br>阻碍者的数量不会超过 100。<br><strong>Program</strong><br><strong>思路</strong><br>看玩家与阻碍者谁先到目标点即可，题目可以四个方向走，也就是可以不走，只要阻碍者先到目标点守株待兔就行了。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(x-a)+<span class="built_in">abs</span>(y-b); <span class="comment">//两点横纵轴之差的绝对值之和，不要用平方</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">escapeGhosts</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ghosts, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> disMe=dis(<span class="number">0</span>, <span class="number">0</span>, target[<span class="number">0</span>], target[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ghosts.size();i++){</span><br><span class="line">            <span class="keyword">int</span> x=ghosts[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y=ghosts[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> tDis=dis(x, y, target[<span class="number">0</span>], target[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(tDis&lt;=disMe) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="843-猜猜这个单词"><a href="#843-猜猜这个单词" class="headerlink" title="843. 猜猜这个单词"></a>843. 猜猜这个单词</h2><p><strong>Description</strong><br>这个问题是 LeetCode 平台新增的交互式问题 。<br>我们给出了一个由一些独特的单词组成的单词列表，每个单词都是 6 个字母长，并且这个列表中的一个单词将被选作秘密。<br>你可以调用 master.guess(word) 来猜单词。你所猜的单词应当是存在于原列表并且由 6 个小写字母组成的类型字符串。<br>此函数将会返回一个整型数字，表示你的猜测与秘密单词的准确匹配（值和位置同时匹配）的数目。此外，如果你的猜测不在给定的单词列表中，它将返回 -1。<br>对于每个测试用例，你有 10 次机会来猜出这个单词。当所有调用都结束时，如果您对 master.guess 的调用不超过 10 次，并且至少有一次猜到秘密，那么您将通过该测试用例。<br>除了下面示例给出的测试用例外，还会有 5 个额外的测试用例，每个单词列表中将会有 100 个单词。这些测试用例中的每个单词的字母都是从 ‘a’ 到 ‘z’ 中随机选取的，并且保证给定单词列表中的每个单词都是唯一的。<br><strong>Example</strong><br>示例 1:<br>输入: secret = “acckzz”, wordlist = [“acckzz”,”ccbazz”,”eiowzz”,”abcczz”]<br>解释:<br>master.guess(“aaaaaa”) 返回 -1, 因为 “aaaaaa” 不在 wordlist 中.<br>master.guess(“acckzz”) 返回 6, 因为 “acckzz” 就是秘密，6个字母完全匹配。<br>master.guess(“ccbazz”) 返回 3, 因为 “ccbazz” 有 3 个匹配项。<br>master.guess(“eiowzz”) 返回 2, 因为 “eiowzz” 有 2 个匹配项。<br>master.guess(“abcczz”) 返回 4, 因为 “abcczz” 有 4 个匹配项。</p>
<p>我们调用了 5 次master.guess，其中一次猜到了秘密，所以我们通过了这个测试用例。<br>提示：任何试图绕过评判的解决方案都将导致比赛资格被取消。<br><strong>Program</strong><br><strong>启发式极小化极大算法</strong><br>显然，可行单词列表中的单词越少越好。如果数据随机，那么我们可以认定这个情况是普遍的。<br>现在，利用极小化极大算法猜测可行的单词列表。如果我们开始有 NN 个单词，我们通过迭代去选择可行单词。<br>算法<br>存储 H[i][j] 为 wordlist[i] 和 wordlist[j] 单词匹配数。每次猜测要求之前没有猜过，按照上面的说法实现极小化极大算法，每次选择猜测的单词是当前可行单词中的一个。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the Master's API interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class Master {</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     int guess(string word);</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calSim</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) {</span><br><span class="line">            res += s1[i] == s2[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; sim, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; candidates)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> N = candidates.size();</span><br><span class="line">        <span class="keyword">int</span> mn = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> mn_ind = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) {</span><br><span class="line">            <span class="keyword">if</span> (!candidates[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; counts(<span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) {</span><br><span class="line">                <span class="keyword">if</span> (j == i || !candidates[j]) <span class="keyword">continue</span>;</span><br><span class="line">                ++counts[sim[i][j]];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">int</span> mx = *max_element(counts.begin(), counts.end());</span><br><span class="line">            <span class="keyword">if</span> (mx &lt; mn) {</span><br><span class="line">                mn = mx;</span><br><span class="line">                mn_ind = i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> mn_ind;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findSecretWord</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordlist, Master&amp; master)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> N = wordlist.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; sim(N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) {</span><br><span class="line">            sim[i][i] = <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; ++j) {</span><br><span class="line">                sim[i][j] = sim[j][i] = calSim(wordlist[i], wordlist[j]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; candidates(N, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="keyword">int</span> i = findNext(sim, candidates);</span><br><span class="line">            <span class="keyword">int</span> s = master.guess(wordlist[i]);</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="number">6</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) {</span><br><span class="line">                <span class="keyword">if</span> (candidates[j] &amp;&amp; sim[j][i] != s) {</span><br><span class="line">                    candidates[j] = <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="913-猫和老鼠"><a href="#913-猫和老鼠" class="headerlink" title="913. 猫和老鼠"></a>913. 猫和老鼠</h2><p><strong>Description</strong><br>两个玩家分别扮演猫（Cat）和老鼠（Mouse）在无向图上进行游戏，他们轮流行动。<br>该图按下述规则给出：graph[a] 是所有结点 b 的列表，使得 ab 是图的一条边。<br>老鼠从结点 1 开始并率先出发，猫从结点 2 开始且随后出发，在结点 0 处有一个洞。<br>在每个玩家的回合中，他们必须沿着与他们所在位置相吻合的图的一条边移动。例如，如果老鼠位于结点 1，那么它只能移动到 graph[1] 中的（任何）结点去。<br>此外，猫无法移动到洞（结点 0）里。<br>然后，游戏在出现以下三种情形之一时结束：<br>如果猫和老鼠占据相同的结点，猫获胜。<br>如果老鼠躲入洞里，老鼠获胜。<br>如果某一位置重复出现（即，玩家们的位置和移动顺序都与上一个回合相同），游戏平局。<br>给定 graph，并假设两个玩家都以最佳状态参与游戏，如果老鼠获胜，则返回 1；如果猫获胜，则返回 2；如果平局，则返回 0。<br><strong>Example</strong><br>示例：<br>输入：[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]<br>输出：0<br>解释：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4---3---1</span><br><span class="line">|&nbsp; &nbsp;|</span><br><span class="line">2---5</span><br><span class="line">&nbsp;\&nbsp;/</span><br><span class="line">&nbsp; 0</span><br></pre></td></tr></tbody></table></figure>
<p>提示：<br>3 &lt;= graph.length &lt;= 200<br>保证 graph[1] 非空。<br>保证 graph[2] 包含非零元素。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> VI = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> VVI = <span class="built_in">vector</span>&lt;VI&gt;;</span><br><span class="line"><span class="keyword">using</span> VVVI = <span class="built_in">vector</span>&lt;VVI&gt;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(VVI&amp; graph, <span class="keyword">int</span> t, <span class="keyword">int</span> x, <span class="keyword">int</span> y, VVVI&amp; dp)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">2</span> * n) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 🏆比赛结束的几大条件按，参考A部分.不要return dp[t][x][y] = 2,想想为啥</span></span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span> dp[t][x][y] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> dp[t][x][y] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[t][x][y] != <span class="number">-1</span>) <span class="keyword">return</span> dp[t][x][y]; <span class="comment">// “不要搜了，爷👴已经搜好了”，老爷爷对小伙子说</span></span><br><span class="line">        <span class="keyword">if</span> (t % <span class="number">2</span> == <span class="number">0</span>){ <span class="comment">// 老鼠走🐀</span></span><br><span class="line">            <span class="keyword">bool</span> catWin = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[x].size(); ++ i){</span><br><span class="line">                <span class="keyword">int</span> nx = graph[x][i];</span><br><span class="line">                <span class="keyword">int</span> next = helper(graph, t + <span class="number">1</span>, nx, y, dp);</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="number">1</span>) <span class="keyword">return</span> dp[t][x][y] = <span class="number">1</span>; <span class="comment">// 直接回家</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (next != <span class="number">2</span>) catWin = <span class="literal">false</span>; <span class="comment">// 假如出现平地且没有回家，就说明下一步🐱不可能赢</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (catWin) <span class="keyword">return</span> dp[t][x][y] = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> dp[t][x][y] = <span class="number">0</span>;</span><br><span class="line">        }<span class="keyword">else</span>{ <span class="comment">// 猫猫走，和上面差不多啦</span></span><br><span class="line">            <span class="keyword">bool</span> mouseWin = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[y].size(); ++ i){</span><br><span class="line">                <span class="keyword">int</span> ny = graph[y][i];</span><br><span class="line">                <span class="keyword">if</span> (ny == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> next = helper(graph, t + <span class="number">1</span>, x, ny, dp);</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="number">2</span>) <span class="keyword">return</span> dp[t][x][y] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (next != <span class="number">1</span>) mouseWin = <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (mouseWin) <span class="keyword">return</span> dp[t][x][y] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> dp[t][x][y] = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">catMouseGame</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>{</span><br><span class="line">        n  = graph.size();</span><br><span class="line">        <span class="function">VVVI <span class="title">dp</span><span class="params">(<span class="number">2</span> * n, VVI(n, VI(n, <span class="number">-1</span>)))</span></span>;</span><br><span class="line">        <span class="keyword">return</span> helper(graph, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, dp);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>


<h2 id="面试题-16-07-最大数值"><a href="#面试题-16-07-最大数值" class="headerlink" title="面试题 16.07. 最大数值"></a>面试题 16.07. 最大数值</h2><p><strong>Description</strong><br>编写一个方法，找出两个数字a和b中最大的那一个。不得使用if-else或其他比较运算符。<br><strong>Example</strong><br>示例：<br>输入： a = 1, b = 2<br>输出： 2<br><strong>Program</strong><br>$[(a+b)+abs(a-b)]/2=max(a, b);$<br>$[(a+b)-abs(a-b)]/2=min(a, b);$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> s = (<span class="keyword">long</span>) a + b;</span><br><span class="line">        <span class="keyword">long</span> d = <span class="built_in">abs</span>((<span class="keyword">long</span>)a-b);</span><br><span class="line">        <span class="keyword">return</span> (s + d) / <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="535-TinyURL-的加密与解密"><a href="#535-TinyURL-的加密与解密" class="headerlink" title="535. TinyURL 的加密与解密"></a>535. TinyURL 的加密与解密</h2><p><strong>Description</strong><br>TinyURL是一种URL简化服务， 比如：当你输入一个URL <a href="https://leetcode.com/problems/design-tinyurl" target="_blank" rel="noopener">https://leetcode.com/problems/design-tinyurl</a> 时，它将返回一个简化的URL <a href="http://tinyurl.com/4e9iAk" target="_blank" rel="noopener">http://tinyurl.com/4e9iAk</a>.<br>要求：设计一个 TinyURL 的加密 encode 和解密 decode 的方法。你的加密和解密算法如何设计和运作是没有限制的，你只需要保证一个URL可以被加密成一个TinyURL，并且这个TinyURL可以用解密方法恢复成原本的URL。<br><strong>Program</strong><br>原封不动</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a URL to a shortened URL.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">encode</span><span class="params">(<span class="built_in">string</span> longUrl)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> longUrl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes a shortened URL to its original URL.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decode</span><span class="params">(<span class="built_in">string</span> shortUrl)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> shortUrl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Solution solution;</span></span><br><span class="line"><span class="comment">// solution.decode(solution.encode(url));</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span> str=<span class="string">"http://tinyurl.com/"</span>;</span><br><span class="line">    <span class="comment">// Encodes a URL to a shortened URL.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">encode</span><span class="params">(<span class="built_in">string</span> longUrl)</span> </span>{</span><br><span class="line">        m[i]=longUrl;</span><br><span class="line">        <span class="keyword">return</span> str + to_string(i++);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes a shortened URL to its original URL.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decode</span><span class="params">(<span class="built_in">string</span> shortUrl)</span> </span>{</span><br><span class="line">        <span class="built_in">string</span> s=shortUrl.substr(str.length());</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:s) i=i*<span class="number">10</span>+ch-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">return</span> m[i];</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Solution solution;</span></span><br><span class="line"><span class="comment">// solution.decode(solution.encode(url));</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="372-超级次方"><a href="#372-超级次方" class="headerlink" title="372. 超级次方"></a>372. 超级次方</h2><p><strong>Description</strong><br>你的任务是计算 a^b 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。<br><strong>Example</strong><br>示例 1:<br>输入: a = 2, b = [3]<br>输出: 8</p>
<p>示例 2:<br>输入: a = 2, b = [1,0]<br>输出: 1024<br><strong>Program</strong><br>超时</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addOne</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=str.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">int</span> d=(carry+str[i]-<span class="string">'0'</span>+<span class="number">1</span>)%<span class="number">10</span>;</span><br><span class="line">            carry=(carry+str[i]-<span class="string">'0'</span>+<span class="number">1</span>)/<span class="number">10</span>;</span><br><span class="line">            str[i]=d+<span class="string">'0'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(carry!=<span class="number">0</span>) str=to_string(carry)+str;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> str=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:b){</span><br><span class="line">            str+=x+<span class="string">'0'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">string</span> s=<span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s!=str){</span><br><span class="line">            ans=(ans*a+<span class="number">1337</span>)%<span class="number">1337</span>;</span><br><span class="line">            s=addOne(s);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>快速幂</strong><br>（1）$a^{[1,0,2,4]}=a^4 * (a^{1,0,2})^10$，所以递归求解;<br>（2）问题转化到$a^k$，二分：</p>
<ul>
<li>k为偶数，$a^k=a^{k/2} * a^{k/2}$;</li>
<li>k为奇数，$a^k=a * a^{k-1}$;</li>
<li>k为0，1;<br>（3）$(a * a)%MOD$可能溢出，可以转化为$((a%MOD) * (a%MOD))%MOD$;<br>证明：$a=Ak+c,b=Bk+d$<br>$(a * b)%k = (ABk^2+Adk+Bck+cd)%k=(cd)%k$<br>$((a%k) * (b%k))%k=(cd)%k$<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1337</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mypow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// a%=MOD;</span></span><br><span class="line">        <span class="keyword">if</span>(k%<span class="number">2</span>==<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">int</span> ans=mypow(a, k/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> ((ans%MOD) * (ans%MOD))%MOD;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">int</span> ans=mypow(a, k<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> ((ans)%MOD * (a%MOD))%MOD;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">1</span>||b.empty()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> last=b.back();</span><br><span class="line">        b.pop_back();</span><br><span class="line">        <span class="keyword">int</span> num1=mypow(a, last);</span><br><span class="line">        <span class="keyword">int</span> num2=mypow(superPow(a, b), <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> ((num1%MOD) * (num2%MOD)) % MOD;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1006-笨阶乘"><a href="#1006-笨阶乘" class="headerlink" title="1006. 笨阶乘"></a>1006. 笨阶乘</h2></li>
</ul>
<p><strong>Description</strong><br>通常，正整数 n 的阶乘是所有小于或等于 n 的正整数的乘积。例如，factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1。<br>相反，我们设计了一个笨阶乘 clumsy：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法( * )，除法(/)，加法(+)和减法(-)。<br>例如，clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。<br>另外，我们使用的除法是地板除法（floor division），所以 10 * 9 / 8 等于 11。这保证结果是一个整数。<br>实现上面定义的笨函数：给定一个整数 N，它返回 N 的笨阶乘。<br><strong>Example</strong><br>示例 1：<br>输入：4<br>输出：7<br>解释：7 = 4 * 3 / 2 + 1</p>
<p>示例 2：<br>输入：10<br>输出：12<br>解释：12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1</p>
<p>提示：<br>1 &lt;= N &lt;= 10000<br>-2^31 &lt;= answer &lt;= 2^31 - 1  （答案保证符合 32 位整数。）<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">clumsy</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> x=N;</span><br><span class="line">        <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> preAns=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">if</span>(idx==<span class="number">0</span>) ans=x;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(idx==<span class="number">1</span>) ans*=x;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(idx==<span class="number">2</span>){</span><br><span class="line">                ans/=x;</span><br><span class="line">                <span class="keyword">if</span>(preAns!=<span class="number">-1</span>) ans=preAns-ans;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(idx==<span class="number">3</span>){</span><br><span class="line">                ans+=x;</span><br><span class="line">                preAns=ans;</span><br><span class="line">                ans=<span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            idx++;</span><br><span class="line">            idx%=<span class="number">4</span>;</span><br><span class="line">            x--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(idx==<span class="number">4</span>) <span class="keyword">return</span> preAns;</span><br><span class="line">        <span class="keyword">if</span>(idx==<span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">return</span> (preAns!=<span class="number">-1</span>)?preAns-ans:ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="478-在圆内随机生成点"><a href="#478-在圆内随机生成点" class="headerlink" title="478. 在圆内随机生成点"></a>478. 在圆内随机生成点</h2><p><strong>Description</strong><br>给定圆的半径和圆心的 x、y 坐标，写一个在圆中产生均匀随机点的函数 randPoint 。</p>
<p>说明:<br>输入值和输出值都将是浮点数。<br>圆的半径和圆心的 x、y 坐标将作为参数传递给类的构造函数。<br>圆周上的点也认为是在圆中。<br>randPoint 返回一个包含随机点的x坐标和y坐标的大小为2的数组。<br><strong>Example</strong><br>示例 1：<br>输入:<br>[“Solution”,”randPoint”,”randPoint”,”randPoint”]<br>[[1,0,0],[],[],[]]<br>输出: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]</p>
<p>示例 2：<br>输入:<br>[“Solution”,”randPoint”,”randPoint”,”randPoint”]<br>[[10,5,-7.5],[],[],[]]<br>输出: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]</p>
<p>输入语法说明：<br>输入是两个列表：调用成员函数名和调用的参数。Solution 的构造函数有三个参数，圆的半径、圆心的 x 坐标、圆心的 y 坐标。randPoint 没有参数。输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。<br><strong>Program</strong><br><strong>思路</strong><br>考虑在圆心为原点的半径为题给r的圆上随机产生点，答案即平移后的结果。<br>圆：$x^2+y^2\leq r^2$<br>即$x^2+y^2= random() * r^2$,其中<code>random()</code>产生[0,1]的随机数<br>转成极坐标：<br>$\rho^2=random() * r^2,即\rho=\sqrt{random()} * r$<br>角度也是随机的：$\theta=random() * 2 \pi$<br>平移后坐标：$x=\rho * \cos\theta + x_{center}, y=\rho * \sin\theta + y_{center}.$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> rad, xc, yc;</span><br><span class="line">    <span class="comment">//c++11 random floating point number generation</span></span><br><span class="line">    mt19937 rng{random_device{}()};</span><br><span class="line">    uniform_real_distribution&lt;<span class="keyword">double</span>&gt; uni{<span class="number">0</span>, <span class="number">1</span>};</span><br><span class="line"></span><br><span class="line">    Solution(<span class="keyword">double</span> radius, <span class="keyword">double</span> x_center, <span class="keyword">double</span> y_center) {</span><br><span class="line">        rad = radius, xc = x_center, yc = y_center;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; randPoint() {</span><br><span class="line">        <span class="keyword">double</span> d = rad * <span class="built_in">sqrt</span>(uni(rng));</span><br><span class="line">        <span class="keyword">double</span> theta = uni(rng) * (<span class="number">2</span> * M_PI);</span><br><span class="line">        <span class="keyword">return</span> {d * <span class="built_in">cos</span>(theta) + xc, d * <span class="built_in">sin</span>(theta) + yc};</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="645-错误的集合"><a href="#645-错误的集合" class="headerlink" title="645. 错误的集合"></a>645. 错误的集合</h2><p><strong>Description</strong><br>集合 S 包含从1到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。<br>给定一个数组 nums 代表了集合 S 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。<br><strong>Example</strong><br>示例 1:<br>输入: nums = [1,2,2,4]<br>输出: [2,3]<br>注意:<br>给定数组的长度范围是 [2, 10000]。<br>给定的数组是无序的。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findErrorNums(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="keyword">int</span> m[<span class="number">10001</span>];</span><br><span class="line">        <span class="keyword">bool</span> vis[<span class="number">10001</span>];</span><br><span class="line">        <span class="built_in">memset</span>(m,<span class="number">0</span>,<span class="keyword">sizeof</span>(m));</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums){</span><br><span class="line">            m[x]++;</span><br><span class="line">            <span class="keyword">if</span>(m[x]&gt;<span class="number">1</span>&amp;&amp;!vis[x]){</span><br><span class="line">                 res.push_back(x);</span><br><span class="line">                 vis[x]=<span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nums.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(m[i]==<span class="number">0</span>) res.push_back(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="592-分数加减运算"><a href="#592-分数加减运算" class="headerlink" title="592. 分数加减运算"></a>592. 分数加减运算</h2><p><strong>Description</strong><br>给定一个表示分数加减运算表达式的字符串，你需要返回一个字符串形式的计算结果。 这个结果应该是不可约分的分数，即最简分数。 如果最终结果是一个整数，例如 2，你需要将它转换成分数形式，其分母为 1。所以在上述例子中, 2 应该被转换为 2/1。<br><strong>Example</strong><br>示例 1:<br>输入:”-1/2+1/2”<br>输出: “0/1”</p>
<p>示例 2:<br>输入:”-1/2+1/2+1/3”<br>输出: “1/3”</p>
<p>示例 3:<br>输入:”1/3-1/2”<br>输出: “-1/6”</p>
<p>示例 4:<br>输入:”5/3+1/3”<br>输出: “2/1”</p>
<p>说明:<br>输入和输出字符串只包含 ‘0’ 到 ‘9’ 的数字，以及 ‘/‘, ‘+’ 和 ‘-‘。<br>输入和输出分数格式均为 ±分子/分母。如果输入的第一个分数或者输出的分数是正数，则 ‘+’ 会被省略掉。<br>输入只包含合法的最简分数，每个分数的分子与分母的范围是  [1,10]。 如果分母是1，意味着这个分数实际上是一个整数。<br>输入的分数个数范围是 [1,10]。<br>最终结果的分子与分母保证是 32 位整数范围内的有效整数。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fraction</span>{</span></span><br><span class="line">        <span class="keyword">int</span> up;</span><br><span class="line">        <span class="keyword">int</span> down;</span><br><span class="line">        Fraction(){}</span><br><span class="line">        Fraction(<span class="keyword">int</span> Up, <span class="keyword">int</span> Down):up(Up), down(Down){}</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> y==<span class="number">0</span>?x:gcd(y, x%y);</span><br><span class="line">    }</span><br><span class="line">    <span class="function">Fraction <span class="title">reduction</span><span class="params">(Fraction fraction)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(fraction.down&lt;<span class="number">0</span>){</span><br><span class="line">            fraction.up=-fraction.up;</span><br><span class="line">            fraction.down=-fraction.down;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(fraction.up==<span class="number">0</span>) fraction.down=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">int</span> gd=gcd(<span class="built_in">abs</span>(fraction.up), <span class="built_in">abs</span>(fraction.down)); <span class="comment">//取正数的最大公因子</span></span><br><span class="line">            fraction.up/=gd;</span><br><span class="line">            fraction.down/=gd;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> fraction;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">Fraction <span class="title">add</span><span class="params">(Fraction a, Fraction b)</span></span>{</span><br><span class="line">        Fraction fraction;</span><br><span class="line">        fraction.up=a.up*b.down+b.up*a.down;</span><br><span class="line">        fraction.down=a.down*b.down;</span><br><span class="line">        <span class="keyword">return</span> reduction(fraction);</span><br><span class="line">    }</span><br><span class="line">    <span class="function">Fraction <span class="title">sub</span><span class="params">(Fraction a, Fraction b)</span></span>{</span><br><span class="line">        Fraction fraction;</span><br><span class="line">        fraction.up=a.up*b.down-b.up*a.down;</span><br><span class="line">        fraction.down=a.down*b.down;</span><br><span class="line">        <span class="keyword">return</span> reduction(fraction);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sToi</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++){</span><br><span class="line">            ans=ans*<span class="number">10</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">Fraction <span class="title">handleStr</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">        Fraction fraction;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'-'</span>) {flag=<span class="number">-1</span>;str=str.substr(<span class="number">1</span>);}</span><br><span class="line">        <span class="keyword">int</span> idx=str.find(<span class="string">'/'</span>);</span><br><span class="line">        fraction.up=flag*sToi(str.substr(<span class="number">0</span>, idx));</span><br><span class="line">        fraction.down=sToi(str.substr(idx+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> reduction(fraction);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">fractionAddition</span><span class="params">(<span class="built_in">string</span> expression)</span> </span>{</span><br><span class="line">        <span class="built_in">queue</span>&lt;Fraction&gt; q;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;expression.length();i++){</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(expression[i]==<span class="string">'+'</span>||expression[i]==<span class="string">'-'</span>){</span><br><span class="line">                    <span class="built_in">string</span> s=expression.substr(start, i-start);</span><br><span class="line">                    q.push(handleStr(s));</span><br><span class="line">                    start=i;</span><br><span class="line">                    <span class="keyword">if</span>(expression[i]==<span class="string">'+'</span>) start++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        q.push(handleStr(expression.substr(start))); <span class="comment">//最后一个分数</span></span><br><span class="line">        <span class="keyword">while</span>(q.size()&gt;<span class="number">1</span>){</span><br><span class="line">            Fraction a=q.front();q.pop();</span><br><span class="line">            Fraction b=q.front();q.pop();</span><br><span class="line">            q.push(add(a, b));</span><br><span class="line">        }</span><br><span class="line">        Fraction res=q.front();q.pop();</span><br><span class="line">        <span class="built_in">string</span> result=<span class="string">""</span>;</span><br><span class="line">        result+=to_string(res.up);</span><br><span class="line">        result+=<span class="string">'/'</span>;</span><br><span class="line">        result+=to_string(res.down);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="剑指-Offer-59-I-滑动窗口的最大值-1"><a href="#剑指-Offer-59-I-滑动窗口的最大值-1" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值"></a>剑指 Offer 59 - I. 滑动窗口的最大值</h2><p><strong>Description</strong><br>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。<br><strong>Example</strong><br>示例:<br>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></tbody></table></figure>

<p>提示：<br>你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。<br><strong>Program</strong><br>保持双端队列首位为最大值，队列降序排列！<br>一个窗口中，较小的数在前面可以剔除，因为后续窗口移动过程中，一定不会是它为窗口最大值。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++){</span><br><span class="line">            <span class="keyword">while</span>(!dq.empty()&amp;&amp;nums[dq.back()]&lt;nums[i]) dq.pop_back();</span><br><span class="line">            dq.push_back(i);</span><br><span class="line">        }</span><br><span class="line">        res.push_back(nums[dq[<span class="number">0</span>]]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(dq[<span class="number">0</span>]&lt;=i-k) dq.pop_front();</span><br><span class="line">             <span class="keyword">while</span>(!dq.empty()&amp;&amp;nums[dq.back()]&lt;nums[i]) dq.pop_back();</span><br><span class="line">             dq.push_back(i);</span><br><span class="line">             res.push_back(nums[dq[<span class="number">0</span>]]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>


<h2 id="1390-四因数"><a href="#1390-四因数" class="headerlink" title="1390. 四因数"></a>1390. 四因数</h2><p><strong>Description</strong><br>给你一个整数数组 nums，请你返回该数组中恰有四个因数的这些整数的各因数之和。<br>如果数组中不存在满足题意的整数，则返回 0 。<br><strong>Example</strong><br>示例：<br>输入：nums = [21,4,7]<br>输出：32<br>解释：<br>21 有 4 个因数：1, 3, 7, 21<br>4 有 3 个因数：1, 2, 4<br>7 有 2 个因数：1, 7<br>答案仅为 21 的所有因数的和。</p>
<p>提示：<br>1 &lt;= nums.length &lt;= 10^4<br>1 &lt;= nums[i] &lt;= 10^5<br><strong>Program</strong><br><strong>暴力</strong><br>时间复杂度：$O(n * \sqrt{n})$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumFourDivisors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j*j&lt;=nums[i];j++){</span><br><span class="line">                <span class="keyword">if</span>(nums[i]%j==<span class="number">0</span>){</span><br><span class="line">                    st.insert(j);</span><br><span class="line">                    <span class="keyword">if</span>(nums[i]/j!=j) st.insert(nums[i]/j);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(st.size()&gt;<span class="number">4</span>)<span class="keyword">break</span>; <span class="comment">//节约点时间</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(st.size()==<span class="number">4</span>){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x:st) ans+=x;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>预处理</strong><br><img src="/assets/img/algorithm/1390_example_01.png" alt="image"><br><img src="/assets/img/algorithm/1390_example_02.png" alt="image"><br>时间还没第一种块。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span> isPrime[MAXN]={<span class="literal">false</span>};</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; primes;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Euler</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;MAXN;i++){</span><br><span class="line">            <span class="keyword">if</span>(!isPrime[i]){</span><br><span class="line">                isPrime[i]=<span class="literal">true</span>;</span><br><span class="line">                primes.push_back(i);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;primes.size()&amp;&amp;i*primes[j]&lt;MAXN;j++){</span><br><span class="line">                isPrime[i*primes[j]]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumFourDivisors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        Euler(); <span class="comment">//欧拉筛选</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; num_factor4;<span class="comment">//只有四因子的数，其因子之和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> prime:primes){</span><br><span class="line">            <span class="keyword">if</span>(prime*prime*prime&lt;=MAXN){</span><br><span class="line">                num_factor4[prime*prime*prime]=<span class="number">1</span>+prime+prime*prime+prime*prime*prime;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;primes.size();i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;primes.size();j++){</span><br><span class="line">                <span class="keyword">if</span>(primes[i]&lt;=MAXN/primes[j]){</span><br><span class="line">                    num_factor4[primes[i]*primes[j]]=<span class="number">1</span>+primes[i]+primes[j]+primes[i]*primes[j];</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums){</span><br><span class="line">            <span class="keyword">if</span>(num_factor4.find(num)!=num_factor4.end()){</span><br><span class="line">                ans+=num_factor4[num];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="838-推多米诺"><a href="#838-推多米诺" class="headerlink" title="838. 推多米诺"></a>838. 推多米诺</h2><p><strong>Description</strong><br>一行中有 N 张多米诺骨牌，我们将每张多米诺骨牌垂直竖立。<br>在开始时，我们同时把一些多米诺骨牌向左或向右推。<br><img src="/assets/img/algorithm/838_example_01.png" alt="image"><br>每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。<br>同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。<br>如果同时有多米诺骨牌落在一张垂直竖立的多米诺骨牌的两边，由于受力平衡， 该骨牌仍然保持不变。<br>就这个问题而言，我们会认为正在下降的多米诺骨牌不会对其它正在下降或已经下降的多米诺骨牌施加额外的力。<br>给定表示初始状态的字符串 “S” 。如果第 i 张多米诺骨牌被推向左边，则 S[i] = ‘L’；如果第 i 张多米诺骨牌被推向右边，则 S[i] = ‘R’；如果第 i 张多米诺骨牌没有被推动，则 S[i] = ‘.’。<br>返回表示最终状态的字符串。<br><strong>Example</strong><br>示例 1：<br>输入：”.L.R…LR..L..”<br>输出：”LL.RR.LLRRLL..”</p>
<p>示例 2：<br>输入：”RR.L”<br>输出：”RR.L”<br>说明：第一张多米诺骨牌没有给第二张施加额外的力。</p>
<p>提示：<br>0 &lt;= N &lt;= 10^5<br>表示多米诺骨牌状态的字符串只含有 ‘L’，’R’; 以及 ‘.’;<br><strong>Program</strong><br>两个新串l_str,r_str分别仅记录左推和右推后的结果，则结果字符串res为：<br>（1）l_str[i]==r_str[i]，即初试R或L的位置或者无作用力的’.’;<br>（2）l_str[i]==L&amp;&amp;r_str[i]==R，表示受两边R和L的作用，得到整个区间，res在该区间左半部分为R，右半部分为L，中间（奇数）为’.’；<br>（3）l_str[i]==’L’&amp;&amp;r_str[i]==’.’,res[i]=L;<br>（4）l_str[i]==’.’&amp;&amp;r_str[i]==’R’，res[i]=R;</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">pushDominoes</span><span class="params">(<span class="built_in">string</span> dominoes)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=dominoes.length();</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">l_str</span><span class="params">(dominoes)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">r_str</span><span class="params">(dominoes)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">if</span>(l_str[i]==<span class="string">'.'</span>&amp;&amp;l_str[i+<span class="number">1</span>]==<span class="string">'L'</span>) l_str[i]=<span class="string">'L'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(r_str[i]==<span class="string">'.'</span>&amp;&amp;r_str[i<span class="number">-1</span>]==<span class="string">'R'</span>) r_str[i]=<span class="string">'R'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">res</span><span class="params">(n, <span class="string">'.'</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">-1</span>, end=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(l_str[i]==r_str[i]) res[i]=l_str[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(l_str[i]==<span class="string">'L'</span>&amp;&amp;r_str[i]==<span class="string">'.'</span>) res[i]=<span class="string">'L'</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(l_str[i]==<span class="string">'.'</span>&amp;&amp;r_str[i]==<span class="string">'R'</span>) res[i]=<span class="string">'R'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){ <span class="comment">//计算受两边力的区间，并计算结果</span></span><br><span class="line">            <span class="keyword">if</span>(l_str[i]==<span class="string">'L'</span>&amp;&amp;r_str[i]==<span class="string">'R'</span>){</span><br><span class="line">                <span class="keyword">if</span>(start==<span class="number">-1</span>) start=i;</span><br><span class="line">                end=i;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(!(l_str[i]==<span class="string">'L'</span>&amp;&amp;r_str[i]==<span class="string">'R'</span>)&amp;&amp;start!=<span class="number">-1</span>){</span><br><span class="line">                <span class="keyword">int</span> mid=(start+end+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> s=start;s&lt;mid;s++) res[s]=<span class="string">'R'</span>;</span><br><span class="line">                <span class="keyword">if</span>((end-start+<span class="number">1</span>)%<span class="number">2</span>!=<span class="number">0</span>) res[mid++]=<span class="string">'.'</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> s=mid;s&lt;=end;s++) res[s]=<span class="string">'L'</span>;</span><br><span class="line">                start=<span class="number">-1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="面试题-17-09-第-k-个数"><a href="#面试题-17-09-第-k-个数" class="headerlink" title="面试题 17.09. 第 k 个数"></a>面试题 17.09. 第 k 个数</h2><p><strong>Description</strong><br>有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。<br><strong>Example</strong><br>示例 1:<br>输入: k = 5<br>输出: 9<br><strong>Program</strong><br>思路：<br>每次希望产生较小的数作为第i个数，且要求没有重复计算，很自然采用三指针。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKthMagicNumber</span><span class="params">(<span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> p3=<span class="number">0</span>,p5=<span class="number">0</span>,p7=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> arr[k];</span><br><span class="line">        <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line">        arr[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++){</span><br><span class="line">            <span class="keyword">int</span> x=min(arr[p3]*<span class="number">3</span>, min(arr[p5]*<span class="number">5</span>, arr[p7]*<span class="number">7</span>));</span><br><span class="line">            <span class="keyword">if</span>(x==arr[p3]*<span class="number">3</span>) p3++;</span><br><span class="line">            <span class="keyword">if</span>(x==arr[p5]*<span class="number">5</span>) p5++;</span><br><span class="line">            <span class="keyword">if</span>(x==arr[p7]*<span class="number">7</span>) p7++;</span><br><span class="line">            arr[i]=x;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> arr[k<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1015-可被-K-整除的最小整数"><a href="#1015-可被-K-整除的最小整数" class="headerlink" title="1015. 可被 K 整除的最小整数"></a>1015. 可被 K 整除的最小整数</h2><p><strong>Description</strong><br>给定正整数 K，你需要找出可以被 K 整除的、仅包含数字 1 的最小正整数 N。<br>返回 N 的长度。如果不存在这样的 N，就返回 -1。<br><strong>Example</strong><br>示例 1：<br>输入：1<br>输出：1<br>解释：最小的答案是 N = 1，其长度为 1。</p>
<p>示例 2：<br>输入：2<br>输出：-1<br>解释：不存在可被 2 整除的正整数 N 。</p>
<p>示例 3：<br>输入：3<br>输出：3<br>解释：最小的答案是 N = 111，其长度为 3。</p>
<p>提示：<br>1 &lt;= K &lt;= 10^5<br><strong>Program</strong><br>正常思路为：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(x%K!=<span class="number">0</span>){</span><br><span class="line">  x=<span class="number">10</span>*x+<span class="number">1</span>;  <span class="comment">//会溢出</span></span><br><span class="line">  len++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>由于容易溢出，所以得想想办法：<br>$x_i=ak+b$<br>$x_{i+1}*10+1=10ak+b+1$<br>即$x_i \mod k=b$,<br>$x_{i+1} \mod k=(b+1) \mod k=(x_i \mod k+1) \mod k$<br>所以求$x_{i+1}$时，我们只需要$x_i$的一部分$b$来组成$x_{i+1}$可以避免溢出，因为$0&lt;k&lt;10^5$，所以不会溢出。<br>另外注意$k=2或k=5$一定不会有答案，因为这两个数作为因子，所得的数个位一定不会为1！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">smallestRepunitDivByK</span><span class="params">(<span class="keyword">int</span> K)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(K%<span class="number">2</span>==<span class="number">0</span>||K%<span class="number">5</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//一定不可能有答案</span></span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(x%K!=<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">int</span> b=x%K; <span class="comment">//防止溢出</span></span><br><span class="line">            x=<span class="number">10</span>*b+<span class="number">1</span>;</span><br><span class="line">            len++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>


<h2 id="1175-质数排列"><a href="#1175-质数排列" class="headerlink" title="1175. 质数排列"></a>1175. 质数排列</h2><p><strong>Description</strong><br>请你帮忙给从 1 到 n 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。<br>让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。<br>由于答案可能会很大，所以请你返回答案 模 mod 10^9 + 7 之后的结果即可。<br><strong>Example</strong><br>示例 1：<br>输入：n = 5<br>输出：12<br>解释：举个例子，[1,2,5,4,3] 是一个有效的排列，但 [5,2,3,4,1] 不是，因为在第二种情况里质数 5 被错误地放在索引为 1 的位置上。</p>
<p>示例 2：<br>输入：n = 100<br>输出：682289015</p>
<p>提示：<br>1 &lt;= n &lt;= 100<br><strong>Program</strong><br><strong>欧拉筛选/阶乘/排列组合</strong><br>首先计算[1,n]内质数个数k，则结果为:<br>$k! * (n-k)!$<br>而如何求质数个数呢？<br>欧拉筛选：时间复杂度$O(n)$<br>总的时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">calFactorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>{ <span class="comment">//阶乘</span></span><br><span class="line">        <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">1</span>){</span><br><span class="line">            ans=(ans*n)%MOD;</span><br><span class="line">            n--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numPrimeArrangements</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">bool</span> isPrime[n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; primes;</span><br><span class="line">        <span class="built_in">memset</span>(isPrime, <span class="literal">false</span>, <span class="keyword">sizeof</span>(isPrime));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++){ <span class="comment">//欧拉筛选</span></span><br><span class="line">            <span class="keyword">if</span>(!isPrime[i]){</span><br><span class="line">                isPrime[i]=<span class="literal">true</span>;</span><br><span class="line">                primes.push_back(i);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;primes.size()&amp;&amp;i*primes[j]&lt;=n;j++){</span><br><span class="line">                isPrime[i*primes[j]]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> (calFactorial(primes.size())*calFactorial(n-primes.size()))%MOD;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="640-求解方程"><a href="#640-求解方程" class="headerlink" title="640. 求解方程"></a>640. 求解方程</h2><p><strong>Description</strong><br>求解一个给定的方程，将x以字符串”x=#value”的形式返回。该方程仅包含’+’，’ - ‘操作，变量 x 和其对应系数。<br>如果方程没有解，请返回“No solution”。<br>如果方程有无限解，则返回“Infinite solutions”。<br>如果方程中只有一个解，要保证返回值 x 是一个整数。<br><strong>Example</strong><br>示例 1：<br>输入: “x+5-3+x=6+x-2”<br>输出: “x=2”</p>
<p>示例 2:<br>输入: “x=x”<br>输出: “Infinite solutions”</p>
<p>示例 3:<br>输入: “2x=x”<br>输出: “x=0”</p>
<p>示例 4:<br>输入: “2x+3x-6x=x+2”<br>输出: “x=-1”</p>
<p>示例 5:<br>输入: “x=x+2”<br>输出: “No solution”<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sToi</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">""</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//空字符串即x</span></span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"-"</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'-'</span>) {flag=<span class="number">-1</span>;str=str.substr(<span class="number">1</span>);};</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++){</span><br><span class="line">            ans=ans*<span class="number">10</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> flag*ans;</span><br><span class="line">    }</span><br><span class="line">    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; calEquation(<span class="built_in">string</span> str){</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=str.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">'+'</span>||str[i]==<span class="string">'-'</span>){</span><br><span class="line">                <span class="built_in">string</span> s;</span><br><span class="line">                <span class="keyword">if</span>(str[i<span class="number">-1</span>]==<span class="string">'x'</span>) {</span><br><span class="line">                    s=str.substr(start, i<span class="number">-2</span>-start+<span class="number">1</span>);</span><br><span class="line">                    x+=sToi(s);</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    s=str.substr(start,i<span class="number">-1</span>-start+<span class="number">1</span>);</span><br><span class="line">                    num+=sToi(s);</span><br><span class="line">                }</span><br><span class="line">                start=i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(str[i]==<span class="string">'-'</span>) start--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">string</span> s=str.substr(start);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;s&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(s[s.length()<span class="number">-1</span>]==<span class="string">'x'</span>) x+=sToi(s.substr(<span class="number">0</span>, s.length()<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">else</span> num+=sToi(s);</span><br><span class="line">        <span class="keyword">return</span> {x, num};</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">solveEquation</span><span class="params">(<span class="built_in">string</span> equation)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> idx=equation.find(<span class="string">'='</span>);</span><br><span class="line">        <span class="built_in">string</span> lq=equation.substr(<span class="number">0</span>, idx);</span><br><span class="line">        <span class="built_in">string</span> rq=equation.substr(idx+<span class="number">1</span>);</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; lp=calEquation(lq); <span class="comment">//计算左方程组x系数以及数字和</span></span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; rp=calEquation(rq); <span class="comment">//计算右方程x系数以及数字和</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;lp.first&lt;&lt;" "&lt;&lt;lp.second&lt;&lt;endl</span></span><br><span class="line">        <span class="comment">//     &lt;&lt;rp.first&lt;&lt;" "&lt;&lt;rp.second&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">int</span> lx=lp.first-rp.first;  <span class="comment">//x全移到左边</span></span><br><span class="line">        <span class="keyword">int</span> rnum=rp.second-lp.second; <span class="comment">//数字全移到右边</span></span><br><span class="line">        <span class="keyword">if</span>(lx==rnum&amp;&amp;lx==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">"Infinite solutions"</span>; <span class="comment">//左右两边都为0，则有无限解</span></span><br><span class="line">        <span class="keyword">if</span>(lx==<span class="number">0</span>&amp;&amp;rnum!=<span class="number">0</span>) <span class="keyword">return</span> <span class="string">"No solution"</span>; <span class="comment">//左为0，右不为0，无解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"x="</span>+to_string(rnum/lx); <span class="comment">//左不为0，求解</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="970-强整数"><a href="#970-强整数" class="headerlink" title="970. 强整数"></a>970. 强整数</h2><p><strong>Description</strong><br>给定两个正整数 x 和 y，如果某一整数等于 x^i + y^j，其中整数 i &gt;= 0 且 j &gt;= 0，那么我们认为该整数是一个强整数。<br>返回值小于或等于 bound 的所有强整数组成的列表。<br>你可以按任何顺序返回答案。在你的回答中，每个值最多出现一次。<br><strong>Example</strong><br>示例 1：<br>输入：x = 2, y = 3, bound = 10<br>输出：[2,3,4,5,7,9,10]<br>解释：<br>2 = 2^0 + 3^0<br>3 = 2^1 + 3^0<br>4 = 2^0 + 3^1<br>5 = 2^1 + 3^1<br>7 = 2^2 + 3^1<br>9 = 2^3 + 3^0<br>10 = 2^0 + 3^2</p>
<p>示例 2：<br>输入：x = 3, y = 5, bound = 15<br>输出：[2,4,6,8,10,14]</p>
<p>提示：<br>1 &lt;= x &lt;= 100<br>1 &lt;= y &lt;= 100<br>0 &lt;= bound &lt;= 10^6<br><strong>Program</strong><br><strong>思路</strong><br>注意特判x，y为1的情况，因为1的任何次方都为1.<br>最坏时间复杂度：$O((\log_{2}{n})^2)$，其中n为bound的范围</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; powerfulIntegers(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> bound) {</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>&amp;&amp;y==<span class="number">1</span>){</span><br><span class="line">            <span class="keyword">if</span>(bound&gt;=<span class="number">2</span>) <span class="keyword">return</span> {<span class="number">2</span>};</span><br><span class="line">            <span class="keyword">return</span> {};</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>((x!=<span class="number">1</span>&amp;&amp;y==<span class="number">1</span>)||(x==<span class="number">1</span>&amp;&amp;y!=<span class="number">1</span>)){</span><br><span class="line">            <span class="keyword">int</span> z=x==<span class="number">1</span>?y:x;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;(<span class="keyword">int</span>)<span class="built_in">pow</span>(z, i)+<span class="number">1</span>&lt;=bound;i++) res.push_back((<span class="keyword">int</span>)<span class="built_in">pow</span>(z, i)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;(<span class="keyword">int</span>)<span class="built_in">pow</span>(x, i)&lt;=bound;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;(<span class="keyword">int</span>)<span class="built_in">pow</span>(y, j)&lt;=bound;j++){</span><br><span class="line">                <span class="keyword">int</span> p=(<span class="keyword">int</span>)<span class="built_in">pow</span>(x, i)+(<span class="keyword">int</span>)<span class="built_in">pow</span>(y, j);</span><br><span class="line">                <span class="keyword">if</span>(p&lt;=bound){</span><br><span class="line">                    st.insert(p);</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(st.begin(), st.end());</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="面试题-01-05-一次编辑"><a href="#面试题-01-05-一次编辑" class="headerlink" title="面试题 01.05. 一次编辑"></a>面试题 01.05. 一次编辑</h2><p><strong>Description</strong><br>字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。<br><strong>Example</strong><br>示例 1:<br>输入:<br>first = “pale”<br>second = “ple”<br>输出: True</p>
<p>示例 2:<br>输入:<br>first = “pales”<br>second = “pal”<br>输出: False<br><strong>Program</strong><br><strong>思路</strong><br>双指针，p1,p2分别表示长串和短串的指针<br>（1）两字符串相等，满足题意<br>（2）两字符串长度相差大于等于2，不满足题意<br>（3）两字符串长度相差1：<br>①first[p1]==second[p2],俩指针自增1；<br>②否则，如果俩字符串长度相等，则替换操作，isOpt=true，俩指针自增1；<br>③否则，即俩子串长度不等，则添加操作(删除与添加等价)，isOpt=true, p1自增，p2不变；（如果采用删除而不是添加也一样，p1自增，p2不变）<br>④在整个过程中如果有isOpt==true，则说明已经编辑了一次，如果还需要编辑，则不满足题意，直接返回false.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">oneEditAway</span><span class="params">(<span class="built_in">string</span> first, <span class="built_in">string</span> second)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(first==second) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> m=first.length();</span><br><span class="line">        <span class="keyword">int</span> n=second.length();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(m-n)&gt;=<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(m&lt;n){ <span class="comment">//使得second更短</span></span><br><span class="line">            swap(first, second);</span><br><span class="line">            swap(m, n);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> p1, p2;</span><br><span class="line">        p1=p2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> isOpt=<span class="literal">false</span>; <span class="comment">//是否操作</span></span><br><span class="line">        <span class="keyword">while</span>(p1&lt;m&amp;&amp;p2&lt;n){</span><br><span class="line">            <span class="keyword">if</span>(first[p1]==second[p2]){p1++;p2++;}</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">if</span>(isOpt) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span>{</span><br><span class="line">                    isOpt=<span class="literal">true</span>;</span><br><span class="line">                    p1++;</span><br><span class="line">                    p2+=(m==n)?<span class="number">1</span>:<span class="number">0</span>; <span class="comment">//相等则替换，不等则添加，添加与删除 变成一个操作添加</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="441-排列硬币"><a href="#441-排列硬币" class="headerlink" title="441. 排列硬币"></a>441. 排列硬币</h2><p><strong>Description</strong><br>你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。<br>给定一个数字 n，找出可形成完整阶梯行的总行数。<br>n 是一个非负整数，并且在32位有符号整型的范围内。<br><strong>Example</strong><br>示例 1:<br>n = 5<br>硬币可排列成以下几行:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">¤</span><br><span class="line">¤ ¤</span><br><span class="line">¤ ¤</span><br></pre></td></tr></tbody></table></figure>
<p>因为第三行不完整，所以返回2.</p>
<p>示例 2:<br>n = 8<br>硬币可排列成以下几行:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">¤</span><br><span class="line">¤ ¤</span><br><span class="line">¤ ¤ ¤</span><br><span class="line">¤ ¤</span><br></pre></td></tr></tbody></table></figure>
<p>因为第四行不完整，所以返回3.<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> N=n;</span><br><span class="line">        <span class="keyword">long</span> rows=(<span class="keyword">long</span>)INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> row=<span class="number">1</span>;row&lt;rows&amp;&amp;row*(row+<span class="number">1</span>)/<span class="number">2</span>&lt;=N;row++){</span><br><span class="line">            ans=row;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> left=<span class="number">1</span>, right=n;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right){</span><br><span class="line">            <span class="keyword">long</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">long</span> s=mid*(mid+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(s==n) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s&gt;n) right=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> left<span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a>215. 数组中的第K个最大元素</h2><p><strong>Description</strong><br>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br><strong>Example</strong><br>示例 1:<br>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5</p>
<p>示例 2:<br>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4<br>说明:<br>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。<br>。<br><strong>Program</strong><br><strong>库函数</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        sort(nums.begin(), nums.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">return</span> nums[k<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>快排</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> temp=nums[left];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]&gt;=temp) right--;</span><br><span class="line">            nums[left]=nums[right];</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]&lt;=temp) left++;</span><br><span class="line">            nums[right]=nums[left];</span><br><span class="line">        }</span><br><span class="line">        nums[left]=temp;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len=nums.size();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> pos=partition(nums, left, right);</span><br><span class="line">        <span class="keyword">while</span>(pos+k!=len){</span><br><span class="line">            <span class="keyword">if</span>(pos+k&lt;len) pos=partition(nums, pos+<span class="number">1</span>, right);</span><br><span class="line">            <span class="keyword">else</span> pos=partition(nums, left, pos<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nums[pos];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>堆排序</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> i=low, j=i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=high){</span><br><span class="line">            <span class="keyword">if</span>(j&lt;high&amp;&amp;nums[j+<span class="number">1</span>]&gt;nums[j]) j++;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[j]){</span><br><span class="line">                swap(nums[i], nums[j]);</span><br><span class="line">                i=j;</span><br><span class="line">                j=i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=(n<span class="number">-1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            downAdjust(nums, i, n);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        createHeap(nums);</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=n-k;i--){</span><br><span class="line">            swap(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">            downAdjust(nums, <span class="number">0</span>, i<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nums[n-k];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a>剑指 Offer 09. 用两个栈实现队列</h2><p><strong>Description</strong><br>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )<br><strong>Example</strong><br>示例 1：<br>输入：<br>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[3],[],[]]<br>输出：[null,null,3,-1]</p>
<p>示例 2：<br>输入：<br>[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[],[5],[2],[],[]]<br>输出：[null,-1,null,null,5,2]<br>提示：<br>1 &lt;= values &lt;= 10000<br>最多会对 appendTail、deleteHead 进行 10000 次调用<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; inSt, ouSt; <span class="comment">//进出栈</span></span><br><span class="line">    CQueue() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        inSt.push(value);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(ouSt.empty()){</span><br><span class="line">            <span class="keyword">if</span>(inSt.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(!inSt.empty()) {ouSt.push(inSt.top()); inSt.pop();}</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> tp=ouSt.top();ouSt.pop();</span><br><span class="line">        <span class="keyword">return</span> tp;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue* obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II"></a>350. 两个数组的交集 II</h2><p><strong>Description</strong><br>给定两个数组，编写一个函数来计算它们的交集。<br><strong>Example</strong><br>示例 1:<br>输入: nums1 = [1,2,2,1], nums2 = [2,2]<br>输出: [2,2]</p>
<p>示例 2:<br>输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>输出: [4,9]<br>说明：</p>
<p>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。<br>我们可以不考虑输出结果的顺序。<br>进阶:<br>如果给定的数组已经排好序呢？你将如何优化你的算法？<br>如果 nums1 的大小比 nums2 小很多，哪种方法更优？<br>如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？<br><strong>Program</strong><br><strong>排序</strong><br>排序后，双指针，更小的右移，相同的加入结果集。<br>时间复杂度：$O(n\log{n}+m\log{m})$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) {</span><br><span class="line">        <span class="keyword">int</span> m=nums1.size(), n=nums2.size();</span><br><span class="line">        sort(nums1.begin(), nums1.end());</span><br><span class="line">        sort(nums2.begin(), nums2.end());</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>, r=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;m&amp;&amp;r&lt;n){</span><br><span class="line">            <span class="keyword">if</span>(nums1[l]==nums2[r]){</span><br><span class="line">                res.push_back(nums1[l]);l++;r++;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(nums1[l]&gt;nums2[r]) r++;</span><br><span class="line">            <span class="keyword">else</span> l++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>哈希表</strong><br>哈希表记录短的数组。<br>时间复杂度：$O(m+n)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) {</span><br><span class="line">        <span class="keyword">int</span> m=nums1.size(), n=nums2.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) mp[nums1[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(mp.find(nums2[i])!=mp.end()&amp;&amp;mp[nums2[i]]&gt;<span class="number">0</span>){</span><br><span class="line">                res.push_back(nums2[i]);</span><br><span class="line">                mp[nums2[i]]--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1337-方阵中战斗力最弱的-K-行"><a href="#1337-方阵中战斗力最弱的-K-行" class="headerlink" title="1337. 方阵中战斗力最弱的 K 行"></a>1337. 方阵中战斗力最弱的 K 行</h2><p><strong>Description</strong><br>给你一个大小为 m * n 的方阵 mat，方阵由若干军人和平民组成，分别用 1 和 0 表示。<br>请你返回方阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。<br>如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。<br>军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。<br><strong>Example</strong><br>示例 1：<br>输入：mat =<br>[[1,1,0,0,0],<br> [1,1,1,1,0],<br> [1,0,0,0,0],<br> [1,1,0,0,0],<br> [1,1,1,1,1]],<br>k = 3<br>输出：[2,0,3]<br>解释：<br>每行中的军人数目：<br>行 0 -&gt; 2<br>行 1 -&gt; 4<br>行 2 -&gt; 1<br>行 3 -&gt; 2<br>行 4 -&gt; 5<br>从最弱到最强对这些行排序后得到 [2,0,3,1,4]</p>
<p>示例 2：<br>输入：mat =<br>[[1,0,0,0],<br> [1,1,1,1],<br> [1,0,0,0],<br> [1,0,0,0]],<br>k = 2<br>输出：[0,2]<br>解释：<br>每行中的军人数目：<br>行 0 -&gt; 1<br>行 1 -&gt; 4<br>行 2 -&gt; 1<br>行 3 -&gt; 1<br>从最弱到最强对这些行排序后得到 [0,2,3,1]</p>
<p>提示：<br>m == mat.length<br>n == mat[i].length<br>2 &lt;= n, m &lt;= 100<br>1 &lt;= k &lt;= m<br>matrix[i][j] 不是 0 就是 1<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; kWeakestRows(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mat.size();i++){</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;mat[i].size();j++){</span><br><span class="line">                sum+=(mat[i][j]==<span class="number">1</span>)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            vec.push_back({sum, i});</span><br><span class="line">        }</span><br><span class="line">        sort(vec.begin(), vec.end(), [](pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; a, pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; b){</span><br><span class="line">            <span class="keyword">if</span>(a.first!=b.first)<span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> a.second&lt;b.second;</span><br><span class="line">        });</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++){</span><br><span class="line">            res.push_back(vec[i].second);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a>415. 字符串相加</h2><p><strong>Description</strong><br>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</p>
<p>注意：<br>num1 和num2 的长度都小于 5100.<br>num1 和num2 都只包含数字 0-9.<br>num1 和num2 都不包含任何前导零。<br>你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m=num1.length(), n=num2.length();</span><br><span class="line">        <span class="keyword">if</span>(m&lt;n) {swap(num1, num2);swap(m, n);}</span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">        reverse(num1.begin(), num1.end());</span><br><span class="line">        reverse(num2.begin(), num2.end());</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;n;i++){</span><br><span class="line">            res+=(num1[i]-<span class="string">'0'</span>+num2[i]-<span class="string">'0'</span>+carry)%<span class="number">10</span>+<span class="string">'0'</span>;</span><br><span class="line">            carry=(num1[i]-<span class="string">'0'</span>+num2[i]-<span class="string">'0'</span>+carry)/<span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;m;i++){</span><br><span class="line">            res+=(num1[i]-<span class="string">'0'</span>+carry)%<span class="number">10</span>+<span class="string">'0'</span>;</span><br><span class="line">            carry=(num1[i]-<span class="string">'0'</span>+carry)/<span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(carry!=<span class="number">0</span>) res+=carry+<span class="string">'0'</span>;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1291-顺次数"><a href="#1291-顺次数" class="headerlink" title="1291. 顺次数"></a>1291. 顺次数</h2><p><strong>Description</strong><br>我们定义「顺次数」为：每一位上的数字都比前一位上的数字大 1 的整数。<br>请你返回由 [low, high] 范围内所有顺次数组成的 有序 列表（从小到大排序）。<br><strong>Example</strong><br>示例 1：<br>输出：low = 100, high = 300<br>输出：[123,234]</p>
<p>示例 2：<br>输出：low = 1000, high = 13000<br>输出：[1234,2345,3456,4567,5678,6789,12345]</p>
<p>提示：<br>10 &lt;= low &lt;= high &lt;= 10^9<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sToi</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++) ans=ans*<span class="number">10</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequentialDigits(<span class="keyword">int</span> low, <span class="keyword">int</span> high) {</span><br><span class="line">        <span class="built_in">string</span> str=<span class="string">"12"</span>;</span><br><span class="line">        <span class="keyword">int</span> x=sToi(str);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;=high){</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=low) res.push_back(x);</span><br><span class="line">            <span class="keyword">int</span> n=str.length();</span><br><span class="line">            <span class="keyword">if</span>(str[n<span class="number">-1</span>]!=<span class="string">'9'</span>){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) str[i]+=<span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">if</span>(n==<span class="number">9</span>) <span class="keyword">break</span>;</span><br><span class="line">                str=<span class="string">""</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)str+=i+<span class="string">'1'</span>;</span><br><span class="line">            }</span><br><span class="line">            x=sToi(str);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequentialDigits(<span class="keyword">int</span> low, <span class="keyword">int</span> high) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">9</span>;i++){</span><br><span class="line">            <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=<span class="number">9</span>;j++){</span><br><span class="line">                x=x*<span class="number">10</span>+j;</span><br><span class="line">                <span class="keyword">if</span>(x&gt;=low&amp;&amp;x&lt;=high) res.push_back(x);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        sort(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="867-转置矩阵"><a href="#867-转置矩阵" class="headerlink" title="867. 转置矩阵"></a>867. 转置矩阵</h2><p><strong>Description</strong><br>给定一个矩阵 A， 返回 A 的转置矩阵。<br>矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。<br><strong>Example</strong><br>示例 1：<br>输入：[[1,2,3],[4,5,6],[7,8,9]]<br>输出：[[1,4,7],[2,5,8],[3,6,9]]</p>
<p>示例 2：<br>输入：[[1,2,3],[4,5,6]]<br>输出：[[1,4],[2,5],[3,6]]</p>
<p>提示：<br>1 &lt;= A.length &lt;= 1000<br>1 &lt;= A[0].length &lt;= 1000<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; transpose(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A) {</span><br><span class="line">        <span class="keyword">int</span> m=A.size(), n=A[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                res[j][i]=A[i][j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a>347. 前 K 个高频元素</h2><p><strong>Description</strong><br>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。<br><strong>Example</strong><br>示例 1:<br>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]</p>
<p>示例 2:<br>输入: nums = [1], k = 1<br>输出: [1]</p>
<p>提示：<br>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。<br>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。<br>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。<br>你可以按任意顺序返回答案。<br><strong>Program</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Cmp</span>{</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; p1, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; p2)</span> <span class="keyword">const</span></span>{</span><br><span class="line">            <span class="keyword">return</span> p1.second&lt;p2.second;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topKFrequent(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums) m[x]++;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;, Cmp&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p:m){</span><br><span class="line">            pq.push(p);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty()&amp;&amp;k&gt;<span class="number">0</span>){</span><br><span class="line">            vec.push_back(pq.top().first); pq.pop();</span><br><span class="line">            k--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1705-吃苹果的最大数目"><a href="#1705-吃苹果的最大数目" class="headerlink" title="1705. 吃苹果的最大数目"></a>1705. 吃苹果的最大数目</h2><p><strong>Description</strong><br>有一棵特殊的苹果树，一连 n 天，每天都可以长出若干个苹果。在第 i 天，树上会长出 apples[i] 个苹果，这些苹果将会在 days[i] 天后（也就是说，第 i + days[i] 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 apples[i] == 0 且 days[i] == 0 表示。<br>你打算每天 最多 吃一个苹果来保证营养均衡。注意，你可以在这 n 天之后继续吃苹果。<br>给你两个长度为 n 的整数数组 days 和 apples ，返回你可以吃掉的苹果的最大数目。<br><strong>Example</strong><br>示例 1：<br>输入：apples = [1,2,3,5,2], days = [3,2,1,4,2]<br>输出：7<br>解释：你可以吃掉 7 个苹果：</p>
<ul>
<li>第一天，你吃掉第一天长出来的苹果。</li>
<li>第二天，你吃掉一个第二天长出来的苹果。</li>
<li>第三天，你吃掉一个第二天长出来的苹果。过了这一天，第三天长出来的苹果就已经腐烂了。</li>
<li>第四天到第七天，你吃的都是第四天长出来的苹果。</li>
</ul>
<p>示例 2：<br>输入：apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2]<br>输出：5<br>解释：你可以吃掉 5 个苹果：</p>
<ul>
<li>第一天到第三天，你吃的都是第一天长出来的苹果。</li>
<li>第四天和第五天不吃苹果。</li>
<li>第六天和第七天，你吃的都是第六天长出来的苹果。</li>
</ul>
<p>提示：<br>apples.length == n<br>days.length == n<br>1 &lt;= n &lt;= 2 * 10^4<br>0 &lt;= apples[i], days[i] &lt;= 2 * 10^4<br>只有在 apples[i] = 0 时，days[i] = 0 才成立<br><strong>Program</strong><br><strong>思路</strong><br>优先吃更早腐烂过期的苹果</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> cnt;</span><br><span class="line">        <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">int</span> end;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> _cnt, <span class="keyword">int</span> _s, <span class="keyword">int</span> _e):cnt(_cnt), start(_s), end(_e){}</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; other) <span class="keyword">const</span>{</span><br><span class="line">            <span class="keyword">return</span> end&gt;other.end;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eatenApples</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; apples, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; days)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=apples.size();</span><br><span class="line">        priority_queue&lt;Node&gt; pq;</span><br><span class="line">        <span class="keyword">int</span> day=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty()||day&lt;=n){</span><br><span class="line">            <span class="keyword">while</span>(!pq.empty()&amp;&amp;pq.top().end&lt;=day) pq.pop(); <span class="comment">//腐烂过期</span></span><br><span class="line">            <span class="keyword">if</span>(day&lt;=n){</span><br><span class="line">                <span class="keyword">if</span>(apples[day<span class="number">-1</span>]!=<span class="number">0</span>) pq.push(Node(apples[day<span class="number">-1</span>], day, day+days[day<span class="number">-1</span>]));</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(!pq.empty()){</span><br><span class="line">                ans++;</span><br><span class="line">                Node node=pq.top();pq.pop();</span><br><span class="line">                node.cnt--;</span><br><span class="line">                <span class="keyword">if</span>(node.cnt!=<span class="number">0</span>) pq.push(node);</span><br><span class="line">            }</span><br><span class="line">            day++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1706-球会落何处"><a href="#1706-球会落何处" class="headerlink" title="1706. 球会落何处"></a>1706. 球会落何处</h2><p><strong>Description</strong><br>用一个大小为 m x n 的二维网格 grid 表示一个箱子。你有 n 颗球。箱子的顶部和底部都是开着的。<br>箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。<br>将球导向右侧的挡板跨过左上角和右下角，在网格中用 1 表示。<br>将球导向左侧的挡板跨过右上角和左下角，在网格中用 -1 表示。<br>在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的 “V” 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。<br>返回一个大小为 n 的数组 answer ，其中 answer[i] 是球放在顶部的第 i 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 -1 。<br><strong>Example</strong><br>示例 1：<br><img src="/assets/img/algorithm/ball.jpg" alt="image"><br>输入：grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]<br>输出：[1,-1,-1,-1,-1]<br>解释：示例如图：<br>b0 球开始放在第 0 列上，最终从箱子底部第 1 列掉出。<br>b1 球开始放在第 1 列上，会卡在第 2、3 列和第 1 行之间的 “V” 形里。<br>b2 球开始放在第 2 列上，会卡在第 2、3 列和第 0 行之间的 “V” 形里。<br>b3 球开始放在第 3 列上，会卡在第 2、3 列和第 0 行之间的 “V” 形里。<br>b4 球开始放在第 4 列上，会卡在第 2、3 列和第 1 行之间的 “V” 形里。</p>
<p>示例 2：<br>输入：grid = [[-1]]<br>输出：[-1]<br>解释：球被卡在箱子左侧边上。</p>
<p>提示：<br>m == grid.length<br>n == grid[i].length<br>1 &lt;= m, n &lt;= 100<br>grid[i][j] 为 1 或 -1<br><strong>Program</strong><br><strong>思路</strong><br>广搜，状态节点：<br>i,j球的位置，diag网格(i,j)的挡板方向，pos球在网格(i,j)的上/下(1/0，上表示与上边相连，下表示与下边相连)；</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> i,j;  <span class="comment">//球的位置</span></span><br><span class="line">        <span class="keyword">int</span> diag, pos; <span class="comment">//挡板方向，球的位置（上/下）</span></span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> _i, <span class="keyword">int</span> _j, <span class="keyword">int</span> _d, <span class="keyword">int</span> _p){</span><br><span class="line">            i=_i;</span><br><span class="line">            j=_j;</span><br><span class="line">            diag=_d;</span><br><span class="line">            pos=_p;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> (r&gt;=<span class="number">0</span>&amp;&amp;r&lt;m&amp;&amp;c&gt;=<span class="number">0</span>&amp;&amp;c&lt;n);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, Node node)</span></span>{</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">        q.push(node);</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            Node curNode=q.front();q.pop();</span><br><span class="line">            <span class="keyword">int</span> r=curNode.i, c=curNode.j;</span><br><span class="line">            <span class="keyword">int</span> diag=curNode.diag, pos=curNode.pos;</span><br><span class="line">            <span class="keyword">if</span>(r==m<span class="number">-1</span>&amp;&amp;c&gt;=<span class="number">0</span>&amp;&amp;c&lt;n){</span><br><span class="line">                <span class="keyword">if</span>(pos==<span class="number">0</span>){</span><br><span class="line">                    res=c;<span class="comment">//能够出来</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(c&lt;<span class="number">0</span>||c&gt;=n) <span class="keyword">break</span>; <span class="comment">//无法出来</span></span><br><span class="line">            <span class="keyword">if</span>(diag==<span class="number">1</span>){ <span class="comment">//左上到右下挡板</span></span><br><span class="line">                <span class="keyword">if</span>(pos==<span class="number">1</span>){</span><br><span class="line">                    <span class="keyword">int</span> new_r=r, new_c=c+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(judge(new_r, new_c)){</span><br><span class="line">                        <span class="keyword">if</span>(grid[new_r][new_c]==<span class="number">-1</span>) <span class="keyword">break</span>; <span class="comment">//无法出来</span></span><br><span class="line">                        q.push(Node(new_r, new_c, grid[new_r][new_c], <span class="number">0</span>));</span><br><span class="line">                    }<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    <span class="keyword">int</span> new_r=r+<span class="number">1</span>, new_c=c;</span><br><span class="line">                    <span class="keyword">if</span>(judge(new_r, new_c)){</span><br><span class="line">                        q.push(Node(new_r, new_c, grid[new_r][new_c], <span class="number">1</span>));</span><br><span class="line">                    }<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }<span class="keyword">else</span>{ <span class="comment">//左下到右上挡板</span></span><br><span class="line">                <span class="keyword">if</span>(pos==<span class="number">1</span>){</span><br><span class="line">                    <span class="keyword">int</span> new_r=r, new_c=c<span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(judge(new_r,new_c)){</span><br><span class="line">                        <span class="keyword">if</span>(grid[new_r][new_c]==<span class="number">1</span>) <span class="keyword">break</span>;<span class="comment">//无法出来</span></span><br><span class="line">                        q.push(Node(new_r, new_c, grid[new_r][new_c], <span class="number">0</span>));</span><br><span class="line">                    }<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    <span class="keyword">int</span> new_r=r+<span class="number">1</span>, new_c=c;</span><br><span class="line">                    <span class="keyword">if</span>(judge(new_r, new_c)){</span><br><span class="line">                        q.push(Node(new_r, new_c, grid[new_r][new_c], <span class="number">1</span>));</span><br><span class="line">                    }<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findBall(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid) {</span><br><span class="line">        m=grid.size(), n=grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(grid[<span class="number">0</span>][i]==<span class="number">1</span>) res[i]=bfs(grid, Node(<span class="number">0</span>, i, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span> res[i]=bfs(grid, Node(<span class="number">0</span>, i, <span class="number">-1</span>, <span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

      

      
        <div class="page-reward">
          <a href="javascript:;" class="page-reward-btn tooltip-top">
            <div class="tooltip tooltip-east">
            <span class="tooltip-item">
              赏
            </span>
            <span class="tooltip-content">
              <span class="tooltip-text">
                <span class="tooltip-inner">
                  <p class="reward-p"><i class="icon icon-quo-left"></i>Thank you for inviting me to have candy.<i class="icon icon-quo-right"></i></p>
                  <div class="reward-box">
                    
                    <div class="reward-box-item">
                      <img class="reward-img" src="/assets/img/blog/zhifubao.png">
                      <span class="reward-type">支付宝</span>
                    </div>
                    
                    
                    <div class="reward-box-item">
                      <img class="reward-img" src="/assets/img/blog/weixin.jpg">
                      <span class="reward-type">微信</span>
                    </div>
                    
                  </div>
                </span>
              </span>
            </span>
          </div>
          </a>
        </div>
      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">Algorithm</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">C++</a>
        		</li>
      		
		</ul>
	</div>

      

      

      
        
<div class="share-btn share-icons tooltip-left">
  <div class="tooltip tooltip-east">
    <span class="tooltip-item">
      <a href="javascript:;" class="share-sns share-outer">
        <i class="icon icon-share"></i>
      </a>
    </span>
    <span class="tooltip-content">
      <div class="share-wrap">
        <div class="share-icons">
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="icon icon-weibo"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="icon icon-weixin"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="icon icon-qq"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="icon icon-douban"></i>
          </a>
          <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a>
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="icon icon-facebook"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="icon icon-twitter"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="icon icon-google"></i>
          </a>
        </div>
      </div>
    </span>
  </div>
</div>

<div class="page-modal wx-share js-wx-box">
    <a class="close js-modal-close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="http://s.jiathis.com/qrcode.php?url=https://lourisxu.github.io/2019/11/12/leetcode.html/" alt="微信分享二维码">
    </div>
</div>

<div class="mask js-mask"></div>
      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
    <a href="/2019/11/23/mxboard.html/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          MXBoard
        
      </div>
    </a>
  
  
    <a href="/2019/11/08/a-review-of-atutomated-methods-for-the-detection-sickle-cell-disease.html/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">A Review of Atutomated Methods for the Detection of Sickle Cell Disease</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>


<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
        <div class="toc-container tooltip-left">
            <i class="icon-font icon-category"></i>
            <div class="tooltip tooltip-east">
                <span class="tooltip-item">
                </span>
                <span class="tooltip-content">
                  <div class="toc-article">
                  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#技巧"><span class="toc-number">1.</span> <span class="toc-text">技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#992-K-个不同整数的子数组"><span class="toc-number">1.0.1.</span> <span class="toc-text">992. K 个不同整数的子数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LCP"><span class="toc-number">2.</span> <span class="toc-text">LCP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LCP-17-速算机器人"><span class="toc-number">2.1.</span> <span class="toc-text">LCP 17. 速算机器人</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LCP-18-早餐组合"><span class="toc-number">2.2.</span> <span class="toc-text">LCP 18. 早餐组合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LCP-19-秋叶收藏集"><span class="toc-number">2.3.</span> <span class="toc-text">LCP 19. 秋叶收藏集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LCP-22-黑白方格画"><span class="toc-number">2.4.</span> <span class="toc-text">LCP 22. 黑白方格画</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#单调队列"><span class="toc-number">3.</span> <span class="toc-text">单调队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#239-滑动窗口最大值"><span class="toc-number">3.1.</span> <span class="toc-text">239. 滑动窗口最大值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1438-绝对差不超过限制的最长连续子数组"><span class="toc-number">3.2.</span> <span class="toc-text">1438. 绝对差不超过限制的最长连续子数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5631-跳跃游戏-VI"><span class="toc-number">3.3.</span> <span class="toc-text">5631. 跳跃游戏 VI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#剑指-Offer-59-I-滑动窗口的最大值"><span class="toc-number">3.4.</span> <span class="toc-text">剑指 Offer 59 - I. 滑动窗口的最大值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#剑指-Offer-59-II-队列的最大值"><span class="toc-number">3.5.</span> <span class="toc-text">剑指 Offer 59 - II. 队列的最大值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#树状数组-差分数组"><span class="toc-number">4.</span> <span class="toc-text">树状数组&#x2F;差分数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#307-区域和检索-数组可修改"><span class="toc-number">4.1.</span> <span class="toc-text">307. 区域和检索 - 数组可修改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#327-区间和的个数"><span class="toc-number">4.2.</span> <span class="toc-text">327. 区间和的个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1674-使数组互补的最少操作次数"><span class="toc-number">4.3.</span> <span class="toc-text">1674. 使数组互补的最少操作次数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#前缀和"><span class="toc-number">5.</span> <span class="toc-text">前缀和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#技巧："><span class="toc-number">5.1.</span> <span class="toc-text">技巧：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题-17-05-字母与数字"><span class="toc-number">5.2.</span> <span class="toc-text">面试题 17.05.  字母与数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1590-使数组和能被-P-整除"><span class="toc-number">5.3.</span> <span class="toc-text">1590. 使数组和能被 P 整除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#930-和相同的二元子数组"><span class="toc-number">5.4.</span> <span class="toc-text">930. 和相同的二元子数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1497-检查数组对是否可以被-k-整除"><span class="toc-number">5.5.</span> <span class="toc-text">1497. 检查数组对是否可以被 k 整除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1010-总持续时间可被-60-整除的歌曲"><span class="toc-number">5.6.</span> <span class="toc-text">1010. 总持续时间可被 60 整除的歌曲</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#523-连续的子数组和"><span class="toc-number">5.7.</span> <span class="toc-text">523. 连续的子数组和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#560-和为K的子数组"><span class="toc-number">5.8.</span> <span class="toc-text">560. 和为K的子数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字典树"><span class="toc-number">6.</span> <span class="toc-text">字典树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#648-单词替换"><span class="toc-number">6.1.</span> <span class="toc-text">648. 单词替换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#676-实现一个魔法字典"><span class="toc-number">6.2.</span> <span class="toc-text">676. 实现一个魔法字典</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#720-词典中最长的单词"><span class="toc-number">6.3.</span> <span class="toc-text">720. 词典中最长的单词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#421-数组中两个数的最大异或值"><span class="toc-number">6.4.</span> <span class="toc-text">421. 数组中两个数的最大异或值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1707-与数组中元素的最大异或值"><span class="toc-number">6.5.</span> <span class="toc-text">1707. 与数组中元素的最大异或值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#并查集"><span class="toc-number">7.</span> <span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#684-冗余连接"><span class="toc-number">7.1.</span> <span class="toc-text">684. 冗余连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#685-冗余连接-II"><span class="toc-number">7.2.</span> <span class="toc-text">685. 冗余连接 II</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#队列"><span class="toc-number">8.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#933-最近的请求次数"><span class="toc-number">8.1.</span> <span class="toc-text">933. 最近的请求次数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#状态压缩"><span class="toc-number">9.</span> <span class="toc-text">状态压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#691-贴纸拼词"><span class="toc-number">9.1.</span> <span class="toc-text">691. 贴纸拼词</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#欧拉回路"><span class="toc-number">10.</span> <span class="toc-text">欧拉回路</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#332-重新安排行程"><span class="toc-number">10.1.</span> <span class="toc-text">332. 重新安排行程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#排序"><span class="toc-number">11.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#56-合并区间"><span class="toc-number">11.1.</span> <span class="toc-text">56. 合并区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57-插入区间"><span class="toc-number">11.2.</span> <span class="toc-text">57. 插入区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75-颜色分类"><span class="toc-number">11.3.</span> <span class="toc-text">75. 颜色分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#147-对链表进行插入排序"><span class="toc-number">11.4.</span> <span class="toc-text">147. 对链表进行插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#148-排序链表"><span class="toc-number">11.5.</span> <span class="toc-text">148. 排序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#179-最大数"><span class="toc-number">11.6.</span> <span class="toc-text">179. 最大数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#220-存在重复元素-III"><span class="toc-number">11.7.</span> <span class="toc-text">220. 存在重复元素 III</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#242-有效的字母异位词"><span class="toc-number">11.8.</span> <span class="toc-text">242. 有效的字母异位词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#324-摆动排序-II"><span class="toc-number">11.9.</span> <span class="toc-text">324. 摆动排序 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#524-通过删除字母匹配到字典里最长单词"><span class="toc-number">11.10.</span> <span class="toc-text">524. 通过删除字母匹配到字典里最长单词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#853-车队"><span class="toc-number">11.11.</span> <span class="toc-text">853. 车队</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#969-煎饼排序"><span class="toc-number">11.12.</span> <span class="toc-text">969. 煎饼排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1030-距离顺序排列矩阵单元格"><span class="toc-number">11.13.</span> <span class="toc-text">1030. 距离顺序排列矩阵单元格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1122-数组的相对排序"><span class="toc-number">11.14.</span> <span class="toc-text">1122. 数组的相对排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1305-两棵二叉搜索树中的所有元素"><span class="toc-number">11.15.</span> <span class="toc-text">1305. 两棵二叉搜索树中的所有元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1329-将矩阵按对角线排序"><span class="toc-number">11.16.</span> <span class="toc-text">1329. 将矩阵按对角线排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1366-通过投票对团队排名"><span class="toc-number">11.17.</span> <span class="toc-text">1366. 通过投票对团队排名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1387-将整数按权重排序"><span class="toc-number">11.18.</span> <span class="toc-text">1387. 将整数按权重排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1424-对角线遍历-II"><span class="toc-number">11.19.</span> <span class="toc-text">1424. 对角线遍历 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1452-收藏清单"><span class="toc-number">11.20.</span> <span class="toc-text">1452. 收藏清单</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1471-数组中的-k-个最强值"><span class="toc-number">11.21.</span> <span class="toc-text">1471. 数组中的 k 个最强值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1481-不同整数的最少数目"><span class="toc-number">11.22.</span> <span class="toc-text">1481. 不同整数的最少数目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1491-去掉最低工资和最高工资后的工资平均值"><span class="toc-number">11.23.</span> <span class="toc-text">1491. 去掉最低工资和最高工资后的工资平均值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1502-判断能否形成等差数列"><span class="toc-number">11.24.</span> <span class="toc-text">1502. 判断能否形成等差数列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1508-子数组和排序后的区间和"><span class="toc-number">11.25.</span> <span class="toc-text">1508. 子数组和排序后的区间和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1528-重新排列字符串"><span class="toc-number">11.26.</span> <span class="toc-text">1528. 重新排列字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1561-你可以获得的最大硬币数目"><span class="toc-number">11.27.</span> <span class="toc-text">1561. 你可以获得的最大硬币数目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1636-按照频率将数组升序排序"><span class="toc-number">11.28.</span> <span class="toc-text">1636. 按照频率将数组升序排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1637-两点之间不包含任何点的最宽垂直面积"><span class="toc-number">11.29.</span> <span class="toc-text">1637. 两点之间不包含任何点的最宽垂直面积</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#深搜"><span class="toc-number">12.</span> <span class="toc-text">深搜</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#733-图像渲染"><span class="toc-number">12.1.</span> <span class="toc-text">733. 图像渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#841-钥匙和房间"><span class="toc-number">12.2.</span> <span class="toc-text">841. 钥匙和房间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#双指针"><span class="toc-number">13.</span> <span class="toc-text">双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-盛最多水的容器"><span class="toc-number">13.1.</span> <span class="toc-text">11. 盛最多水的容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-下一个排列"><span class="toc-number">13.2.</span> <span class="toc-text">31. 下一个排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#344-反转字符串"><span class="toc-number">13.3.</span> <span class="toc-text">344. 反转字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题-16-06-最小差"><span class="toc-number">13.4.</span> <span class="toc-text">面试题 16.06. 最小差</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题-17-11-单词距离"><span class="toc-number">13.5.</span> <span class="toc-text">面试题 17.11. 单词距离</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#栈-字符串"><span class="toc-number">14.</span> <span class="toc-text">栈&#x2F;字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#32-最长有效括号"><span class="toc-number">14.1.</span> <span class="toc-text">32. 最长有效括号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-字符串相乘"><span class="toc-number">14.2.</span> <span class="toc-text">43. 字符串相乘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#71-简化路径"><span class="toc-number">14.3.</span> <span class="toc-text">71. 简化路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#150-逆波兰表达式求值"><span class="toc-number">14.4.</span> <span class="toc-text">150. 逆波兰表达式求值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#214-最短回文串"><span class="toc-number">14.5.</span> <span class="toc-text">214. 最短回文串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#316-去除重复字母"><span class="toc-number">14.6.</span> <span class="toc-text">316. 去除重复字母</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#321-拼接最大数"><span class="toc-number">14.7.</span> <span class="toc-text">321. 拼接最大数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#331-验证二叉树的前序序列化"><span class="toc-number">14.8.</span> <span class="toc-text">331. 验证二叉树的前序序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#385-迷你语法分析器"><span class="toc-number">14.9.</span> <span class="toc-text">385. 迷你语法分析器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#394-字符串解码"><span class="toc-number">14.10.</span> <span class="toc-text">394. 字符串解码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#456-132模式"><span class="toc-number">14.11.</span> <span class="toc-text">456. 132模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#459-重复的子字符串"><span class="toc-number">14.12.</span> <span class="toc-text">459. 重复的子字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#496-下一个更大元素-I"><span class="toc-number">14.13.</span> <span class="toc-text">496. 下一个更大元素 I</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#503-下一个更大元素-II"><span class="toc-number">14.14.</span> <span class="toc-text">503. 下一个更大元素 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#557-反转字符串中的单词-III"><span class="toc-number">14.15.</span> <span class="toc-text">557. 反转字符串中的单词 III</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#636-函数的独占时间"><span class="toc-number">14.16.</span> <span class="toc-text">636. 函数的独占时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#657-机器人能否返回原点"><span class="toc-number">14.17.</span> <span class="toc-text">657. 机器人能否返回原点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#682-棒球比赛"><span class="toc-number">14.18.</span> <span class="toc-text">682. 棒球比赛</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#696-计数二进制子串"><span class="toc-number">14.19.</span> <span class="toc-text">696. 计数二进制子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#735-行星碰撞"><span class="toc-number">14.20.</span> <span class="toc-text">735. 行星碰撞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#739-每日温度"><span class="toc-number">14.21.</span> <span class="toc-text">739. 每日温度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#844-比较含退格的字符串"><span class="toc-number">14.22.</span> <span class="toc-text">844. 比较含退格的字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#856-括号的分数"><span class="toc-number">14.23.</span> <span class="toc-text">856. 括号的分数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#880-索引处的解码字符串"><span class="toc-number">14.24.</span> <span class="toc-text">880. 索引处的解码字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#901-股票价格跨度"><span class="toc-number">14.25.</span> <span class="toc-text">901. 股票价格跨度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#907-子数组的最小值之和"><span class="toc-number">14.26.</span> <span class="toc-text">907. 子数组的最小值之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#946-验证栈序列"><span class="toc-number">14.27.</span> <span class="toc-text">946. 验证栈序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1002-查找常用字符"><span class="toc-number">14.28.</span> <span class="toc-text">1002. 查找常用字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1003-检查替换后的词是否有效"><span class="toc-number">14.29.</span> <span class="toc-text">1003. 检查替换后的词是否有效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1019-链表中的下一个更大节点"><span class="toc-number">14.30.</span> <span class="toc-text">1019. 链表中的下一个更大节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1021-删除最外层的括号"><span class="toc-number">14.31.</span> <span class="toc-text">1021. 删除最外层的括号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1023-驼峰式匹配"><span class="toc-number">14.32.</span> <span class="toc-text">1023. 驼峰式匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1047-删除字符串中的所有相邻重复项"><span class="toc-number">14.33.</span> <span class="toc-text">1047. 删除字符串中的所有相邻重复项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1081-不同字符的最小子序列"><span class="toc-number">14.34.</span> <span class="toc-text">1081. 不同字符的最小子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1124-表现良好的最长时间段"><span class="toc-number">14.35.</span> <span class="toc-text">1124. 表现良好的最长时间段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1190-反转每对括号间的子串"><span class="toc-number">14.36.</span> <span class="toc-text">1190. 反转每对括号间的子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1209-删除字符串中的所有相邻重复项-II"><span class="toc-number">14.37.</span> <span class="toc-text">1209. 删除字符串中的所有相邻重复项 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1249-移除无效的括号"><span class="toc-number">14.38.</span> <span class="toc-text">1249. 移除无效的括号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1370-上升下降字符串"><span class="toc-number">14.39.</span> <span class="toc-text">1370. 上升下降字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1381-设计一个支持增量操作的栈"><span class="toc-number">14.40.</span> <span class="toc-text">1381. 设计一个支持增量操作的栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1410-HTML-实体解析器"><span class="toc-number">14.41.</span> <span class="toc-text">1410. HTML 实体解析器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1441-用栈操作构建数组"><span class="toc-number">14.42.</span> <span class="toc-text">1441. 用栈操作构建数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1544-整理字符串"><span class="toc-number">14.43.</span> <span class="toc-text">1544. 整理字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#剑指-Offer-30-包含min函数的栈"><span class="toc-number">14.44.</span> <span class="toc-text">剑指 Offer 30. 包含min函数的栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题-03-02-栈的最小值"><span class="toc-number">14.45.</span> <span class="toc-text">面试题 03.02. 栈的最小值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题-03-04-化栈为队"><span class="toc-number">14.46.</span> <span class="toc-text">面试题 03.04. 化栈为队</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题-17-17-多次搜索"><span class="toc-number">14.47.</span> <span class="toc-text">面试题 17.17. 多次搜索</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#树"><span class="toc-number">15.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#树的序列化"><span class="toc-number">15.1.</span> <span class="toc-text">树的序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#652-寻找重复的子树"><span class="toc-number">15.1.1.</span> <span class="toc-text">652. 寻找重复的子树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树的操作"><span class="toc-number">15.2.</span> <span class="toc-text">树的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#114-二叉树展开为链表"><span class="toc-number">15.2.1.</span> <span class="toc-text">114. 二叉树展开为链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#99-恢复二叉搜索树"><span class="toc-number">15.2.2.</span> <span class="toc-text">99. 恢复二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#98-验证二叉搜索树"><span class="toc-number">15.2.3.</span> <span class="toc-text">98. 验证二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#105-从前序与中序遍历序列构造二叉树"><span class="toc-number">15.2.4.</span> <span class="toc-text">105. 从前序与中序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#106-从中序与后序遍历序列构造二叉树"><span class="toc-number">15.2.5.</span> <span class="toc-text">106. 从中序与后序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#109-有序链表转换二叉搜索树"><span class="toc-number">15.2.6.</span> <span class="toc-text">109. 有序链表转换二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#113-路径总和-II"><span class="toc-number">15.2.7.</span> <span class="toc-text">113. 路径总和 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#116-填充每个节点的下一个右侧节点指针"><span class="toc-number">15.2.8.</span> <span class="toc-text">116. 填充每个节点的下一个右侧节点指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#117-填充每个节点的下一个右侧节点指针-II"><span class="toc-number">15.2.9.</span> <span class="toc-text">117. 填充每个节点的下一个右侧节点指针 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#129-求根到叶子节点数字之和"><span class="toc-number">15.2.10.</span> <span class="toc-text">129. 求根到叶子节点数字之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#133-克隆图"><span class="toc-number">15.2.11.</span> <span class="toc-text">133. 克隆图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#199-二叉树的右视图"><span class="toc-number">15.2.12.</span> <span class="toc-text">199. 二叉树的右视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#235-二叉搜索树的最近公共祖先"><span class="toc-number">15.2.13.</span> <span class="toc-text">235. 二叉搜索树的最近公共祖先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#236-二叉树的最近公共祖先"><span class="toc-number">15.2.14.</span> <span class="toc-text">236. 二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#257-二叉树的所有路径"><span class="toc-number">15.2.15.</span> <span class="toc-text">257. 二叉树的所有路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#437-路径总和-III"><span class="toc-number">15.2.16.</span> <span class="toc-text">437. 路径总和 III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#508-出现次数最多的子树元素和"><span class="toc-number">15.2.17.</span> <span class="toc-text">508. 出现次数最多的子树元素和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#572-另一个树的子树"><span class="toc-number">15.2.18.</span> <span class="toc-text">572. 另一个树的子树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#530-二叉搜索树的最小绝对差"><span class="toc-number">15.2.19.</span> <span class="toc-text">530. 二叉搜索树的最小绝对差</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#538-把二叉搜索树转换为累加树"><span class="toc-number">15.2.20.</span> <span class="toc-text">538. 把二叉搜索树转换为累加树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#543-二叉树的直径"><span class="toc-number">15.2.21.</span> <span class="toc-text">543. 二叉树的直径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#563-二叉树的坡度"><span class="toc-number">15.2.22.</span> <span class="toc-text">563. 二叉树的坡度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#617-合并二叉树"><span class="toc-number">15.2.23.</span> <span class="toc-text">617. 合并二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#655-输出二叉树"><span class="toc-number">15.2.24.</span> <span class="toc-text">655. 输出二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#662-二叉树最大宽度"><span class="toc-number">15.2.25.</span> <span class="toc-text">662. 二叉树最大宽度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#894-所有可能的满二叉树"><span class="toc-number">15.2.26.</span> <span class="toc-text">894. 所有可能的满二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#919-完全二叉树插入器"><span class="toc-number">15.2.27.</span> <span class="toc-text">919. 完全二叉树插入器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#968-监控二叉树"><span class="toc-number">15.2.28.</span> <span class="toc-text">968. 监控二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#979-在二叉树中分配硬币"><span class="toc-number">15.2.29.</span> <span class="toc-text">979. 在二叉树中分配硬币</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#987-二叉树的垂序遍历"><span class="toc-number">15.2.30.</span> <span class="toc-text">987. 二叉树的垂序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1008-前序遍历构造二叉搜索树"><span class="toc-number">15.2.31.</span> <span class="toc-text">1008. 前序遍历构造二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1104-二叉树寻路"><span class="toc-number">15.2.32.</span> <span class="toc-text">1104. 二叉树寻路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1261-在受污染的二叉树中查找元素"><span class="toc-number">15.2.33.</span> <span class="toc-text">1261. 在受污染的二叉树中查找元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1530-好叶子节点对的数量"><span class="toc-number">15.2.34.</span> <span class="toc-text">1530. 好叶子节点对的数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-68-II-二叉树的最近公共祖先"><span class="toc-number">15.2.35.</span> <span class="toc-text">剑指 Offer 68 - II. 二叉树的最近公共祖先</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树遍历"><span class="toc-number">15.3.</span> <span class="toc-text">树遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#94-二叉树的中序遍历"><span class="toc-number">15.3.1.</span> <span class="toc-text">94. 二叉树的中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#144-二叉树的前序遍历"><span class="toc-number">15.3.2.</span> <span class="toc-text">144. 二叉树的前序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#145-二叉树的后序遍历"><span class="toc-number">15.3.3.</span> <span class="toc-text">145. 二叉树的后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#222-完全二叉树的节点个数"><span class="toc-number">15.3.4.</span> <span class="toc-text">222. 完全二叉树的节点个数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#501-二叉搜索树中的众数"><span class="toc-number">15.4.</span> <span class="toc-text">501. 二叉搜索树中的众数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#637-二叉树的层平均值"><span class="toc-number">15.5.</span> <span class="toc-text">637. 二叉树的层平均值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1022-从根到叶的二进制数之和"><span class="toc-number">15.5.1.</span> <span class="toc-text">1022. 从根到叶的二进制数之和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树计数"><span class="toc-number">15.6.</span> <span class="toc-text">树计数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#230-二叉搜索树中第K小的元素"><span class="toc-number">15.6.1.</span> <span class="toc-text">230. 二叉搜索树中第K小的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#404-左叶子之和"><span class="toc-number">15.6.2.</span> <span class="toc-text">404. 左叶子之和</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二分查找"><span class="toc-number">16.</span> <span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#线性二分"><span class="toc-number">16.1.</span> <span class="toc-text">线性二分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#33-搜索旋转排序数组"><span class="toc-number">16.1.1.</span> <span class="toc-text">33. 搜索旋转排序数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-在排序数组中查找元素的第一个和最后一个位置"><span class="toc-number">16.1.2.</span> <span class="toc-text">34. 在排序数组中查找元素的第一个和最后一个位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-搜索插入位置"><span class="toc-number">16.1.3.</span> <span class="toc-text">35. 搜索插入位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#69-x-的平方根"><span class="toc-number">16.1.4.</span> <span class="toc-text">69. x 的平方根</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#81-搜索旋转排序数组-II"><span class="toc-number">16.1.5.</span> <span class="toc-text">81. 搜索旋转排序数组 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#153-寻找旋转排序数组中的最小值"><span class="toc-number">16.1.6.</span> <span class="toc-text">153. 寻找旋转排序数组中的最小值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#162-寻找峰值"><span class="toc-number">16.1.7.</span> <span class="toc-text">162. 寻找峰值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#270-最接近的二叉搜索树值"><span class="toc-number">16.1.8.</span> <span class="toc-text">270. 最接近的二叉搜索树值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#274-H-指数"><span class="toc-number">16.1.9.</span> <span class="toc-text">274. H 指数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#275-H指数-II"><span class="toc-number">16.1.10.</span> <span class="toc-text">275. H指数 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#278-第一个错误的版本"><span class="toc-number">16.1.11.</span> <span class="toc-text">278. 第一个错误的版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#287-寻找重复数"><span class="toc-number">16.1.12.</span> <span class="toc-text">287. 寻找重复数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#374-猜数字大小"><span class="toc-number">16.1.13.</span> <span class="toc-text">374. 猜数字大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#436-寻找右区间"><span class="toc-number">16.1.14.</span> <span class="toc-text">436. 寻找右区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#475-供暖器"><span class="toc-number">16.1.15.</span> <span class="toc-text">475. 供暖器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#528-按权重随机选择"><span class="toc-number">16.1.16.</span> <span class="toc-text">528. 按权重随机选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#658-找到-K-个最接近的元素"><span class="toc-number">16.1.17.</span> <span class="toc-text">658. 找到 K 个最接近的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#704-二分查找"><span class="toc-number">16.1.18.</span> <span class="toc-text">704. 二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#744-寻找比目标字母大的最小字母"><span class="toc-number">16.1.19.</span> <span class="toc-text">744. 寻找比目标字母大的最小字母</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#826-安排工作以达到最大收益"><span class="toc-number">16.1.20.</span> <span class="toc-text">826. 安排工作以达到最大收益</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#852-山脉数组的峰顶索引"><span class="toc-number">16.1.21.</span> <span class="toc-text">852. 山脉数组的峰顶索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#875-爱吃香蕉的珂珂"><span class="toc-number">16.1.22.</span> <span class="toc-text">875. 爱吃香蕉的珂珂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#911-在线选举"><span class="toc-number">16.1.23.</span> <span class="toc-text">911. 在线选举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1011-在-D-天内送达包裹的能力"><span class="toc-number">16.1.24.</span> <span class="toc-text">1011. 在 D 天内送达包裹的能力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1150-检查一个数是否在数组中占绝大多数"><span class="toc-number">16.1.25.</span> <span class="toc-text">1150. 检查一个数是否在数组中占绝大多数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1064-不动点"><span class="toc-number">16.1.26.</span> <span class="toc-text">1064. 不动点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1283-使结果不超过阈值的最小除数"><span class="toc-number">16.1.27.</span> <span class="toc-text">1283. 使结果不超过阈值的最小除数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1300-转变数组后最接近目标值的数组和"><span class="toc-number">16.1.28.</span> <span class="toc-text">1300. 转变数组后最接近目标值的数组和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1351-统计有序矩阵中的负数"><span class="toc-number">16.1.29.</span> <span class="toc-text">1351. 统计有序矩阵中的负数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1482-制作-m-束花所需的最少天数"><span class="toc-number">16.1.30.</span> <span class="toc-text">1482. 制作 m 束花所需的最少天数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5643-将数组分成三个子数组的方案数"><span class="toc-number">16.1.31.</span> <span class="toc-text">5643. 将数组分成三个子数组的方案数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5644-得到子序列的最少操作次数"><span class="toc-number">16.1.32.</span> <span class="toc-text">5644. 得到子序列的最少操作次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题-10-03-搜索旋转数组"><span class="toc-number">16.1.33.</span> <span class="toc-text">面试题 10.03. 搜索旋转数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-11-旋转数组的最小数字"><span class="toc-number">16.1.34.</span> <span class="toc-text">剑指 Offer 11. 旋转数组的最小数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-53-I-在排序数组中查找数字-I"><span class="toc-number">16.1.35.</span> <span class="toc-text">剑指 Offer 53 - I. 在排序数组中查找数字 I</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-53-II-0～n-1中缺失的数字"><span class="toc-number">16.1.36.</span> <span class="toc-text">剑指 Offer 53 - II. 0～n-1中缺失的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题-10-05-稀疏数组搜索"><span class="toc-number">16.1.37.</span> <span class="toc-text">面试题 10.05. 稀疏数组搜索</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#矩阵二分"><span class="toc-number">16.2.</span> <span class="toc-text">矩阵二分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#74-搜索二维矩阵"><span class="toc-number">16.2.1.</span> <span class="toc-text">74. 搜索二维矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#240-搜索二维矩阵-II"><span class="toc-number">16.2.2.</span> <span class="toc-text">240. 搜索二维矩阵 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#378-有序矩阵中第K小的元素"><span class="toc-number">16.2.3.</span> <span class="toc-text">378. 有序矩阵中第K小的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1292-元素和小于等于阈值的正方形的最大边长"><span class="toc-number">16.2.4.</span> <span class="toc-text">1292. 元素和小于等于阈值的正方形的最大边长</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题-10-09-排序矩阵查找"><span class="toc-number">16.2.5.</span> <span class="toc-text">面试题 10.09. 排序矩阵查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二分思想"><span class="toc-number">16.3.</span> <span class="toc-text">二分思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#454-四数相加-II"><span class="toc-number">16.3.1.</span> <span class="toc-text">454. 四数相加 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题-08-03-魔术索引"><span class="toc-number">16.3.2.</span> <span class="toc-text">面试题 08.03. 魔术索引</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分治"><span class="toc-number">17.</span> <span class="toc-text">分治</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#经典分治"><span class="toc-number">17.1.</span> <span class="toc-text">经典分治</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-寻找两个正序数组的中位数"><span class="toc-number">17.1.1.</span> <span class="toc-text">4. 寻找两个正序数组的中位数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-合并K个排序链表"><span class="toc-number">17.1.2.</span> <span class="toc-text">23. 合并K个排序链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#218-天际线问题"><span class="toc-number">17.1.3.</span> <span class="toc-text">218. 天际线问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#241-为运算表达式设计优先级"><span class="toc-number">17.1.4.</span> <span class="toc-text">241. 为运算表达式设计优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#493-翻转对"><span class="toc-number">17.1.5.</span> <span class="toc-text">493. 翻转对</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#932-漂亮数组"><span class="toc-number">17.1.6.</span> <span class="toc-text">932. 漂亮数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#973-最接近原点的-K-个点"><span class="toc-number">17.1.7.</span> <span class="toc-text">973. 最接近原点的 K 个点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-25-合并两个排序的链表"><span class="toc-number">17.1.8.</span> <span class="toc-text">剑指 Offer 25. 合并两个排序的链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-40-最小的k个数"><span class="toc-number">17.1.9.</span> <span class="toc-text">剑指 Offer 40. 最小的k个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题-17-14-最小K个数"><span class="toc-number">17.1.10.</span> <span class="toc-text">面试题 17.14. 最小K个数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#位运算"><span class="toc-number">18.</span> <span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#常规位运算"><span class="toc-number">18.1.</span> <span class="toc-text">常规位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#78-子集"><span class="toc-number">18.1.1.</span> <span class="toc-text">78. 子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1356-根据数字二进制下-1-的数目排序"><span class="toc-number">18.1.2.</span> <span class="toc-text">1356. 根据数字二进制下 1 的数目排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#去重位运算"><span class="toc-number">18.2.</span> <span class="toc-text">去重位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#136-只出现一次的数字"><span class="toc-number">18.2.1.</span> <span class="toc-text">136. 只出现一次的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-39-数组中出现次数超过一半的数字"><span class="toc-number">18.2.2.</span> <span class="toc-text">剑指 Offer 39. 数组中出现次数超过一半的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#137-只出现一次的数字-II"><span class="toc-number">18.2.3.</span> <span class="toc-text">137. 只出现一次的数字 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#268-缺失数字"><span class="toc-number">18.2.4.</span> <span class="toc-text">268. 缺失数字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#贪心"><span class="toc-number">19.</span> <span class="toc-text">贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#区间贪心"><span class="toc-number">19.1.</span> <span class="toc-text">区间贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#55-跳跃游戏"><span class="toc-number">19.1.1.</span> <span class="toc-text">55. 跳跃游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#135-分发糖果"><span class="toc-number">19.1.2.</span> <span class="toc-text">135. 分发糖果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#605-种花问题"><span class="toc-number">19.1.3.</span> <span class="toc-text">605. 种花问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#632-最小区间"><span class="toc-number">19.1.4.</span> <span class="toc-text">632. 最小区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1024-视频拼接"><span class="toc-number">19.1.5.</span> <span class="toc-text">1024. 视频拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5641-卡车上的最大单元数"><span class="toc-number">19.1.6.</span> <span class="toc-text">5641. 卡车上的最大单元数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5642-大餐计数"><span class="toc-number">19.1.7.</span> <span class="toc-text">5642. 大餐计数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树形分治"><span class="toc-number">19.2.</span> <span class="toc-text">树形分治</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-36-二叉搜索树与双向链表"><span class="toc-number">19.2.1.</span> <span class="toc-text">剑指 Offer 36. 二叉搜索树与双向链表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数学"><span class="toc-number">20.</span> <span class="toc-text">数学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#常规数学"><span class="toc-number">20.1.</span> <span class="toc-text">常规数学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-两数相加"><span class="toc-number">20.1.1.</span> <span class="toc-text">2. 两数相加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-整数反转"><span class="toc-number">20.1.2.</span> <span class="toc-text">7.整数反转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-字符串转换整数-atoi"><span class="toc-number">20.1.3.</span> <span class="toc-text">8. 字符串转换整数 (atoi)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-回文数"><span class="toc-number">20.1.4.</span> <span class="toc-text">9.回文数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-整数转罗马数字"><span class="toc-number">20.1.5.</span> <span class="toc-text">12. 整数转罗马数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-两数相除"><span class="toc-number">20.1.6.</span> <span class="toc-text">29. 两数相除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50-Pow-x-n"><span class="toc-number">20.1.7.</span> <span class="toc-text">50. Pow(x, n)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#223-矩形面积"><span class="toc-number">20.1.8.</span> <span class="toc-text">223. 矩形面积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#367-有效的完全平方数"><span class="toc-number">20.1.9.</span> <span class="toc-text">367. 有效的完全平方数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1093-大样本统计"><span class="toc-number">20.1.10.</span> <span class="toc-text">1093. 大样本统计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#规划数学"><span class="toc-number">20.2.</span> <span class="toc-text">规划数学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题-16-11-跳水板"><span class="toc-number">20.2.1.</span> <span class="toc-text">面试题 16.11. 跳水板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟数学"><span class="toc-number">20.3.</span> <span class="toc-text">模拟数学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#67-二进制求和"><span class="toc-number">20.3.1.</span> <span class="toc-text">67. 二进制求和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数学规律"><span class="toc-number">20.4.</span> <span class="toc-text">数学规律</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#168-Excel表列名称"><span class="toc-number">20.4.1.</span> <span class="toc-text">168. Excel表列名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#166-分数到小数"><span class="toc-number">20.4.2.</span> <span class="toc-text">166. 分数到小数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#171-Excel表列序号"><span class="toc-number">20.4.3.</span> <span class="toc-text">171. Excel表列序号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#172-阶乘后的零"><span class="toc-number">20.4.4.</span> <span class="toc-text">172. 阶乘后的零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#202-快乐数"><span class="toc-number">20.4.5.</span> <span class="toc-text">202. 快乐数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#231-2的幂"><span class="toc-number">20.4.6.</span> <span class="toc-text">231. 2的幂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#258-各位相加"><span class="toc-number">20.4.7.</span> <span class="toc-text">258. 各位相加</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数学推导"><span class="toc-number">20.5.</span> <span class="toc-text">数学推导</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1201-丑数-III"><span class="toc-number">20.5.1.</span> <span class="toc-text">1201. 丑数 III</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#素数筛选"><span class="toc-number">20.6.</span> <span class="toc-text">素数筛选</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#204-计数质数"><span class="toc-number">20.6.1.</span> <span class="toc-text">204. 计数质数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#有限状态自动机"><span class="toc-number">21.</span> <span class="toc-text">有限状态自动机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#确定性有限状态自动机"><span class="toc-number">21.1.</span> <span class="toc-text">确定性有限状态自动机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#65-有效数字"><span class="toc-number">21.1.1.</span> <span class="toc-text">65. 有效数字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#滑动窗口"><span class="toc-number">22.</span> <span class="toc-text">滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#经典滑窗"><span class="toc-number">22.1.</span> <span class="toc-text">经典滑窗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-无重复字符的最长子串"><span class="toc-number">22.1.1.</span> <span class="toc-text">3. 无重复字符的最长子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#209-长度最小的子数组"><span class="toc-number">22.1.2.</span> <span class="toc-text">209. 长度最小的子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#424-替换后的最长重复字符"><span class="toc-number">22.1.3.</span> <span class="toc-text">424. 替换后的最长重复字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#567-字符串的排列"><span class="toc-number">22.1.4.</span> <span class="toc-text">567. 字符串的排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#992-K-个不同整数的子数组-1"><span class="toc-number">22.1.5.</span> <span class="toc-text">992. K 个不同整数的子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1004-最大连续1的个数-III"><span class="toc-number">22.1.6.</span> <span class="toc-text">1004. 最大连续1的个数 III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1052-爱生气的书店老板"><span class="toc-number">22.1.7.</span> <span class="toc-text">1052. 爱生气的书店老板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1208-尽可能使字符串相等"><span class="toc-number">22.1.8.</span> <span class="toc-text">1208. 尽可能使字符串相等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1234-替换子串得到平衡字符串"><span class="toc-number">22.1.9.</span> <span class="toc-text">1234. 替换子串得到平衡字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1456-定长子串中元音的最大数目"><span class="toc-number">22.1.10.</span> <span class="toc-text">1456. 定长子串中元音的最大数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1658-将-x-减到-0-的最小操作数"><span class="toc-number">22.1.11.</span> <span class="toc-text">1658. 将 x 减到 0 的最小操作数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-48-最长不含重复字符的子字符串"><span class="toc-number">22.1.12.</span> <span class="toc-text">剑指 Offer 48. 最长不含重复字符的子字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#技巧滑窗"><span class="toc-number">22.2.</span> <span class="toc-text">技巧滑窗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#239-滑动窗口最大值-1"><span class="toc-number">22.2.1.</span> <span class="toc-text">239. 滑动窗口最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1033-移动石子直到连续"><span class="toc-number">22.2.2.</span> <span class="toc-text">1033. 移动石子直到连续</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1438-绝对差不超过限制的最长连续子数组-1"><span class="toc-number">22.2.3.</span> <span class="toc-text">1438. 绝对差不超过限制的最长连续子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1040-移动石子直到连续-II"><span class="toc-number">22.2.4.</span> <span class="toc-text">1040. 移动石子直到连续 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1498-满足条件的子序列数目"><span class="toc-number">22.2.5.</span> <span class="toc-text">1498. 满足条件的子序列数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-59-II-队列的最大值-1"><span class="toc-number">22.2.6.</span> <span class="toc-text">剑指 Offer 59 - II. 队列的最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题-17-18-最短超串"><span class="toc-number">22.2.7.</span> <span class="toc-text">面试题 17.18. 最短超串</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#链表"><span class="toc-number">23.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#24-两两交换链表中的节点"><span class="toc-number">23.1.</span> <span class="toc-text">24. 两两交换链表中的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#61-旋转链表"><span class="toc-number">23.2.</span> <span class="toc-text">61. 旋转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82-删除排序链表中的重复元素-II"><span class="toc-number">23.3.</span> <span class="toc-text">82. 删除排序链表中的重复元素 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#86-分隔链表"><span class="toc-number">23.4.</span> <span class="toc-text">86. 分隔链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92-反转链表-II"><span class="toc-number">23.5.</span> <span class="toc-text">92. 反转链表 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#142-环形链表-II"><span class="toc-number">23.6.</span> <span class="toc-text">142. 环形链表 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#143-重排链表"><span class="toc-number">23.7.</span> <span class="toc-text">143. 重排链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#234-回文链表"><span class="toc-number">23.8.</span> <span class="toc-text">234. 回文链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#237-删除链表中的节点"><span class="toc-number">23.9.</span> <span class="toc-text">237. 删除链表中的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#328-奇偶链表"><span class="toc-number">23.10.</span> <span class="toc-text">328. 奇偶链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#430-扁平化多级双向链表"><span class="toc-number">23.11.</span> <span class="toc-text">430. 扁平化多级双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#445-两数相加-II"><span class="toc-number">23.12.</span> <span class="toc-text">445. 两数相加 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#725-分隔链表"><span class="toc-number">23.13.</span> <span class="toc-text">725. 分隔链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#876-链表的中间结点"><span class="toc-number">23.14.</span> <span class="toc-text">876. 链表的中间结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1171-从链表中删去总和值为零的连续节点"><span class="toc-number">23.15.</span> <span class="toc-text">1171. 从链表中删去总和值为零的连续节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题-02-01-移除重复节点"><span class="toc-number">23.16.</span> <span class="toc-text">面试题 02.01. 移除重复节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题-02-08-环路检测"><span class="toc-number">23.17.</span> <span class="toc-text">面试题 02.08. 环路检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#剑指-Offer-52-两个链表的第一个公共节点"><span class="toc-number">23.18.</span> <span class="toc-text">剑指 Offer 52. 两个链表的第一个公共节点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#设计"><span class="toc-number">24.</span> <span class="toc-text">设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#146-LRU缓存机制"><span class="toc-number">24.1.</span> <span class="toc-text">146. LRU缓存机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#170-两数之和-III-数据结构设计"><span class="toc-number">24.2.</span> <span class="toc-text">170. 两数之和 III - 数据结构设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#173-二叉搜索树迭代器"><span class="toc-number">24.3.</span> <span class="toc-text">173. 二叉搜索树迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#208-实现-Trie-前缀树"><span class="toc-number">24.4.</span> <span class="toc-text">208. 实现 Trie (前缀树)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#211-添加与搜索单词-数据结构设计"><span class="toc-number">24.5.</span> <span class="toc-text">211. 添加与搜索单词 - 数据结构设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#232-用栈实现队列"><span class="toc-number">24.6.</span> <span class="toc-text">232. 用栈实现队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#284-顶端迭代器"><span class="toc-number">24.7.</span> <span class="toc-text">284. 顶端迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#341-扁平化嵌套列表迭代器"><span class="toc-number">24.8.</span> <span class="toc-text">341. 扁平化嵌套列表迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#355-设计推特"><span class="toc-number">24.9.</span> <span class="toc-text">355. 设计推特</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#497-非重叠矩形中的随机点"><span class="toc-number">24.10.</span> <span class="toc-text">497. 非重叠矩形中的随机点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#622-设计循环队列"><span class="toc-number">24.11.</span> <span class="toc-text">622. 设计循环队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#641-设计循环双端队列"><span class="toc-number">24.12.</span> <span class="toc-text">641. 设计循环双端队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#703-数据流中的第K大元素"><span class="toc-number">24.13.</span> <span class="toc-text">703. 数据流中的第K大元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#707-设计链表"><span class="toc-number">24.14.</span> <span class="toc-text">707. 设计链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#981-基于时间的键值存储"><span class="toc-number">24.15.</span> <span class="toc-text">981. 基于时间的键值存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1286-字母组合迭代器"><span class="toc-number">24.16.</span> <span class="toc-text">1286. 字母组合迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题-03-01-三合一"><span class="toc-number">24.17.</span> <span class="toc-text">面试题 03.01. 三合一</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题-03-06-动物收容所"><span class="toc-number">24.18.</span> <span class="toc-text">面试题 03.06. 动物收容所</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题-16-25-LRU缓存"><span class="toc-number">24.19.</span> <span class="toc-text">面试题 16.25. LRU缓存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#搜索"><span class="toc-number">25.</span> <span class="toc-text">搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#常规题"><span class="toc-number">25.1.</span> <span class="toc-text">常规题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#329-矩阵中的最长递增路径"><span class="toc-number">25.1.1.</span> <span class="toc-text">329. 矩阵中的最长递增路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#851-喧闹和富有"><span class="toc-number">25.1.2.</span> <span class="toc-text">851. 喧闹和富有</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#回溯算法"><span class="toc-number">26.</span> <span class="toc-text">回溯算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#17-电话号码的字母组合"><span class="toc-number">26.1.</span> <span class="toc-text">17. 电话号码的字母组合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-括号生成"><span class="toc-number">26.2.</span> <span class="toc-text">22. 括号生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-解数独"><span class="toc-number">26.3.</span> <span class="toc-text">37. 解数独</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-组合总和"><span class="toc-number">26.4.</span> <span class="toc-text">39. 组合总和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-组合总和-II"><span class="toc-number">26.5.</span> <span class="toc-text">40. 组合总和 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-全排列"><span class="toc-number">26.6.</span> <span class="toc-text">46. 全排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-全排列-II"><span class="toc-number">26.7.</span> <span class="toc-text">47. 全排列 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-N-皇后"><span class="toc-number">26.8.</span> <span class="toc-text">51. N 皇后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-N皇后-II"><span class="toc-number">26.9.</span> <span class="toc-text">52. N皇后 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#60-第k个排列"><span class="toc-number">26.10.</span> <span class="toc-text">60. 第k个排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#77-组合"><span class="toc-number">26.11.</span> <span class="toc-text">77. 组合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#79-单词搜索"><span class="toc-number">26.12.</span> <span class="toc-text">79. 单词搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#89-格雷编码"><span class="toc-number">26.13.</span> <span class="toc-text">89. 格雷编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#90-子集-II"><span class="toc-number">26.14.</span> <span class="toc-text">90. 子集 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#93-复原IP地址"><span class="toc-number">26.15.</span> <span class="toc-text">93. 复原IP地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#131-分割回文串"><span class="toc-number">26.16.</span> <span class="toc-text">131. 分割回文串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#140-单词拆分-II"><span class="toc-number">26.17.</span> <span class="toc-text">140. 单词拆分 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#216-组合总和-III"><span class="toc-number">26.18.</span> <span class="toc-text">216. 组合总和 III</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#491-递增子序列"><span class="toc-number">26.19.</span> <span class="toc-text">491. 递增子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#526-优美的排列"><span class="toc-number">26.20.</span> <span class="toc-text">526. 优美的排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#679-24-点游戏"><span class="toc-number">26.21.</span> <span class="toc-text">679. 24 点游戏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#797-所有可能的路径"><span class="toc-number">26.22.</span> <span class="toc-text">797. 所有可能的路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#980-不同路径-III"><span class="toc-number">26.23.</span> <span class="toc-text">980. 不同路径 III</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#996-正方形数组的数目"><span class="toc-number">26.24.</span> <span class="toc-text">996. 正方形数组的数目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1079-活字印刷"><span class="toc-number">26.25.</span> <span class="toc-text">1079. 活字印刷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1219-黄金矿工"><span class="toc-number">26.26.</span> <span class="toc-text">1219. 黄金矿工</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1415-长度为-n-的开心字符串中字典序第-k-小的字符串"><span class="toc-number">26.27.</span> <span class="toc-text">1415. 长度为 n 的开心字符串中字典序第 k 小的字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5520-拆分字符串使唯一子字符串的数目最大"><span class="toc-number">26.28.</span> <span class="toc-text">5520. 拆分字符串使唯一子字符串的数目最大</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#剑指-Offer-38-字符串的排列"><span class="toc-number">26.29.</span> <span class="toc-text">剑指 Offer 38. 字符串的排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题-08-04-幂集"><span class="toc-number">26.30.</span> <span class="toc-text">面试题 08.04. 幂集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题-08-07-无重复字符串的排列组合"><span class="toc-number">26.31.</span> <span class="toc-text">面试题 08.07. 无重复字符串的排列组合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题-08-08-有重复字符串的排列组合"><span class="toc-number">26.32.</span> <span class="toc-text">面试题 08.08. 有重复字符串的排列组合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题-08-09-括号"><span class="toc-number">26.33.</span> <span class="toc-text">面试题 08.09. 括号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题-08-12-八皇后"><span class="toc-number">26.34.</span> <span class="toc-text">面试题 08.12. 八皇后</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其他"><span class="toc-number">27.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-两数之和"><span class="toc-number">27.1.</span> <span class="toc-text">1.两数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-罗马数字转整数"><span class="toc-number">27.2.</span> <span class="toc-text">13.罗马数字转整数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-最长公共前缀"><span class="toc-number">27.3.</span> <span class="toc-text">14. 最长公共前缀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-有效的括号"><span class="toc-number">27.4.</span> <span class="toc-text">20. 有效的括号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-合并两个有序链表"><span class="toc-number">27.5.</span> <span class="toc-text">21. 合并两个有序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-删除排序数组中的重复项"><span class="toc-number">27.6.</span> <span class="toc-text">26. 删除排序数组中的重复项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-移除元素"><span class="toc-number">27.7.</span> <span class="toc-text">27. 移除元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-实现strStr"><span class="toc-number">27.8.</span> <span class="toc-text">28. 实现strStr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-报数"><span class="toc-number">27.9.</span> <span class="toc-text">38. 报数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-旋转图像"><span class="toc-number">27.10.</span> <span class="toc-text">48. 旋转图像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58-最后一个单词的长度"><span class="toc-number">27.11.</span> <span class="toc-text">58. 最后一个单词的长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66-加一"><span class="toc-number">27.12.</span> <span class="toc-text">66. 加一</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#83-删除排序链表中的重复元素"><span class="toc-number">27.13.</span> <span class="toc-text">83. 删除排序链表中的重复元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#88-合并两个有序数组"><span class="toc-number">27.14.</span> <span class="toc-text">88. 合并两个有序数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#100-相同的树"><span class="toc-number">27.15.</span> <span class="toc-text">100. 相同的树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101-对称二叉树"><span class="toc-number">27.16.</span> <span class="toc-text">101. 对称二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#104-二叉树的最大深度"><span class="toc-number">27.17.</span> <span class="toc-text">104. 二叉树的最大深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#107-二叉树的层次遍历-II"><span class="toc-number">27.18.</span> <span class="toc-text">107. 二叉树的层次遍历 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#108-将有序数组转换为二叉搜索树"><span class="toc-number">27.19.</span> <span class="toc-text">108. 将有序数组转换为二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#110-平衡二叉树"><span class="toc-number">27.20.</span> <span class="toc-text">110. 平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#111-二叉树的最小深度"><span class="toc-number">27.21.</span> <span class="toc-text">111. 二叉树的最小深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#112-路径总和"><span class="toc-number">27.22.</span> <span class="toc-text">112. 路径总和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#118-杨辉三角"><span class="toc-number">27.23.</span> <span class="toc-text">118. 杨辉三角</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#119-杨辉三角-II"><span class="toc-number">27.24.</span> <span class="toc-text">119. 杨辉三角 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#125-验证回文串"><span class="toc-number">27.25.</span> <span class="toc-text">125. 验证回文串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#141-环形链表"><span class="toc-number">27.26.</span> <span class="toc-text">141. 环形链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#155-最小栈"><span class="toc-number">27.27.</span> <span class="toc-text">155. 最小栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#160-相交链表"><span class="toc-number">27.28.</span> <span class="toc-text">160. 相交链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#167-两数之和-II-输入有序数组"><span class="toc-number">27.29.</span> <span class="toc-text">167. 两数之和 II - 输入有序数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#169-多数元素"><span class="toc-number">27.30.</span> <span class="toc-text">169. 多数元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#189-旋转数组"><span class="toc-number">27.31.</span> <span class="toc-text">189. 旋转数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#190-颠倒二进制位"><span class="toc-number">27.32.</span> <span class="toc-text">190. 颠倒二进制位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#191-位1的个数"><span class="toc-number">27.33.</span> <span class="toc-text">191. 位1的个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#203-移除链表元素"><span class="toc-number">27.34.</span> <span class="toc-text">203. 移除链表元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#205-同构字符串"><span class="toc-number">27.35.</span> <span class="toc-text">205. 同构字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#206-反转链表"><span class="toc-number">27.36.</span> <span class="toc-text">206. 反转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#217-存在重复元素"><span class="toc-number">27.37.</span> <span class="toc-text">217. 存在重复元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#219-存在重复元素-II"><span class="toc-number">27.38.</span> <span class="toc-text">219. 存在重复元素 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#225-用队列实现栈"><span class="toc-number">27.39.</span> <span class="toc-text">225. 用队列实现栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#226-翻转二叉树"><span class="toc-number">27.40.</span> <span class="toc-text">226. 翻转二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#207-课程表"><span class="toc-number">27.41.</span> <span class="toc-text">207. 课程表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#210-课程表-II"><span class="toc-number">27.42.</span> <span class="toc-text">210. 课程表 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#349-两个数组的交集"><span class="toc-number">27.43.</span> <span class="toc-text">349. 两个数组的交集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#130-被围绕的区域"><span class="toc-number">27.44.</span> <span class="toc-text">130. 被围绕的区域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#200-岛屿数量"><span class="toc-number">27.45.</span> <span class="toc-text">200. 岛屿数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#399-除法求值"><span class="toc-number">27.46.</span> <span class="toc-text">399. 除法求值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#547-朋友圈"><span class="toc-number">27.47.</span> <span class="toc-text">547. 朋友圈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#315-计算右侧小于当前元素的个数"><span class="toc-number">27.48.</span> <span class="toc-text">315. 计算右侧小于当前元素的个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#187-重复的DNA序列"><span class="toc-number">27.49.</span> <span class="toc-text">187. 重复的DNA序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#201-数字范围按位与"><span class="toc-number">27.50.</span> <span class="toc-text">201. 数字范围按位与</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#260-只出现一次的数字-III"><span class="toc-number">27.51.</span> <span class="toc-text">260. 只出现一次的数字 III</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#318-最大单词长度乘积"><span class="toc-number">27.52.</span> <span class="toc-text">318. 最大单词长度乘积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#338-比特位计数"><span class="toc-number">27.53.</span> <span class="toc-text">338. 比特位计数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#342-4的幂"><span class="toc-number">27.54.</span> <span class="toc-text">342. 4的幂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#371-两整数之和"><span class="toc-number">27.55.</span> <span class="toc-text">371. 两整数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#389-找不同"><span class="toc-number">27.56.</span> <span class="toc-text">389. 找不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#393-UTF-8-编码验证"><span class="toc-number">27.57.</span> <span class="toc-text">393. UTF-8 编码验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#401-二进制手表"><span class="toc-number">27.58.</span> <span class="toc-text">401. 二进制手表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#397-整数替换"><span class="toc-number">27.59.</span> <span class="toc-text">397. 整数替换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#405-数字转换为十六进制数"><span class="toc-number">27.60.</span> <span class="toc-text">405. 数字转换为十六进制数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#421-数组中两个数的最大异或值-1"><span class="toc-number">27.61.</span> <span class="toc-text">421. 数组中两个数的最大异或值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#461-汉明距离"><span class="toc-number">27.62.</span> <span class="toc-text">461. 汉明距离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#476-数字的补数"><span class="toc-number">27.63.</span> <span class="toc-text">476. 数字的补数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#477-汉明距离总和"><span class="toc-number">27.64.</span> <span class="toc-text">477. 汉明距离总和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#693-交替位二进制数"><span class="toc-number">27.65.</span> <span class="toc-text">693. 交替位二进制数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#756-金字塔转换矩阵"><span class="toc-number">27.66.</span> <span class="toc-text">756. 金字塔转换矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#762-二进制表示中质数个计算置位"><span class="toc-number">27.67.</span> <span class="toc-text">762. 二进制表示中质数个计算置位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#784-字母大小写全排列"><span class="toc-number">27.68.</span> <span class="toc-text">784. 字母大小写全排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1131-绝对值表达式的最大值"><span class="toc-number">27.69.</span> <span class="toc-text">1131. 绝对值表达式的最大值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1239-串联字符串的最大长度"><span class="toc-number">27.70.</span> <span class="toc-text">1239. 串联字符串的最大长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1290-二进制链表转整数"><span class="toc-number">27.71.</span> <span class="toc-text">1290. 二进制链表转整数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1297-子串的最大出现次数"><span class="toc-number">27.72.</span> <span class="toc-text">1297. 子串的最大出现次数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1310-子数组异或查询"><span class="toc-number">27.73.</span> <span class="toc-text">1310. 子数组异或查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1318-或运算的最小翻转次数"><span class="toc-number">27.74.</span> <span class="toc-text">1318. 或运算的最小翻转次数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#721-账户合并"><span class="toc-number">27.75.</span> <span class="toc-text">721. 账户合并</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#947-移除最多的同行或同列石头"><span class="toc-number">27.76.</span> <span class="toc-text">947. 移除最多的同行或同列石头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#959-由斜杠划分区域"><span class="toc-number">27.77.</span> <span class="toc-text">959. 由斜杠划分区域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#990-等式方程的可满足性"><span class="toc-number">27.78.</span> <span class="toc-text">990. 等式方程的可满足性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1202-交换字符串中的元素"><span class="toc-number">27.79.</span> <span class="toc-text">1202. 交换字符串中的元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1319-连通网络的操作次数"><span class="toc-number">27.80.</span> <span class="toc-text">1319. 连通网络的操作次数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#95-不同的二叉搜索树-II"><span class="toc-number">27.81.</span> <span class="toc-text">95. 不同的二叉搜索树 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#392-判断子序列"><span class="toc-number">27.82.</span> <span class="toc-text">392. 判断子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#787-K-站中转内最便宜的航班"><span class="toc-number">27.83.</span> <span class="toc-text">787. K 站中转内最便宜的航班</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102-二叉树的层次遍历"><span class="toc-number">27.84.</span> <span class="toc-text">102. 二叉树的层次遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#103-二叉树的锯齿形层次遍历"><span class="toc-number">27.85.</span> <span class="toc-text">103. 二叉树的锯齿形层次遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#126-单词接龙-II"><span class="toc-number">27.86.</span> <span class="toc-text">126. 单词接龙 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#127-单词接龙"><span class="toc-number">27.87.</span> <span class="toc-text">127. 单词接龙</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#310-最小高度树"><span class="toc-number">27.88.</span> <span class="toc-text">310. 最小高度树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#914-卡牌分组"><span class="toc-number">27.89.</span> <span class="toc-text">914. 卡牌分组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#820-单词的压缩编码"><span class="toc-number">27.90.</span> <span class="toc-text">820. 单词的压缩编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#417-太平洋大西洋水流问题"><span class="toc-number">27.91.</span> <span class="toc-text">417. 太平洋大西洋水流问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1162-地图分析"><span class="toc-number">27.92.</span> <span class="toc-text">1162. 地图分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题62-圆圈中最后剩下的数字"><span class="toc-number">27.93.</span> <span class="toc-text">面试题62. 圆圈中最后剩下的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#513-找树左下角的值"><span class="toc-number">27.94.</span> <span class="toc-text">513. 找树左下角的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#515-在每个树行中找最大值"><span class="toc-number">27.95.</span> <span class="toc-text">515. 在每个树行中找最大值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#529-扫雷游戏"><span class="toc-number">27.96.</span> <span class="toc-text">529. 扫雷游戏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#542-01-矩阵"><span class="toc-number">27.97.</span> <span class="toc-text">542. 01 矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#690-员工的重要性"><span class="toc-number">27.98.</span> <span class="toc-text">690. 员工的重要性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#743-网络延迟时间"><span class="toc-number">27.99.</span> <span class="toc-text">743. 网络延迟时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#752-打开转盘锁"><span class="toc-number">27.100.</span> <span class="toc-text">752. 打开转盘锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#429-N叉树的层序遍历"><span class="toc-number">27.101.</span> <span class="toc-text">429. N叉树的层序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#559-N叉树的最大深度"><span class="toc-number">27.102.</span> <span class="toc-text">559. N叉树的最大深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#785-判断二分图"><span class="toc-number">27.103.</span> <span class="toc-text">785. 判断二分图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#863-二叉树中所有距离为-K-的结点"><span class="toc-number">27.104.</span> <span class="toc-text">863. 二叉树中所有距离为 K 的结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#909-蛇梯棋"><span class="toc-number">27.105.</span> <span class="toc-text">909. 蛇梯棋</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#934-最短的桥"><span class="toc-number">27.106.</span> <span class="toc-text">934. 最短的桥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#993-二叉树的堂兄弟节点"><span class="toc-number">27.107.</span> <span class="toc-text">993. 二叉树的堂兄弟节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1091-二进制矩阵中的最短路径"><span class="toc-number">27.108.</span> <span class="toc-text">1091. 二进制矩阵中的最短路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#994-腐烂的橘子"><span class="toc-number">27.109.</span> <span class="toc-text">994. 腐烂的橘子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题-04-03-特定深度节点链表"><span class="toc-number">27.110.</span> <span class="toc-text">面试题 04.03. 特定深度节点链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建设道路"><span class="toc-number">27.111.</span> <span class="toc-text">建设道路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1129-颜色交替的最短路径"><span class="toc-number">27.112.</span> <span class="toc-text">1129. 颜色交替的最短路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1306-跳跃游戏-III"><span class="toc-number">27.113.</span> <span class="toc-text">1306. 跳跃游戏 III</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1311-获取你好友已观看的视频"><span class="toc-number">27.114.</span> <span class="toc-text">1311. 获取你好友已观看的视频</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题32-I-从上到下打印二叉树"><span class="toc-number">27.115.</span> <span class="toc-text">面试题32 - I. 从上到下打印二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题32-II-从上到下打印二叉树-II"><span class="toc-number">27.116.</span> <span class="toc-text">面试题32 - II. 从上到下打印二叉树 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题32-III-从上到下打印二叉树-III"><span class="toc-number">27.117.</span> <span class="toc-text">面试题32 - III. 从上到下打印二叉树 III</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题-16-19-水域大小"><span class="toc-number">27.118.</span> <span class="toc-text">面试题 16.19. 水域大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题-17-22-单词转换"><span class="toc-number">27.119.</span> <span class="toc-text">面试题 17.22. 单词转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题-17-07-婴儿名字"><span class="toc-number">27.120.</span> <span class="toc-text">面试题 17.07. 婴儿名字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1391-检查网格中是否存在有效路径"><span class="toc-number">27.121.</span> <span class="toc-text">1391. 检查网格中是否存在有效路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1282-用户分组"><span class="toc-number">27.122.</span> <span class="toc-text">1282. 用户分组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1029-两地调度"><span class="toc-number">27.123.</span> <span class="toc-text">1029. 两地调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1046-最后一块石头的重量"><span class="toc-number">27.124.</span> <span class="toc-text">1046. 最后一块石头的重量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1296-划分数组为连续数字的集合"><span class="toc-number">27.125.</span> <span class="toc-text">1296. 划分数组为连续数字的集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1053-交换一次的先前排列"><span class="toc-number">27.126.</span> <span class="toc-text">1053. 交换一次的先前排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#621-任务调度器"><span class="toc-number">27.127.</span> <span class="toc-text">621. 任务调度器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1090-受标签影响的最大值"><span class="toc-number">27.128.</span> <span class="toc-text">1090. 受标签影响的最大值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1094-拼车"><span class="toc-number">27.129.</span> <span class="toc-text">1094. 拼车</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#649-Dota2-参议院"><span class="toc-number">27.130.</span> <span class="toc-text">649. Dota2 参议院</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#134-加油站"><span class="toc-number">27.131.</span> <span class="toc-text">134. 加油站</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#659-分割数组为连续子序列"><span class="toc-number">27.132.</span> <span class="toc-text">659. 分割数组为连续子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1111-有效括号的嵌套深度"><span class="toc-number">27.133.</span> <span class="toc-text">1111. 有效括号的嵌套深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1338-数组大小减半"><span class="toc-number">27.134.</span> <span class="toc-text">1338. 数组大小减半</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#738-单调递增的数字"><span class="toc-number">27.135.</span> <span class="toc-text">738. 单调递增的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1353-最多可以参加的会议数目"><span class="toc-number">27.136.</span> <span class="toc-text">1353. 最多可以参加的会议数目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#763-划分字母区间"><span class="toc-number">27.137.</span> <span class="toc-text">763. 划分字母区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#767-重构字符串"><span class="toc-number">27.138.</span> <span class="toc-text">767. 重构字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1217-玩筹码"><span class="toc-number">27.139.</span> <span class="toc-text">1217. 玩筹码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#306-累加数"><span class="toc-number">27.140.</span> <span class="toc-text">306. 累加数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#842-将数组拆分成斐波那契序列"><span class="toc-number">27.141.</span> <span class="toc-text">842. 将数组拆分成斐波那契序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1400-构造-K-个回文字符串"><span class="toc-number">27.142.</span> <span class="toc-text">1400. 构造 K 个回文字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#860-柠檬水找零"><span class="toc-number">27.143.</span> <span class="toc-text">860. 柠檬水找零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#861-翻转矩阵后的得分"><span class="toc-number">27.144.</span> <span class="toc-text">861. 翻转矩阵后的得分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1414-和为-K-的最少斐波那契数字数目"><span class="toc-number">27.145.</span> <span class="toc-text">1414. 和为 K 的最少斐波那契数字数目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#870-优势洗牌"><span class="toc-number">27.146.</span> <span class="toc-text">870. 优势洗牌</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1386-安排电影院座位"><span class="toc-number">27.147.</span> <span class="toc-text">1386. 安排电影院座位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1403-非递增顺序的最小子序列"><span class="toc-number">27.148.</span> <span class="toc-text">1403. 非递增顺序的最小子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#874-模拟行走机器人"><span class="toc-number">27.149.</span> <span class="toc-text">874. 模拟行走机器人</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#881-救生艇"><span class="toc-number">27.150.</span> <span class="toc-text">881. 救生艇</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1405-最长快乐字符串"><span class="toc-number">27.151.</span> <span class="toc-text">1405. 最长快乐字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1221-分割平衡字符串"><span class="toc-number">27.152.</span> <span class="toc-text">1221. 分割平衡字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#402-移掉K位数字"><span class="toc-number">27.153.</span> <span class="toc-text">402. 移掉K位数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#406-根据身高重建队列"><span class="toc-number">27.154.</span> <span class="toc-text">406. 根据身高重建队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#910-最小差值-II"><span class="toc-number">27.155.</span> <span class="toc-text">910. 最小差值 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#921-使括号有效的最少添加"><span class="toc-number">27.156.</span> <span class="toc-text">921. 使括号有效的最少添加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#435-无重叠区间"><span class="toc-number">27.157.</span> <span class="toc-text">435. 无重叠区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#452-用最少数量的箭引爆气球"><span class="toc-number">27.158.</span> <span class="toc-text">452. 用最少数量的箭引爆气球</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1433-检查一个字符串是否可以打破另一个字符串"><span class="toc-number">27.159.</span> <span class="toc-text">1433. 检查一个字符串是否可以打破另一个字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#944-删列造序"><span class="toc-number">27.160.</span> <span class="toc-text">944. 删列造序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1247-交换字符使得字符串相同"><span class="toc-number">27.161.</span> <span class="toc-text">1247. 交换字符使得字符串相同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#948-令牌放置"><span class="toc-number">27.162.</span> <span class="toc-text">948. 令牌放置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#455-分发饼干"><span class="toc-number">27.163.</span> <span class="toc-text">455. 分发饼干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#955-删列造序-II"><span class="toc-number">27.164.</span> <span class="toc-text">955. 删列造序 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#984-不含-AAA-或-BBB-的字符串"><span class="toc-number">27.165.</span> <span class="toc-text">984. 不含 AAA 或 BBB 的字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#991-坏了的计算器"><span class="toc-number">27.166.</span> <span class="toc-text">991. 坏了的计算器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1276-不浪费原料的汉堡制作方案"><span class="toc-number">27.167.</span> <span class="toc-text">1276. 不浪费原料的汉堡制作方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1253-重构-2-行二进制矩阵"><span class="toc-number">27.168.</span> <span class="toc-text">1253. 重构 2 行二进制矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1005-K-次取反后最大化的数组和"><span class="toc-number">27.169.</span> <span class="toc-text">1005. K 次取反后最大化的数组和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#537-复数乘法"><span class="toc-number">27.170.</span> <span class="toc-text">537. 复数乘法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1154-一年中的第几天"><span class="toc-number">27.171.</span> <span class="toc-text">1154. 一年中的第几天</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#976-三角形的最大周长"><span class="toc-number">27.172.</span> <span class="toc-text">976. 三角形的最大周长</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#400-第N个数字"><span class="toc-number">27.173.</span> <span class="toc-text">400. 第N个数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题67-把字符串转换成整数"><span class="toc-number">27.174.</span> <span class="toc-text">面试题67. 把字符串转换成整数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题-16-05-阶乘尾数"><span class="toc-number">27.175.</span> <span class="toc-text">面试题 16.05. 阶乘尾数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题17-打印从1到最大的n位数"><span class="toc-number">27.176.</span> <span class="toc-text">面试题17. 打印从1到最大的n位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#593-有效的正方形"><span class="toc-number">27.177.</span> <span class="toc-text">593. 有效的正方形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#553-最优除法"><span class="toc-number">27.178.</span> <span class="toc-text">553. 最优除法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1362-最接近的因数"><span class="toc-number">27.179.</span> <span class="toc-text">1362. 最接近的因数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#775-全局倒置与局部倒置"><span class="toc-number">27.180.</span> <span class="toc-text">775. 全局倒置与局部倒置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#892-三维形体的表面积"><span class="toc-number">27.181.</span> <span class="toc-text">892. 三维形体的表面积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1317-将整数转换为两个无零整数的和"><span class="toc-number">27.182.</span> <span class="toc-text">1317. 将整数转换为两个无零整数的和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题49-丑数"><span class="toc-number">27.183.</span> <span class="toc-text">面试题49. 丑数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#869-重新排序得到-2-的幂"><span class="toc-number">27.184.</span> <span class="toc-text">869. 重新排序得到 2 的幂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1009-十进制整数的反码"><span class="toc-number">27.185.</span> <span class="toc-text">1009. 十进制整数的反码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1237-找出给定方程的正整数解"><span class="toc-number">27.186.</span> <span class="toc-text">1237. 找出给定方程的正整数解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题20-表示数值的字符串"><span class="toc-number">27.187.</span> <span class="toc-text">面试题20. 表示数值的字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#908-最小差值-I"><span class="toc-number">27.188.</span> <span class="toc-text">908. 最小差值 I</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1447-最简分数"><span class="toc-number">27.189.</span> <span class="toc-text">1447. 最简分数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#868-二进制间距"><span class="toc-number">27.190.</span> <span class="toc-text">868. 二进制间距</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#598-范围求和-II"><span class="toc-number">27.191.</span> <span class="toc-text">598. 范围求和 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1037-有效的回旋镖"><span class="toc-number">27.192.</span> <span class="toc-text">1037. 有效的回旋镖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1017-负二进制转换"><span class="toc-number">27.193.</span> <span class="toc-text">1017. 负二进制转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-螺旋矩阵"><span class="toc-number">27.194.</span> <span class="toc-text">54. 螺旋矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#885-螺旋矩阵-III"><span class="toc-number">27.195.</span> <span class="toc-text">885. 螺旋矩阵 III</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#789-逃脱阻碍者"><span class="toc-number">27.196.</span> <span class="toc-text">789. 逃脱阻碍者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#843-猜猜这个单词"><span class="toc-number">27.197.</span> <span class="toc-text">843. 猜猜这个单词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#913-猫和老鼠"><span class="toc-number">27.198.</span> <span class="toc-text">913. 猫和老鼠</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题-16-07-最大数值"><span class="toc-number">27.199.</span> <span class="toc-text">面试题 16.07. 最大数值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#535-TinyURL-的加密与解密"><span class="toc-number">27.200.</span> <span class="toc-text">535. TinyURL 的加密与解密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#372-超级次方"><span class="toc-number">27.201.</span> <span class="toc-text">372. 超级次方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1006-笨阶乘"><span class="toc-number">27.202.</span> <span class="toc-text">1006. 笨阶乘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#478-在圆内随机生成点"><span class="toc-number">27.203.</span> <span class="toc-text">478. 在圆内随机生成点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#645-错误的集合"><span class="toc-number">27.204.</span> <span class="toc-text">645. 错误的集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#592-分数加减运算"><span class="toc-number">27.205.</span> <span class="toc-text">592. 分数加减运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#剑指-Offer-59-I-滑动窗口的最大值-1"><span class="toc-number">27.206.</span> <span class="toc-text">剑指 Offer 59 - I. 滑动窗口的最大值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1390-四因数"><span class="toc-number">27.207.</span> <span class="toc-text">1390. 四因数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#838-推多米诺"><span class="toc-number">27.208.</span> <span class="toc-text">838. 推多米诺</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题-17-09-第-k-个数"><span class="toc-number">27.209.</span> <span class="toc-text">面试题 17.09. 第 k 个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1015-可被-K-整除的最小整数"><span class="toc-number">27.210.</span> <span class="toc-text">1015. 可被 K 整除的最小整数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1175-质数排列"><span class="toc-number">27.211.</span> <span class="toc-text">1175. 质数排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#640-求解方程"><span class="toc-number">27.212.</span> <span class="toc-text">640. 求解方程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#970-强整数"><span class="toc-number">27.213.</span> <span class="toc-text">970. 强整数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题-01-05-一次编辑"><span class="toc-number">27.214.</span> <span class="toc-text">面试题 01.05. 一次编辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#441-排列硬币"><span class="toc-number">27.215.</span> <span class="toc-text">441. 排列硬币</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#215-数组中的第K个最大元素"><span class="toc-number">27.216.</span> <span class="toc-text">215. 数组中的第K个最大元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#剑指-Offer-09-用两个栈实现队列"><span class="toc-number">27.217.</span> <span class="toc-text">剑指 Offer 09. 用两个栈实现队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#350-两个数组的交集-II"><span class="toc-number">27.218.</span> <span class="toc-text">350. 两个数组的交集 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1337-方阵中战斗力最弱的-K-行"><span class="toc-number">27.219.</span> <span class="toc-text">1337. 方阵中战斗力最弱的 K 行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#415-字符串相加"><span class="toc-number">27.220.</span> <span class="toc-text">415. 字符串相加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1291-顺次数"><span class="toc-number">27.221.</span> <span class="toc-text">1291. 顺次数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#867-转置矩阵"><span class="toc-number">27.222.</span> <span class="toc-text">867. 转置矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#347-前-K-个高频元素"><span class="toc-number">27.223.</span> <span class="toc-text">347. 前 K 个高频元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1705-吃苹果的最大数目"><span class="toc-number">27.224.</span> <span class="toc-text">1705. 吃苹果的最大数目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1706-球会落何处"><span class="toc-number">27.225.</span> <span class="toc-text">1706. 球会落何处</span></a></li></ol></li></ol>
                  </div>
                </span>

            </div>
        </div>
        

    </div>
</aside>




  

  

  

  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2024 Louris
        <span style="font-size: smaller">
          Hosted by
          <a href="https://coding.net/" target="_blank" rel="noopener" style="font-weight: bold">Coding Pages</a>/
          <a href="https://gitee.com/" target="_blank" rel="noopener" style="font-weight: bold">Gitee Pages</a>/
          <a href="https://github.com/" target="_blank" rel="noopener" style="font-weight: bold">Github Pages</a>
        </span>
        <!-- <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
        <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人次</span> -->
    	</div>

      <!-- <div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
           <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
           <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人次</span>
      </div> -->

      <div class="footer-right">
      	<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      </div>
    </div>
  </div>
</footer>

    </div>
    <script>
	var yiliaConfig = {
		mathjax: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: false,
		root: "/",
		innerArchive: true,
		showTags: false
	}
</script>

<script>!function(t){function n(e){if(r[e])return r[e].exports;var i=r[e]={exports:{},id:e,loaded:!1};return t[e].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var r={};n.m=t,n.c=r,n.p="./",n(0)}([function(t,n,r){r(203),t.exports=r(199)},function(t,n,r){var e=r(3),i=r(49),o=r(26),u=r(27),c=r(46),f="prototype",a=function(t,n,r){var s,l,h,v,p=t&a.F,d=t&a.G,y=t&a.S,g=t&a.P,m=t&a.B,b=d?e:y?e[n]||(e[n]={}):(e[n]||{})[f],x=d?i:i[n]||(i[n]={}),S=x[f]||(x[f]={});d&&(r=n);for(s in r)l=!p&&b&&void 0!==b[s],h=(l?b:r)[s],v=m&&l?c(h,e):g&&"function"==typeof h?c(Function.call,h):h,b&&u(b,s,h,t&a.U),x[s]!=h&&o(x,s,v),g&&S[s]!=h&&(S[s]=h)};e.core=i,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,n,r){var e=r(5);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n,r){var e=r(128)("wks"),i=r(78),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(170),o=r(53),u=Object.defineProperty;n.f=r(9)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(52),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){t.exports=!r(18)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(22);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(20),i=r(59),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(95),i=r(33);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(40)("wks"),i=r(23),o=r(6).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(50);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(21);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n){var r=t.exports={version:"2.5.1"};"number"==typeof __e&&(__e=r)},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(10),i=r(74);t.exports=r(9)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(3),i=r(26),o=r(25),u=r(78)("src"),c="toString",f=Function[c],a=(""+f).split(c);r(49).inspectSource=function(t){return f.call(t)},(t.exports=function(t,n,r,c){var f="function"==typeof r;f&&(o(r,"name")||i(r,"name",n)),t[n]!==r&&(f&&(o(r,u)||i(r,u,t[n]?""+t[n]:a.join(String(n)))),t===e?t[n]=r:c?t[n]?t[n]=r:i(t,n,r):(delete t[n],i(t,n,r)))})(Function.prototype,c,function(){return"function"==typeof this&&this[u]||f.call(this)})},function(t,n,r){var e=r(1),i=r(4),o=r(50),u=/"/g,c=function(t,n,r,e){var i=String(o(t)),c="<"+n;return""!==r&&(c+=" "+r+'="'+String(e).replace(u,"&quot;")+'"'),c+">"+i+"</"+n+">"};t.exports=function(t,n){var r={};r[t]=n(c),e(e.P+e.F*i(function(){var n=""[t]('"');return n!==n.toLowerCase()||n.split('"').length>3}),"String",r)}},function(t,n,r){var e=r(64),i=r(34);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(116),i=r(74),o=r(32),u=r(53),c=r(25),f=r(170),a=Object.getOwnPropertyDescriptor;n.f=r(9)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(25),i=r(17),o=r(149)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(115),i=r(50);t.exports=function(t){return e(i(t))}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(8),o=r(16)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(23);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(6),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n,r){var e=r(21);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(6),i=r(24),o=r(36),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(16)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(19);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){"use strict";var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n,r){var e=r(46),i=r(115),o=r(17),u=r(11),c=r(134);t.exports=function(t,n){var r=1==t,f=2==t,a=3==t,s=4==t,l=6==t,h=5==t||l,v=n||c;return function(n,c,p){for(var d,y,g=o(n),m=i(g),b=e(c,p,3),x=u(m.length),S=0,w=r?v(n,x):f?v(n,0):void 0;x>S;S++)if((h||S in m)&&(d=m[S],y=b(d,S,g),t))if(r)w[S]=y;else if(y)switch(t){case 3:return!0;case 5:return d;case 6:return S;case 2:w.push(d)}else if(s)return!1;return l?-1:a||s?s:w}}},function(t,n){var r=t.exports={version:"2.5.1"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var e=r(1),i=r(49),o=r(4);t.exports=function(t,n){var r=(i.Object||{})[t]||Object[t],u={};u[t]=n(r),e(e.S+e.F*o(function(){r(1)}),"Object",u)}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n,r){var e=r(5);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(6),i=r(24),o=r(92),u=r(13),c="prototype",f=function(t,n,r){var a,s,l,h=t&f.F,v=t&f.G,p=t&f.S,d=t&f.P,y=t&f.B,g=t&f.W,m=v?i:i[n]||(i[n]={}),b=m[c],x=v?e:p?e[n]:(e[n]||{})[c];v&&(r=n);for(a in r)(s=!h&&x&&void 0!==x[a])&&a in m||(l=s?x[a]:r[a],m[a]=v&&"function"!=typeof x[a]?r[a]:y&&s?o(l,e):g&&x[a]==l?function(t){var n=function(n,r,e){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,r)}return new t(n,r,e)}return t.apply(this,arguments)};return n[c]=t[c],n}(l):d&&"function"==typeof l?o(Function.call,l):l,d&&((m.virtual||(m.virtual={}))[a]=l,t&f.R&&b&&!b[a]&&u(b,a,l)))};f.F=1,f.G=2,f.S=4,f.P=8,f.B=16,f.W=32,f.U=64,f.R=128,t.exports=f},function(t,n,r){var e=r(191),i=r(1),o=r(128)("metadata"),u=o.store||(o.store=new(r(194))),c=function(t,n,r){var i=u.get(t);if(!i){if(!r)return;u.set(t,i=new e)}var o=i.get(n);if(!o){if(!r)return;i.set(n,o=new e)}return o};t.exports={store:u,map:c,has:function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},get:function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},set:function(t,n,r,e){c(r,e,!0).set(t,n)},keys:function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},key:function(t){return void 0===t||"symbol"==typeof t?t:String(t)},exp:function(t){i(i.S,"Reflect",t)}}},function(t,n,r){"use strict";if(r(9)){var e=r(70),i=r(3),o=r(4),u=r(1),c=r(130),f=r(155),a=r(46),s=r(68),l=r(74),h=r(26),v=r(75),p=r(52),d=r(11),y=r(189),g=r(77),m=r(53),b=r(25),x=r(114),S=r(5),w=r(17),_=r(141),O=r(71),E=r(31),M=r(72).f,P=r(157),j=r(78),F=r(7),A=r(48),L=r(117),N=r(129),T=r(158),I=r(80),k=r(123),R=r(76),C=r(133),D=r(162),G=r(10),W=r(30),U=G.f,V=W.f,B=i.RangeError,q=i.TypeError,z=i.Uint8Array,H="ArrayBuffer",K="Shared"+H,J="BYTES_PER_ELEMENT",Y="prototype",$=Array[Y],X=f.ArrayBuffer,Q=f.DataView,Z=A(0),tt=A(2),nt=A(3),rt=A(4),et=A(5),it=A(6),ot=L(!0),ut=L(!1),ct=T.values,ft=T.keys,at=T.entries,st=$.lastIndexOf,lt=$.reduce,ht=$.reduceRight,vt=$.join,pt=$.sort,dt=$.slice,yt=$.toString,gt=$.toLocaleString,mt=F("iterator"),bt=F("toStringTag"),xt=j("typed_constructor"),St=j("def_constructor"),wt=c.CONSTR,_t=c.TYPED,Ot=c.VIEW,Et="Wrong length!",Mt=A(1,function(t,n){return Lt(N(t,t[St]),n)}),Pt=o(function(){return 1===new z(new Uint16Array([1]).buffer)[0]}),jt=!!z&&!!z[Y].set&&o(function(){new z(1).set({})}),Ft=function(t,n){var r=p(t);if(r<0||r%n)throw B("Wrong offset!");return r},At=function(t){if(S(t)&&_t in t)return t;throw q(t+" is not a typed array!")},Lt=function(t,n){if(!(S(t)&&xt in t))throw q("It is not a typed array constructor!");return new t(n)},Nt=function(t,n){return Tt(N(t,t[St]),n)},Tt=function(t,n){for(var r=0,e=n.length,i=Lt(t,e);e>r;)i[r]=n[r++];return i},It=function(t,n,r){U(t,n,{get:function(){return this._d[r]}})},kt=function(t){var n,r,e,i,o,u,c=w(t),f=arguments.length,s=f>1?arguments[1]:void 0,l=void 0!==s,h=P(c);if(void 0!=h&&!_(h)){for(u=h.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(l&&f>2&&(s=a(s,arguments[2],2)),n=0,r=d(c.length),i=Lt(this,r);r>n;n++)i[n]=l?s(c[n],n):c[n];return i},Rt=function(){for(var t=0,n=arguments.length,r=Lt(this,n);n>t;)r[t]=arguments[t++];return r},Ct=!!z&&o(function(){gt.call(new z(1))}),Dt=function(){return gt.apply(Ct?dt.call(At(this)):At(this),arguments)},Gt={copyWithin:function(t,n){return D.call(At(this),t,n,arguments.length>2?arguments[2]:void 0)},every:function(t){return rt(At(this),t,arguments.length>1?arguments[1]:void 0)},fill:function(t){return C.apply(At(this),arguments)},filter:function(t){return Nt(this,tt(At(this),t,arguments.length>1?arguments[1]:void 0))},find:function(t){return et(At(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function(t){return it(At(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function(t){Z(At(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function(t){return ut(At(this),t,arguments.length>1?arguments[1]:void 0)},includes:function(t){return ot(At(this),t,arguments.length>1?arguments[1]:void 0)},join:function(t){return vt.apply(At(this),arguments)},lastIndexOf:function(t){return st.apply(At(this),arguments)},map:function(t){return Mt(At(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function(t){return lt.apply(At(this),arguments)},reduceRight:function(t){return ht.apply(At(this),arguments)},reverse:function(){for(var t,n=this,r=At(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(At(this),t,arguments.length>1?arguments[1]:void 0)},sort:function(t){return pt.call(At(this),t)},subarray:function(t,n){var r=At(this),e=r.length,i=g(t,e);return new(N(r,r[St]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,d((void 0===n?e:g(n,e))-i))}},Wt=function(t,n){return Nt(this,dt.call(At(this),t,n))},Ut=function(t){At(this);var n=Ft(arguments[1],1),r=this.length,e=w(t),i=d(e.length),o=0;if(i+n>r)throw B(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(At(this))},keys:function(){return ft.call(At(this))},values:function(){return ct.call(At(this))}},Bt=function(t,n){return S(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return Bt(t,n=m(n,!0))?l(2,t[n]):V(t,n)},zt=function(t,n,r){return!(Bt(t,n=m(n,!0))&&S(r)&&b(r,"value"))||b(r,"get")||b(r,"set")||r.configurable||b(r,"writable")&&!r.writable||b(r,"enumerable")&&!r.enumerable?U(t,n,r):(t[n]=r.value,t)};wt||(W.f=qt,G.f=zt),u(u.S+u.F*!wt,"Object",{getOwnPropertyDescriptor:qt,defineProperty:zt}),o(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Ht=v({},Gt);v(Ht,Vt),h(Ht,mt,Vt.values),v(Ht,{slice:Wt,set:Ut,constructor:function(){},toString:yt,toLocaleString:Dt}),It(Ht,"buffer","b"),It(Ht,"byteOffset","o"),It(Ht,"byteLength","l"),It(Ht,"length","e"),U(Ht,bt,{get:function(){return this[_t]}}),t.exports=function(t,n,r,f){var a=t+((f=!!f)?"Clamped":"")+"Array",l="get"+t,v="set"+t,p=i[a],g=p||{},m=p&&E(p),b=!p||!c.ABV,w={},_=p&&p[Y],P=function(t,r){var e=t._d;return e.v[l](r*n+e.o,Pt)},j=function(t,r,e){var i=t._d;f&&(e=(e=Math.round(e))<0?0:e>255?255:255&e),i.v[v](r*n+i.o,e,Pt)},F=function(t,n){U(t,n,{get:function(){return P(this,n)},set:function(t){return j(this,n,t)},enumerable:!0})};b?(p=r(function(t,r,e,i){s(t,p,a,"_d");var o,u,c,f,l=0,v=0;if(S(r)){if(!(r instanceof X||(f=x(r))==H||f==K))return _t in r?Tt(p,r):kt.call(p,r);o=r,v=Ft(e,n);var g=r.byteLength;if(void 0===i){if(g%n)throw B(Et);if((u=g-v)<0)throw B(Et)}else if((u=d(i)*n)+v>g)throw B(Et);c=u/n}else c=y(r),u=c*n,o=new X(u);for(h(t,"_d",{b:o,o:v,l:u,e:c,v:new Q(o)});l<c;)F(t,l++)}),_=p[Y]=O(Ht),h(_,"constructor",p)):o(function(){p(1)})&&o(function(){new p(-1)})&&k(function(t){new p,new p(null),new p(1.5),new p(t)},!0)||(p=r(function(t,r,e,i){s(t,p,a);var o;return S(r)?r instanceof X||(o=x(r))==H||o==K?void 0!==i?new g(r,Ft(e,n),i):void 0!==e?new g(r,Ft(e,n)):new g(r):_t in r?Tt(p,r):kt.call(p,r):new g(y(r))}),Z(m!==Function.prototype?M(g).concat(M(m)):M(g),function(t){t in p||h(p,t,g[t])}),p[Y]=_,e||(_.constructor=p));var A=_[mt],L=!!A&&("values"==A.name||void 0==A.name),N=Vt.values;h(p,xt,!0),h(_,_t,a),h(_,Ot,!0),h(_,St,p),(f?new p(1)[bt]==a:bt in _)||U(_,bt,{get:function(){return a}}),w[a]=p,u(u.G+u.W+u.F*(p!=g),w),u(u.S,a,{BYTES_PER_ELEMENT:n}),u(u.S+u.F*o(function(){g.of.call(p,1)}),a,{from:kt,of:Rt}),J in _||h(_,J,n),u(u.P,a,Gt),R(a),u(u.P+u.F*jt,a,{set:Ut}),u(u.P+u.F*!L,a,Vt),e||_.toString==yt||(_.toString=yt),u(u.P+u.F*o(function(){new p(1).slice()}),a,{slice:Wt}),u(u.P+u.F*(o(function(){return[1,2].toLocaleString()!=new p([1,2]).toLocaleString()})||!o(function(){_.toLocaleString.call([1,2])})),a,{toLocaleString:Dt}),I[a]=L?A:N,e||L||h(_,mt,N)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(21),i=r(6).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(18)(function(){return 7!=Object.defineProperty(r(58)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var e=r(36),i=r(54),o=r(65),u=r(13),c=r(8),f=r(35),a=r(97),s=r(38),l=r(103),h=r(16)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,m,b,x){a(r,n,g);var S,w,_,O=function(t){if(!v&&t in j)return j[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",M=m==d,P=!1,j=t.prototype,F=j[h]||j["@@iterator"]||m&&j[m],A=F||O(m),L=m?M?O("entries"):A:void 0,N="Array"==n?j.entries||F:F;if(N&&(_=l(N.call(new t)))!==Object.prototype&&_.next&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),M&&F&&F.name!==d&&(P=!0,A=function(){return F.call(this)}),e&&!x||!v&&!P&&j[h]||u(j,h,A),f[n]=A,f[E]=y,m)if(S={values:M?A:O(d),keys:b?A:O(p),entries:L},x)for(w in S)w in j||o(j,w,S[w]);else i(i.P+i.F*(v||P),n,S);return S}},function(t,n,r){var e=r(20),i=r(100),o=r(34),u=r(39)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(58)("iframe"),e=o.length;for(n.style.display="none",r(94).appendChild(n),n.src="javascript:",(t=n.contentWindow.document).open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(64),i=r(34).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(8),i=r(15),o=r(91)(!1),u=r(39)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;void 0==i[e]&&r(26)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n,r){var e=r(78)("meta"),i=r(5),o=r(25),u=r(10).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=t.exports={KEY:e,NEED:!1,fastKey:function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},getWeak:function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},onFreeze:function(t){return a&&l.NEED&&f(t)&&!o(t,e)&&s(t),t}}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n,r){var e=r(46),i=r(173),o=r(141),u=r(2),c=r(11),f=r(157),a={},s={};(n=t.exports=function(t,n,r,l,h){var v,p,d,y,g=h?function(){return t}:f(t),m=e(r,l,n?2:1),b=0;if("function"!=typeof g)throw TypeError(t+" is not iterable!");if(o(g)){for(v=c(t.length);v>b;b++)if((y=n?m(u(p=t[b])[0],p[1]):m(t[b]))===a||y===s)return y}else for(d=g.call(t);!(p=d.next()).done;)if((y=i(d,m,p.value,n))===a||y===s)return y}).BREAK=a,n.RETURN=s},function(t,n){t.exports=!1},function(t,n,r){var e=r(2),i=r(179),o=r(137),u=r(149)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(136)("iframe"),e=o.length;for(n.style.display="none",r(139).appendChild(n),n.src="javascript:",(t=n.contentWindow.document).open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(181),i=r(137).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(181),i=r(137);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n,r){var e=r(27);t.exports=function(t,n,r){for(var i in n)e(t,i,n[i],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(10),o=r(9),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(52),i=Math.max,o=Math.min;t.exports=function(t,n){return(t=e(t))<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(33);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports={}},function(t,n,r){var e=r(10).f,i=r(25),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(1),i=r(50),o=r(4),u=r(153),c="["+u+"]",f=RegExp("^"+c+c+"*"),a=RegExp(c+c+"*$"),s=function(t,n,r){var i={},c=o(function(){return!!u[t]()||"​"!="​"[t]()}),f=i[t]=c?n(l):u[t];r&&(i[r]=f),e(e.P+e.F*c,"String",i)},l=s.trim=function(t,n){return t=String(i(t)),1&n&&(t=t.replace(f,"")),2&n&&(t=t.replace(a,"")),t};t.exports=s},function(t,n,r){var e=r(5);t.exports=function(t,n){if(!e(t)||t._t!==n)throw TypeError("Incompatible receiver, "+n+" required!");return t}},function(t,n,r){t.exports={default:r(87),__esModule:!0}},function(t,n,r){t.exports={default:r(88),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=e(r(85)),o=e(r(84)),u="function"==typeof o.default&&"symbol"==typeof i.default?function(t){return typeof t}:function(t){return t&&"function"==typeof o.default&&t.constructor===o.default&&t!==o.default.prototype?"symbol":typeof t};n.default="function"==typeof o.default&&"symbol"===u(i.default)?function(t){return void 0===t?"undefined":u(t)}:function(t){return t&&"function"==typeof o.default&&t.constructor===o.default&&t!==o.default.prototype?"symbol":void 0===t?"undefined":u(t)}},function(t,n,r){r(110),r(108),r(111),r(112),t.exports=r(24).Symbol},function(t,n,r){r(109),r(113),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var e=r(15),i=r(106),o=r(105);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){var e=r(89);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(29),i=r(63),o=r(37);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){var e=r(6).document;t.exports=e&&e.documentElement},function(t,n,r){var e=r(57);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(57);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(61),i=r(22),o=r(38),u={};r(13)(u,r(16)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(23)("meta"),i=r(21),o=r(8),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(18)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=t.exports={KEY:e,NEED:!1,fastKey:function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},getWeak:function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},onFreeze:function(t){return a&&l.NEED&&f(t)&&!o(t,e)&&s(t),t}}},function(t,n,r){var e=r(14),i=r(20),o=r(29);t.exports=r(12)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(22),o=r(15),u=r(42),c=r(8),f=r(59),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(15),i=r(62).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(8),i=r(79),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(41),i=r(33);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f))<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return(t=e(t))<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(90),i=r(98),o=r(35),u=r(15);t.exports=r(60)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(104)(!0);r(60)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(6),i=r(8),o=r(12),u=r(54),c=r(65),f=r(99).KEY,a=r(18),s=r(40),l=r(38),h=r(23),v=r(16),p=r(44),d=r(43),y=r(93),g=r(96),m=r(20),b=r(15),x=r(42),S=r(22),w=r(61),_=r(102),O=r(101),E=r(14),M=r(29),P=O.f,j=E.f,F=_.f,A=e.Symbol,L=e.JSON,N=L&&L.stringify,T="prototype",I=v("_hidden"),k=v("toPrimitive"),R={}.propertyIsEnumerable,C=s("symbol-registry"),D=s("symbols"),G=s("op-symbols"),W=Object[T],U="function"==typeof A,V=e.QObject,B=!V||!V[T]||!V[T].findChild,q=o&&a(function(){return 7!=w(j({},"a",{get:function(){return j(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=P(W,n);e&&delete W[n],j(t,n,r),e&&t!==W&&j(W,n,e)}:j,z=function(t){var n=D[t]=w(A[T]);return n._k=t,n},H=U&&"symbol"==typeof A.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof A},K=function(t,n,r){return t===W&&K(G,n,r),m(t),n=x(n,!0),m(r),i(D,n)?(r.enumerable?(i(t,I)&&t[I][n]&&(t[I][n]=!1),r=w(r,{enumerable:S(0,!1)})):(i(t,I)||j(t,I,S(1,{})),t[I][n]=!0),q(t,n,r)):j(t,n,r)},J=function(t,n){m(t);for(var r,e=y(n=b(n)),i=0,o=e.length;o>i;)K(t,r=e[i++],n[r]);return t},Y=function(t){var n=R.call(this,t=x(t,!0));return!(this===W&&i(D,t)&&!i(G,t))&&(!(n||!i(this,t)||!i(D,t)||i(this,I)&&this[I][t])||n)},$=function(t,n){if(t=b(t),n=x(n,!0),t!==W||!i(D,n)||i(G,n)){var r=P(t,n);return!r||!i(D,n)||i(t,I)&&t[I][n]||(r.enumerable=!0),r}},X=function(t){for(var n,r=F(b(t)),e=[],o=0;r.length>o;)i(D,n=r[o++])||n==I||n==f||e.push(n);return e},Q=function(t){for(var n,r=t===W,e=F(r?G:b(t)),o=[],u=0;e.length>u;)!i(D,n=e[u++])||r&&!i(W,n)||o.push(D[n]);return o};U||(A=function(){if(this instanceof A)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===W&&n.call(G,r),i(this,I)&&i(this[I],t)&&(this[I][t]=!1),q(this,t,S(1,r))};return o&&B&&q(W,t,{configurable:!0,set:n}),z(t)},c(A[T],"toString",function(){return this._k}),O.f=$,E.f=K,r(62).f=_.f=X,r(37).f=Y,r(63).f=Q,o&&!r(36)&&c(W,"propertyIsEnumerable",Y,!0),p.f=function(t){return z(v(t))}),u(u.G+u.W+u.F*!U,{Symbol:A});for(var Z="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),tt=0;Z.length>tt;)v(Z[tt++]);for(var nt=M(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!U,"Symbol",{for:function(t){return i(C,t+="")?C[t]:C[t]=A(t)},keyFor:function(t){if(!H(t))throw TypeError(t+" is not a symbol!");for(var n in C)if(C[n]===t)return n},useSetter:function(){B=!0},useSimple:function(){B=!1}}),u(u.S+u.F*!U,"Object",{create:function(t,n){return void 0===n?w(t):J(w(t),n)},defineProperty:K,defineProperties:J,getOwnPropertyDescriptor:$,getOwnPropertyNames:X,getOwnPropertySymbols:Q}),L&&u(u.S+u.F*(!U||a(function(){var t=A();return"[null]"!=N([t])||"{}"!=N({a:t})||"{}"!=N(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!H(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return"function"==typeof(n=e[1])&&(r=n),!r&&g(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!H(n))return n}),e[1]=n,N.apply(L,e)}}}),A[T][k]||r(13)(A[T],k,A[T].valueOf),l(A,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(107);for(var e=r(6),i=r(13),o=r(35),u=r(16)("toStringTag"),c="CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","),f=0;f<c.length;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){var e=r(45),i=r(7)("toStringTag"),o="Arguments"==e(function(){return arguments}()),u=function(t,n){try{return t[n]}catch(t){}};t.exports=function(t){var n,r,c;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=u(n=Object(t),i))?r:o?e(n):"Object"==(c=e(n))&&"function"==typeof n.callee?"Arguments":c}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(32),i=r(11),o=r(77);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){"use strict";var e=r(3),i=r(1),o=r(27),u=r(75),c=r(67),f=r(69),a=r(68),s=r(5),l=r(4),h=r(123),v=r(81),p=r(140);t.exports=function(t,n,r,d,y,g){var m=e[t],b=m,x=y?"set":"add",S=b&&b.prototype,w={},_=function(t){var n=S[t];o(S,t,"delete"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"has"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"get"==t?function(t){return g&&!s(t)?void 0:n.call(this,0===t?0:t)}:"add"==t?function(t){return n.call(this,0===t?0:t),this}:function(t,r){return n.call(this,0===t?0:t,r),this})};if("function"==typeof b&&(g||S.forEach&&!l(function(){(new b).entries().next()}))){var O=new b,E=O[x](g?{}:-0,1)!=O,M=l(function(){O.has(1)}),P=h(function(t){new b(t)}),j=!g&&l(function(){for(var t=new b,n=5;n--;)t[x](n,n);return!t.has(-0)});P||(b=n(function(n,r){a(n,b,t);var e=p(new m,n,b);return void 0!=r&&f(r,y,e[x],e),e}),b.prototype=S,S.constructor=b),(M||j)&&(_("delete"),_("has"),y&&_("get")),(j||E)&&_(x),g&&S.clear&&delete S.clear}else b=d.getConstructor(n,t,y,x),u(b.prototype,r),c.NEED=!0;return v(b,t),w[t]=b,i(i.G+i.W+i.F*(b!=m),w),g||d.setStrong(b,t,y),b}},function(t,n,r){"use strict";var e=r(26),i=r(27),o=r(4),u=r(50),c=r(7);t.exports=function(t,n,r){var f=c(t),a=r(u,f,""[t]),s=a[0],l=a[1];o(function(){var n={};return n[f]=function(){return 7},7!=""[t](n)})&&(i(String.prototype,t,s),e(RegExp.prototype,f,2==n?function(t,n){return l.call(t,this,n)}:function(t){return l.call(t,this)}))}},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){var e=r(5),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var e=r(7)("iterator"),i=!1;try{var o=[7][e]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!i)return!1;var r=!1;try{var o=[7],u=o[e]();u.next=function(){return{done:r=!0}},o[e]=function(){return u},t(o)}catch(t){}return r}},function(t,n,r){"use strict";t.exports=r(70)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){"use strict";var e=r(1),i=r(19),o=r(46),u=r(69);t.exports=function(t){e(e.S,t,{from:function(t){var n,r,e,c,f=arguments[1];return i(this),(n=void 0!==f)&&i(f),void 0==t?new this:(r=[],n?(e=0,c=o(f,arguments[2],2),u(t,!1,function(t){r.push(c(t,e++))})):u(t,!1,r.push,r),new this(r))}})}},function(t,n,r){"use strict";var e=r(1);t.exports=function(t){e(e.S,t,{of:function(){for(var t=arguments.length,n=Array(t);t--;)n[t]=arguments[t];return new this(n)}})}},function(t,n,r){var e=r(3),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n,r){var e=r(2),i=r(19),o=r(7)("species");t.exports=function(t,n){var r,u=e(t).constructor;return void 0===u||void 0==(r=e(u)[o])?n:i(r)}},function(t,n,r){for(var e,i=r(3),o=r(26),u=r(78),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n){"use strict";var r={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&-1==t.indexOf("KHTML"),mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:-1==t.indexOf("Safari"),weixin:-1==t.indexOf("MicroMessenger")}}()};t.exports=r},function(t,n,r){"use strict";var e=function(t){return t&&t.__esModule?t:{default:t}}(r(86)),i=function(){function t(t,n,r){return n||r?String.fromCharCode(n||r):u[t]||t}function n(t){return l[t]}var r=/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,o=/['<> "&]/g,u={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},c=/\u00a0/g,f=/<br\s*\/?>/gi,a=/\r?\n/g,s=/\s/g,l={};for(var h in u)l[u[h]]=h;return u["&apos;"]="'",l["'"]="&#39;",{encode:function(t){return t?(""+t).replace(o,n).replace(a,"<br/>").replace(s,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(f,"\n").replace(r,t).replace(c," "):""},encodeBase16:function(t){if(!t)return t;for(var n=[],r=0,e=(t+="").length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;for(var n=[],r=0,e=(t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")})).length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;for(var n=[],r=0,e=(t+="").length;e>r;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;r>n;n++)t[n]=i.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,e.default)(t)))for(var o in t)t[o]=i.encodeObject(t[o]);else if("string"==typeof t)return i.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=i},function(t,n,r){"use strict";var e=r(17),i=r(77),o=r(11);t.exports=function(t){for(var n=e(this),r=o(n.length),u=arguments.length,c=i(u>1?arguments[1]:void 0,r),f=u>2?arguments[2]:void 0,a=void 0===f?r:i(f,r);a>c;)n[c++]=t;return n}},function(t,n,r){var e=r(211);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(10),i=r(74);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(5),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(t){var n=/./;try{"/./"[t](n)}catch(r){try{return n[e]=!1,!"/./"[t](n)}catch(t){}}return!0}},function(t,n,r){var e=r(3).document;t.exports=e&&e.documentElement},function(t,n,r){var e=r(5),i=r(148).set;t.exports=function(t,n,r){var o,u=n.constructor;return u!==r&&"function"==typeof u&&(o=u.prototype)!==r.prototype&&e(o)&&i&&i(t,o),t}},function(t,n,r){var e=r(80),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){"use strict";var e=r(71),i=r(74),o=r(81),u={};r(26)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var e=r(70),i=r(1),o=r(27),u=r(26),c=r(25),f=r(80),a=r(142),s=r(81),l=r(31),h=r(7)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,m,b,x){a(r,n,g);var S,w,_,O=function(t){if(!v&&t in j)return j[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",M=m==d,P=!1,j=t.prototype,F=j[h]||j["@@iterator"]||m&&j[m],A=F||O(m),L=m?M?O("entries"):A:void 0,N="Array"==n?j.entries||F:F;if(N&&(_=l(N.call(new t)))!==Object.prototype&&_.next&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),M&&F&&F.name!==d&&(P=!0,A=function(){return F.call(this)}),e&&!x||!v&&!P&&j[h]||u(j,h,A),f[n]=A,f[E]=y,m)if(S={values:M?A:O(d),keys:b?A:O(p),entries:L},x)for(w in S)w in j||o(j,w,S[w]);else i(i.P+i.F*(v||P),n,S);return S}},function(t,n){var r=Math.expm1;t.exports=!r||r(10)>22025.465794806718||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:t>-1e-6&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var e=r(3),i=r(154).set,o=e.MutationObserver||e.WebKitMutationObserver,u=e.process,c=e.Promise,f="process"==r(45)(u);t.exports=function(){var t,n,r,a=function(){var e,i;for(f&&(e=u.domain)&&e.exit();t;){i=t.fn,t=t.next;try{i()}catch(e){throw t?r():n=void 0,e}}n=void 0,e&&e.enter()};if(f)r=function(){u.nextTick(a)};else if(o){var s=!0,l=document.createTextNode("");new o(a).observe(l,{characterData:!0}),r=function(){l.data=s=!s}}else if(c&&c.resolve){var h=c.resolve();r=function(){h.then(a)}}else r=function(){i.call(e,a)};return function(e){var i={fn:e,next:void 0};n&&(n.next=i),t||(t=i,r()),n=i}}},function(t,n,r){"use strict";function e(t){var n,r;this.promise=new t(function(t,e){if(void 0!==n||void 0!==r)throw TypeError("Bad Promise constructor");n=t,r=e}),this.resolve=i(n),this.reject=i(r)}var i=r(19);t.exports.f=function(t){return new e(t)}},function(t,n,r){var e=r(5),i=r(2),o=function(t,n){if(i(t),!e(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,n,e){try{(e=r(46)(Function.call,r(30).f(Object.prototype,"__proto__").set,2))(t,[]),n=!(t instanceof Array)}catch(t){n=!0}return function(t,r){return o(t,r),n?t.__proto__=r:e(t,r),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(128)("keys"),i=r(78);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(52),i=r(50);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f))<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536}}},function(t,n,r){var e=r(122),i=r(50);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var e=r(52),i=r(50);t.exports=function(t){var n=String(i(this)),r="",o=e(t);if(o<0||o==1/0)throw RangeError("Count can't be negative");for(;o>0;(o>>>=1)&&(n+=n))1&o&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(46),c=r(171),f=r(139),a=r(136),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=s.Dispatch,y=0,g={},m="onreadystatechange",b=function(){var t=+this;if(g.hasOwnProperty(t)){var n=g[t];delete g[t],n()}},x=function(t){b.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return g[++y]=function(){c("function"==typeof t?t:Function(t),n)},e(y),y},v=function(t){delete g[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(b,t,1))}:d&&d.now?e=function(t){d.now(u(b,t,1))}:p?(i=new p,o=i.port2,i.port1.onmessage=x,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",x,!1)):e=m in a("script")?function(t){f.appendChild(a("script"))[m]=function(){f.removeChild(this),b.call(t)}}:function(t){setTimeout(u(b,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";function e(t,n,r){var e,i,o,u=Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?W(2,-24)-W(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for((t=G(t))!=t||t===C?(i=t!=t?1:0,e=f):(e=U(V(t)/B),t*(o=W(2,-e))<1&&(e--,o*=2),(t+=e+a>=1?s/o:s*W(2,1-a))*o>=2&&(e++,o/=2),e+a>=f?(i=0,e=f):e+a>=1?(i=(t*o-1)*W(2,n),e+=a):(i=t*W(2,a-1)*W(2,n),e=0));n>=8;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;c>0;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u}function i(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;c>0;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;c>0;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-C:C;e+=W(2,n),s-=u}return(a?-1:1)*e*W(2,s-n)}function o(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]}function u(t){return[255&t]}function c(t){return[255&t,t>>8&255]}function f(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]}function a(t){return e(t,52,8)}function s(t){return e(t,23,4)}function l(t,n,r){M(t[L],n,{get:function(){return this[r]}})}function h(t,n,r,e){var i=O(+r);if(i+n>t[J])throw R(N);var o=t[K]._b,u=i+t[Y],c=o.slice(u,u+n);return e?c:c.reverse()}function v(t,n,r,e,i,o){var u=O(+r);if(u+n>t[J])throw R(N);for(var c=t[K]._b,f=u+t[Y],a=e(+i),s=0;s<n;s++)c[f+s]=a[o?s:n-s-1]}var p=r(3),d=r(9),y=r(70),g=r(130),m=r(26),b=r(75),x=r(4),S=r(68),w=r(52),_=r(11),O=r(189),E=r(72).f,M=r(10).f,P=r(133),j=r(81),F="ArrayBuffer",A="DataView",L="prototype",N="Wrong index!",T=p[F],I=p[A],k=p.Math,R=p.RangeError,C=p.Infinity,D=T,G=k.abs,W=k.pow,U=k.floor,V=k.log,B=k.LN2,q="buffer",z="byteLength",H="byteOffset",K=d?"_b":q,J=d?"_l":z,Y=d?"_o":H;if(g.ABV){if(!x(function(){T(1)})||!x(function(){new T(-1)})||x(function(){return new T,new T(1.5),new T(NaN),T.name!=F})){for(var $,X=(T=function(t){return S(this,T),new D(O(t))})[L]=D[L],Q=E(D),Z=0;Q.length>Z;)($=Q[Z++])in T||m(T,$,D[$]);y||(X.constructor=T)}var tt=new I(new T(2)),nt=I[L].setInt8;tt.setInt8(0,2147483648),tt.setInt8(1,2147483649),!tt.getInt8(0)&&tt.getInt8(1)||b(I[L],{setInt8:function(t,n){nt.call(this,t,n<<24>>24)},setUint8:function(t,n){nt.call(this,t,n<<24>>24)}},!0)}else T=function(t){S(this,T,F);var n=O(t);this._b=P.call(Array(n),0),this[J]=n},I=function(t,n,r){S(this,I,A),S(t,T,A);var e=t[J],i=w(n);if(i<0||i>e)throw R("Wrong offset!");if(r=void 0===r?e-i:_(r),i+r>e)throw R("Wrong length!");this[K]=t,this[Y]=i,this[J]=r},d&&(l(T,z,"_l"),l(I,q,"_b"),l(I,z,"_l"),l(I,H,"_o")),b(I[L],{getInt8:function(t){return h(this,1,t)[0]<<24>>24},getUint8:function(t){return h(this,1,t)[0]},getInt16:function(t){var n=h(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=h(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return o(h(this,4,t,arguments[1]))},getUint32:function(t){return o(h(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return i(h(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return i(h(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){v(this,1,t,u,n)},setUint8:function(t,n){v(this,1,t,u,n)},setInt16:function(t,n){v(this,2,t,c,n,arguments[2])},setUint16:function(t,n){v(this,2,t,c,n,arguments[2])},setInt32:function(t,n){v(this,4,t,f,n,arguments[2])},setUint32:function(t,n){v(this,4,t,f,n,arguments[2])},setFloat32:function(t,n){v(this,4,t,s,n,arguments[2])},setFloat64:function(t,n){v(this,8,t,a,n,arguments[2])}});j(T,F),j(I,A),m(I[L],g.VIEW,!0),n[F]=T,n[A]=I},function(t,n,r){var e=r(3),i=r(49),o=r(70),u=r(190),c=r(10).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(114),i=r(7)("iterator"),o=r(80);t.exports=r(49).getIteratorMethod=function(t){if(void 0!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(66),i=r(174),o=r(80),u=r(32);t.exports=r(143)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){t.exports=function(t,n){t.classList?t.classList.add(n):t.className+=" "+n}},function(t,n){t.exports=function(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var e=r(17),i=r(77),o=r(11);t.exports=[].copyWithin||function(t,n){var r=e(this),u=o(r.length),c=i(t,u),f=i(n,u),a=arguments.length>2?arguments[2]:void 0,s=Math.min((void 0===a?u:i(a,u))-f,u-c),l=1;for(f<c&&c<f+s&&(l=-1,f+=s-1,c+=s-1);s-- >0;)f in r?r[c]=r[f]:delete r[c],c+=l,f+=l;return r}},function(t,n,r){var e=r(69);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var e=r(19),i=r(17),o=r(115),u=r(11);t.exports=function(t,n,r,c,f){e(n);var a=i(t),s=o(a),l=u(a.length),h=f?l-1:0,v=f?-1:1;if(r<2)for(;;){if(h in s){c=s[h],h+=v;break}if(h+=v,f?h<0:l<=h)throw TypeError("Reduce of empty array with no initial value")}for(;f?h>=0:l>h;h+=v)h in s&&(c=n(c,s[h],h,a));return c}},function(t,n,r){"use strict";var e=r(19),i=r(5),o=r(171),u=[].slice,c={},f=function(t,n,r){if(!(n in c)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";c[n]=Function("F,a","return new F("+e.join(",")+")")}return c[n](t,r)};t.exports=Function.bind||function(t){var n=e(this),r=u.call(arguments,1),c=function(){var e=r.concat(u.call(arguments));return this instanceof c?f(n,e.length,e):o(n,e,t)};return i(n.prototype)&&(c.prototype=n.prototype),c}},function(t,n,r){"use strict";var e=r(10).f,i=r(71),o=r(75),u=r(46),c=r(68),f=r(69),a=r(143),s=r(174),l=r(76),h=r(9),v=r(67).fastKey,p=r(83),d=h?"_s":"size",y=function(t,n){var r,e=v(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,n,r,a){var s=t(function(t,e){c(t,s,n,"_i"),t._t=n,t._i=i(null),t._f=void 0,t._l=void 0,t[d]=0,void 0!=e&&f(e,r,t[a],t)});return o(s.prototype,{clear:function(){for(var t=p(this,n),r=t._i,e=t._f;e;e=e.n)e.r=!0,e.p&&(e.p=e.p.n=void 0),delete r[e.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var r=p(this,n),e=y(r,t);if(e){var i=e.n,o=e.p;delete r._i[e.i],e.r=!0,o&&(o.n=i),i&&(i.p=o),r._f==e&&(r._f=i),r._l==e&&(r._l=o),r[d]--}return!!e},forEach:function(t){p(this,n);for(var r,e=u(t,arguments.length>1?arguments[1]:void 0,3);r=r?r.n:this._f;)for(e(r.v,r.k,this);r&&r.r;)r=r.p},has:function(t){return!!y(p(this,n),t)}}),h&&e(s.prototype,"size",{get:function(){return p(this,n)[d]}}),s},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=v(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,n,r){a(t,n,function(t,r){this._t=p(t,n),this._k=r,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?"keys"==n?s(0,r.k):"values"==n?s(0,r.v):s(0,[r.k,r.v]):(t._t=void 0,s(1))},r?"entries":"values",!r,!0),l(n)}}},function(t,n,r){var e=r(114),i=r(163);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var e=r(75),i=r(67).getWeak,o=r(2),u=r(5),c=r(68),f=r(69),a=r(48),s=r(25),l=r(83),h=a(5),v=a(6),p=0,d=function(t){return t._l||(t._l=new y)},y=function(){this.a=[]},g=function(t,n){return h(t.a,function(t){return t[0]===n})};y.prototype={get:function(t){var n=g(this,t);if(n)return n[1]},has:function(t){return!!g(this,t)},set:function(t,n){var r=g(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(t){var n=v(this.a,function(n){return n[0]===t});return~n&&this.a.splice(n,1),!!~n}},t.exports={getConstructor:function(t,n,r,o){var a=t(function(t,e){c(t,a,n,"_i"),t._t=n,t._i=p++,t._l=void 0,void 0!=e&&f(e,r,t[o],t)});return e(a.prototype,{delete:function(t){if(!u(t))return!1;var r=i(t);return!0===r?d(l(this,n)).delete(t):r&&s(r,this._i)&&delete r[this._i]},has:function(t){if(!u(t))return!1;var r=i(t);return!0===r?d(l(this,n)).has(t):r&&s(r,this._i)}}),a},def:function(t,n,r){var e=i(o(n),!0);return!0===e?d(t).set(n,r):e[t._i]=r,t},ufstore:d}},function(t,n,r){"use strict";function e(t,n,r,a,s,l,h,v){for(var p,d,y=s,g=0,m=!!h&&c(h,v,3);g<a;){if(g in r){if(p=m?m(r[g],g,n):r[g],d=!1,o(p)&&(d=p[f],d=void 0!==d?!!d:i(p)),d&&l>0)y=e(t,n,p,u(p.length),y,l-1)-1;else{if(y>=9007199254740991)throw TypeError();t[y]=p}y++}g++}return y}var i=r(121),o=r(5),u=r(11),c=r(46),f=r(7)("isConcatSpreadable");t.exports=e},function(t,n,r){t.exports=!r(9)&&!r(4)(function(){return 7!=Object.defineProperty(r(136)("div"),"a",{get:function(){return 7}}).a})},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(5),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var e=r(2);t.exports=function(t,n,r,i){try{return i?n(e(r)[0],r[1]):n(r)}catch(n){var o=t.return;throw void 0!==o&&e(o.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(145),i=Math.pow,o=i(2,-52),u=i(2,-23),c=i(2,127)*(2-u),f=i(2,-126),a=function(t){return t+1/o-1/o};t.exports=Math.fround||function(t){var n,r,i=Math.abs(t),s=e(t);return i<f?s*a(i/f/u)*f*u:(n=(1+u/o)*i,(r=n-(n-i))>c||r!=r?s*(1/0):s*r)}},function(t,n){t.exports=Math.log1p||function(t){return(t=+t)>-1e-8&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n){t.exports=Math.scale||function(t,n,r,e,i){return 0===arguments.length||t!=t||n!=n||r!=r||e!=e||i!=i?NaN:t===1/0||t===-1/0?t:(t-n)*(i-e)/(r-n)+e}},function(t,n,r){"use strict";var e=r(73),i=r(125),o=r(116),u=r(17),c=r(115),f=Object.assign;t.exports=!f||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=f({},t)[r]||Object.keys(f({},n)).join("")!=e})?function(t,n){for(var r=u(t),f=arguments.length,a=1,s=i.f,l=o.f;f>a;)for(var h,v=c(arguments[a++]),p=s?e(v).concat(s(v)):e(v),d=p.length,y=0;d>y;)l.call(v,h=p[y++])&&(r[h]=v[h]);return r}:f},function(t,n,r){var e=r(10),i=r(2),o=r(73);t.exports=r(9)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(32),i=r(72).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(25),i=r(32),o=r(117)(!1),u=r(149)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){var e=r(73),i=r(32),o=r(116).f;t.exports=function(t){return function(n){for(var r,u=i(n),c=e(u),f=c.length,a=0,s=[];f>a;)o.call(u,r=c[a++])&&s.push(t?[r,u[r]]:u[r]);return s}}},function(t,n,r){var e=r(72),i=r(125),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(82).trim;t.exports=1/e(r(153)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(82).trim,o=r(153),u=/^[-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=function(t){try{return{e:!1,v:t()}}catch(t){return{e:!0,v:t}}}},function(t,n,r){var e=r(2),i=r(5),o=r(147);t.exports=function(t,n){if(e(t),i(n)&&n.constructor===t)return n;var r=o.f(t);return(0,r.resolve)(n),r.promise}},function(t,n,r){var e=r(11),i=r(152),o=r(50);t.exports=function(t,n,r,u){var c=String(o(t)),f=c.length,a=void 0===r?" ":String(r),s=e(n);if(s<=f||""==a)return c;var l=s-f,h=i.call(a,Math.ceil(l/a.length));return h.length>l&&(h=h.slice(0,l)),u?h+c:c+h}},function(t,n,r){var e=r(52),i=r(11);t.exports=function(t){if(void 0===t)return 0;var n=e(t),r=i(n);if(n!==r)throw RangeError("Wrong length!");return r}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(166),i=r(83),o="Map";t.exports=r(118)(o,function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(i(this,o),t);return n&&n.v},set:function(t,n){return e.def(i(this,o),0===t?0:t,n)}},e,!0)},function(t,n,r){r(9)&&"g"!=/./g.flags&&r(10).f(RegExp.prototype,"flags",{configurable:!0,get:r(120)})},function(t,n,r){"use strict";var e=r(166),i=r(83);t.exports=r(118)("Set",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(i(this,"Set"),t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var e,i=r(48)(0),o=r(27),u=r(67),c=r(178),f=r(168),a=r(5),s=r(4),l=r(83),h="WeakMap",v=u.getWeak,p=Object.isExtensible,d=f.ufstore,y={},g=function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},m={get:function(t){if(a(t)){var n=v(t);return!0===n?d(l(this,h)).get(t):n?n[this._i]:void 0}},set:function(t,n){return f.def(l(this,h),t,n)}},b=t.exports=r(118)(h,g,m,f,!0,!0);s(function(){return 7!=(new b).set((Object.freeze||Object)(y),7).get(y)})&&(e=f.getConstructor(g,h),c(e.prototype,m),u.NEED=!0,i(["delete","has","get","set"],function(t){var n=b.prototype,r=n[t];o(n,t,function(n,i){if(a(n)&&!p(n)){this._f||(this._f=new e);var o=this._f[t](n,i);return"set"==t?this:o}return r.call(this,n,i)})}))},,,,function(t,n){"use strict";t.exports={init:function(){var t=document.querySelector("#page-nav");t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&lt; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &gt;</a>'),yiliaConfig&&yiliaConfig.open_in_new&&document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")}),yiliaConfig&&yiliaConfig.toc_hide_index&&document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"});var n=document.querySelector("#js-aboutme");n&&0!==n.length&&(n.innerHTML=n.innerText)}}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n){var r=/\/|index.html/g;return t.replace(r,"")===n.replace(r,"")}function o(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var o=t[r];i(n,o.getAttribute("href"))&&(0,l.default)(o,"active")}}function u(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}function c(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}function f(t,n,r,e,i){var o=u(t),f=c(t)-n;if(f-r<=i){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,h.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(r||f)+"px",a.style.left=o+"px",a.style.zIndex=e||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");f(t,document.body.scrollTop,-63,2,0),f(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}var l=e(r(159)),h=e((e(r(160)),r(410))),v=e(r(131)),p=e(r(198)),d=r(132);v.default.versions.mobile&&window.screen.width<800&&(o(),s()),(0,d.addLoadEvent)(function(){p.default.init()}),t.exports={}},,,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object[e](t,n,{writable:!0,configurable:!0,value:r})}if(r(409),r(204),r(207),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;var e="defineProperty";n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},function(t,n){(function(n){!function(n){"use strict";function r(t,n,r,e){var o=n&&n.prototype instanceof i?n:i,u=Object.create(o.prototype),c=new v(e||[]);return u._invoke=a(t,r,c),u}function e(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function i(){}function o(){}function u(){}function c(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function f(t){function r(n,i,o,u){var c=e(t[n],t,i);if("throw"!==c.type){var f=c.arg,a=f.value;return a&&"object"==typeof a&&m.call(a,"__await")?Promise.resolve(a.__await).then(function(t){r("next",t,o,u)},function(t){r("throw",t,o,u)}):Promise.resolve(a).then(function(t){f.value=t,o(f)},u)}u(c.arg)}"object"==typeof n.process&&n.process.domain&&(r=n.process.domain.bind(r));var i;this._invoke=function(t,n){function e(){return new Promise(function(e,i){r(t,n,e,i)})}return i=i?i.then(e,e):e()}}function a(t,n,r){var i=E;return function(o,u){if(i===P)throw new Error("Generator is already running");if(i===j){if("throw"===o)throw u;return d()}for(r.method=o,r.arg=u;;){var c=r.delegate;if(c){var f=s(c,r);if(f){if(f===F)continue;return f}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(i===E)throw i=j,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);i=P;var a=e(t,n,r);if("normal"===a.type){if(i=r.done?j:M,a.arg===F)continue;return{value:a.arg,done:r.done}}"throw"===a.type&&(i=j,r.method="throw",r.arg=a.arg)}}}function s(t,n){var r=t.iterator[n.method];if(r===y){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=y,s(t,n),"throw"===n.method))return F;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return F}var i=e(r,t.iterator,n.arg);if("throw"===i.type)return n.method="throw",n.arg=i.arg,n.delegate=null,F;var o=i.arg;return o?o.done?(n[t.resultName]=o.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=y),n.delegate=null,F):o:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,F)}function l(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function h(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function v(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(l,this),this.reset(!0)}function p(t){if(t){var n=t[x];if(n)return n.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,e=function n(){for(;++r<t.length;)if(m.call(t,r))return n.value=t[r],n.done=!1,n;return n.value=y,n.done=!0,n};return e.next=e}}return{next:d}}function d(){return{value:y,done:!0}}var y,g=Object.prototype,m=g.hasOwnProperty,b="function"==typeof Symbol?Symbol:{},x=b.iterator||"@@iterator",S=b.asyncIterator||"@@asyncIterator",w=b.toStringTag||"@@toStringTag",_="object"==typeof t,O=n.regeneratorRuntime;if(O)_&&(t.exports=O);else{(O=n.regeneratorRuntime=_?t.exports:{}).wrap=r;var E="suspendedStart",M="suspendedYield",P="executing",j="completed",F={},A={};A[x]=function(){return this};var L=Object.getPrototypeOf,N=L&&L(L(p([])));N&&N!==g&&m.call(N,x)&&(A=N);var T=u.prototype=i.prototype=Object.create(A);o.prototype=T.constructor=u,u.constructor=o,u[w]=o.displayName="GeneratorFunction",O.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===o||"GeneratorFunction"===(n.displayName||n.name))},O.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,u):(t.__proto__=u,w in t||(t[w]="GeneratorFunction")),t.prototype=Object.create(T),t},O.awrap=function(t){return{__await:t}},c(f.prototype),f.prototype[S]=function(){return this},O.AsyncIterator=f,O.async=function(t,n,e,i){var o=new f(r(t,n,e,i));return O.isGeneratorFunction(n)?o:o.next().then(function(t){return t.done?t.value:o.next()})},c(T),T[w]="Generator",T[x]=function(){return this},T.toString=function(){return"[object Generator]"},O.keys=function(t){var n=[];for(var r in t)n.push(r);return n.reverse(),function r(){for(;n.length;){var e=n.pop();if(e in t)return r.value=e,r.done=!1,r}return r.done=!0,r}},O.values=p,v.prototype={constructor:v,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=y,this.done=!1,this.delegate=null,this.method="next",this.arg=y,this.tryEntries.forEach(h),!t)for(var n in this)"t"===n.charAt(0)&&m.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=y)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){function n(n,e){return o.type="throw",o.arg=t,r.next=n,e&&(r.method="next",r.arg=y),!!e}if(this.done)throw t;for(var r=this,e=this.tryEntries.length-1;e>=0;--e){var i=this.tryEntries[e],o=i.completion;if("root"===i.tryLoc)return n("end");if(i.tryLoc<=this.prev){var u=m.call(i,"catchLoc"),c=m.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return n(i.catchLoc,!0);if(this.prev<i.finallyLoc)return n(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return n(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return n(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&m.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,F):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),F},finish:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),h(r),F}},catch:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;h(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:p(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=y),F}}}}("object"==typeof n?n:"object"==typeof window?window:"object"==typeof self?self:this)}).call(n,function(){return this}())},,,function(t,n,r){r(217),t.exports=r(49).RegExp.escape},,,,function(t,n,r){var e=r(5),i=r(121),o=r(7)("species");t.exports=function(t){var n;return i(t)&&("function"!=typeof(n=t.constructor)||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&null===(n=n[o])&&(n=void 0)),void 0===n?Array:n}},function(t,n,r){"use strict";var e=r(4),i=Date.prototype.getTime,o=Date.prototype.toISOString,u=function(t){return t>9?t:"0"+t};t.exports=e(function(){return"0385-07-25T07:06:39.999Z"!=o.call(new Date(-5e13-1))})||!e(function(){o.call(new Date(NaN))})?function(){if(!isFinite(i.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":n>9999?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(r>99?r:"0"+u(r))+"Z"}:o},function(t,n,r){"use strict";var e=r(2),i=r(53),o="number";t.exports=function(t){if("string"!==t&&t!==o&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),t!=o)}},function(t,n,r){var e=r(73),i=r(125),o=r(116);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n){t.exports=function(t,n){var r=n===Object(n)?function(t){return n[t]}:n;return function(n){return String(n).replace(t,r)}}},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var e=r(1),i=r(215)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(162)}),r(66)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(48)(4);e(e.P+e.F*!r(47)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(133)}),r(66)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(48)(2);e(e.P+e.F*!r(47)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(66)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(66)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(0),o=r(47)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(46),i=r(1),o=r(17),u=r(173),c=r(141),f=r(11),a=r(135),s=r(157);i(i.S+i.F*!r(123)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,i,l,h=o(t),v="function"==typeof this?this:Array,p=arguments.length,d=p>1?arguments[1]:void 0,y=void 0!==d,g=0,m=s(h);if(y&&(d=e(d,p>2?arguments[2]:void 0,2)),void 0==m||v==Array&&c(m))for(n=f(h.length),r=new v(n);n>g;g++)a(r,g,y?d(h[g],g):h[g]);else for(l=m.call(h),r=new v;!(i=l.next()).done;g++)a(r,g,y?u(l,d,[i.value,g],!0):i.value);return r.length=g,r}})},function(t,n,r){"use strict";var e=r(1),i=r(117)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(47)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(121)})},function(t,n,r){"use strict";var e=r(1),i=r(32),o=[].join;e(e.P+e.F*(r(115)!=Object||!r(47)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(32),o=r(52),u=r(11),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(47)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(arguments.length>1&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);e>=0;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(1);e(e.P+e.F*!r(47)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(135);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);n>t;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(164);e(e.P+e.F*!r(47)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(164);e(e.P+e.F*!r(47)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(139),o=r(45),u=r(77),c=r(11),f=[].slice;e(e.P+e.F*r(4)(function(){i&&f.call(i)}),"Array",{slice:function(t,n){var r=c(this.length),e=o(this);if(n=void 0===n?r:n,"Array"==e)return f.call(this,t,n);for(var i=u(t,r),a=u(n,r),s=c(a-i),l=Array(s),h=0;h<s;h++)l[h]="String"==e?this.charAt(i+h):this[i+h];return l}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(3);e(e.P+e.F*!r(47)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(19),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(47)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(76)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){var e=r(1),i=r(212);e(e.P+e.F*(Date.prototype.toISOString!==i),"Date",{toISOString:i})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(53);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(26)(i,e,r(213))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(27)(e,o,function(){var t=c.call(this);return t===t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(165)})},function(t,n,r){"use strict";var e=r(5),i=r(31),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(10).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(10).f,i=Function.prototype,o=/^\s*function ([^ (]*)/,u="name";u in i||r(9)&&e(i,u,{configurable:!0,get:function(){try{return(""+this).match(o)[1]}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(176),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:t>94906265.62425156?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){function e(t){return isFinite(t=+t)&&0!=t?t<0?-e(-t):Math.log(t+Math.sqrt(t*t+1)):t}var i=r(1),o=Math.asinh;i(i.S+i.F*!(o&&1/o(0)>0),"Math",{asinh:e})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(145);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(144);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1);e(e.S,"Math",{fround:r(175)})},function(t,n,r){var e=r(1),i=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,o=0,u=0,c=arguments.length,f=0;u<c;)r=i(arguments[u++]),f<r?(e=f/r,o=o*e*e+1,f=r):r>0?(e=r/f,o+=e*e):o+=r;return f===1/0?1/0:f*Math.sqrt(o)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)*Math.LOG10E}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(176)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(145)})},function(t,n,r){var e=r(1),i=r(144),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(144),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(t>0?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(25),o=r(45),u=r(140),c=r(53),f=r(4),a=r(72).f,s=r(30).f,l=r(10).f,h=r(82).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(71)(y))==v,m="trim"in String.prototype,b=function(t){var n=c(t,!1);if("string"==typeof n&&n.length>2){var r,e,i,o=(n=m?n.trim():h(n,3)).charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,f=n.slice(2),a=0,s=f.length;a<s;a++)if((u=f.charCodeAt(a))<48||u>i)return NaN;return parseInt(f,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?f(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(b(n)),r,p):b(n)};for(var x,S=r(9)?a(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),w=0;S.length>w;w++)i(d,x=S[w])&&!i(p,x)&&l(p,x,s(d,x));p.prototype=y,y.constructor=p,r(27)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(172)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(172),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(184);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(185);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),i=r(52),o=r(161),u=r(152),c=1..toFixed,f=Math.floor,a=[0,0,0,0,0,0],s="Number.toFixed: incorrect invocation!",l="0",h=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*a[r],a[r]=e%1e7,e=f(e/1e7)},v=function(t){for(var n=6,r=0;--n>=0;)r+=a[n],a[n]=f(r/t),r=r%t*1e7},p=function(){for(var t=6,n="";--t>=0;)if(""!==n||0===t||0!==a[t]){var r=String(a[t]);n=""===n?r:n+u.call(l,7-r.length)+r}return n},d=function(t,n,r){return 0===n?r:n%2==1?d(t,n-1,r*t):d(t*t,n/2,r)},y=function(t){for(var n=0,r=t;r>=4096;)n+=12,r/=4096;for(;r>=2;)n+=1,r/=2;return n};e(e.P+e.F*(!!c&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){c.call({})})),"Number",{toFixed:function(t){var n,r,e,c,f=o(this,s),a=i(t),g="",m=l;if(a<0||a>20)throw RangeError(s);if(f!=f)return"NaN";if(f<=-1e21||f>=1e21)return String(f);if(f<0&&(g="-",f=-f),f>1e-21)if(n=y(f*d(2,69,1))-69,r=n<0?f*d(2,-n,1):f/d(2,n,1),r*=4503599627370496,(n=52-n)>0){for(h(0,r),e=a;e>=7;)h(1e7,0),e-=7;for(h(d(10,e,1),0),e=n-1;e>=23;)v(1<<23),e-=23;v(1<<e),h(1,1),v(2),m=p()}else h(0,r),h(1<<-n,0),m=p()+u.call(l,a);return a>0?(c=m.length,m=g+(c<=a?"0."+u.call(l,a-c)+m:m.slice(0,c-a)+"."+m.slice(c-a))):m=g+m,m}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(161),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(178)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(71)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(9),"Object",{defineProperties:r(179)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(9),"Object",{defineProperty:r(10).f})},function(t,n,r){var e=r(5),i=r(67).onFreeze;r(51)("freeze",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(32),i=r(30).f;r(51)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(51)("getOwnPropertyNames",function(){return r(180).f})},function(t,n,r){var e=r(17),i=r(31);r(51)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(5);r(51)("isExtensible",function(t){return function(n){return!!e(n)&&(!t||t(n))}})},function(t,n,r){var e=r(5);r(51)("isFrozen",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(5);r(51)("isSealed",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(216)})},function(t,n,r){var e=r(17),i=r(73);r(51)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(5),i=r(67).onFreeze;r(51)("preventExtensions",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(5),i=r(67).onFreeze;r(51)("seal",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(148).set})},function(t,n,r){"use strict";var e=r(114),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(27)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(184);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(185);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u,c=r(70),f=r(3),a=r(46),s=r(114),l=r(1),h=r(5),v=r(19),p=r(68),d=r(69),y=r(129),g=r(154).set,m=r(146)(),b=r(147),x=r(186),S=r(187),w="Promise",_=f.TypeError,O=f.process,E=f[w],M="process"==s(O),P=function(){},j=i=b.f,F=!!function(){try{var t=E.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(P,P)};return(M||"function"==typeof PromiseRejectionEvent)&&t.then(P)instanceof n}catch(t){}}(),A=function(t){var n;return!(!h(t)||"function"!=typeof(n=t.then))&&n},L=function(t,n){if(!t._n){t._n=!0;var r=t._c;m(function(){for(var e=t._v,i=1==t._s,o=0;r.length>o;)!function(n){var r,o,u=i?n.ok:n.fail,c=n.resolve,f=n.reject,a=n.domain;try{u?(i||(2==t._h&&I(t),t._h=1),!0===u?r=e:(a&&a.enter(),r=u(e),a&&a.exit()),r===n.promise?f(_("Promise-chain cycle")):(o=A(r))?o.call(r,c,f):c(r)):f(e)}catch(t){f(t)}}(r[o++]);t._c=[],t._n=!1,n&&!t._h&&N(t)})}},N=function(t){g.call(f,function(){var n,r,e,i=t._v,o=T(t);if(o&&(n=x(function(){M?O.emit("unhandledRejection",i,t):(r=f.onunhandledrejection)?r({promise:t,reason:i}):(e=f.console)&&e.error&&e.error("Unhandled promise rejection",i)}),t._h=M||T(t)?2:1),t._a=void 0,o&&n.e)throw n.v})},T=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if((n=r[e++]).fail||!T(n.promise))return!1;return!0},I=function(t){g.call(f,function(){var n;M?O.emit("rejectionHandled",t):(n=f.onrejectionhandled)&&n({promise:t,reason:t._v})})},k=function(t){var n=this;n._d||(n._d=!0,n=n._w||n,n._v=t,n._s=2,n._a||(n._a=n._c.slice()),L(n,!0))},R=function(t){var n,r=this;if(!r._d){r._d=!0,r=r._w||r;try{if(r===t)throw _("Promise can't be resolved itself");(n=A(t))?m(function(){var e={_w:r,_d:!1};try{n.call(t,a(R,e,1),a(k,e,1))}catch(t){k.call(e,t)}}):(r._v=t,r._s=1,L(r,!1))}catch(t){k.call({_w:r,_d:!1},t)}}};F||(E=function(t){p(this,E,w,"_h"),v(t),e.call(this);try{t(a(R,this,1),a(k,this,1))}catch(t){k.call(this,t)}},e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},e.prototype=r(75)(E.prototype,{then:function(t,n){var r=j(y(this,E));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=M?O.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&L(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),o=function(){var t=new e;this.promise=t,this.resolve=a(R,t,1),this.reject=a(k,t,1)},b.f=j=function(t){return t===E||t===u?new o(t):i(t)}),l(l.G+l.W+l.F*!F,{Promise:E}),r(81)(E,w),r(76)(w),u=r(49)[w],l(l.S+l.F*!F,w,{reject:function(t){var n=j(this);return(0,n.reject)(t),n.promise}}),l(l.S+l.F*(c||!F),w,{resolve:function(t){return S(c&&this===u?E:this,t)}}),l(l.S+l.F*!(F&&r(123)(function(t){E.all(t).catch(P)})),w,{all:function(t){var n=this,r=j(n),e=r.resolve,i=r.reject,o=x(function(){var r=[],o=0,u=1;d(t,!1,function(t){var c=o++,f=!1;r.push(void 0),u++,n.resolve(t).then(function(t){f||(f=!0,r[c]=t,--u||e(r))},i)}),--u||e(r)});return o.e&&i(o.v),r.promise},race:function(t){var n=this,r=j(n),e=r.reject,i=x(function(){d(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i.e&&e(i.v),r.promise}})},function(t,n,r){var e=r(1),i=r(19),o=r(2),u=(r(3).Reflect||{}).apply,c=Function.apply;e(e.S+e.F*!r(4)(function(){u(function(){})}),"Reflect",{apply:function(t,n,r){var e=i(t),f=o(r);return u?u(e,n,f):c.call(e,n,f)}})},function(t,n,r){var e=r(1),i=r(71),o=r(19),u=r(2),c=r(5),f=r(4),a=r(165),s=(r(3).Reflect||{}).construct,l=f(function(){function t(){}return!(s(function(){},[],t)instanceof t)}),h=!f(function(){s(function(){})});e(e.S+e.F*(l||h),"Reflect",{construct:function(t,n){o(t),u(n);var r=arguments.length<3?t:o(arguments[2]);if(h&&!l)return s(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(a.apply(t,e))}var f=r.prototype,v=i(c(f)?f:Object.prototype),p=Function.apply.call(t,v,n);return c(p)?p:v}})},function(t,n,r){var e=r(10),i=r(1),o=r(2),u=r(53);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(30).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(142)(o,"Object",function(){var t,n=this,r=n._k;do{if(n._i>=r.length)return{value:void 0,done:!0}}while(!((t=r[n._i++])in n._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(30),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(31),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){function e(t,n){var r,c,s=arguments.length<3?t:arguments[2];return a(t)===s?t[n]:(r=i.f(t,n))?u(r,"value")?r.value:void 0!==r.get?r.get.call(s):void 0:f(c=o(t))?e(c,n,s):void 0}var i=r(30),o=r(31),u=r(25),c=r(1),f=r(5),a=r(2);c(c.S,"Reflect",{get:e})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(183)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(148);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){function e(t,n,r){var f,h,v=arguments.length<4?t:arguments[3],p=o.f(s(t),n);if(!p){if(l(h=u(t)))return e(h,n,r,v);p=a(0)}return c(p,"value")?!(!1===p.writable||!l(v)||(f=o.f(v,n)||a(0),f.value=r,i.f(v,n,f),0)):void 0!==p.set&&(p.set.call(v,r),!0)}var i=r(10),o=r(30),u=r(31),c=r(25),f=r(1),a=r(74),s=r(2),l=r(5);f(f.S,"Reflect",{set:e})},function(t,n,r){var e=r(3),i=r(140),o=r(10).f,u=r(72).f,c=r(122),f=r(120),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(9)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),o=void 0===n;return!r&&e&&t.constructor===a&&o?t:i(p?new s(e&&!o?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&o?f.call(t):n),r?this:l,a)};for(var d=u(s),y=0;d.length>y;)!function(t){t in a||o(a,t,{configurable:!0,get:function(){return s[t]},set:function(n){s[t]=n}})}(d[y++]);l.constructor=a,a.prototype=l,r(27)(e,"RegExp",a)}r(76)("RegExp")},function(t,n,r){r(119)("match",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("replace",2,function(t,n,r){return[function(e,i){"use strict";var o=t(this),u=void 0==e?void 0:e[n];return void 0!==u?u.call(e,o,i):r.call(String(o),e,i)},r]})},function(t,n,r){r(119)("search",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("split",2,function(t,n,e){"use strict";var i=r(122),o=e,u=[].push,c="split",f="length",a="lastIndex";if("c"=="abbc"[c](/(b)*/)[1]||4!="test"[c](/(?:)/,-1)[f]||2!="ab"[c](/(?:ab)*/)[f]||4!="."[c](/(.?)(.?)/)[f]||"."[c](/()()/)[f]>1||""[c](/.?/)[f]){var s=void 0===/()??/.exec("")[1];e=function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!i(t))return o.call(r,t,n);var e,c,l,h,v,p=[],d=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),y=0,g=void 0===n?4294967295:n>>>0,m=new RegExp(t.source,d+"g");for(s||(e=new RegExp("^"+m.source+"$(?!\\s)",d));(c=m.exec(r))&&!((l=c.index+c[0][f])>y&&(p.push(r.slice(y,c.index)),!s&&c[f]>1&&c[0].replace(e,function(){for(v=1;v<arguments[f]-2;v++)void 0===arguments[v]&&(c[v]=void 0)}),c[f]>1&&c.index<r[f]&&u.apply(p,c.slice(1)),h=c[0][f],y=l,p[f]>=g));)m[a]===c.index&&m[a]++;return y===r[f]?!h&&m.test("")||p.push(""):p.push(r.slice(y)),p[f]>g?p.slice(0,g):p}}else"0"[c](void 0,0)[f]&&(e=function(t,n){return void 0===t&&0===n?[]:o.call(this,t,n)});return[function(r,i){var o=t(this),u=void 0==r?void 0:r[n];return void 0!==u?u.call(r,o,i):e.call(String(o),r,i)},e]})},function(t,n,r){"use strict";r(192);var e=r(2),i=r(120),o=r(9),u="toString",c=/./[u],f=function(t){r(27)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(28)("anchor",function(t){return function(n){return t(this,"a","name",n)}})},function(t,n,r){"use strict";r(28)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(28)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(28)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(150)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(11),o=r(151),u="endsWith",c=""[u];e(e.P+e.F*r(138)(u),"String",{endsWith:function(t){var n=o(this,t,u),r=arguments.length>1?arguments[1]:void 0,e=i(n.length),f=void 0===r?e:Math.min(i(r),e),a=String(t);return c?c.call(n,a,f):n.slice(f-a.length,f)===a}})},function(t,n,r){"use strict";r(28)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(28)("fontcolor",function(t){return function(n){return t(this,"font","color",n)}})},function(t,n,r){"use strict";r(28)("fontsize",function(t){return function(n){return t(this,"font","size",n)}})},function(t,n,r){var e=r(1),i=r(77),o=String.fromCharCode,u=String.fromCodePoint;e(e.S+e.F*(!!u&&1!=u.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,u=0;e>u;){if(n=+arguments[u++],i(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?o(n):o(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(151),o="includes";e(e.P+e.F*r(138)(o),"String",{includes:function(t){return!!~i(this,t,o).indexOf(t,arguments.length>1?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(28)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(150)(!0);r(143)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(28)("link",function(t){return function(n){return t(this,"a","href",n)}})},function(t,n,r){var e=r(1),i=r(32),o=r(11);e(e.S,"String",{raw:function(t){for(var n=i(t.raw),r=o(n.length),e=arguments.length,u=[],c=0;r>c;)u.push(String(n[c++])),c<e&&u.push(String(arguments[c]));return u.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(152)})},function(t,n,r){"use strict";r(28)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(11),o=r(151),u="startsWith",c=""[u];e(e.P+e.F*r(138)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(arguments.length>1?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(28)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(28)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(28)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(82)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),i=r(25),o=r(9),u=r(1),c=r(27),f=r(67).KEY,a=r(4),s=r(128),l=r(81),h=r(78),v=r(7),p=r(190),d=r(156),y=r(214),g=r(121),m=r(2),b=r(32),x=r(53),S=r(74),w=r(71),_=r(180),O=r(30),E=r(10),M=r(73),P=O.f,j=E.f,F=_.f,A=e.Symbol,L=e.JSON,N=L&&L.stringify,T="prototype",I=v("_hidden"),k=v("toPrimitive"),R={}.propertyIsEnumerable,C=s("symbol-registry"),D=s("symbols"),G=s("op-symbols"),W=Object[T],U="function"==typeof A,V=e.QObject,B=!V||!V[T]||!V[T].findChild,q=o&&a(function(){return 7!=w(j({},"a",{get:function(){return j(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=P(W,n);e&&delete W[n],j(t,n,r),e&&t!==W&&j(W,n,e)}:j,z=function(t){var n=D[t]=w(A[T]);return n._k=t,n},H=U&&"symbol"==typeof A.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof A},K=function(t,n,r){return t===W&&K(G,n,r),m(t),n=x(n,!0),m(r),i(D,n)?(r.enumerable?(i(t,I)&&t[I][n]&&(t[I][n]=!1),r=w(r,{enumerable:S(0,!1)})):(i(t,I)||j(t,I,S(1,{})),t[I][n]=!0),q(t,n,r)):j(t,n,r)},J=function(t,n){m(t);for(var r,e=y(n=b(n)),i=0,o=e.length;o>i;)K(t,r=e[i++],n[r]);return t},Y=function(t){var n=R.call(this,t=x(t,!0));return!(this===W&&i(D,t)&&!i(G,t))&&(!(n||!i(this,t)||!i(D,t)||i(this,I)&&this[I][t])||n)},$=function(t,n){if(t=b(t),n=x(n,!0),t!==W||!i(D,n)||i(G,n)){var r=P(t,n);return!r||!i(D,n)||i(t,I)&&t[I][n]||(r.enumerable=!0),r}},X=function(t){for(var n,r=F(b(t)),e=[],o=0;r.length>o;)i(D,n=r[o++])||n==I||n==f||e.push(n);return e},Q=function(t){for(var n,r=t===W,e=F(r?G:b(t)),o=[],u=0;e.length>u;)!i(D,n=e[u++])||r&&!i(W,n)||o.push(D[n]);return o};U||(A=function(){if(this instanceof A)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===W&&n.call(G,r),i(this,I)&&i(this[I],t)&&(this[I][t]=!1),q(this,t,S(1,r))};return o&&B&&q(W,t,{configurable:!0,set:n}),z(t)},c(A[T],"toString",function(){return this._k}),O.f=$,E.f=K,r(72).f=_.f=X,r(116).f=Y,r(125).f=Q,o&&!r(70)&&c(W,"propertyIsEnumerable",Y,!0),p.f=function(t){return z(v(t))}),u(u.G+u.W+u.F*!U,{Symbol:A});for(var Z="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),tt=0;Z.length>tt;)v(Z[tt++]);for(var nt=M(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!U,"Symbol",{for:function(t){return i(C,t+="")?C[t]:C[t]=A(t)},keyFor:function(t){if(!H(t))throw TypeError(t+" is not a symbol!");for(var n in C)if(C[n]===t)return n},useSetter:function(){B=!0},useSimple:function(){B=!1}}),u(u.S+u.F*!U,"Object",{create:function(t,n){return void 0===n?w(t):J(w(t),n)},defineProperty:K,defineProperties:J,getOwnPropertyDescriptor:$,getOwnPropertyNames:X,getOwnPropertySymbols:Q}),L&&u(u.S+u.F*(!U||a(function(){var t=A();return"[null]"!=N([t])||"{}"!=N({a:t})||"{}"!=N(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!H(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return"function"==typeof(n=e[1])&&(r=n),!r&&g(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!H(n))return n}),e[1]=n,N.apply(L,e)}}}),A[T][k]||r(26)(A[T],k,A[T].valueOf),l(A,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(130),o=r(155),u=r(2),c=r(77),f=r(11),a=r(5),s=r(3).ArrayBuffer,l=r(129),h=o.ArrayBuffer,v=o.DataView,p=i.ABV&&s.isView,d=h.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(s!==h),{ArrayBuffer:h}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return p&&p(t)||a(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new h(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(u(this),t);for(var r=u(this).byteLength,e=c(t,r),i=c(void 0===n?r:n,r),o=new(l(this,h))(f(i-e)),a=new v(this),s=new v(o),p=0;e<i;)s.setUint8(p++,a.getUint8(e++));return o}}),r(76)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(130).ABV,{DataView:r(155).DataView})},function(t,n,r){r(56)("Float32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(56)("Float64",8,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(56)("Int16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(56)("Int32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(56)("Int8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(56)("Uint16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(56)("Uint32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(56)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(56)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}},!0)},function(t,n,r){"use strict";var e=r(168),i=r(83),o="WeakSet";r(118)(o,function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(i(this,o),t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(169),o=r(17),u=r(11),c=r(19),f=r(134);e(e.P,"Array",{flatMap:function(t){var n,r,e=o(this);return c(t),n=u(e.length),r=f(e,0),i(r,e,e,n,0,1,t,arguments[1]),r}}),r(66)("flatMap")},function(t,n,r){"use strict";var e=r(1),i=r(169),o=r(17),u=r(11),c=r(52),f=r(134);e(e.P,"Array",{flatten:function(){var t=arguments[0],n=o(this),r=u(n.length),e=f(n,0);return i(e,n,n,r,0,void 0===t?1:c(t)),e}}),r(66)("flatten")},function(t,n,r){"use strict";var e=r(1),i=r(117)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(66)("includes")},function(t,n,r){var e=r(1),i=r(146)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.G,{global:r(3)})},function(t,n,r){r(126)("Map")},function(t,n,r){r(127)("Map")},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(167)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{clamp:function(t,n,r){return Math.min(r,Math.max(n,t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{DEG_PER_RAD:Math.PI/180})},function(t,n,r){var e=r(1),i=180/Math.PI;e(e.S,"Math",{degrees:function(t){return t*i}})},function(t,n,r){var e=r(1),i=r(177),o=r(175);e(e.S,"Math",{fscale:function(t,n,r,e,u){return o(i(t,n,r,e,u))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=r>>>0;return(n>>>0)+(e>>>0)+((i&o|(i|o)&~(i+o>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>16,f=i>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>16)+((o*f>>>0)+(a&r)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=r>>>0;return(n>>>0)-(e>>>0)-((~i&o|~(i^o)&i-o>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{RAD_PER_DEG:180/Math.PI})},function(t,n,r){var e=r(1),i=Math.PI/180;e(e.S,"Math",{radians:function(t){return t*i}})},function(t,n,r){var e=r(1);e(e.S,"Math",{scale:r(177)})},function(t,n,r){var e=r(1);e(e.S,"Math",{signbit:function(t){return(t=+t)!=t?t:0==t?1/t==1/0:t>0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>>16,f=i>>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>>16)+((o*f>>>0)+(a&r)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(19),u=r(10);r(9)&&e(e.P+r(124),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(19),u=r(10);r(9)&&e(e.P+r(124),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(182)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),i=r(183),o=r(32),u=r(30),c=r(135);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r,e=o(t),f=u.f,a=i(e),s={},l=0;a.length>l;)void 0!==(r=f(e,n=a[l++]))&&c(s,n,r);return s}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(53),u=r(31),c=r(30).f;r(9)&&e(e.P+r(124),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(53),u=r(31),c=r(30).f;r(9)&&e(e.P+r(124),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(182)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),i=r(3),o=r(49),u=r(146)(),c=r(7)("observable"),f=r(19),a=r(2),s=r(68),l=r(75),h=r(26),v=r(69),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},m=function(t){g(t)||(t._o=void 0,y(t))},b=function(t,n){a(t),this._c=void 0,this._o=t,t=new x(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};b.prototype=l({},{unsubscribe:function(){m(this)}});var x=function(t){this._s=t};x.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{m(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var S=function(t){s(this,S,"Observable","_f")._f=f(t)};l(S.prototype,{subscribe:function(t){return new b(t,this._f)},forEach:function(t){var n=this;return new(o.Promise||i.Promise)(function(r,e){f(t);var i=n.subscribe({next:function(n){try{return t(n)}catch(t){e(t),i.unsubscribe()}},error:e,complete:r})})}}),l(S,{from:function(t){var n="function"==typeof this?this:S,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return u(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,r=Array(n);t<n;)r[t]=arguments[t++];return new("function"==typeof this?this:S)(function(t){var n=!1;return u(function(){if(!n){for(var e=0;e<r.length;++e)if(t.next(r[e]),n)return;t.complete()}}),function(){n=!0}})}}),h(S.prototype,c,function(){return this}),e(e.G,{Observable:S}),r(76)("Observable")},function(t,n,r){"use strict";var e=r(1),i=r(49),o=r(3),u=r(129),c=r(187);e(e.P+e.R,"Promise",{finally:function(t){var n=u(this,i.Promise||o.Promise),r="function"==typeof t;return this.then(r?function(r){return c(n,t()).then(function(){return r})}:t,r?function(r){return c(n,t()).then(function(){throw r})}:t)}})},function(t,n,r){"use strict";var e=r(1),i=r(147),o=r(186);e(e.S,"Promise",{try:function(t){var n=i.f(this),r=o(t);return(r.e?n.reject:n.resolve)(r.v),n.promise}})},function(t,n,r){var e=r(55),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(55),i=r(2),o=e.key,u=e.map,c=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:o(arguments[2]),e=u(i(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var f=c.get(n);return f.delete(r),!!f.size||c.delete(n)}})},function(t,n,r){var e=r(193),i=r(163),o=r(55),u=r(2),c=r(31),f=o.keys,a=o.key,s=function(t,n){var r=f(t,n),o=c(t);if(null===o)return r;var u=s(o,n);return u.length?r.length?i(new e(r.concat(u))):u:r};o.exp({getMetadataKeys:function(t){return s(u(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(55),i=r(2),o=r(31),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(55),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(55),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(55),i=r(2),o=r(31),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(55),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(55),i=r(2),o=r(19),u=e.key,c=e.set;e.exp({metadata:function(t,n){return function(r,e){c(t,n,(void 0!==e?i:o)(r),u(e))}}})},function(t,n,r){r(126)("Set")},function(t,n,r){r(127)("Set")},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(167)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(150)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(50),o=r(11),u=r(122),c=r(120),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(142)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(188);e(e.P,"String",{padEnd:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(188);e(e.P,"String",{padStart:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(82)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(82)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(156)("asyncIterator")},function(t,n,r){r(156)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){r(126)("WeakMap")},function(t,n,r){r(127)("WeakMap")},function(t,n,r){r(126)("WeakSet")},function(t,n,r){r(127)("WeakSet")},function(t,n,r){for(var e=r(158),i=r(73),o=r(27),u=r(3),c=r(26),f=r(80),a=r(7),s=a("iterator"),l=a("toStringTag"),h=f.Array,v={CSSRuleList:!0,CSSStyleDeclaration:!1,CSSValueList:!1,ClientRectList:!1,DOMRectList:!1,DOMStringList:!1,DOMTokenList:!0,DataTransferItemList:!1,FileList:!1,HTMLAllCollection:!1,HTMLCollection:!1,HTMLFormElement:!1,HTMLSelectElement:!1,MediaList:!0,MimeTypeArray:!1,NamedNodeMap:!1,NodeList:!0,PaintRequestList:!1,Plugin:!1,PluginArray:!1,SVGLengthList:!1,SVGNumberList:!1,SVGPathSegList:!1,SVGPointList:!1,SVGStringList:!1,SVGTransformList:!1,SourceBufferList:!1,StyleSheetList:!0,TextTrackCueList:!1,TextTrackList:!1,TouchList:!1},p=i(v),d=0;d<p.length;d++){var y,g=p[d],m=v[g],b=u[g],x=b&&b.prototype;if(x&&(x[s]||c(x,s,h),x[l]||c(x,l,g),f[g]=h,m))for(y in e)x[y]||o(x,y,e[y],!0)}},function(t,n,r){var e=r(1),i=r(154);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=e.navigator,u=[].slice,c=!!o&&/MSIE .\./.test(o.userAgent),f=function(t){return function(n,r){var e=arguments.length>2,i=!!e&&u.call(arguments,2);return t(e?function(){("function"==typeof n?n:Function(n)).apply(this,i)}:n,r)}};i(i.G+i.B+i.F*c,{setTimeout:f(e.setTimeout),setInterval:f(e.setInterval)})},function(t,n,r){r(337),r(276),r(278),r(277),r(280),r(282),r(287),r(281),r(279),r(289),r(288),r(284),r(285),r(283),r(275),r(286),r(290),r(291),r(243),r(245),r(244),r(293),r(292),r(263),r(273),r(274),r(264),r(265),r(266),r(267),r(268),r(269),r(270),r(271),r(272),r(246),r(247),r(248),r(249),r(250),r(251),r(252),r(253),r(254),r(255),r(256),r(257),r(258),r(259),r(260),r(261),r(262),r(324),r(329),r(336),r(327),r(319),r(320),r(325),r(330),r(332),r(315),r(316),r(317),r(318),r(321),r(322),r(323),r(326),r(328),r(331),r(333),r(334),r(335),r(238),r(240),r(239),r(242),r(241),r(227),r(225),r(231),r(228),r(234),r(236),r(224),r(230),r(221),r(235),r(219),r(233),r(232),r(226),r(229),r(218),r(220),r(223),r(222),r(237),r(158),r(309),r(314),r(192),r(310),r(311),r(312),r(313),r(294),r(191),r(193),r(194),r(349),r(338),r(339),r(344),r(347),r(348),r(342),r(345),r(343),r(346),r(340),r(341),r(295),r(296),r(297),r(298),r(299),r(302),r(300),r(301),r(303),r(304),r(305),r(306),r(308),r(307),r(352),r(350),r(351),r(393),r(396),r(395),r(397),r(398),r(394),r(399),r(400),r(374),r(377),r(373),r(371),r(372),r(375),r(376),r(358),r(392),r(357),r(391),r(403),r(405),r(356),r(390),r(402),r(404),r(355),r(401),r(354),r(359),r(360),r(361),r(362),r(363),r(365),r(364),r(366),r(367),r(368),r(370),r(369),r(379),r(380),r(381),r(382),r(384),r(383),r(386),r(385),r(387),r(388),r(389),r(353),r(378),r(408),r(407),r(406),t.exports=r(49)},function(t,n){t.exports=function(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}}])</script><script src="/./main.e8862b.js"></script><script>!function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}("/slider.5b7e29.js")</script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">All articles</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">Friends</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">About me</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Algorithm</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">C++</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">DS</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">Android</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Tech</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">ML</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">DL</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">English</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Essay</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">git</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">hexo</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">golang</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">HTML</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Javascript</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">CSS</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">js</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">html</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Java</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Redis</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">MYSQL</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">Spring</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">linux</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">papers</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">RL</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">k8s</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="https://leetcode-cn.com/u/louris/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>我的力扣</a>
            </li>
          
            <li class="search-li">
              <a href="https://www.six1110.top/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>饭勺</a>
            </li>
          
            <li class="search-li">
              <a href="https://www.zjcheng.site/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>中建</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">做一个安静细微的人，&lt;br&gt; 于角落里自在开放，&lt;br&gt; 默默悦人，&lt;br&gt; 却始终不引起过分热闹的关注，&lt;br&gt; 保有独立而随意的品格，&lt;br&gt; 这就很好。&lt;br&gt;&lt;br&gt; Stick to what you insist on,&lt;br&gt; believe what you believe!&lt;br&gt; Life hastily for decades,&lt;br&gt; do what I can!</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":1},"log":false});</script></body>
</html>