<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="renderer" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link rel="dns-prefetch" href="https://lourisxu.github.io"><title>算法笔记 | Louris&#39; Blog</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="简单模拟 【PAT B1001】害死人不偿命的（3n+1）猜想卡拉兹(Callatz)猜想：对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去，最后一定在某一步得到n&#x3D;1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证(3n+1)，以"><meta property="og:type" content="article"><meta property="og:title" content="算法笔记"><meta property="og:url" content="https://lourisxu.github.io/2019/02/17/algorithm-note.html/index.html"><meta property="og:site_name" content="Louris&#39; Blog"><meta property="og:description" content="简单模拟 【PAT B1001】害死人不偿命的（3n+1）猜想卡拉兹(Callatz)猜想：对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去，最后一定在某一步得到n&#x3D;1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证(3n+1)，以"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/Jungle_Roads_01.jpg"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/CriticalPath_01.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/CriticalPath_02.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/tree_traverse_01.jpg"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/KMP_01.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/Palindrome_01.jpg"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/Trie.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/monotonous_stack_01.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/332_fig1.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/332_fig2.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/skiplist.png"><meta property="article:published_time" content="2019-02-17T12:13:45.000Z"><meta property="article:modified_time" content="2024-01-19T02:20:51.958Z"><meta property="article:author" content="Louris"><meta property="article:tag" content="Algorithm"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://lourisxu.github.io/assets/img/algorithm/Jungle_Roads_01.jpg"><link rel="alternative" href="/atom.xml" title="Louris&#39; Blog" type="application/atom+xml"><link rel="icon" href="/assets/img/blog/favicon.png"><link rel="stylesheet" href="/./main.e8862b.css"><style>#container.show{background:linear-gradient(200deg,#a0cfe4,#e8c37e)}</style><meta name="generator" content="Hexo 4.2.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><body><div id="container" q-class="show:isCtnShow"><canvas id="anm-canvas" class="anm-canvas"></canvas><div class="left-col" q-class="show:isShow"><div class="overlay" style="background:#00bfff"></div><div class="intrude-less"><header id="header" class="inner"> <a href="/" class="profilepic"><img src="/assets/img/blog/userpic.jpg" class="js-avatar"></a><hgroup><h1 class="header-author"><a href="/">Louris</a></h1></hgroup><p class="header-subtitle">Do what I can</p><nav class="header-menu"><ul><li><a href="/">Home</a></li><li><a href="/categories/DS/">DS</a></li><li><a href="/tags/ML/">ML&amp;DL</a></li><li><a href="/tags/Tech/">Tech</a></li><li><a href="/tags/Algorithm/">Algorithm</a></li></ul></nav><nav class="header-smart-menu"> <a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">All articles</a> <a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">Friends</a> <a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">About me</a></nav><nav><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="230" height="86" src="//music.163.com/outchain/player?type=2&id=2080322&auto=1&height=66"></iframe></nav><nav class="header-nav"><div class="social"><a class="github" target="_blank" href="https://github.com/LourisXu" title="github"><i class="icon-github"></i></a><a class="weibo" target="_blank" href="http://weibo.com/5634881238/profile?rightmod=1&wvr=6&mod=personinfo" title="weibo"><i class="icon-weibo"></i></a><a class="mail" target="_blank" href="mailto:louris@csu.edu.cn" title="mail"><i class="icon-mail"></i></a></div></nav></header></div></div><div class="mid-col" q-class="show:isShow,hide:isShow|isFalse"><nav id="mobile-nav"><div class="overlay js-overlay" style="background:#00bfff"></div><div class="btnctn js-mobile-btnctn"><div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div></div><div class="intrude-less"><header id="header" class="inner"><div class="profilepic"> <img src="/assets/img/blog/userpic.jpg" class="js-avatar"></div><hgroup><h1 class="header-author js-header-author">Louris</h1></hgroup><p class="header-subtitle"><i class="icon icon-quo-left"></i>Do what I can<i class="icon icon-quo-right"></i></p><nav class="header-nav"><div class="social"><a class="github" target="_blank" href="https://github.com/LourisXu" title="github"><i class="icon-github"></i></a><a class="weibo" target="_blank" href="http://weibo.com/5634881238/profile?rightmod=1&wvr=6&mod=personinfo" title="weibo"><i class="icon-weibo"></i></a><a class="mail" target="_blank" href="mailto:louris@csu.edu.cn" title="mail"><i class="icon-mail"></i></a></div></nav><nav class="header-menu js-header-menu"><ul style="width:70%"><li style="width:20%"><a href="/">Home</a></li><li style="width:20%"><a href="/categories/DS/">DS</a></li><li style="width:20%"><a href="/tags/ML/">ML&amp;DL</a></li><li style="width:20%"><a href="/tags/Tech/">Tech</a></li><li style="width:20%"><a href="/tags/Algorithm/">Algorithm</a></li></ul></nav></header></div><div class="mobile-mask" style="display:none" q-show="isShow"></div></nav><div id="wrapper" class="body-wrap"><div class="menu-l"><div class="canvas-wrap"><canvas data-colors="#eaeaea" data-sectionheight="100" data-contentid="js-content" id="myCanvas1" class="anm-canvas"></canvas></div><div id="js-content" class="content-ll"><article id="post-Algorithm/算法笔记" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner"><header class="article-header"><h1 class="article-title" itemprop="name"> 算法笔记</h1><a href="/2019/02/17/algorithm-note.html/" class="archive-article-date"><time datetime="2019-02-17T12:13:45.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i> 2019-02-17</time></a></header><div class="article-entry" itemprop="articleBody"><link rel="stylesheet" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><h1 id="简单模拟"><a href="#简单模拟" class="headerlink" title="简单模拟"></a>简单模拟</h1></blockquote><h2 id="【PAT-B1001】害死人不偿命的（3n-1）猜想"><a href="#【PAT-B1001】害死人不偿命的（3n-1）猜想" class="headerlink" title="【PAT B1001】害死人不偿命的（3n+1）猜想"></a>【PAT B1001】害死人不偿命的（3n+1）猜想</h2><p>卡拉兹(Callatz)猜想：<br>对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去，最后一定在某一步得到n=1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证(3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……<br>我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过1000的正整数n，简单地数一下，需要多少步（砍几下）才能得到n=1？<br><strong>输入格式</strong><br>每个测试输入包含1个测试用例，即给出自然数n的值。<br><strong>输出格式</strong><br>输出从n计算到1需要的步数。<br><strong>输入样例</strong><br>3<br><strong>输出样例</strong><br>5<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> step;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		step=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(n!=<span class="number">1</span>){</span><br><span class="line">			<span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>){</span><br><span class="line">				n/=<span class="number">2</span>;</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				n=(<span class="number">3</span>*n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">			}</span><br><span class="line">			step++;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;step&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="【PAT-B1032】挖掘机技术哪家强"><a href="#【PAT-B1032】挖掘机技术哪家强" class="headerlink" title="【PAT B1032】挖掘机技术哪家强"></a>【PAT B1032】挖掘机技术哪家强</h2><p>为了用事实说明挖掘机技术到底哪家强，PAT 组织了一场挖掘机技能大赛。现请你根据比赛结果统计出技术最强的那个学校。<br><strong>输入格式</strong><br>输入在第 1 行给出不超过 10<br>​5<br>​​ 的正整数 N，即参赛人数。随后 N 行，每行给出一位参赛者的信息和成绩，包括其所代表的学校的编号（从 1 开始连续编号）、及其比赛成绩（百分制），中间以空格分隔。<br><strong>输出格式</strong><br>在一行中给出总得分最高的学校的编号、及其总分，中间以空格分隔。题目保证答案唯一，没有并列。<br><strong>输入样例</strong><br>6<br>3 65<br>2 80<br>1 100<br>2 70<br>3 40<br>3 0<br><strong>输出样例</strong><br>2 150<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_SIZE=<span class="number">100000</span>;</span><br><span class="line"><span class="keyword">int</span> schools[MAX_SIZE];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	fill(schools,schools+MAX_SIZE,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	<span class="keyword">int</span> a,b;</span><br><span class="line">	<span class="keyword">int</span> maxSch,maxScore=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;number;</span><br><span class="line">	<span class="keyword">while</span>(number--){</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		schools[a]+=b;</span><br><span class="line">		<span class="keyword">if</span>(schools[a]&gt;maxScore){</span><br><span class="line">			maxScore=schools[a];</span><br><span class="line">			maxSch=a;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;maxSch&lt;&lt;<span class="string">" "</span>&lt;&lt;maxScore&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="剩下的树"><a href="#剩下的树" class="headerlink" title="剩下的树"></a>剩下的树</h2><p><strong>题目描述</strong><br>有一个长度为整数L(1&lt;=L&lt;=10000)的马路，可以想象成数轴上长度为L的一个线段，起点是坐标原点，在每个整数坐标点有一棵树，即在0,1,2，…，L共L+1个位置上有L+1棵树。<br> 现在要移走一些树，移走的树的区间用一对数字表示，如 100 200表示移走从100到200之间（包括端点）所有的树。<br> 可能有M(1&lt;=M&lt;=100)个区间，区间之间可能有重叠。现在要求移走所有区间的树之后剩下的树的个数。<br><strong>输入</strong><br>两个整数L(1&lt;=L&lt;=10000)和M(1&lt;=M&lt;=100)。<br> 接下来有M组整数，每组有一对数字。<br><strong>输出</strong><br> 可能有多组输入数据，对于每组输入数据，输出一个数，表示移走所有区间的树之后剩下的树的个数。<br><strong>样例输入</strong><br>4 2<br>1 2<br>0 2<br>11 2<br>1 5<br>4 7<br>0 0<br><strong>样例输出</strong><br>2<br>5<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_SIZE=<span class="number">10001</span>;</span><br><span class="line"><span class="keyword">int</span> trees[MAX_SIZE];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> L,M;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;L&gt;&gt;M&amp;&amp;(L&gt;<span class="number">0</span>&amp;&amp;M&gt;<span class="number">0</span>)){</span><br><span class="line">		fill(trees,trees+L+<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//0~L（包括端点）区间初始化</span></span><br><span class="line">		<span class="keyword">while</span>(M--){</span><br><span class="line">			<span class="keyword">int</span> l,r;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++){</span><br><span class="line">				<span class="keyword">if</span>(trees[i]&gt;<span class="number">0</span>){</span><br><span class="line">					trees[i]--;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=L;i++){</span><br><span class="line">			<span class="keyword">if</span>(trees[i]&gt;<span class="number">0</span>){</span><br><span class="line">				num++;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="A-B"><a href="#A-B" class="headerlink" title="A+B"></a>A+B</h2><p><strong>题目描述</strong><br>给定两个整数A和B，其表示形式是：从个位开始，每三位数用逗号”,”隔开。<br>现在请计算A+B的结果，并以正常形式输出。</p><p><strong>输入</strong><br>输入包含多组数据数据，每组数据占一行，由两个整数A和B组成（-10^9 &lt; A,B &lt; 10^9）。</p><p><strong>输出</strong><br>请计算A+B的结果，并以正常形式输出，每组数据占一行。</p><p><strong>样例输入</strong><br>-234,567,890 123,456,789<br>1,234 2,345,678<br><strong>样例输出</strong><br>-111111101<br>2346912<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">string</span> a,b;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b){</span><br><span class="line">		<span class="keyword">long</span> aa,bb;</span><br><span class="line">		aa=bb=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length();i++){</span><br><span class="line">			<span class="keyword">if</span>(a[i]&gt;=<span class="string">'0'</span>&amp;&amp;a[i]&lt;=<span class="string">'9'</span>){</span><br><span class="line">				aa=aa*<span class="number">10</span>+a[i]-<span class="string">'0'</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="string">'-'</span>){</span><br><span class="line">			aa=-aa;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.length();i++){</span><br><span class="line">			<span class="keyword">if</span>(b[i]&gt;=<span class="string">'0'</span>&amp;&amp;b[i]&lt;=<span class="string">'9'</span>){</span><br><span class="line">				bb=bb*<span class="number">10</span>+b[i]-<span class="string">'0'</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(b[<span class="number">0</span>]==<span class="string">'-'</span>){</span><br><span class="line">			bb=-bb;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;aa+bb&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="特殊乘法"><a href="#特殊乘法" class="headerlink" title="特殊乘法"></a>特殊乘法</h2><p><strong>题目描述</strong><br>写个算法，对2个小于1000000000的输入，求结果。特殊乘法举例：123 * 45 = 1*4 +1*5 +2*4 +2*5 +3*4+3*5<br><strong>输入</strong><br> 两个小于1000000000的数</p><p><strong>输出</strong><br> 输入可能有多组数据，对于每一组数据，输出Input中的两个数按照题目要求的方法进行运算后得到的结果。</p><p><strong>样例输入</strong><br>24 65<br>42 66666<br>3 67<br><strong>样例输出</strong><br>66<br>180<br>39<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">string</span> a,b;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b){</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length();i++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b.length();j++){</span><br><span class="line">				sum+=(a[i]-<span class="string">'0'</span>)*(b[j]-<span class="string">'0'</span>);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="比较奇偶数个数"><a href="#比较奇偶数个数" class="headerlink" title="比较奇偶数个数"></a>比较奇偶数个数</h2><p><strong>题目描述</strong><br>第一行输入一个数，为n，第二行输入n个数，这n个数中，如果偶数比奇数多，输出NO，否则输出YES。<br><strong>输入</strong><br>输入有多组数据。<br>每组输入n，然后输入n个整数（1&lt;=n&lt;=1000）。<br><strong>输出</strong><br>如果偶数比奇数多，输出NO，否则输出YES。<br><strong>样例输入</strong><br>1<br>67<br>7<br>0 69 24 78 58 62 64<br><strong>样例输出</strong><br>YES<br>NO<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		<span class="keyword">int</span> tmpN=n;</span><br><span class="line">		<span class="keyword">int</span> count=<span class="number">0</span>; <span class="comment">//偶数个数</span></span><br><span class="line">		<span class="keyword">while</span>(n--){</span><br><span class="line">			<span class="keyword">int</span> tmp;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">			<span class="keyword">if</span>(tmp%<span class="number">2</span>==<span class="number">0</span>){</span><br><span class="line">				count++;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(count&gt;=<span class="built_in">ceil</span>(tmpN/<span class="number">2.0</span>)){  <span class="comment">//tmpN/2向上取整</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Shortest-Distance"><a href="#Shortest-Distance" class="headerlink" title="Shortest Distance"></a>Shortest Distance</h2><p>The task is really simple: given N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits.<br><strong>Input Specification</strong><br>Each input file contains one test case. For each case, the first line contains an integer N (in [3, 105]), followed by N integer distances D1 D2 … DN, where Di is the distance between the i-th and the (i+1)-st exits, and DN is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M (&lt;=104), with M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than 107.<br><strong>Output Specification</strong><br>For each test case, print your results in M lines, each contains the shortest distance between the corresponding given pair of exits.<br><strong>Sample Input</strong><br>5 1 2 4 14 9<br>3<br>1 3<br>2 5<br>4 1<br><strong>Sample Output</strong><br>3<br>10<br>7<br><strong>Procedure</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">输入Di的时候记录a cycle的总距离cyDis</span></span><br><span class="line"><span class="comment">之后根据要求的两个exit的序号a,b（保证a比b小）</span></span><br><span class="line"><span class="comment">求a与b之间升序的各exit距离和sum，</span></span><br><span class="line"><span class="comment">与cyDis-sum（反向路程长）比较</span></span><br><span class="line"><span class="comment">输出二者中较小值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> M,N;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;N){</span><br><span class="line">		<span class="keyword">int</span> cyDis=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;dis[i];</span><br><span class="line">			cyDis+=dis[i];</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;M;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++){</span><br><span class="line">			<span class="keyword">int</span> a,b;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">			<span class="keyword">if</span>(a&gt;b) swap(a,b);</span><br><span class="line">			<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=a;j&lt;b;j++){</span><br><span class="line">				sum+=dis[j];</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span>(sum&gt;cyDis-sum){</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;cyDis-sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="A-B和C"><a href="#A-B和C" class="headerlink" title="A+B和C"></a>A+B和C</h2><p><strong>题目描述</strong><br>给定区间$[-2^{31}, 2^{31}]$内的3个整数A、B和C，请判断A+B是否大于C。<br><strong>输入</strong><br>输入第1行给出正整数T(&lt;=10)，是测试用例的个数。随后给出T组测试用例，每组占一行，顺序给出A、B和C。整数间以空格分隔。<br><strong>输出</strong><br>对每组测试用例，在一行中输出“Case #X: true”如果A+B&gt;C，否则输出“Case #X: false”，其中X是测试用例的编号（从1开始）。<br><strong>样例输入</strong><br>4<br>1 2 3<br>2 3 4<br>2147483647 0 2147483646<br>0 -2147483648 -2147483647<br><strong>样例输出</strong><br>Case #1: false<br>Case #2: true<br>Case #3: true<br>Case #4: false<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> result[<span class="number">2</span>]={</span><br><span class="line">	<span class="string">"false"</span>,</span><br><span class="line">	<span class="string">"true"</span></span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=T;i++){</span><br><span class="line">		<span class="keyword">long</span> a,b,c; <span class="comment">//int 2字节，long 4字节，long long 8字节 unsigned long 4字节</span></span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;i&lt;&lt;<span class="string">": "</span>&lt;&lt;result[a+b&gt;c]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="数字分类"><a href="#数字分类" class="headerlink" title="数字分类"></a>数字分类</h2><p><strong>题目描述</strong><br>给定一系列正整数，请按要求对数字进行分类，并输出以下5个数字：<br>A1 = 能被5整除的数字中所有偶数的和；<br>A2 = 将被5除后余1的数字按给出顺序进行交错求和，即计算n1-n2+n3-n4…；<br>A3 = 被5除后余2的数字的个数；<br>A4 = 被5除后余3的数字的平均数，精确到小数点后1位；<br>A5 = 被5除后余4的数字中最大数字。<br><strong>输入</strong><br>每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N，随后给出N个不超过1000的待分类的正整数。数字间以空格分隔。<br><strong>输出</strong><br>对给定的N个正整数，按题目要求计算A1~A5并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。<br>若其中某一类数字不存在，则在相应位置输出“N”。<br><strong>样例输入</strong><br>13 1 2 3 4 5 6 7 8 9 10 20 16 18<br>8 1 2 4 5 6 7 9 16<br><strong>样例输出</strong><br>30 11 2 9.7 9<br>N 11 2 N 9<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">double</span> x;</span><br><span class="line">	<span class="keyword">bool</span> exist;</span><br><span class="line">};</span><br><span class="line">Node A[<span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> N;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;N){</span><br><span class="line">		<span class="keyword">int</span> tmp;</span><br><span class="line">		<span class="keyword">int</span> a2=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> a3=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++){</span><br><span class="line">			A[i].x=<span class="number">0</span>;</span><br><span class="line">			A[i].exist=<span class="literal">false</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">while</span>(N--){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">			<span class="keyword">switch</span>(tmp%<span class="number">5</span>){</span><br><span class="line">				<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">					<span class="keyword">if</span>(tmp%<span class="number">2</span>==<span class="number">0</span>){</span><br><span class="line">						A[<span class="number">1</span>].x+=tmp;</span><br><span class="line">						A[<span class="number">1</span>].exist=<span class="literal">true</span>;</span><br><span class="line">					}</span><br><span class="line">					 <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">					A[<span class="number">2</span>].exist=<span class="literal">true</span>;</span><br><span class="line">					A[<span class="number">2</span>].x+=<span class="built_in">pow</span>(<span class="number">-1</span>,a2)*tmp;</span><br><span class="line">					a2==<span class="number">0</span>?a2=<span class="number">1</span>:a2=<span class="number">0</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">					A[<span class="number">3</span>].exist=<span class="literal">true</span>;</span><br><span class="line">					A[<span class="number">3</span>].x++;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">					A[<span class="number">4</span>].exist=<span class="literal">true</span>;</span><br><span class="line">					A[<span class="number">4</span>].x+=tmp;</span><br><span class="line">					a3++;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">					A[<span class="number">5</span>].exist=<span class="literal">true</span>;</span><br><span class="line">					A[<span class="number">5</span>].x=(A[<span class="number">5</span>].x&gt;tmp?A[<span class="number">5</span>].x:tmp);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(a3!=<span class="number">0</span>) A[<span class="number">4</span>].x/=a3;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++){</span><br><span class="line">			<span class="keyword">if</span>(i!=<span class="number">1</span>){</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span>(A[i].exist){</span><br><span class="line">				<span class="keyword">if</span>(i!=<span class="number">4</span>){</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"%0.f"</span>,A[i].x);</span><br><span class="line">				}<span class="keyword">else</span>{</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"%0.1f"</span>,A[i].x);</span><br><span class="line">				}</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"N"</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="部分A-B"><a href="#部分A-B" class="headerlink" title="部分A+B"></a>部分A+B</h2><p><strong>题目描述</strong><br>正整数A的“DA（为1位整数）部分”定义为由A中所有DA组成的新整数PA。例如：给定A = 3862767，DA = 6，则A的“6部分”PA是66，因为A中有2个6。<br>现给定A、DA、B、DB，请编写程序计算PA + PB。<br><strong>输入</strong><br>输入在一行中依次给出A、DA、B、DB，中间以空格分隔，其中0 &lt; A, B &lt; 1010。<br><strong>输出</strong><br>在一行中输出PA + PB的值。<br><strong>样例输入</strong><br>3862767 6 13530293 3<br>3862767 1 13530293 8<br><strong>样例输出</strong><br>399<br>0<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">string</span> A,B;</span><br><span class="line">	<span class="keyword">int</span> DA,DB;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;A&gt;&gt;DA&gt;&gt;B&gt;&gt;DB){</span><br><span class="line">		<span class="keyword">int</span> aa=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.length();i++){</span><br><span class="line">			<span class="keyword">if</span>(A[i]-<span class="string">'0'</span>==DA){</span><br><span class="line">				aa=aa*<span class="number">10</span>+DA;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">int</span> bb=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;B.length();i++){</span><br><span class="line">			<span class="keyword">if</span>(B[i]-<span class="string">'0'</span>==DB){</span><br><span class="line">				bb=bb*<span class="number">10</span>+DB;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;aa+bb&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="锤子剪刀布"><a href="#锤子剪刀布" class="headerlink" title="锤子剪刀布"></a>锤子剪刀布</h2><p>现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。<br><strong>输入格式</strong><br>输入第1行给出正整数N（&lt;=105），即双方交锋的次数。随后N行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C代表“锤子”、J代表“剪刀”、B代表“布”，第1个字母代表甲方，第2个代表乙方，中间有1个空格。<br><strong>输出格式</strong><br>输出第1、2行分别给出甲、乙的胜、平、负次数，数字间以1个空格分隔。第3行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有1个空格。如果解不唯一，则输出按字母序最小的解。<br><strong>输入样例</strong><br>10<br>C J<br>J B<br>C B<br>B B<br>B C<br>C C<br>C B<br>J B<br>B C<br>J J<br><strong>输出样例</strong><br>5 3 2<br>2 3 5<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">int</span> sum;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(a.sum==b.sum){</span><br><span class="line">		<span class="keyword">return</span> a.ch&lt;b.ch;</span><br><span class="line">	}<span class="keyword">else</span>{</span><br><span class="line">		<span class="keyword">return</span> a.sum&gt;b.sum;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> CH[<span class="number">3</span>]={<span class="string">'C'</span>,<span class="string">'J'</span>,<span class="string">'B'</span>};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> N;</span><br><span class="line">	Node A[<span class="number">3</span>],B[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++){</span><br><span class="line">		A[i].ch=CH[i];</span><br><span class="line">		A[i].sum=<span class="number">0</span>;</span><br><span class="line">		B[i].ch=CH[i];</span><br><span class="line">		B[i].sum=<span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;N){</span><br><span class="line">		<span class="keyword">int</span> w,d,times;</span><br><span class="line">		w=d=<span class="number">0</span>;</span><br><span class="line">		times=N;</span><br><span class="line">		<span class="keyword">while</span>(N--){</span><br><span class="line">			<span class="keyword">char</span> a,b;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">			<span class="keyword">if</span>(a==b){   <span class="comment">//平</span></span><br><span class="line">				d++;</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span>(a==<span class="string">'C'</span>&amp;&amp;b==<span class="string">'J'</span>){</span><br><span class="line">					w++;</span><br><span class="line">					A[<span class="number">0</span>].sum++;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">if</span>(a==<span class="string">'J'</span>&amp;&amp;b==<span class="string">'B'</span>){</span><br><span class="line">					w++;</span><br><span class="line">					A[<span class="number">1</span>].sum++;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">if</span>(a==<span class="string">'B'</span>&amp;&amp;b==<span class="string">'C'</span>){</span><br><span class="line">					w++;</span><br><span class="line">					A[<span class="number">2</span>].sum++;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">if</span>(a==<span class="string">'C'</span>&amp;&amp;b==<span class="string">'B'</span>){</span><br><span class="line">					B[<span class="number">2</span>].sum++;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">if</span>(a==<span class="string">'J'</span>&amp;&amp;b==<span class="string">'C'</span>){</span><br><span class="line">					B[<span class="number">0</span>].sum++;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">if</span>(a==<span class="string">'B'</span>&amp;&amp;b==<span class="string">'J'</span>){</span><br><span class="line">					B[<span class="number">1</span>].sum++;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;w&lt;&lt;<span class="string">" "</span>&lt;&lt;d&lt;&lt;<span class="string">" "</span>&lt;&lt;times-w-d&lt;&lt;<span class="built_in">endl</span></span><br><span class="line">			&lt;&lt;times-w-d&lt;&lt;<span class="string">" "</span>&lt;&lt;d&lt;&lt;<span class="string">" "</span>&lt;&lt;w&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		sort(A,A+<span class="number">3</span>,cmp);</span><br><span class="line">		sort(B,B+<span class="number">3</span>,cmp);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;A[<span class="number">0</span>].ch&lt;&lt;<span class="string">" "</span>&lt;&lt;B[<span class="number">0</span>].ch&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h1></blockquote><h2 id="统计同成绩学生人数"><a href="#统计同成绩学生人数" class="headerlink" title="统计同成绩学生人数"></a>统计同成绩学生人数</h2><p><strong>题目描述</strong><br>读入N名学生的成绩，将获得某一给定分数的学生人数输出。<br><strong>输入</strong><br>测试输入包含若干测试用例，每个测试用例的格式为</p><p>第1行：N<br>第2行：N名学生的成绩，相邻两数字用一个空格间隔。<br>第3行：给定分数</p><p>当读到N=0时输入结束。其中N不超过1000，成绩分数为（包含）0到100之间的一个整数。<br><strong>输出</strong><br>对每个测试用例，将获得给定分数的学生人数输出。<br><strong>样例输入</strong><br>4<br>70 80 90 100<br>80<br>3<br>65 75 85<br>55<br>5<br>60 90 90 90 85<br>90<br>0<br><strong>样例输出</strong><br>1<br>0<br>3<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> N;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;N&amp;&amp;N!=<span class="number">0</span>){</span><br><span class="line">		<span class="keyword">int</span> A[<span class="number">1001</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">int</span> tmp;</span><br><span class="line">		<span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line">			<span class="keyword">if</span>(A[i]==tmp) count++;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="找x"><a href="#找x" class="headerlink" title="找x"></a>找x</h2><p><strong>题目描述</strong><br>输入一个数n，然后输入n个数值各不相同，再输入一个值x，输出这个值在这个数组中的下标（从0开始，若不在数组中则输出-1）。<br><strong>输入</strong><br>测试数据有多组，输入n(1&lt;=n&lt;=200)，接着输入n个数，然后输入x。<br>输出<br>对于每组输入,请输出结果。<br><strong>样例输入</strong><br>4<br>1 2 3 4<br>3<br><strong>样例输出</strong><br>2<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> A[<span class="number">201</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="keyword">if</span>(x==A[i]){</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(i==n){</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="查找学生信息"><a href="#查找学生信息" class="headerlink" title="查找学生信息"></a>查找学生信息</h2><p><strong>题目描述</strong><br>输入N个学生的信息，然后进行查询。<br><strong>输入</strong><br>输入的第一行为N，即学生的个数(N&lt;=1000)<br>接下来的N行包括N个学生的信息，信息格式如下：<br>01 李江 男 21<br>02 刘唐 男 23<br>03 张军 男 19<br>04 王娜 女 19<br>然后输入一个M(M&lt;=10000),接下来会有M行，代表M次查询，每行输入一个学号，格式如下：<br>02<br>03<br>01<br>04<br><strong>输出</strong><br>输出M行，每行包括一个对应于查询的学生的信息。<br>如果没有对应的学生信息，则输出“No Answer!”<br><strong>样例输入</strong><br>5<br>001 张三 男 19<br>002 李四 男 20<br>003 王五 男 18<br>004 赵六 女 17<br>005 刘七 女 21<br>7<br>003<br>002<br>005<br>004<br>003<br>001<br>006<br><strong>样例输出</strong><br>003 王五 男 18<br>002 李四 男 20<br>005 刘七 女 21<br>004 赵六 女 17<br>003 王五 男 18<br>001 张三 男 19<br>No Answer!<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="built_in">string</span> gender;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	Node(){}</span><br><span class="line">	Node(<span class="built_in">string</span> Name,<span class="built_in">string</span> Gender,<span class="keyword">int</span> Age)</span><br><span class="line">		:name(Name),gender(Gender),age(Age){}</span><br><span class="line">	toString(){</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;name&lt;&lt;<span class="string">" "</span>&lt;&lt;gender&lt;&lt;<span class="string">" "</span>&lt;&lt;age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,Node&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> N,M;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;N){</span><br><span class="line">		m.clear();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line">			<span class="built_in">string</span> id,name,gender;</span><br><span class="line">			<span class="keyword">int</span> age;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;id&gt;&gt;name&gt;&gt;gender&gt;&gt;age;</span><br><span class="line">			m[id]=Node(name,gender,age);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;M;</span><br><span class="line">		<span class="keyword">while</span>(M--){</span><br><span class="line">			<span class="built_in">string</span> id;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;id;</span><br><span class="line">			<span class="built_in">map</span>&lt;<span class="built_in">string</span>,Node&gt;::iterator it;</span><br><span class="line">			it=m.find(id);</span><br><span class="line">			<span class="keyword">if</span>(it!=m.end()){</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;it-&gt;first;</span><br><span class="line">				it-&gt;second.toString();</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"No Answer!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p><strong>题目描述</strong><br>输入数组长度 n<br>输入数组 a[1…n]<br>输入查找个数m<br>输入查找数字b[1…m]<br>输出 YES or NO 查找有则YES 否则NO 。<br><strong>输入</strong><br>输入有多组数据。<br>每组输入n，然后输入n个整数，再输入m，然后再输入m个整数（1&lt;=m&lt;=n&lt;=100）。<br><strong>输出</strong><br>如果在n个数组中输出YES否则输出NO。<br><strong>样例输入</strong><br>6<br>3 2 5 4 7 8<br>2<br>3 6<br><strong>样例输出</strong><br>YES<br>NO<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line"></span><br><span class="line">		<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(n--){</span><br><span class="line">			<span class="keyword">int</span> tmp;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">			s.insert(tmp);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">int</span> m;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">		<span class="keyword">while</span>(m--){</span><br><span class="line">			<span class="keyword">int</span> tmp;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">			<span class="keyword">if</span>(s.find(tmp)!=s.end()){</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="图形输出"><a href="#图形输出" class="headerlink" title="图形输出"></a>图形输出</h1></blockquote><h2 id="跟奥巴马一起编程"><a href="#跟奥巴马一起编程" class="headerlink" title="跟奥巴马一起编程"></a>跟奥巴马一起编程</h2><p>美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014 年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！<br><strong>输入格式</strong><br>输入在一行中给出正方形边长 N（3≤N≤20）和组成正方形边的某种字符 C，间隔一个空格。<br><strong>输出格式</strong><br>输出由给定字符 C 画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的 50%（四舍五入取整）。<br><strong>输入样例</strong><br>10 a<br><strong>输出样例</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aaaaaaaaaa</span><br><span class="line">a        a</span><br><span class="line">a        a</span><br><span class="line">a        a</span><br><span class="line">aaaaaaaaaa</span><br></pre></td></tr></tbody></table></figure><p><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;c){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cout</span>&lt;&lt;c;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">int</span> row=(<span class="keyword">int</span>)(n/<span class="number">2.0</span>+<span class="number">0.5</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;row<span class="number">-1</span>;i++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">				<span class="keyword">if</span>(j==<span class="number">0</span>||j==n<span class="number">-1</span>){</span><br><span class="line">					<span class="built_in">cout</span>&lt;&lt;c;</span><br><span class="line">				}<span class="keyword">else</span>{</span><br><span class="line">					<span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cout</span>&lt;&lt;c;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Hello-World-for-U"><a href="#Hello-World-for-U" class="headerlink" title="Hello World for U"></a>Hello World for U</h2><p><strong>题目描述</strong><br>Given any string of N (&gt;=5) characters, you are asked to form the characters into the shape of U. For example, “helloworld” can be printed as:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h  d</span><br><span class="line">e  l</span><br><span class="line">l  r</span><br><span class="line">lowo</span><br></pre></td></tr></tbody></table></figure><p>That is, the characters must be printed in the original order, starting top-down from the left vertical line with n1 characters, then left to right along the bottom line with n2 characters, and finally bottom-up along the vertical line with n3 characters. And more, we would like U to be as squared as possible – that is, it must be satisfied that n1 = n3 = max { k| k &lt;= n2 for all 3 &lt;= n2 &lt;= N } with n1 + n2 + n3 - 2 = N.<br><strong>输入</strong><br>Each input file contains one test case. Each case contains one string with no less than 5 and no more than 80 characters in a line. The string contains no white space.<br><strong>输出</strong><br>For each test case, print the input string in the shape of U as specified in the description.<br><strong>样例输入</strong><br>helloworld!<br><strong>样例输出</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h   !</span><br><span class="line">e   d</span><br><span class="line">l   l</span><br><span class="line">lowor</span><br></pre></td></tr></tbody></table></figure><p><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str){</span><br><span class="line">		<span class="keyword">int</span> len=str.length();</span><br><span class="line">		<span class="keyword">int</span> sideLen=(len+<span class="number">2</span>)/<span class="number">3</span>; <span class="comment">//两列字符长</span></span><br><span class="line">		<span class="keyword">int</span> belowLen=len+<span class="number">2</span><span class="number">-2</span>*sideLen; <span class="comment">//底部字符长</span></span><br><span class="line">		<span class="keyword">int</span> front=<span class="number">0</span>,rear=len<span class="number">-1</span>;   <span class="comment">//头尾指针</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sideLen<span class="number">-1</span>;i++){  <span class="comment">//输出除底行外的所有行</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;belowLen;j++){</span><br><span class="line">				<span class="keyword">if</span>(j==<span class="number">0</span>){</span><br><span class="line">					<span class="built_in">cout</span>&lt;&lt;str[front++];</span><br><span class="line">				}<span class="keyword">else</span> <span class="keyword">if</span>(j==belowLen<span class="number">-1</span>){</span><br><span class="line">					<span class="built_in">cout</span>&lt;&lt;str[rear--];</span><br><span class="line">				}<span class="keyword">else</span>{</span><br><span class="line">					<span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">while</span>(front&lt;=rear){  <span class="comment">//输出底行</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;str[front++];</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="等腰梯形"><a href="#等腰梯形" class="headerlink" title="等腰梯形"></a>等腰梯形</h2><p><strong>题目描述</strong><br>请输入高度h，输入一个高为h，上底边长为h的等腰梯形（例如h=4，图形如下）。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   ****</span><br><span class="line">  ******</span><br><span class="line"> ********</span><br><span class="line">**********</span><br></pre></td></tr></tbody></table></figure><p><strong>输入</strong><br>输入第一行表示样例数m，接下来m行每行一个整数h，h不超过10。<br><strong>输出</strong><br>对应于m个case输出要求的等腰梯形。<br><strong>样例输入</strong><br>1<br>4<br><strong>样例输出</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   ****</span><br><span class="line">  ******</span><br><span class="line"> ********</span><br><span class="line">**********</span><br></pre></td></tr></tbody></table></figure><p><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="keyword">int</span> h;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(m--){</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;h;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=h;i++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=h-i;j++){  <span class="comment">//前缀空格</span></span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=h+<span class="number">2</span>*(i<span class="number">-1</span>);j++){ <span class="comment">//输出字符</span></span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"*"</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="沙漏图形"><a href="#沙漏图形" class="headerlink" title="沙漏图形"></a>沙漏图形</h2><p><strong>题目描述</strong><br>问题：输入n，输出正倒n层星号三角形。首行顶格，星号间有一空格，效果见样例<br><strong>输入样例</strong><br>3<br><strong>输出样例</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* * *</span><br><span class="line"> * *</span><br><span class="line">  *</span><br><span class="line"> * *</span><br><span class="line">* * *</span><br></pre></td></tr></tbody></table></figure><p><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){  <span class="comment">//上半区，包括中间行</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++) <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>; <span class="comment">//前缀空格</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-i;j++){</span><br><span class="line">				<span class="keyword">if</span>(j!=<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"*"</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--){ <span class="comment">//下半区，不包括中间行</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++) <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>; <span class="comment">//前缀空格</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-i;j++){</span><br><span class="line">				<span class="keyword">if</span>(j!=<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"*"</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="日期处理"><a href="#日期处理" class="headerlink" title="日期处理"></a>日期处理</h1></blockquote><h2 id="日期差值"><a href="#日期差值" class="headerlink" title="日期差值"></a>日期差值</h2><p><strong>题目描述</strong><br>有两个日期，求两个日期之间的天数，如果两个日期是连续的我们规定他们之间的天数为两天。<br><strong>输入</strong><br>有多组数据，每组数据有两行，分别表示两个日期，形式为YYYYMMDD<br><strong>输出</strong><br>每组数据输出一行，即日期差值<br><strong>样例输入</strong><br>20130101<br>20130105<br><strong>样例输出</strong><br>5<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MONTH[<span class="number">2</span>][<span class="number">13</span>]={</span><br><span class="line">	<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>, <span class="comment">//非闰年各月天数</span></span><br><span class="line">	<span class="number">0</span>,<span class="number">31</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>  <span class="comment">//闰年各月天数</span></span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeap</span><span class="params">(<span class="keyword">int</span> year)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>((year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>)||(year%<span class="number">400</span>==<span class="number">0</span>)){</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">string</span> date1,date2;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;date1&gt;&gt;date2){</span><br><span class="line">		<span class="keyword">if</span>(date1&gt;date2) swap(date1,date2);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;date1&lt;&lt;<span class="string">" "</span>&lt;&lt;date2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">int</span> year1,year2;</span><br><span class="line">		<span class="keyword">int</span> month1,month2;</span><br><span class="line">		<span class="keyword">int</span> day1,day2;</span><br><span class="line">		year1=(date1[<span class="number">0</span>]-<span class="string">'0'</span>)*<span class="number">1000</span>+(date1[<span class="number">1</span>]-<span class="string">'0'</span>)*<span class="number">100</span>+(date1[<span class="number">2</span>]-<span class="string">'0'</span>)*<span class="number">10</span>+date1[<span class="number">3</span>]-<span class="string">'0'</span>;</span><br><span class="line">		year2=(date2[<span class="number">0</span>]-<span class="string">'0'</span>)*<span class="number">1000</span>+(date2[<span class="number">1</span>]-<span class="string">'0'</span>)*<span class="number">100</span>+(date2[<span class="number">2</span>]-<span class="string">'0'</span>)*<span class="number">10</span>+date2[<span class="number">3</span>]-<span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">		month1=(date1[<span class="number">4</span>]-<span class="string">'0'</span>)*<span class="number">10</span>+date1[<span class="number">5</span>]-<span class="string">'0'</span>;</span><br><span class="line">		month2=(date2[<span class="number">4</span>]-<span class="string">'0'</span>)*<span class="number">10</span>+date2[<span class="number">5</span>]-<span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">		day1=(date1[<span class="number">6</span>]-<span class="string">'0'</span>)*<span class="number">10</span>+date1[<span class="number">7</span>]-<span class="string">'0'</span>;</span><br><span class="line">		day2=(date2[<span class="number">6</span>]-<span class="string">'0'</span>)*<span class="number">10</span>+date2[<span class="number">7</span>]-<span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> sumDays=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(year1==year2){</span><br><span class="line">			<span class="keyword">if</span>(month1==month2){</span><br><span class="line"></span><br><span class="line">				<span class="comment">//month1(month2)</span></span><br><span class="line">				sumDays=day2-day1+<span class="number">1</span>;</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				<span class="comment">//month1</span></span><br><span class="line">				<span class="keyword">int</span> index=isLeap(year1);</span><br><span class="line">				sumDays+=MONTH[index][month1]-day1+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//month1+1~month2-1</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> month=month1+<span class="number">1</span>;month&lt;month2;month++){</span><br><span class="line">					sumDays+=MONTH[index][month];</span><br><span class="line">				}</span><br><span class="line"></span><br><span class="line">				<span class="comment">//month2</span></span><br><span class="line">				sumDays+=day2;</span><br><span class="line">			}</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			<span class="comment">//year1</span></span><br><span class="line">			<span class="keyword">int</span> index=isLeap(year1);</span><br><span class="line">			sumDays+=MONTH[index][month1]-day1+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> month=month1+<span class="number">1</span>;month&lt;=<span class="number">12</span>;month++){</span><br><span class="line">				sumDays+=MONTH[index][month];</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="comment">//year1+1~year2-1</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> year=year1+<span class="number">1</span>;year&lt;year2;year++){</span><br><span class="line">				<span class="keyword">if</span>(isLeap(year)){</span><br><span class="line">					sumDays+=<span class="number">366</span>;</span><br><span class="line">				}<span class="keyword">else</span>{</span><br><span class="line">					sumDays+=<span class="number">365</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="comment">//year2</span></span><br><span class="line">			index=isLeap(year2);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> month=<span class="number">1</span>;month&lt;month2;month++){</span><br><span class="line">				sumDays+=MONTH[index][month];</span><br><span class="line">			}</span><br><span class="line">			sumDays+=day2;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;sumDays&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Day-of-week"><a href="#Day-of-week" class="headerlink" title="Day of week"></a>Day of week</h2><p><strong>题目描述</strong><br>We now use the Gregorian style of dating in Russia. The leap years are years with number divisible by 4 but not divisible by 100, or divisible by 400.<br>For example, years 2004, 2180 and 2400 are leap. Years 2004, 2181 and 2300 are not leap.<br>Your task is to write a program which will compute the day of week corresponding to a given date in the nearest past or in the future using today’s agreement about dating.<br><strong>输入</strong><br>There is one single line contains the day number d, month name M and year number y(1000≤y≤3000). The month name is the corresponding English name starting from the capital letter.<br><strong>输出</strong><br>Output a single line with the English name of the day of week corresponding to the date, starting from the capital letter. All other letters must be in lower case.<br><strong>样例输入</strong><br>21 December 2012<br>5 January 2013<br><strong>样例输出</strong><br>Friday<br>Saturday<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> monthDays[<span class="number">2</span>][<span class="number">13</span>]={</span><br><span class="line">	<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>, <span class="comment">//非闰年各月天数</span></span><br><span class="line">	<span class="number">0</span>,<span class="number">31</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>  <span class="comment">//闰年各月天数</span></span><br><span class="line">};</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; monthMap;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> dayName[<span class="number">7</span>]={</span><br><span class="line">	<span class="string">"Sunday"</span>,</span><br><span class="line">	<span class="string">"Monday"</span>,</span><br><span class="line">	<span class="string">"Tuesday"</span>,</span><br><span class="line">	<span class="string">"Wednesday"</span>,</span><br><span class="line">	<span class="string">"Thursday"</span>,</span><br><span class="line">	<span class="string">"Friday"</span>,</span><br><span class="line">	<span class="string">"Saturday"</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeap</span><span class="params">(<span class="keyword">int</span> year)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>((year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>)||(year%<span class="number">400</span>==<span class="number">0</span>)){</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> YEAR=<span class="number">2012</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MONTH=<span class="number">12</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> DAY=<span class="number">21</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dayWeek=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">	monthMap[<span class="string">"January"</span>]=<span class="number">1</span>;</span><br><span class="line">	monthMap[<span class="string">"February"</span>]=<span class="number">2</span>;</span><br><span class="line">	monthMap[<span class="string">"March"</span>]=<span class="number">3</span>;</span><br><span class="line">	monthMap[<span class="string">"April"</span>]=<span class="number">4</span>;</span><br><span class="line">	monthMap[<span class="string">"May"</span>]=<span class="number">5</span>;</span><br><span class="line">	monthMap[<span class="string">"June"</span>]=<span class="number">6</span>;</span><br><span class="line">	monthMap[<span class="string">"July"</span>]=<span class="number">7</span>;</span><br><span class="line">	monthMap[<span class="string">"August"</span>]=<span class="number">8</span>;</span><br><span class="line">	monthMap[<span class="string">"September"</span>]=<span class="number">9</span>;</span><br><span class="line">	monthMap[<span class="string">"Octember"</span>]=<span class="number">10</span>;</span><br><span class="line">	monthMap[<span class="string">"November"</span>]=<span class="number">11</span>;</span><br><span class="line">	monthMap[<span class="string">"December"</span>]=<span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> day,year;</span><br><span class="line">	<span class="built_in">string</span> month;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;day&gt;&gt;month&gt;&gt;year){</span><br><span class="line">		<span class="keyword">int</span> sumDays=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> year1=YEAR,year2=year;</span><br><span class="line">		<span class="keyword">int</span> month1=MONTH,month2=monthMap[month];</span><br><span class="line">		<span class="keyword">int</span> day1=DAY,day2=day;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//保证year1与year2对应日期大者在后</span></span><br><span class="line">		<span class="keyword">if</span>(year1&gt;year2){</span><br><span class="line">			swap(year1,year2);</span><br><span class="line">			swap(month1,month2);</span><br><span class="line">			swap(day1,day2);</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">if</span>(year1==year2) {</span><br><span class="line">			<span class="keyword">if</span>(month1&gt;month2){</span><br><span class="line">				swap(month1,month2);</span><br><span class="line">				swap(day1,day2);</span><br><span class="line">			}<span class="keyword">else</span> <span class="keyword">if</span>(month1==month2){</span><br><span class="line">				<span class="keyword">if</span>(day1&gt;day2){</span><br><span class="line">					swap(day1,day2);</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(year1==year2){</span><br><span class="line">			<span class="keyword">if</span>(month1==month2){</span><br><span class="line"></span><br><span class="line">				<span class="comment">//month1(month2)</span></span><br><span class="line">				sumDays=day2-day1+<span class="number">1</span>;</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				<span class="comment">//month1</span></span><br><span class="line">				<span class="keyword">int</span> index=isLeap(year1);</span><br><span class="line">				sumDays+=monthDays[index][month1]-day1+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//month1+1~month2-1</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> month=month1+<span class="number">1</span>;month&lt;month2;month++){</span><br><span class="line">					sumDays+=monthDays[index][month];</span><br><span class="line">				}</span><br><span class="line"></span><br><span class="line">				<span class="comment">//month2</span></span><br><span class="line">				sumDays+=day2;</span><br><span class="line">			}</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			<span class="comment">//year1</span></span><br><span class="line">			<span class="keyword">int</span> index=isLeap(year1);</span><br><span class="line">			sumDays+=monthDays[index][month1]-day1+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> month=month1+<span class="number">1</span>;month&lt;=<span class="number">12</span>;month++){</span><br><span class="line">				sumDays+=monthDays[index][month];</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="comment">//year1+1~year2-1</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> year=year1+<span class="number">1</span>;year&lt;year2;year++){</span><br><span class="line">				<span class="keyword">if</span>(isLeap(year)){</span><br><span class="line">					sumDays+=<span class="number">366</span>;</span><br><span class="line">				}<span class="keyword">else</span>{</span><br><span class="line">					sumDays+=<span class="number">365</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="comment">//year2</span></span><br><span class="line">			index=isLeap(year2);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> month=<span class="number">1</span>;month&lt;month2;month++){</span><br><span class="line">				sumDays+=monthDays[index][month];</span><br><span class="line">			}</span><br><span class="line">			sumDays+=day2;</span><br><span class="line">		}</span><br><span class="line">		sumDays--; <span class="comment">//原先计算值是两日期之差，包含两日期在内</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> rest=(sumDays+dayWeek)%<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;dayName[rest]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="打印日期"><a href="#打印日期" class="headerlink" title="打印日期"></a>打印日期</h2><p><strong>题目描述</strong><br>给出年分m和一年中的第n天，算出第n天是几月几号。<br><strong>输入</strong><br>输入包括两个整数y(1&lt;=y&lt;=3000)，n(1&lt;=n&lt;=366)。<br><strong>输出</strong><br>可能有多组测试数据，对于每组数据，按 yyyy-mm-dd的格式将输入中对应的日期打印出来。<br><strong>样例输入</strong><br>2013 60<br>2012 300<br>2011 350<br>2000 211<br><strong>样例输出</strong><br>2013-03-01<br>2012-10-26<br>2011-12-16<br>2000-07-29<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> monthDays[<span class="number">2</span>][<span class="number">13</span>]={</span><br><span class="line">	<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>, <span class="comment">//非闰年各月天数</span></span><br><span class="line">	<span class="number">0</span>,<span class="number">31</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>  <span class="comment">//闰年各月天数</span></span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeap</span><span class="params">(<span class="keyword">int</span> year)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>((year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>)||(year%<span class="number">400</span>==<span class="number">0</span>)){</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> year,n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;year&gt;&gt;n){</span><br><span class="line">		<span class="keyword">int</span> sumDays=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> index=isLeap(year);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> month=<span class="number">1</span>;month&lt;=<span class="number">12</span>;month++){</span><br><span class="line">			<span class="keyword">if</span>(n-sumDays&gt;=monthDays[index][month]){</span><br><span class="line">				sumDays+=monthDays[index][month];</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				<span class="keyword">if</span>(n-sumDays==<span class="number">0</span>){</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"%04d-%02d-%02d\n"</span>,year,month<span class="number">-1</span>,monthDays[index][month<span class="number">-1</span>]);</span><br><span class="line">				}<span class="keyword">else</span>{</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"%04d-%02d-%02d\n"</span>,year,month,n-sumDays);</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><p><strong>题目描述</strong><br>编写一个日期类，要求按xxxx-xx-xx 的格式输出日期，实现加一天的操作。<br><strong>输入</strong><br>输入第一行表示测试用例的个数m，接下来m行每行有3个用空格隔开的整数，分别表示年月日。测试数据不会有闰年。<br><strong>输出</strong><br>输出m行。按xxxx-xx-xx的格式输出，表示输入日期的后一天的日期。<br><strong>样例输入</strong><br>2<br>1999 10 20<br>2001 1 31<br><strong>样例输出</strong><br>1999-10-21<br>2001-02-01<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>{</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Date(){}</span><br><span class="line">		Date(<span class="keyword">int</span> Year,<span class="keyword">int</span> Month,<span class="keyword">int</span> Day):year(Year),month(Month),day(Day){}</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">addOneDay</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">printfNextDay</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span> year;</span><br><span class="line">		<span class="keyword">int</span> month;</span><br><span class="line">		<span class="keyword">int</span> day;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span> monthDays[<span class="number">2</span>][<span class="number">13</span>]={</span><br><span class="line">			{<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>}, <span class="comment">//非闰年各月天数</span></span><br><span class="line">			{<span class="number">0</span>,<span class="number">31</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>}  <span class="comment">//闰年各月天数</span></span><br><span class="line">		};</span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">isLeap</span><span class="params">(<span class="keyword">int</span> year)</span></span>{</span><br><span class="line">			<span class="keyword">if</span>((year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>)||(year%<span class="number">400</span>==<span class="number">0</span>)){</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">void</span> Date::addOneDay(){</span><br><span class="line">	<span class="keyword">int</span> index=isLeap(<span class="keyword">this</span>-&gt;year);</span><br><span class="line">	<span class="keyword">int</span> days=<span class="keyword">this</span>-&gt;day+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(days&gt;monthDays[index][<span class="keyword">this</span>-&gt;month]){</span><br><span class="line">		<span class="keyword">this</span>-&gt;day=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;month=(<span class="keyword">this</span>-&gt;month+<span class="number">1</span>)%<span class="number">13</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>-&gt;month==<span class="number">0</span>){</span><br><span class="line">			<span class="keyword">this</span>-&gt;month=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;year++;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	}<span class="keyword">else</span>{</span><br><span class="line">		<span class="keyword">this</span>-&gt;day++;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">void</span> Date::printfNextDay()<span class="keyword">const</span>{</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%04d-%02d-%02d\n"</span>,<span class="keyword">this</span>-&gt;year,<span class="keyword">this</span>-&gt;month,<span class="keyword">this</span>-&gt;day);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(n--){</span><br><span class="line">		<span class="keyword">int</span> year,month,day;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;year&gt;&gt;month&gt;&gt;day;</span><br><span class="line">		<span class="function">Date <span class="title">date</span><span class="params">(year,month,day)</span></span>;</span><br><span class="line">		date.addOneDay();</span><br><span class="line">		date.printfNextDay();</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="日期累加"><a href="#日期累加" class="headerlink" title="日期累加"></a>日期累加</h2><p><strong>题目描述</strong><br>设计一个程序能计算一个日期加上若干天后是什么日期。<br><strong>输入</strong><br>输入第一行表示样例个数m，接下来m行每行四个整数分别表示年月日和累加的天数。<br><strong>输出</strong><br>输出m行，每行按yyyy-mm-dd的个数输出。<br><strong>样例输入</strong><br>1<br>2008 2 3 100<br><strong>样例输出</strong><br>2008-05-13<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> monthDays[<span class="number">2</span>][<span class="number">13</span>]={</span><br><span class="line">	{<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>}, <span class="comment">//the number of days per months in a non-leap year</span></span><br><span class="line">	{<span class="number">0</span>,<span class="number">31</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>}  <span class="comment">//the number of days per month in a leap year</span></span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeap</span><span class="params">(<span class="keyword">int</span> year)</span></span>{ <span class="comment">//Judge whether the parameter 'year' is the leap year.</span></span><br><span class="line">	<span class="keyword">if</span>((year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>)||(year%<span class="number">400</span>==<span class="number">0</span>)){</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">while</span>(n--){</span><br><span class="line">		<span class="keyword">int</span> year,month,day,days;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;year&gt;&gt;month&gt;&gt;day&gt;&gt;days;</span><br><span class="line">		<span class="keyword">int</span> index=isLeap(year);</span><br><span class="line">		<span class="keyword">if</span>(day+days&lt;=monthDays[index][month]){ <span class="comment">//The final date is still within this month.</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%04d-%02d-%02d\n"</span>,year,month,day+days);</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			days-=monthDays[index][month]-day; <span class="comment">//Subtract the remainning days of the month.</span></span><br><span class="line"></span><br><span class="line">			month=(month+<span class="number">1</span>)%<span class="number">13</span>;         <span class="comment">//Note that month must be between 1 and 12</span></span><br><span class="line">			<span class="keyword">if</span>(month==<span class="number">0</span>){				<span class="comment">//Arrive the next year</span></span><br><span class="line">				year++;</span><br><span class="line">				month=<span class="number">1</span>;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span>(days&gt;=monthDays[index][month]){ <span class="comment">//Substract all Full-Month days</span></span><br><span class="line">				days-=monthDays[index][month];</span><br><span class="line"></span><br><span class="line">				month=(month+<span class="number">1</span>)%<span class="number">13</span>;   <span class="comment">//As above</span></span><br><span class="line">				<span class="keyword">if</span>(month==<span class="number">0</span>){</span><br><span class="line">					year++;</span><br><span class="line">					month=<span class="number">1</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(days==<span class="number">0</span>){   <span class="comment">//It happens to be the last day of a month</span></span><br><span class="line">				month--;</span><br><span class="line">				<span class="keyword">if</span>(month==<span class="number">0</span>){</span><br><span class="line">					month=<span class="number">12</span>;</span><br><span class="line">					year--;</span><br><span class="line">				}</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%04d-%02d-%02d\n"</span>,year,month,monthDays[index][month]);</span><br><span class="line">			}<span class="keyword">else</span>{  <span class="comment">//The day of a month except the last day</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%04d-%02d-%02d\n"</span>,year,month,days);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1></blockquote><h2 id="又一版A-B"><a href="#又一版A-B" class="headerlink" title="又一版A+B"></a>又一版A+B</h2><p><strong>题目描述</strong><br>输入两个不超过整型定义的非负10进制整数A和B($&lt;=2^{31}-1$)，输出A+B的m (1 &lt; m &lt; 10)进制数。<br><strong>输入</strong><br>输入格式：测试输入包含若干测试用例。每个测试用例占一行，给出m和A，B的值。<br>当m为0时输入结束。<br><strong>输出</strong><br>输出格式：每个测试用例的输出占一行，输出A+B的m进制数。<br><strong>样例输入</strong><br>2 4 5<br>8 123 456<br>0<br><strong>样例输出</strong><br>1001<br>1103<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> m,a,b;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Use Class Vector instead of Class Stack</span></span><br><span class="line">	<span class="comment">//beacause Class Stack don't have the member function "void clear();"</span></span><br><span class="line">	<span class="comment">//that can clear up all elements of the stack.</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; vec;  </span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;m&amp;&amp;m!=<span class="number">0</span>){</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		vec.clear();</span><br><span class="line">		a+=b;</span><br><span class="line">		<span class="keyword">if</span>(a==<span class="number">0</span>) vec.push_back(a); <span class="comment">//The special situation of a</span></span><br><span class="line">		<span class="keyword">while</span>(a!=<span class="number">0</span>){   <span class="comment">//Convert base</span></span><br><span class="line">			<span class="keyword">int</span> tmp=a%m;</span><br><span class="line">			vec.push_back(tmp);</span><br><span class="line">			a/=m;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;::reverse_iterator rit;   <span class="comment">//Output the elements of Vector in reverse order</span></span><br><span class="line">		<span class="keyword">for</span>(rit=vec.rbegin();rit!=vec.rend();rit++){</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;*rit;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="数制转换"><a href="#数制转换" class="headerlink" title="数制转换"></a>数制转换</h2><p><strong>题目描述</strong><br>求任意两个不同进制非负整数的转换（2进制～16进制），所给整数在long所能表达的范围之内。<br>不同进制的表示符号为（0，1，…，9，a，b，…，f）或者（0，1，…，9，A，B，…，F）。<br><strong>输入</strong><br>输入只有一行，包含三个整数a，n，b。a表示其后的n 是a进制整数，b表示欲将a进制整数n转换成b进制整数。a，b是十进制整数，2 =&lt; a，b &lt;= 16。<br><strong>输出</strong><br>可能有多组测试数据，对于每组数据，输出包含一行，该行有一个整数为转换后的b进制数。输出时字母符号全部用大写表示，即（0，1，…，9，A，B，…，F）。<br><strong>样例输入</strong><br>4 123 10<br><strong>样例输出</strong><br>27<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> BASE[<span class="number">16</span>]={<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">long</span> a,b;</span><br><span class="line">	<span class="built_in">string</span> n;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; vec;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; res;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;n&gt;&gt;b){</span><br><span class="line">		<span class="keyword">long</span> result;</span><br><span class="line">		vec.clear();</span><br><span class="line">		res.clear();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n.length();i++){  <span class="comment">//'a' radix converts to '10' radix.</span></span><br><span class="line">			result+=(n[i]-<span class="string">'0'</span>)*<span class="built_in">pow</span>(a,n.length()-i<span class="number">-1</span>);</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(result==<span class="number">0</span>) vec.push_back(result);  <span class="comment">//The special situation of result</span></span><br><span class="line">		<span class="keyword">while</span>(result!=<span class="number">0</span>){              <span class="comment">//'10' radix converts to 'b' radix.</span></span><br><span class="line">			<span class="keyword">long</span> tmp=result%b;</span><br><span class="line">			vec.push_back(tmp);</span><br><span class="line">			result/=b;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size();i++){</span><br><span class="line">			res.push_back(BASE[vec[i]]);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=vec.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;res[i];</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="进制转换-1"><a href="#进制转换-1" class="headerlink" title="进制转换"></a>进制转换</h2><p><strong>题目描述</strong><br>将一个长度最多为30位数字的十进制非负整数转换为二进制数输出。<br><strong>输入</strong><br>多组数据，每行为一个长度不超过30位的十进制非负整数。<br>（注意是10进制数字的个数可能有30个，而非30bits的整数）<br><strong>输出</strong><br>每行输出对应的二进制数。<br><strong>样例输入</strong><br>985<br>211<br>1126<br><strong>样例输出</strong><br>1111011001<br>11010011<br>10001100110<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str){</span><br><span class="line">		<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">		<span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">		<span class="comment">//The loop will end when each character of the parameter 'str' of Class String</span></span><br><span class="line">		<span class="comment">//becomes the same character '0'.</span></span><br><span class="line">		<span class="keyword">while</span>(count!=str.length()){  </span><br><span class="line">			count=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> rest=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++){  <span class="comment">//Simulte the process of integer's division</span></span><br><span class="line">				<span class="keyword">int</span> tmp=rest;</span><br><span class="line">				rest=(rest*<span class="number">10</span>+str[i]-<span class="string">'0'</span>)%<span class="number">2</span>;</span><br><span class="line">				str[i]=(tmp*<span class="number">10</span>+str[i]-<span class="string">'0'</span>)/<span class="number">2</span>+<span class="string">'0'</span>;</span><br><span class="line">				<span class="keyword">if</span>(str[i]==<span class="string">'0'</span>){</span><br><span class="line">					count++;      <span class="comment">//Flag that records the state of every character of the parameter 'str'</span></span><br><span class="line">				}			</span><br><span class="line">			}</span><br><span class="line">			s.push(rest);</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//Output the binary result, first input last output.</span></span><br><span class="line">		<span class="keyword">while</span>(!s.empty()){</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;s.top();</span><br><span class="line">			s.pop();</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h2><p><strong>题目描述</strong><br>输入一个整数，将其转换成八进制数输出。<br><strong>输入</strong><br>输入包括一个整数N(0&lt;=N&lt;=100000)。<br><strong>输出</strong><br>可能有多组测试数据，对于每组数据，<br>输出N的八进制表示数。<br><strong>样例输入</strong><br>9<br>8<br>5<br><strong>样例输出</strong><br>11<br>10<br>5<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>) s.push(n); <span class="comment">//The special situation of n</span></span><br><span class="line">		<span class="keyword">while</span>(n){</span><br><span class="line">			s.push(n%<span class="number">8</span>);</span><br><span class="line">			n/=<span class="number">8</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">while</span>(!s.empty()){</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;s.top();</span><br><span class="line">			s.pop();</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h1></blockquote><h2 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h2><p><strong>题目描述</strong><br>不借用任何字符串库函数实现无冗余地接受两个字符串，然后把它们无冗余的连接起来。<br><strong>输入</strong><br>每一行包括两个字符串，长度不超过100。<br><strong>输出</strong><br>可能有多组测试数据，对于每组数据，<br>不借用任何字符串库函数实现无冗余地接受两个字符串，然后把它们无冗余的连接起来。<br>输出连接后的字符串。<br><strong>样例输入</strong><br>abc def<br><strong>样例输出</strong><br>abcdef<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">101</span>;</span><br><span class="line"><span class="keyword">char</span> ch1[MAX],ch2[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;ch1&gt;&gt;ch2){</span><br><span class="line">		<span class="keyword">int</span> index1=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(ch1[index1]!=<span class="string">'\0'</span>) ++index1;</span><br><span class="line">		<span class="keyword">int</span> index2=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(ch2[index2]!=<span class="string">'\0'</span>){</span><br><span class="line">			ch1[index1++]=ch2[index2++];</span><br><span class="line">		}</span><br><span class="line">		ch1[index1]=<span class="string">'\0'</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ch1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="首字母大写"><a href="#首字母大写" class="headerlink" title="首字母大写"></a>首字母大写</h2><p><strong>题目描述</strong><br>对一个字符串中的所有单词，如果单词的首字母不是大写字母，则把单词的首字母变成大写字母。<br>在字符串中，单词之间通过空白符分隔，空白符包括：空格(’ ‘)、制表符(‘\t’)、回车符(‘\r’)、换行符(‘\n’)。<br><strong>输入</strong><br>输入一行：待处理的字符串（长度小于100）。<br><strong>输出</strong><br>可能有多组测试数据，对于每组数据，<br>输出一行：转换后的字符串。<br><strong>样例输入</strong><br>if so, you already have a google account. you can sign in on the right.<br><strong>样例输出</strong><br>If So, You Already Have A Google Account. You Can Sign In On The Right.<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	<span class="keyword">while</span>(getline(<span class="built_in">cin</span>,str)){</span><br><span class="line">		<span class="keyword">char</span> pre=<span class="string">' '</span>;</span><br><span class="line">		<span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(str[index]!=<span class="string">'\0'</span>){</span><br><span class="line">			<span class="keyword">if</span>(pre==<span class="string">' '</span>||pre==<span class="string">'\t'</span>||pre==<span class="string">'\r'</span>||pre==<span class="string">'\n'</span>){ <span class="comment">//Judge whether the previous character is one of the Blank Characters.</span></span><br><span class="line">				<span class="keyword">if</span>(str[index]&gt;=<span class="string">'a'</span>&amp;&amp;str[index]&lt;=<span class="string">'z'</span>){</span><br><span class="line">					str[index]=str[index]+<span class="string">'A'</span>-<span class="string">'a'</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			pre=str[index];</span><br><span class="line">			index++;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="字符串的查找删除"><a href="#字符串的查找删除" class="headerlink" title="字符串的查找删除"></a>字符串的查找删除</h2><p><strong>题目描述</strong><br>给定一个短字符串（不含空格），再给定若干字符串，在这些字符串中删除所含有的短字符串。<br><strong>输入</strong><br>输入只有1组数据。<br>输入一个短字符串（不含空格），再输入若干字符串直到文件结束为止。<br><strong>输出</strong><br>删除输入的短字符串(不区分大小写)并去掉空格,输出。<br><strong>样例输入</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">in</span><br><span class="line">#include</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">  printf(" Hi ");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> sample;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(sample[l]==str[r])</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;sample;</span><br><span class="line">	getchar(); <span class="comment">//Erase line feeds</span></span><br><span class="line">	<span class="keyword">while</span>(getline(<span class="built_in">cin</span>,str)){</span><br><span class="line">		<span class="keyword">while</span>(str.find(sample)!=<span class="built_in">string</span>::npos){ <span class="comment">//Erase all specified strings in the string</span></span><br><span class="line">			<span class="keyword">int</span> index=str.find(sample);</span><br><span class="line">			str.erase(index,sample.length());</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">while</span>(str.find(<span class="string">" "</span>)!=<span class="built_in">string</span>::npos){  <span class="comment">//Erase all white spaces in the string</span></span><br><span class="line">			<span class="keyword">int</span> index=str.find(<span class="string">" "</span>);</span><br><span class="line">			str.erase(index,<span class="number">1</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="单词替换"><a href="#单词替换" class="headerlink" title="单词替换"></a>单词替换</h2><p><strong>题目描述</strong><br>输入一个字符串，以回车结束（字符串长度&lt;=100）。该字符串由若干个单词组成，单词之间用一个空格隔开，所有单词区分大小写。现需要将其中的某个单词替换成另一个单词，并输出替换之后的字符串。<br><strong>输入</strong><br>多组数据。每组数据输入包括3行，<br>第1行是包含多个单词的字符串 s，<br>第2行是待替换的单词a，(长度&lt;=100)<br>第3行是a将被替换的单词b。(长度&lt;=100)</p><p>s, a, b 最前面和最后面都没有空格。<br><strong>输出</strong><br>每个测试数据输出只有 1 行，<br>将s中所有单词a替换成b之后的字符串。<br><strong>样例输入</strong><br>I love Tian Qin<br>I<br>You<br><strong>样例输出</strong><br>You love Tian Qin<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> str,src,dst;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Warning: note the differences among the functions 'find()' and 'find_first_of()'</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(getline(<span class="built_in">cin</span>,str)){</span><br><span class="line">		getline(<span class="built_in">cin</span>,src);</span><br><span class="line">		getline(<span class="built_in">cin</span>,dst);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="string">":"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;src&lt;&lt;<span class="string">":"</span>&lt;&lt;dst&lt;&lt;<span class="string">":"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">int</span> index=str.find(src,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span>(index!=<span class="built_in">string</span>::npos){</span><br><span class="line">			<span class="keyword">if</span>( (index==<span class="number">0</span>||str[index<span class="number">-1</span>]==<span class="string">' '</span>)</span><br><span class="line">			    &amp;&amp;</span><br><span class="line">				(str[index+src.length()]==<span class="string">' '</span>||str[index+src.length()]==<span class="string">'\0'</span>)</span><br><span class="line">			  ){  </span><br><span class="line">			    <span class="comment">//The specified word which can be replaced</span></span><br><span class="line">			    <span class="comment">//may be between two white spaces,</span></span><br><span class="line">			    <span class="comment">//the first word of the sentence,</span></span><br><span class="line">			    <span class="comment">//or the last word of the sentence.</span></span><br><span class="line"></span><br><span class="line">				str.replace(index,src.length(),dst); <span class="comment">//Replace the specified word</span></span><br><span class="line"></span><br><span class="line">				index=str.find(src,index+dst.length());  <span class="comment">//Resume to find next word</span></span><br><span class="line"></span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">			    <span class="comment">//find the location of next word</span></span><br><span class="line">				index=str.find(<span class="string">' '</span>,index);</span><br><span class="line">				<span class="keyword">if</span>(index!=<span class="built_in">string</span>::npos)</span><br><span class="line">					index=str.find(src,index);</span><br><span class="line"></span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="字符串中去特定字符"><a href="#字符串中去特定字符" class="headerlink" title="字符串中去特定字符"></a>字符串中去特定字符</h2><p><strong>题目描述</strong><br>输入字符串s和字符c，要求去掉s中所有的c字符，并输出结果。<br><strong>输入</strong><br>测试数据有多组，每组输入字符串s和字符c。<br><strong>输出</strong><br>对于每组输入,输出去除c字符后的结果。<br><strong>样例输入</strong><br>goaod<br>a<br><strong>样例输出</strong><br>good<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">while</span>(getline(<span class="built_in">cin</span>,str)){</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">		<span class="keyword">while</span>(str.find(ch)!=<span class="built_in">string</span>::npos){</span><br><span class="line">			<span class="keyword">int</span> index=str.find(ch);</span><br><span class="line">			str.erase(index,<span class="number">1</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="数组逆置"><a href="#数组逆置" class="headerlink" title="数组逆置"></a>数组逆置</h2><p><strong>题目描述</strong><br>输入一个字符串，长度小于等于200，然后将数组逆置输出。<br><strong>输入</strong><br>测试数据有多组，每组输入一个字符串。<br><strong>输出</strong><br>对于每组输入,请输出逆置后的结果。<br><strong>样例输入</strong><br>tianqin<br><strong>样例输出</strong><br>niqnait<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	<span class="keyword">while</span>(getline(<span class="built_in">cin</span>,str)){</span><br><span class="line">		reverse(str.begin(),str.end());</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h2><p><strong>题目描述</strong><br>输入两个字符串，比较两字符串的长度大小关系。<br><strong>输入</strong><br>输入第一行表示测试用例的个数m，接下来m行每行两个字符串A和B，字符串长度不超过50。<br><strong>输出</strong><br>输出m行。若两字符串长度相等则输出A is equal long to B；若A比B长，则输出A is longer than B；否则输出A is shorter than B。<br><strong>样例输入</strong><br>2<br>abc xy<br>bbb ccc<br><strong>样例输出</strong><br>abc is longer than xy<br>bbb is equal long to ccc<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">string</span> a,b;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">while</span>(n--){</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		<span class="keyword">if</span>(a.length()&lt;b.length()){</span><br><span class="line">			swap(a,b);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(a.length()==b.length()){</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">" is equal long to "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">" is longer than "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="编排字符串"><a href="#编排字符串" class="headerlink" title="编排字符串"></a>编排字符串</h2><p><strong>题目描述</strong><br>请输入字符串，最多输入4 个字符串，要求后输入的字符串排在前面，例如<br>输入：EricZ<br>输出：1=EricZ<br>输入：David<br>输出：1=David 2=EricZ<br>输入：Peter<br>输出：1=Peter 2=David 3=EricZ<br>输入：Alan<br>输出：1=Alan 2=Peter 3=David 4=EricZ<br>输入：Jane<br>输出：1=Jane 2=Alan 3=Peter 4=David<br><strong>输入</strong><br>第一行为字符串个数m，接下来m行每行一个字符床，m不超过100，每个字符床长度不超过20。<br><strong>输出</strong><br>输出m行，每行按照样例格式输出，注意用一个空格隔开。<br><strong>样例输入</strong><br>5<br>EricZ<br>David<br>Peter<br>Alan<br>Jane<br><strong>样例输出</strong><br>1=EricZ<br>1=David 2=EricZ<br>1=Peter 2=David 3=EricZ<br>1=Alan 2=Peter 3=David 4=EricZ<br>1=Jane 2=Alan 3=Peter 4=David<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(m--){</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line">		vec.push_back(str);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> index=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=vec.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>&amp;&amp;index&lt;=<span class="number">4</span>;i--){</span><br><span class="line">			<span class="keyword">if</span>(i!=vec.size()<span class="number">-1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;index++&lt;&lt;<span class="string">"="</span>&lt;&lt;vec[i];</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="回文串"><a href="#回文串" class="headerlink" title="回文串"></a>回文串</h2><p><strong>题目描述</strong><br>读入一串字符，判断是否是回文串。“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。<br><strong>输入</strong><br>一行字符串，长度不超过255。<br><strong>输出</strong><br>如果是回文串，输出“YES”，否则输出“NO”。<br><strong>样例输入</strong><br>12321<br><strong>样例输出</strong><br>YES<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str){</span><br><span class="line">		<span class="built_in">string</span> tmp=str;</span><br><span class="line">		reverse(tmp.begin(),tmp.end());</span><br><span class="line">		<span class="keyword">if</span>(tmp==str){</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1></blockquote><h2 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h2><p><strong>题目描述</strong><br>对输入的n个数进行排序并输出。<br><strong>输入</strong><br>输入的第一行包括一个整数n(1&lt;=n&lt;=100)。 接下来的一行包括n个整数。<br><strong>输出</strong><br>可能有多组测试数据，对于每组数据，将排序后的n个整数输出，每个数后面都有一个空格。<br>每组测试数据的结果占一行。<br><strong>样例输入</strong><br>5<br>5 4 3 1 2<br><strong>样例输出</strong><br>1 2 3 4 5<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">		<span class="keyword">while</span>(n--){</span><br><span class="line">			<span class="keyword">int</span> tmp;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">			vec.push_back(tmp);</span><br><span class="line">		}</span><br><span class="line">		sort(vec.begin(),vec.end(),less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">		<span class="keyword">for</span>(it=vec.begin();it!=vec.end();it++){</span><br><span class="line">			<span class="keyword">if</span>(it!=vec.begin()) <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;*it;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="特殊排序"><a href="#特殊排序" class="headerlink" title="特殊排序"></a>特殊排序</h2><p><strong>题目描述</strong><br>输入一系列整数，将其中最大的数挑出，并将剩下的数进行排序。<br><strong>输入</strong><br>输入第一行包括1个整数N，1&lt;=N&lt;=1000，代表输入数据的个数。<br>接下来的一行有N个整数。<br><strong>输出</strong><br>可能有多组测试数据，对于每组数据，<br>第一行输出一个整数，代表N个整数中的最大值，并将此值从数组中去除，将剩下的数进行排序。<br>第二行将排序的结果输出。<br><strong>样例输入</strong><br>5<br>5 3 2 4 1<br><strong>样例输出</strong><br>5<br>1 2 3 4<br><strong>提示</strong><br>如果数组中只有一个数，当第一行将其输出后，第二行请输出”-1”。<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">		<span class="keyword">while</span>(n--){</span><br><span class="line">			<span class="keyword">int</span> tmp;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">			vec.push_back(tmp);</span><br><span class="line">		}</span><br><span class="line">		sort(vec.begin(),vec.end(),less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;vec[vec.size()<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=vec.begin();it!=--vec.end();it++){</span><br><span class="line">			<span class="keyword">if</span>(it!=vec.begin()) <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;*it;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(vec.size()==<span class="number">1</span>){</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Excel排序"><a href="#Excel排序" class="headerlink" title="Excel排序"></a>Excel排序</h2><p><strong>题目描述</strong><br>Excel可以对一组纪录按任意指定列排序。现请你编写程序实现类似功能。<br>对每个测试用例，首先输出1行“Case i:”，其中 i 是测试用例的编号（从1开始）。随后在 N 行中输出按要求排序后的结果，即：当 C=1 时，按学号递增排序；当 C=2时，按姓名的非递减字典序排序；当 C=3 时，按成绩的非递减排序。当若干学生具有相同姓名或者相同成绩时，则按他们的学号递增排序。<br><strong>输入</strong><br>测试输入包含若干测试用例。每个测试用例的第1行包含两个整数 N (N&lt;=100000) 和 C，其中 N 是纪录的条数，C 是指定排序的列号。以下有N行，每行包含一条学生纪录。每条学生纪录由学号（6位数字，同组测试中没有重复的学号）、姓名（不超过8位且不包含空格的字符串）、成绩（闭区间[0, 100]内的整数）组成，每个项目间用1个空格隔开。当读到 N=0 时，全部输入结束，相应的结果不要输出。<br><strong>输出</strong><br>对每个测试用例，首先输出1行“Case i:”，其中 i 是测试用例的编号（从1开始）。随后在 N 行中输出按要求排序后的结果，即：当 C=1 时，按学号递增排序；当 C=2时，按姓名的非递减字典序排序；当 C=3 时，按成绩的非递减排序。当若干学生具有相同姓名或者相同成绩时，则按他们的学号递增排序。<br><strong>样例输入</strong><br>4 1<br>000001 Zhao 75<br>000004 Qian 88<br>000003 Li 64<br>000002 Sun 90<br>4 2<br>000005 Zhao 95<br>000011 Zhao 75<br>000007 Qian 68<br>000006 Sun 85<br>4 3<br>000002 Qian 88<br>000015 Li 95<br>000012 Zhao 70<br>000009 Sun 95<br>0 3<br><strong>样例输出</strong><br>Case 1:<br>000001 Zhao 75<br>000002 Sun 90<br>000003 Li 64<br>000004 Qian 88<br>Case 2:<br>000007 Qian 68<br>000006 Sun 85<br>000005 Zhao 95<br>000011 Zhao 75<br>Case 3:<br>000012 Zhao 70<br>000002 Qian 88<br>000009 Sun 95<br>000015 Li 95<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>{</span></span><br><span class="line">	<span class="built_in">string</span> id;     <span class="comment">//Student ID</span></span><br><span class="line">	<span class="built_in">string</span> name;   <span class="comment">//Student Name</span></span><br><span class="line">	<span class="keyword">int</span> score;     <span class="comment">//Student Score</span></span><br><span class="line">	<span class="keyword">int</span> item;      <span class="comment">//Sort Item that represents the different sort means</span></span><br><span class="line">	Student(){}    <span class="comment">//Default Consructor</span></span><br><span class="line">	Student(<span class="built_in">string</span> ID,<span class="built_in">string</span> Name,<span class="keyword">int</span> Score,<span class="keyword">int</span> Item)  <span class="comment">//Custom Constructor</span></span><br><span class="line">	:id(ID),name(Name),score(Score),item(Item){}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Student b) <span class="keyword">const</span>{ <span class="comment">//Comparing Operator Rewriting</span></span><br><span class="line">		<span class="keyword">bool</span> result=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span>(item){  <span class="comment">//Select a particular sort method based on 'item'</span></span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:{   <span class="comment">//Base on 'id'</span></span><br><span class="line">				result=<span class="keyword">this</span>-&gt;id&lt;b.id;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:{   <span class="comment">//Base on 'name' when two students have different names</span></span><br><span class="line">				<span class="keyword">if</span>(<span class="keyword">this</span>-&gt;name!=b.name){</span><br><span class="line">					result=<span class="keyword">this</span>-&gt;name&lt;b.name;</span><br><span class="line">				}<span class="keyword">else</span>{</span><br><span class="line">					result=<span class="keyword">this</span>-&gt;id&lt;b.id;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:{   <span class="comment">//Base on 'score when two students have different scores</span></span><br><span class="line">				<span class="keyword">if</span>(<span class="keyword">this</span>-&gt;score!=b.score){</span><br><span class="line">					result=<span class="keyword">this</span>-&gt;score&lt;b.score;</span><br><span class="line">				}<span class="keyword">else</span>{</span><br><span class="line">					result=<span class="keyword">this</span>-&gt;id&lt;b.id;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">toString</span><span class="params">()</span></span>{  <span class="comment">//Print the information</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;id&lt;&lt;<span class="string">" "</span>&lt;&lt;name&lt;&lt;<span class="string">" "</span>&lt;&lt;score&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">string</span> id,name;</span><br><span class="line">	<span class="keyword">int</span> score;</span><br><span class="line">	<span class="keyword">int</span> n,item;</span><br><span class="line">	<span class="keyword">int</span> nCase=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;item&amp;&amp;n!=<span class="number">0</span>){</span><br><span class="line">		nCase++;</span><br><span class="line">		<span class="built_in">vector</span>&lt;Student&gt; vec;</span><br><span class="line">		<span class="comment">//Input data</span></span><br><span class="line">		<span class="keyword">while</span>(n--){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;id&gt;&gt;name&gt;&gt;score;</span><br><span class="line">			vec.push_back(Student(id,name,score,item));</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">//Sort data</span></span><br><span class="line">		sort(vec.begin(),vec.end());</span><br><span class="line"></span><br><span class="line">		<span class="comment">//Print data</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Case "</span>&lt;&lt;nCase&lt;&lt;<span class="string">":"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">vector</span>&lt;Student&gt;::iterator it;</span><br><span class="line">		<span class="keyword">for</span>(it=vec.begin();it!=vec.end();it++){				</span><br><span class="line">			it-&gt;toString();</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="字符串内排序"><a href="#字符串内排序" class="headerlink" title="字符串内排序"></a>字符串内排序</h2><p><strong>题目描述</strong><br>输入一个字符串，长度小于等于200，然后将输出按字符顺序升序排序后的字符串。<br><strong>输入</strong><br>测试数据有多组，输入字符串。<br><strong>输出</strong><br>对于每组输入,输出处理后的结果。<br><strong>样例输入</strong><br>tianqin<br><strong>样例输出</strong><br>aiinnqt<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	<span class="keyword">while</span> (getline(<span class="built_in">cin</span>, str)) {</span><br><span class="line">		sort(str.begin(), str.end(),less&lt;<span class="keyword">char</span>&gt;());</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		str.clear();</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Problem-B"><a href="#Problem-B" class="headerlink" title="Problem B"></a>Problem B</h2><p><strong>题目描述</strong><br>请写一个程序，对于一个m行m列的（1&lt;m&lt;10）的方阵，求其每一行，每一列及主对角线元素之和，最后按照从大到小的顺序依次输出。<br><strong>输入</strong><br>共一组数据，输入的第一行为一个正整数，表示m，接下来的m行，每行m个整数表示方阵元素。<br><strong>输出</strong><br>从大到小排列的一行整数，每个整数后跟一个空格，最后换行。<br><strong>样例输入</strong><br>4<br>15 8 -2 6<br>31 24 18 71<br>-3 -9 27 13<br>17 21 38 69<br><strong>样例输出</strong><br>159 145 144 135 81 60 44 32 28 27<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Parameters that respectively represents the sum of each row, column, diagnal line</span></span><br><span class="line">	<span class="keyword">int</span> *row,*col,*diag;</span><br><span class="line">	row=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">	col=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">	diag=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initiate all arrays</span></span><br><span class="line">	fill(row,row+n,<span class="number">0</span>);</span><br><span class="line">	fill(col,col+n,<span class="number">0</span>);</span><br><span class="line">	fill(diag,diag+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Input</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">			<span class="keyword">int</span> tmp;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">			row[i]+=tmp;</span><br><span class="line">			col[j]+=tmp;</span><br><span class="line">			<span class="keyword">if</span>(i==j) diag[<span class="number">0</span>]+=tmp;</span><br><span class="line">			<span class="keyword">if</span>(i+j==n<span class="number">-1</span>) diag[<span class="number">1</span>]+=tmp;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Vector used to sort all data</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">		vec.push_back(row[i]);</span><br><span class="line">		vec.push_back(col[i]);</span><br><span class="line">	}</span><br><span class="line">	vec.push_back(diag[<span class="number">0</span>]);</span><br><span class="line">	vec.push_back(diag[<span class="number">1</span>]);</span><br><span class="line">	sort(vec.begin(),vec.end(),greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Output</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=vec.begin();it!=vec.end();it++){</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Free memory</span></span><br><span class="line">	<span class="keyword">delete</span> [] row;</span><br><span class="line">	<span class="keyword">delete</span> [] col;</span><br><span class="line">	<span class="keyword">delete</span> [] diag;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="小白鼠排队"><a href="#小白鼠排队" class="headerlink" title="小白鼠排队"></a>小白鼠排队</h2><p><strong>题目描述</strong><br>N只小白鼠(1 &lt;= N &lt;= 100)，每只鼠头上戴着一顶有颜色的帽子。现在称出每只白鼠的重量，要求按照白鼠重量从大到小的顺序输出它们头上帽子的颜色。帽子的颜色用“red”，“blue”等字符串来表示。不同的小白鼠可以戴相同颜色的帽子。白鼠的重量用整数表示。<br><strong>输入</strong><br>多案例输入，每个案例的输入第一行为一个整数N，表示小白鼠的数目。<br>下面有N行，每行是一只白鼠的信息。第一个为不大于100的正整数，表示白鼠的重量，；第二个为字符串，表示白鼠的帽子颜色，字符串长度不超过10个字符。<br>注意：白鼠的重量各不相同。<br><strong>输出</strong><br>每个案例按照白鼠的重量从大到小的顺序输出白鼠的帽子颜色。<br><strong>样例输入</strong><br>1<br>79 omi<br>9<br>46 lcg<br>92 cru<br>37 ceq<br>54 vhr<br>17 wus<br>27 tnv<br>13 kyr<br>95 wld<br>34 qox<br><strong>样例输出</strong><br>omi<br>wld<br>cru<br>vhr<br>lcg<br>ceq<br>qox<br>tnv<br>wus<br>kyr<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mouse</span> {</span></span><br><span class="line">	<span class="keyword">int</span> heavy;</span><br><span class="line">	<span class="built_in">string</span> color;</span><br><span class="line">	Mouse(<span class="keyword">int</span> h, <span class="built_in">string</span> c) {</span><br><span class="line">		heavy = h;</span><br><span class="line">		color = c;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Mouse &amp; m)<span class="keyword">const</span> {</span><br><span class="line">		<span class="keyword">return</span> heavy &gt; m.heavy;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">vector</span>&lt;Mouse&gt; vec;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) {</span><br><span class="line">		vec.clear();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">			<span class="keyword">int</span> h;</span><br><span class="line">			<span class="built_in">string</span> str;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; h &gt;&gt; str;</span><br><span class="line">			vec.push_back(Mouse(h, str));</span><br><span class="line">		}</span><br><span class="line">		sort(vec.begin(), vec.end());</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Mouse&gt;::iterator it = vec.begin(); it != vec.end(); it++) {</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; it-&gt;color &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="中位数"><a href="#中位数" class="headerlink" title="中位数"></a>中位数</h2><p><strong>题目描述</strong><br>中位数定义：一组数据按从小到大的顺序依次排列，处在中间位置的一个数（或最中间两个数据的平均数）.<br>给出一组无序整数，求出中位数，如果求最中间两个数的平均数，向下取整即可（不需要使用浮点数）<br><strong>输入</strong><br>该程序包含多组测试数据，每一组测试数据的第一行为N，代表该组测试数据包含的数据个数，1&lt;=N&lt;=10000.<br>接着N行为N个数据的输入，N=0时结束输入<br><strong>输出</strong><br>输出中位数，每一组测试数据输出一行<br><strong>样例输入</strong><br>1<br>468<br>15<br>501<br>170<br>725<br>479<br>359<br>963<br>465<br>706<br>146<br>282<br>828<br>962<br>492<br>996<br>943<br>0<br><strong>样例输出</strong><br>468<br>501</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n&amp;&amp;n!=<span class="number">0</span>) {</span><br><span class="line">		vec.clear();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">			<span class="keyword">double</span> temp;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">			vec.push_back(temp);</span><br><span class="line">		}</span><br><span class="line">		sort(vec.begin(), vec.end());</span><br><span class="line">		<span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">0</span>) {</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">floor</span>((vec[n / <span class="number">2</span>] + vec[n / <span class="number">2</span> - <span class="number">1</span>])/<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> {</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; vec[n / <span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>##整数奇偶排序</p><p><strong>题目描述</strong><br>输入10个整数，彼此以空格分隔。重新排序以后输出(也按空格分隔)，要求:<br>1.先输出其中的奇数,并按从大到小排列；<br>2.然后输出其中的偶数,并按从小到大排列。<br><strong>输入</strong><br>任意排序的10个整数（0～100），彼此以空格分隔。<br><strong>输出</strong><br>可能有多组测试数据，对于每组数据，按照要求排序后输出，由空格分隔。<br><strong>样例输入</strong><br>0 56 19 81 59 48 35 90 83 75<br>17 86 71 51 30 1 9 36 14 16<br><strong>样例输出</strong><br>83 81 75 59 35 19 0 48 56 90<br>71 51 17 9 1 14 16 30 36 86</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecA, vecB;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; x) {</span><br><span class="line">		flag++;</span><br><span class="line">		<span class="keyword">if</span> ((x &amp; <span class="number">1</span>) != <span class="number">0</span>) {</span><br><span class="line">			vecA.push_back(x);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> {</span><br><span class="line">			vecB.push_back(x);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (flag % <span class="number">10</span> == <span class="number">0</span>) {</span><br><span class="line">			flag = <span class="number">0</span>;</span><br><span class="line">			sort(vecA.begin(), vecA.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">			sort(vecB.begin(), vecB.end(), less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">			<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = vecA.begin(); it != vecA.end(); it++) {</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = vecB.begin(); it != vecB.end(); it++) {</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line">				<span class="keyword">if</span> (it != vecB.end() - <span class="number">1</span>) {</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			vecA.clear();</span><br><span class="line">			vecB.clear();</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="排名"><a href="#排名" class="headerlink" title="排名"></a>排名</h2><p><strong>题目描述</strong><br>今天的上机考试虽然有实时的Ranklist，但上面的排名只是根据完成的题数排序，没有考虑每题的分值，所以并不是最后的排名。给定录取分数线，请你写程序找出最后通过分数线的考生，并将他们的成绩按降序打印。<br><strong>输入</strong><br>测试输入包含若干场考试的信息。每场考试信息的第1行给出考生人数N ( 0 &lt; N &lt; 1000 )、考题数M ( 0 &lt; M &lt; = 10 )、分数线（正整数）G；第2行排序给出第1题至第M题的正整数分值；以下N行，每行给出一名考生的准考证号（长度不超过20的字符串）、该生解决的题目总数m、以及这m道题的题号（题目号由1到M）。<br>当读入的考生人数为0时，输入结束，该场考试不予处理。<br><strong>输出</strong><br>对每场考试，首先在第1行输出不低于分数线的考生人数n，随后n行按分数从高到低输出上线考生的考号与分数，其间用1空格分隔。若有多名考生分数相同，则按他们考号的升序输出。<br><strong>样例输入</strong><br>3 5 32<br>17 10 12 9 15<br>CS22003 5 1 2 3 4 5<br>CS22004 3 5 1 3<br>CS22002 2 1 5<br>0<br><strong>样例输出</strong><br>3<br>CS22003 63<br>CS22004 44<br>CS22002 32</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> {</span></span><br><span class="line">	<span class="built_in">string</span> id;</span><br><span class="line">	<span class="keyword">int</span> score;</span><br><span class="line">	Node(<span class="built_in">string</span> Id, <span class="keyword">int</span> Score) {</span><br><span class="line">		id = Id;</span><br><span class="line">		score = Score;</span><br><span class="line">	}</span><br><span class="line">	Node() {}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp; s) <span class="keyword">const</span> {</span><br><span class="line">		<span class="keyword">return</span> score &gt; s.score;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; vec;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; result;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nQuestion;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> n, m, g;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; g &amp;&amp; n != <span class="number">0</span>) {</span><br><span class="line">		vec.clear();</span><br><span class="line">		result.clear();</span><br><span class="line">		nQuestion.clear();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">			<span class="keyword">int</span> temp;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">			nQuestion.push_back(temp);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">			<span class="built_in">string</span> id;</span><br><span class="line">			<span class="keyword">int</span> x;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; id &gt;&gt; x;</span><br><span class="line">			vec.push_back(Node(id, <span class="number">0</span>));</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x; j++) {</span><br><span class="line">				<span class="keyword">int</span> temp;</span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">				vec[i].score += nQuestion[temp - <span class="number">1</span>];</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		sort(vec.begin(), vec.end());</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Node&gt;::iterator it = vec.begin(); it != vec.end(); it++) {</span><br><span class="line">			<span class="keyword">if</span> (it-&gt;score &gt;= g) {</span><br><span class="line">				result.push_back(*it);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Node&gt;::iterator it = result.begin(); it != result.end(); it++) {</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; it-&gt;id &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="谁是你的潜在朋友"><a href="#谁是你的潜在朋友" class="headerlink" title="谁是你的潜在朋友"></a>谁是你的潜在朋友</h2><p><strong>题目描述</strong><br> “臭味相投”——这是我们描述朋友时喜欢用的词汇。两个人是朋友通常意味着他们存在着许多共同的兴趣。然而作为一个宅男，你发现自己与他人相互了解的机会 并不太多。幸运的是，你意外得到了一份北大图书馆的图书借阅记录，于是你挑灯熬夜地编程，想从中发现潜在的朋友。<br> 首先你对借阅记录进行了一番整理，把N个读者依次编号为1,2,…,N，把M本书依次编号为1,2,…,M。同时，按照“臭味相投”的原则，和你喜欢读同一本书的人，就是你的潜在朋友。你现在的任务是从这份借阅记录中计算出每个人有几个潜在朋友。</p><p><strong>输入</strong><br> 每个案例第一行两个整数N,M，2 &lt;= N ，M&lt;= 200。接下来有N行，第i(i = 1,2,…,N)行每一行有一个数，表示读者i-1最喜欢的图书的编号P(1&lt;=P&lt;=M)</p><p><strong>输出</strong><br> 每个案例包括N行，每行一个数，第i行的数表示读者i有几个潜在朋友。如果i和任何人都没有共同喜欢的书，则输出“BeiJu”（即悲剧，^ ^）</p><p><strong>样例输入</strong><br>4 5<br>2<br>3<br>2<br>1<br><strong>样例输出</strong><br>1<br>BeiJu<br>1<br>BeiJu</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec; <span class="comment">//The array records the data of books that everyone likes.</span></span><br><span class="line"><span class="keyword">int</span> hashTable[<span class="number">201</span>];    <span class="comment">//The array records the sum of each book.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) {</span><br><span class="line">		vec.resize(n,<span class="number">0</span>); <span class="comment">//Initiate the vector</span></span><br><span class="line">		fill(hashTable,hashTable+<span class="number">201</span>,<span class="number">0</span>); <span class="comment">//as above</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="keyword">int</span> temp;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">			vec[i]=temp;</span><br><span class="line">			hashTable[temp]++;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="keyword">if</span>(hashTable[vec[i]]&lt;<span class="number">2</span>){</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"BeiJu"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;hashTable[vec[i]]<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="分组统计"><a href="#分组统计" class="headerlink" title="分组统计"></a>分组统计</h2><p><strong>题目描述</strong><br>先输入一组数，然后输入其分组，按照分组统计出现次数并输出，参见样例。<br><strong>输入</strong><br>输入第一行表示样例数m，对于每个样例，第一行为数的个数n，接下来两行分别有n个数，第一行有n个数，第二行的n个数分别对应上一行每个数的分组，n不超过100。<br><strong>输出</strong><br>输出m行，格式参见样例，按从小到大排。<br><strong>样例输入</strong><br>1<br>7<br>3 2 3 8 8 2 3<br>1 2 3 2 1 3 1<br><strong>样例输出</strong><br>1={2=0,3=2,8=1}<br>2={2=1,3=0,8=1}<br>3={2=1,3=1,8=0}</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; Link[<span class="number">101</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; noMulti;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;  Set;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">	<span class="keyword">while</span> (m--) {</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		vec.clear();</span><br><span class="line">		noMulti.clear();</span><br><span class="line">		Set.clear();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) {</span><br><span class="line">			Link[i].clear();</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">			<span class="keyword">int</span> temp;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">			Set.insert(temp);</span><br><span class="line">			vec.push_back(temp);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">			<span class="keyword">int</span> temp;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">			Link[temp].insert(vec[i]);</span><br><span class="line">			noMulti.insert(temp);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = noMulti.begin(); it != noMulti.end(); it++) {</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">"={"</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator its = Set.begin(); its != Set.end(); its++) {</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; *its &lt;&lt; <span class="string">"="</span> &lt;&lt; Link[*it].count(*its);</span><br><span class="line">				<span class="keyword">if</span> (its != --Set.end()) {</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; <span class="string">","</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"}"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Be-Unique"><a href="#Be-Unique" class="headerlink" title="Be Unique"></a>Be Unique</h2><p><strong>题目描述</strong><br>Being unique is so important to people on Mars that even their lottery is designed in a unique way. The rule of winning is simple: one bets on a number chosen from [1, 104]. The first one who bets on a unique number wins. For example, if there are 7 people betting on 5 31 5 88 67 88 17, then the second one who bets on 31 wins.<br><strong>输入</strong><br>Each input file contains one test case. Each case contains a line which begins with a positive integer N (&lt;=105) and then followed by N bets. The numbers are separated by a space.<br><strong>输出</strong><br>For each test case, print the winning number in a line. If there is no winner, print “None” instead.<br><strong>样例输入</strong><br>7 5 31 5 88 67 88 17<br>5 888 666 666 888 888<br><strong>样例输出</strong><br>31<br>None</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Method 1:</span></span><br><span class="line"><span class="comment">//Hash</span></span><br><span class="line"><span class="comment">/*const int MAX_SIZE=10001;</span></span><br><span class="line"><span class="comment">int isUnique[MAX_SIZE];</span></span><br><span class="line"><span class="comment">vector&lt;int&gt; vec;</span></span><br><span class="line"><span class="comment">int main() {</span></span><br><span class="line"><span class="comment">	int n;</span></span><br><span class="line"><span class="comment">	while(cin&gt;&gt;n){</span></span><br><span class="line"><span class="comment">		vec.resize(n,0);</span></span><br><span class="line"><span class="comment">		fill(isUnique,isUnique+MAX_SIZE,0);</span></span><br><span class="line"><span class="comment">		for(int i=0;i&lt;n;i++){</span></span><br><span class="line"><span class="comment">			cin&gt;&gt;vec[i];</span></span><br><span class="line"><span class="comment">			isUnique[vec[i]]++;</span></span><br><span class="line"><span class="comment">		}</span></span><br><span class="line"><span class="comment">		bool isExist=false;</span></span><br><span class="line"><span class="comment">		for(int i=0;i&lt;n;i++){</span></span><br><span class="line"><span class="comment">			if(isUnique[vec[i]]==1){</span></span><br><span class="line"><span class="comment">				isExist=true;</span></span><br><span class="line"><span class="comment">				cout&lt;&lt;vec[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">				break;</span></span><br><span class="line"><span class="comment">			}</span></span><br><span class="line"><span class="comment">		}</span></span><br><span class="line"><span class="comment">		if(!isExist){</span></span><br><span class="line"><span class="comment">			cout&lt;&lt;"None"&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">		}</span></span><br><span class="line"><span class="comment">	}</span></span><br><span class="line"><span class="comment">	return 0;</span></span><br><span class="line"><span class="comment">}*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Method 2:</span></span><br><span class="line"><span class="comment">//MultiSet</span></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; mulSet;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		vec.resize(n,<span class="number">0</span>);</span><br><span class="line">		mulSet.clear();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;vec[i];</span><br><span class="line">			mulSet.insert(vec[i]);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">bool</span> isExist=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="keyword">if</span>(mulSet.count(vec[i])==<span class="number">1</span>){</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;vec[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				isExist=<span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(!isExist){</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"None"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="String-Subtraction"><a href="#String-Subtraction" class="headerlink" title="String Subtraction"></a>String Subtraction</h2><p><strong>题目描述</strong><br>Given two strings S1 and S2, S = S1 - S2 is defined to be the remaining string after taking all the characters in S2 from S1. Your task is simply to calculate S1 - S2for any given strings. However, it might not be that simple to do it fast.<br><strong>输入</strong><br>Each input file contains one test case. Each case consists of two lines which gives S1 and S2, respectively. The string lengths of both strings are no more than 104. It is guaranteed that all the characters are visible ASCII codes and white space, and a new line character signals the end of a string.<br><strong>输出</strong><br>For each test case, print S1 - S2 in one line.<br><strong>样例输入</strong><br>They are students.<br>aeiou<br><strong>样例输出</strong><br>Thy r stdnts.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> s1,s2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="comment">//Get the two strings</span></span><br><span class="line">	<span class="comment">//Function 'getline()' can get all characters of a line except the 'Enter' key</span></span><br><span class="line">	<span class="comment">//Because the 'Enter' key is the flag that distinguishs the different lines</span></span><br><span class="line">	<span class="keyword">while</span>(getline(<span class="built_in">cin</span>,s1),getline(<span class="built_in">cin</span>,s2)){</span><br><span class="line"></span><br><span class="line">		<span class="comment">//Erase all repetitive characters in s2</span></span><br><span class="line">		<span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s2.length();i++){  </span><br><span class="line">			s.insert(s2[i]);</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//Erase all characters in s2 from s1</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt;::iterator it=s.begin();it!=s.end();it++){</span><br><span class="line">			<span class="keyword">while</span>(s1.find(*it)!=<span class="built_in">string</span>::npos){</span><br><span class="line">				s1.erase(s1.find(*it),<span class="number">1</span>);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//print the result</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1></blockquote><h2 id="吃糖果"><a href="#吃糖果" class="headerlink" title="吃糖果"></a>吃糖果</h2><p><strong>题目描述</strong><br>名名的妈妈从外地出差回来，带了一盒好吃又精美的巧克力给名名（盒内共有 N 块巧克力，20 &gt; N &gt;0）。<br>妈妈告诉名名每天可以吃一块或者两块巧克力。<br>假设名名每天都吃巧克力，问名名共有多少种不同的吃完巧克力的方案。<br>例如：<br>如果N=1，则名名第1天就吃掉它，共有1种方案；<br>如果N=2，则名名可以第1天吃1块，第2天吃1块，也可以第1天吃2块，共有2种方案；<br>如果N=3，则名名第1天可以吃1块，剩2块，也可以第1天吃2块剩1块，所以名名共有2+1=3种方案；<br>如果N=4，则名名可以第1天吃1块，剩3块，也可以第1天吃2块，剩2块，共有3+2=5种方案。<br>现在给定N，请你写程序求出名名吃巧克力的方案数目。<br><strong>输入</strong><br>输入只有1行，即整数N。<br><strong>输出</strong><br>可能有多组测试数据，对于每组数据，<br>输出只有1行，即名名吃巧克力的方案数。<br><strong>样例输入</strong><br>1<br>2<br>4<br><strong>样例输出</strong><br>1<br>2<br>5<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Thinking:</span></span><br><span class="line"><span class="comment">Recurrence formula:</span></span><br><span class="line"><span class="comment">f[n]=f[n-1]+f[n-2];</span></span><br><span class="line"><span class="comment">f[0]=1;</span></span><br><span class="line"><span class="comment">f[1]=1;</span></span><br><span class="line"><span class="comment">f[2]=f[1]+f[0]=2;</span></span><br><span class="line"><span class="comment">f[3]=f[2]+f[1]=3</span></span><br><span class="line"><span class="comment">f[4]=f[3]+f[2]=5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Method 1:</span></span><br><span class="line"><span class="comment">//Recursion</span></span><br><span class="line"><span class="comment">/*int Recursion(int n){</span></span><br><span class="line"><span class="comment">	if(n==0||n==1){</span></span><br><span class="line"><span class="comment">		return 1;</span></span><br><span class="line"><span class="comment">	}else{</span></span><br><span class="line"><span class="comment">		return Recursion(n-1)+Recursion(n-2);</span></span><br><span class="line"><span class="comment">	}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">int main(){</span></span><br><span class="line"><span class="comment">	int n;</span></span><br><span class="line"><span class="comment">	while(cin&gt;&gt;n){</span></span><br><span class="line"><span class="comment">		cout&lt;&lt;Recursion(n)&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">	}</span></span><br><span class="line"><span class="comment">	return 0;</span></span><br><span class="line"><span class="comment">}*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Method 2:</span></span><br><span class="line"><span class="comment">//Dynamic Programming</span></span><br><span class="line"><span class="keyword">int</span> DP[<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		DP[<span class="number">0</span>]=DP[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++){</span><br><span class="line">			DP[i]=DP[i<span class="number">-1</span>]+DP[i<span class="number">-2</span>];</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;DP[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="数列"><a href="#数列" class="headerlink" title="数列"></a>数列</h2><p><strong>题目描述</strong><br>编写一个求斐波那契数列的递归函数，输入n 值，使用该递归函数，输出如下图形（参见样例）。<br><strong>输入</strong><br>输入第一行为样例数m，接下来有m行每行一个整数n，n不超过10。<br><strong>输出</strong><br>对应每个样例输出要求的图形(参见样例格式)。<br>1<br><strong>样例输入</strong><br>6<br><strong>样例输出</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">          0</span><br><span class="line">        0 1 1</span><br><span class="line">      0 1 1 2 3</span><br><span class="line">    0 1 1 2 3 5 8</span><br><span class="line">  0 1 1 2 3 5 8 13 21</span><br><span class="line">0 1 1 2 3 5 8 13 21 34 55</span><br></pre></td></tr></tbody></table></figure><p><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> Fib[<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(m--){</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		Fib[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		Fib[<span class="number">1</span>]=Fib[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">2</span>*(n<span class="number">-1</span>);i++){</span><br><span class="line">			Fib[i]=Fib[i<span class="number">-1</span>]+Fib[i<span class="number">-2</span>];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n-i;j++) <span class="built_in">cout</span>&lt;&lt;<span class="string">"  "</span>; <span class="comment">//前缀空格</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">2</span>*(i<span class="number">-1</span>);j++){</span><br><span class="line">				<span class="keyword">if</span>(j!=<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;Fib[j];</span><br><span class="line">			}</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="神奇的口袋"><a href="#神奇的口袋" class="headerlink" title="神奇的口袋"></a>神奇的口袋</h2><p><strong>题目描述</strong><br>有一个神奇的口袋，总的容积是40，用这个口袋可以变出一些物品，这些物品的总体积必须是40。John现在有n个想要得到的物品，每个物品的体积分别是a1，a2……an。John可以从这些物品中选择一些，如果选出的物体的总体积是40，那么利用这个神奇的口袋，John就可以得到这些物品。现在的问题是，John有多少种不同的选择物品的方式。<br><strong>输入</strong><br>输入的第一行是正整数n (1 &lt;= n &lt;= 20)，表示不同的物品的数目。接下来的n行，每行有一个1到40之间的正整数，分别给出a1，a2……an的值。<br><strong>输出</strong><br>输出不同的选择物品的方式的数目。<br><strong>样例输入</strong><br>2<br>12<br>28<br>3<br>21<br>10<br>5<br><strong>样例输出</strong><br>1<br>0<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Thinking:</span></span><br><span class="line"><span class="comment">//Recurrence formula: good a[i] acquired or discarded</span></span><br><span class="line"><span class="comment">//f(40,n)=f(40-a[i],n-1)+f(40,n-1)</span></span><br><span class="line"><span class="comment">//f(0,x)=1; space fills up</span></span><br><span class="line"><span class="comment">//f(x,0)=0; There's room left but all goods have been selected</span></span><br><span class="line"><span class="comment">//f(-x,n)=0; Insufficient space</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////Method 1:</span></span><br><span class="line"><span class="comment">////Recursion</span></span><br><span class="line"><span class="comment">//int a[21];</span></span><br><span class="line"><span class="comment">//int n;</span></span><br><span class="line"><span class="comment">//int selected(int space,int item){</span></span><br><span class="line"><span class="comment">//	if(space==0) return 1;	//Stop recursion when space reaches zero, and get one approach</span></span><br><span class="line"><span class="comment">//	if(space&lt;0)  return 0;  //Insufficient space</span></span><br><span class="line"><span class="comment">//	if(item&lt;=0)  return 0;  //End of selection</span></span><br><span class="line"><span class="comment">//	return selected(space -a[item],item-1)+selected(space,item-1);</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"><span class="comment">//int main(){</span></span><br><span class="line"><span class="comment">//	while(cin&gt;&gt;n){</span></span><br><span class="line"><span class="comment">//	 	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];</span></span><br><span class="line"><span class="comment">//	 	cout&lt;&lt;selected(40,n)&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	}</span></span><br><span class="line"><span class="comment">//	return 0;</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Method 2:</span></span><br><span class="line"><span class="comment">//Dynamic Programming</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">21</span>];</span><br><span class="line"><span class="keyword">int</span> DP[<span class="number">41</span>][<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">21</span>;i++) DP[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">41</span>;i++) DP[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">40</span>;i++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line">				<span class="keyword">if</span>(i-a[j]&lt;<span class="number">0</span>) DP[i][j]=DP[i][j<span class="number">-1</span>];</span><br><span class="line">				<span class="keyword">else</span> DP[i][j]=DP[i-a[j]][j<span class="number">-1</span>]+DP[i][j<span class="number">-1</span>];</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;DP[<span class="number">40</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="八皇后"><a href="#八皇后" class="headerlink" title="八皇后"></a>八皇后</h2><p><strong>题目描述</strong><br>会下国际象棋的人都很清楚：皇后可以在横、竖、斜线上不限步数地吃掉其他棋子。如何将8个皇后放在棋盘上（有8 * 8个方格），使它们谁也不能被吃掉！这就是著名的八皇后问题。<br>对于某个满足要求的8皇后的摆放方法，定义一个皇后串a与之对应，即a=b1b2…b8，其中bi为相应摆法中第i行皇后所处的列数。已经知道8皇后问题一共有92组解（即92个不同的皇后串）。<br>给出一个数b，要求输出第b个串。串的比较是这样的：皇后串x置于皇后串y之前，当且仅当将x视为整数时比y小。<br><strong>输入</strong><br>第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数b(1 &lt;= b &lt;= 92)<br><strong>输出</strong><br>输出有n行，每行输出对应一个输入。输出应是一个正整数，是对应于b的皇后串。<br><strong>样例输入</strong><br>3<br>6<br>4<br>25<br><strong>样例输出</strong><br>25713864<br>17582463<br>36824175<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ERROR=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vResult; <span class="comment">//Result Set</span></span><br><span class="line"><span class="built_in">string</span> temp;            <span class="comment">//Procedure Variable</span></span><br><span class="line"><span class="keyword">bool</span> bVisited[<span class="number">9</span>];       <span class="comment">//An array of tags used to distinguish different columns</span></span><br><span class="line"><span class="function">Status <span class="title">Recursion</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">9</span>){  <span class="comment">//Results</span></span><br><span class="line">		vResult.push_back(temp);</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++){</span><br><span class="line">		<span class="keyword">if</span>(!bVisited[i]){  <span class="comment">//Different columns</span></span><br><span class="line">			<span class="keyword">bool</span> flag=<span class="literal">true</span>;  <span class="comment">//Mark different diagonals</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;temp.size();j++){</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">abs</span>(temp[j]-<span class="string">'0'</span>-i)==<span class="built_in">abs</span>(j+<span class="number">1</span>-n)){</span><br><span class="line">					flag=<span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span>(flag){ <span class="comment">//Different diggonals</span></span><br><span class="line">				<span class="comment">//Record data</span></span><br><span class="line">				bVisited[i]=<span class="literal">true</span>;</span><br><span class="line">				temp+=i+<span class="string">'0'</span>;</span><br><span class="line">				Recursion(n+<span class="number">1</span>); <span class="comment">//Next line</span></span><br><span class="line">				<span class="comment">//Recover</span></span><br><span class="line">				temp.erase(temp.size()<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">				bVisited[i]=<span class="literal">false</span>;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="comment">//Initialize array, perform recursive operations and sort the results</span></span><br><span class="line">	fill(bVisited,bVisited+<span class="number">9</span>,<span class="literal">false</span>);</span><br><span class="line">	Recursion(<span class="number">1</span>);</span><br><span class="line">	sort(vResult.begin(),vResult.end(),less&lt;<span class="built_in">string</span>&gt;());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Input sampels and return target results</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">while</span>(n--){</span><br><span class="line">		<span class="keyword">int</span> tmp;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;tmp;		</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;vResult[tmp<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1></blockquote><h2 id="看电视"><a href="#看电视" class="headerlink" title="看电视"></a>看电视</h2><p><strong>题目描述</strong><br>暑假到了，小明终于可以开心的看电视了。但是小明喜欢的节目太多了，他希望尽量多的看到完整的节目。<br>现在他把他喜欢的电视节目的转播时间表给你，你能帮他合理安排吗？<br><strong>输入</strong><br>输入包含多组测试数据。每组输入的第一行是一个整数n（n&lt;=100），表示小明喜欢的节目的总数。<br>接下来n行，每行输入两个整数si和ei（1&lt;=i&lt;=n），表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。<br>当n=0时，输入结束。<br><strong>输出</strong><br>对于每组输入，输出能完整看到的电视节目的个数。<br><strong>样例输入</strong><br>12<br>1 3<br>3 4<br>0 7<br>3 8<br>15 19<br>15 20<br>10 15<br>8 18<br>6 12<br>5 10<br>4 14<br>2 9<br>0<br><strong>样例输出</strong><br>5<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Thinking：</span></span><br><span class="line"><span class="comment">Interval Greedy</span></span><br><span class="line"><span class="comment">Sort the intervals from small to large according to the right end points of them:</span></span><br><span class="line"><span class="comment">Select the intervals one by one whose right end point is smaller</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Program</span>{</span></span><br><span class="line">	<span class="keyword">int</span> sTime;</span><br><span class="line">	<span class="keyword">int</span> eTime;</span><br><span class="line">	Program(){}</span><br><span class="line">	Program(<span class="keyword">int</span> sT,<span class="keyword">int</span> eT):sTime(sT),eTime(eT){}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Program &amp;tmp) <span class="keyword">const</span>{</span><br><span class="line">		<span class="keyword">return</span> eTime&lt;tmp.eTime;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Program&gt; vec;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n!=<span class="number">0</span>){</span><br><span class="line">		vec.resize(n); <span class="comment">//Resize the vector</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){   <span class="comment">//Input data</span></span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;vec[i].sTime&gt;&gt;vec[i].eTime;</span><br><span class="line">		}</span><br><span class="line">		sort(vec.begin(),vec.end()); <span class="comment">//Sort the data</span></span><br><span class="line">		<span class="keyword">int</span> lastEndTime=<span class="number">0</span>;  <span class="comment">//The end-time of the last program which we can choose</span></span><br><span class="line">		<span class="keyword">int</span> nCount=<span class="number">0</span>;      <span class="comment">//the number of programs</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){ <span class="comment">//Calculate</span></span><br><span class="line">			<span class="keyword">if</span>(vec[i].sTime&gt;=lastEndTime){</span><br><span class="line">				nCount++;</span><br><span class="line">				lastEndTime=vec[i].eTime;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;nCount&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="出租车费"><a href="#出租车费" class="headerlink" title="出租车费"></a>出租车费</h2><p><strong>题目描述</strong><br>某市出租车计价规则如下：起步4公里10元，即使你的行程没超过4公里；接下来的4公里，每公里2元；之后每公里2.4元。行程的最后一段即使不到1公里，也当作1公里计费。<br>一个乘客可以根据行程公里数合理安排坐车方式来使自己的打车费最小。<br>例如，整个行程为16公里，乘客应该将行程分成长度相同的两部分，每部分花费18元，总共花费36元。如果坐出租车一次走完全程要花费37.2元。<br>现在给你整个行程的公里数，请你计算坐出租车的最小花费。</p><p><strong>输入</strong><br>输入包含多组测试数据。每组输入一个正整数n（n&lt;10000000），表示整个行程的公里数。<br>当n=0时，输入结束。<br><strong>输出</strong><br>对于每组输入，输出最小花费。如果需要的话，保留一位小数。<br><strong>样例输入</strong><br>3<br>9<br>16<br>0<br><strong>样例输出</strong><br>10<br>20.4<br>36<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Thinking:</span></span><br><span class="line"><span class="comment">We should pay attemtion to the need to  minimize the cost per kilometer.</span></span><br><span class="line"><span class="comment">Distance-Interval  Unit-Price  Total-Price</span></span><br><span class="line"><span class="comment">4                  2.5          10</span></span><br><span class="line"><span class="comment">4                  2            8</span></span><br><span class="line"><span class="comment">~                  2.4          ~</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Distance &gt; 8:</span></span><br><span class="line"><span class="comment">- 8~13,   Continue the journey without changing the taxi</span></span><br><span class="line"><span class="comment">- &gt;13,    Restart the journey and charge after the taxi travels eight kilometers,</span></span><br><span class="line"><span class="comment">          because the unit-price per kilometer is lower than the one without changing the taxi</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> distance;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;distance&amp;&amp;distance!=<span class="number">0</span>){</span><br><span class="line">		<span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(distance!=<span class="number">0</span>){</span><br><span class="line">			<span class="keyword">if</span>(distance&lt;=<span class="number">13</span>){</span><br><span class="line">				<span class="keyword">if</span>(distance&lt;=<span class="number">4</span>) sum+=<span class="number">10</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(distance&lt;=<span class="number">8</span>) sum+=<span class="number">10</span>+<span class="number">2</span>*(distance<span class="number">-4</span>);</span><br><span class="line">				<span class="keyword">else</span> sum+=<span class="number">18</span>+<span class="number">2.4</span>*(distance<span class="number">-8</span>);</span><br><span class="line">				distance=<span class="number">0</span>;</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				sum+=<span class="number">18</span>;</span><br><span class="line">				distance-=<span class="number">8</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">floor</span>(sum)&lt;sum) <span class="built_in">printf</span>(<span class="string">"%.1f\n"</span>,sum);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(<span class="keyword">int</span>)sum);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="To-Fill-or-Not-to-Fill"><a href="#To-Fill-or-Not-to-Fill" class="headerlink" title="To Fill or Not to Fill"></a>To Fill or Not to Fill</h2><p>With highways available, driving a car from Hangzhou to any other city is easy. But since the tank capacity of a car is limited, we have to find gas stations on the way from time to time. Different gas station may give different price. You are asked to carefully design the cheapest route to go.<br><strong>Input Specification</strong><br>Each input file contains one test case. For each case, the first line contains 4 positive numbers: Cmax (≤ 100), the maximum capacity of the tank; D (≤30000), the distance between Hangzhou and the destination city; Davg(≤20), the average distance per unit gas that the car can run; and N (≤ 500), the total number of gas stations. Then N lines follow, each contains a pair of non-negative numbers: P<br>​i, the unit gas price, and Di(≤D), the distance between this station and Hangzhou, for i=1,⋯,N. All the numbers in a line are separated by a space.<br><strong>Output Specification</strong><br>For each test case, print the cheapest price in a line, accurate up to 2 decimal places. It is assumed that the tank is empty at the beginning. If it is impossible to reach the destination, print The maximum travel distance = X where X is the maximum possible distance the car can run, accurate up to 2 decimal places.<br><strong>Sample Input 1</strong><br>50 1300 12 8<br>6.00 1250<br>7.00 600<br>7.00 150<br>7.10 0<br>7.20 200<br>7.50 400<br>7.30 1000<br>6.85 300<br><strong>Sample Output 1</strong><br>749.17<br><strong>Sample Input 2</strong><br>50 1300 12 2<br>7.10 0<br>7.00 600<br><strong>Sample Output 2</strong><br>The maximum travel distance = 1200.00<br><strong>Procedure</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Thinking:</span></span><br><span class="line"><span class="comment">Greedy:</span></span><br><span class="line"><span class="comment">The price we cost must be the cheapest from HangZhou to the destination.</span></span><br><span class="line"><span class="comment">Supposed that we are at 'A' gas station now, choose the specific one among the reachable gas stations:</span></span><br><span class="line"><span class="comment">1. No station we can reach: we cann't arrive at the destination</span></span><br><span class="line"><span class="comment">2. There is not one gas station whose unit-price is lower than the current statioon:</span></span><br><span class="line"><span class="comment">   Fill the tank up</span></span><br><span class="line"><span class="comment">3. There are some stations whose unit-price is lower than the current station:</span></span><br><span class="line"><span class="comment">   Reach the nearest gas station</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Note:</span></span><br><span class="line"><span class="comment">Cann't select the one whose unit-price is the lowest among the reachable gas stations, consider the following:</span></span><br><span class="line"><span class="comment">Station  Unit-Price Distance</span></span><br><span class="line"><span class="comment">1         3          10</span></span><br><span class="line"><span class="comment">2         2          20</span></span><br><span class="line"><span class="comment">3         1          30</span></span><br><span class="line"><span class="comment">~</span></span><br><span class="line"><span class="comment">Now, we are at the 1 station, and we can reach the 2 and 3 station.</span></span><br><span class="line"><span class="comment">Obviously, 3 station is the one whose unit-price is the lowest.</span></span><br><span class="line"><span class="comment">But we cann't select it arbitrarily:</span></span><br><span class="line"><span class="comment">Supposed that the rest oil in the tank can support us to reach the 1 station, of couse, we can select it.</span></span><br><span class="line"><span class="comment">However, if not that, we should choose the 2 station because we must lower the price per kilometer.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="keyword">double</span> capacity;     <span class="comment">//The maximum capacity of the tank</span></span><br><span class="line"><span class="keyword">double</span> dstDis;       <span class="comment">//The distance between HangZhou and the destination city</span></span><br><span class="line"><span class="keyword">double</span> avgDis;       <span class="comment">//The average distance per unit gas that the car can run</span></span><br><span class="line"><span class="keyword">int</span> nStation;        <span class="comment">//the total number of gas stations</span></span><br><span class="line"><span class="keyword">double</span> minPrice;     <span class="comment">//The cheapest price</span></span><br><span class="line"><span class="keyword">double</span> maxDis;       <span class="comment">//The maximum distance the taxi can run</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Gas station</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Station</span>{</span></span><br><span class="line">	<span class="keyword">double</span> price;</span><br><span class="line">	<span class="keyword">double</span> distance;</span><br><span class="line">	Station(){}      <span class="comment">//Default Constructor</span></span><br><span class="line">	Station(<span class="keyword">double</span> Price,<span class="keyword">double</span> Distance):price(Price),distance(Distance){}   <span class="comment">//Parametric Constructor</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Station &amp; tmp) <span class="keyword">const</span>{</span><br><span class="line">		<span class="keyword">return</span> distance&lt;tmp.distance;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Station&gt; vecStation;  <span class="comment">//The vector records the data of each gas station</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;capacity&gt;&gt;dstDis&gt;&gt;avgDis&gt;&gt;nStation){</span><br><span class="line"></span><br><span class="line">		<span class="comment">//Initialize data</span></span><br><span class="line">		vecStation.resize(nStation+<span class="number">1</span>);</span><br><span class="line">		minPrice=maxDis=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nStation;i++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;vecStation[i].price&gt;&gt;vecStation[i].distance;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		vecStation[nStation].price=<span class="number">0</span>;</span><br><span class="line">		vecStation[nStation].distance=dstDis;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//Sort the elements in the vector 'vec'</span></span><br><span class="line">		sort(vecStation.begin(),vecStation.end(),less&lt;Station&gt;());</span><br><span class="line"></span><br><span class="line">		<span class="comment">//Exceptional case</span></span><br><span class="line">		<span class="keyword">if</span>(vecStation[<span class="number">0</span>].distance!=<span class="number">0</span>){</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"The maximum travel distance = %.2f\n"</span>,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> nowIndex=<span class="number">0</span>;  <span class="comment">//The index of the current gas station</span></span><br><span class="line">		<span class="keyword">double</span> nowDis=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">double</span> nowCapacity=capacity;</span><br><span class="line">		<span class="keyword">bool</span> bNotArrived=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(nowIndex&lt;nStation){</span><br><span class="line"></span><br><span class="line">			<span class="comment">//Find the specific gas station</span></span><br><span class="line">			<span class="keyword">double</span> tmpMinPrice=INF;</span><br><span class="line">			<span class="keyword">int</span> tmpMinIndex=nowIndex;</span><br><span class="line">			<span class="keyword">double</span> tmpMaxDis=vecStation[nowIndex].distance+capacity*avgDis;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=nowIndex+<span class="number">1</span>;i&lt;=nStation&amp;&amp;vecStation[i].distance&lt;=tmpMaxDis;i++){</span><br><span class="line">				<span class="keyword">if</span>(vecStation[nowIndex].price&gt;vecStation[i].price){</span><br><span class="line">					tmpMinPrice=vecStation[i].price;</span><br><span class="line">					tmpMinIndex=i;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">if</span>(tmpMinPrice&gt;=vecStation[i].price){</span><br><span class="line">					tmpMinPrice=vecStation[i].price;</span><br><span class="line">					tmpMinIndex=i;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="comment">//Can't reach the destination</span></span><br><span class="line">			<span class="keyword">if</span>(tmpMinPrice==INF){</span><br><span class="line">				bNotArrived=<span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(tmpMinPrice&gt;=vecStation[nowIndex].price){</span><br><span class="line"></span><br><span class="line">				minPrice+=nowCapacity*vecStation[nowIndex].price;</span><br><span class="line">				nowCapacity=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				<span class="comment">//Consider whether the rest oil can support us reach the next station</span></span><br><span class="line">				<span class="keyword">double</span> tmpDis=(capacity-nowCapacity)*avgDis;</span><br><span class="line">				<span class="keyword">if</span>(tmpDis&lt;vecStation[tmpMinIndex].distance-vecStation[nowIndex].distance){</span><br><span class="line">					<span class="keyword">double</span> tmpCapacity=(vecStation[tmpMinIndex].distance-vecStation[nowIndex].distance-tmpDis)/avgDis;</span><br><span class="line">					minPrice+=tmpCapacity*vecStation[nowIndex].price;</span><br><span class="line">					nowCapacity-=tmpCapacity;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			nowCapacity+=(vecStation[tmpMinIndex].distance-vecStation[nowIndex].distance)/avgDis;</span><br><span class="line">			nowIndex=tmpMinIndex;</span><br><span class="line">			maxDis=capacity*avgDis+vecStation[nowIndex].distance;</span><br><span class="line"></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(bNotArrived){</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"The maximum travel distance = %.2f\n"</span>,maxDis);</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>,minPrice);</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Repair-the-Wall"><a href="#Repair-the-Wall" class="headerlink" title="Repair the Wall"></a>Repair the Wall</h2><p><strong>题目描述</strong><br>Long time ago , Kitty lived in a small village. The air was fresh and the scenery was very beautiful. The only thing that troubled her is the typhoon.<br>When the typhoon came, everything is terrible. It kept blowing and raining for a long time. And what made the situation worse was that all of Kitty’s walls were made of wood.<br>One day, Kitty found that there was a crack in the wall. The shape of the crack is<br>a rectangle with the size of 1×L (in inch). Luckly Kitty got N blocks and a saw(锯子) from her neighbors.<br>The shape of the blocks were rectangle too, and the width of all blocks were 1 inch. So, with the help of saw, Kitty could cut down some of the blocks(of course she could use it directly without cutting) and put them in the crack, and the wall may be repaired perfectly, without any gap.<br>Now, Kitty knew the size of each blocks, and wanted to use as fewer as possible of the blocks to repair the wall, could you help her ?<br><strong>输入</strong><br>The problem contains many test cases, please process to the end of file( EOF ).<br>Each test case contains two lines.<br>In the first line, there are two integers L(0&lt;L&lt;1000000000) and N(0&lt;=N&lt;600) which<br>mentioned above.<br>In the second line, there are N positive integers. The ith integer Ai(0&lt;Ai&lt;1000000000 ) means that the ith block has the size of 1×Ai (in inch).<br><strong>输出</strong><br>For each test case , print an integer which represents the minimal number of blocks are needed.<br>If Kitty could not repair the wall, just print “impossible” instead.<br><strong>样例输入</strong><br>2 2<br>12 11<br>14 3<br>27 11 4<br>109 5<br>38 15 6 21 32<br>5 3<br>1 1 1<br><strong>样例输出</strong><br>1<br>1<br>5<br>impossible<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> L,N;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;L&gt;&gt;N){</span><br><span class="line">		vec.resize(N);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;vec[i];</span><br><span class="line">		}</span><br><span class="line">		sort(vec.begin(),vec.end(),greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">		<span class="keyword">int</span> tmpL=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> nCount=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(tmpL&lt;L&amp;&amp;nCount&lt;vec.size()){</span><br><span class="line">			tmpL+=vec[nCount++];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(tmpL&lt;L){</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"impossible"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;nCount&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="FatMouse’s-Trade"><a href="#FatMouse’s-Trade" class="headerlink" title="FatMouse’s Trade"></a>FatMouse’s Trade</h2><p><strong>题目描述</strong><br>FatMouse prepared M pounds of cat food, ready to trade with the cats guarding the warehouse containing his favorite food, JavaBean.<br>The warehouse has N rooms. The i-th room contains J[i] pounds of JavaBeans and requires F[i] pounds of cat food. FatMouse does not have to trade for all the JavaBeans in the room, instead, he may get J[i]* a% pounds of JavaBeans if he pays F[i]* a% pounds of cat food. Here a is a real number. Now he is assigning this homework to you: tell him the maximum amount of JavaBeans he can obtain.<br><strong>输入</strong><br>The input consists of multiple test cases. Each test case begins with a line containing two non-negative integers M and N. Then N lines follow, each contains two non-negative integers J[i] and F[i] respectively. The last test case is followed by two -1’s. All integers are not greater than 1000.<br><strong>输出</strong><br>For each test case, print in a single line a real number accurate up to 3 decimal places, which is the maximum amount of JavaBeans that FatMouse can obtain.<br><strong>样例输入</strong><br>4 2<br>4 7<br>1 3<br>5 5<br>4 8<br>3 8<br>1 2<br>2 5<br>2 4<br>-1 -1<br><strong>样例输出</strong><br>2.286<br>2.500<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Room</span>{</span></span><br><span class="line">	<span class="keyword">int</span> javaBean;</span><br><span class="line">	<span class="keyword">int</span> food;</span><br><span class="line">	<span class="keyword">double</span> ratio;</span><br><span class="line">	Room(){}</span><br><span class="line">	Room(<span class="keyword">int</span> JavaBean, <span class="keyword">int</span> Food, <span class="keyword">double</span> Ratio)</span><br><span class="line">	:javaBean(JavaBean),food(Food),ratio(Ratio){}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Room tmp) <span class="keyword">const</span>{</span><br><span class="line">		<span class="keyword">return</span> ratio&gt;tmp.ratio;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> M,N;</span><br><span class="line"><span class="built_in">vector</span>&lt;Room&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;M&gt;&gt;N&amp;&amp;(M!=<span class="number">-1</span>||N!=<span class="number">-1</span>)){</span><br><span class="line">		vec.clear();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line">			<span class="keyword">int</span> j,f;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;j&gt;&gt;f;</span><br><span class="line">			vec.push_back(Room(j,f,(<span class="keyword">double</span>)j/f));</span><br><span class="line">		}</span><br><span class="line">		sort(vec.begin(),vec.end());</span><br><span class="line">		<span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">double</span> result=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(M!=<span class="number">0</span>){</span><br><span class="line">			<span class="keyword">if</span>(M&gt;=vec[index].food){</span><br><span class="line">				M-=vec[index].food;</span><br><span class="line">				result+=vec[index].javaBean;</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				result+=vec[index].ratio*M;</span><br><span class="line">				M=<span class="number">0</span>;</span><br><span class="line">			}</span><br><span class="line">			index++;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.3f\n"</span>,result);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="迷瘴"><a href="#迷瘴" class="headerlink" title="迷瘴"></a>迷瘴</h2><p><strong>题目描述</strong><br>小明正在玩游戏，他控制的角色正面临着幽谷的考验——<br>幽谷周围瘴气弥漫，静的可怕，隐约可见地上堆满了骷髅。由于此处长年不见天日，导致空气中布满了毒素，一旦吸入体内，便会全身溃烂而死。<br>幸好小明早有防备，提前备好了解药材料（各种浓度的万能药水）。现在只需按照配置成不同比例的浓度。<br>现已知小明随身携带有n种浓度的万能药水，体积V都相同，浓度则分别为Pi%。并且知道，针对当时幽谷的瘴气情况，只需选择部分或者全部的万能药水，然后配置出浓度不大于 W%的药水即可解毒。<br>现在的问题是：如何配置此药，能得到最大体积的当前可用的解药呢？<br>特别说明：由于幽谷内设备的限制,只允许把一种已有的药全部混入另一种之中（即：不能出现对一种药只取它的一部分这样的操作）。<br><strong>输入</strong><br>输入数据的第一行是一个整数C，表示测试数据的组数；<br>每组测试数据包含2行，首先一行给出三个正整数n,V,W(1&lt;=n,V,W&lt;=100)；<br>接着一行是n个整数，表示n种药水的浓度Pi%(1&lt;=Pi&lt;=100)。<br><strong>输出</strong><br>对于每组测试数据，请输出一个整数和一个浮点数；<br>其中整数表示解药的最大体积，浮点数表示解药的浓度(四舍五入保留2位小数)；<br>如果不能配出满足要求的的解药，则请输出0 0.00。<br><strong>样例输入</strong><br>2<br>1 35 68<br>1<br>2 79 25<br>59 63<br><strong>样例输出</strong><br>35 0.01<br>0 0.00<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,V,M;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> C;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;C;</span><br><span class="line">	<span class="keyword">while</span>(C--){</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;N&gt;&gt;V&gt;&gt;M;</span><br><span class="line">		vec.resize(N);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) <span class="built_in">cin</span>&gt;&gt;vec[i];</span><br><span class="line">		sort(vec.begin(),vec.end(),less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">		<span class="keyword">double</span> drog=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> maxV=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">double</span> ratio=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((index==<span class="number">0</span>||(drog/(index*V)&lt;=M/<span class="number">100.0</span>))&amp;&amp;index&lt;N){</span><br><span class="line">			drog+=vec[index]/<span class="number">100.0</span>*V;</span><br><span class="line">			index++;</span><br><span class="line">			<span class="keyword">if</span>(drog/(index*V)&lt;=M/<span class="number">100.0</span>){</span><br><span class="line">				maxV+=V;</span><br><span class="line">				ratio=drog/(index*V);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d %0.2f\n"</span>,maxV,ratio);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="找零钱"><a href="#找零钱" class="headerlink" title="找零钱"></a>找零钱</h2><p><strong>题目描述</strong><br>小智去超市买东西，买了不超过一百块的东西。收银员想尽量用少的纸币来找钱。<br>纸币面额分为50 20 10 5 1 五种。请在知道要找多少钱n给小明的情况下，输出纸币数量最少的方案。 1&lt;=n&lt;=99;<br><strong>输入</strong><br>有多组数据 1&lt;=n&lt;=99;<br><strong>输出</strong><br>对于每种数量不为0的纸币，输出他们的面值*数量，再加起来输出<br><strong>样例输入</strong><br>25<br>32<br><strong>样例输出</strong><br>20*1+5*1<br>20*1+10*1+1*2<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> money[<span class="number">2</span>][<span class="number">5</span>]={</span><br><span class="line">	<span class="number">50</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">1</span>,</span><br><span class="line">	<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++){</span><br><span class="line">			money[<span class="number">1</span>][i]=<span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++){</span><br><span class="line">			<span class="keyword">while</span>(n&gt;=money[<span class="number">0</span>][i]){</span><br><span class="line">				n-=money[<span class="number">0</span>][i];</span><br><span class="line">				money[<span class="number">1</span>][i]++;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">bool</span> bFirst=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++){</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(money[<span class="number">1</span>][i]!=<span class="number">0</span>){</span><br><span class="line">				<span class="keyword">if</span>(!bFirst) <span class="built_in">cout</span>&lt;&lt;<span class="string">"+"</span>;</span><br><span class="line">				bFirst=<span class="literal">false</span>;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;money[<span class="number">0</span>][i]&lt;&lt;<span class="string">"*"</span>&lt;&lt;money[<span class="number">1</span>][i];</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1></blockquote><h2 id="技巧："><a href="#技巧：" class="headerlink" title="技巧："></a>技巧：</h2><p>1、矩阵每行升序，每列升序，从左下角或右上角开始二分！<br>2、求两个数组的和，满足每一个关系，可以先排序，再从i=0…m,j=n-1…0，双指针开始二分！时间复杂度降维$O(n\log{n}+n), n=max(m,n)$</p><h2 id="找x-1"><a href="#找x-1" class="headerlink" title="找x"></a>找x</h2><p><strong>题目描述</strong><br>输入一个数n，然后输入n个数值各不相同，再输入一个值x，输出这个值在这个数组中的下标（从0开始，若不在数组中则输出-1）。<br><strong>输入</strong><br>测试数据有多组，输入n(1&lt;=n&lt;=200)，接着输入n个数，然后输入x。<br><strong>输出</strong><br>对于每组输入,请输出结果。<br><strong>样例输入</strong><br>4<br>1 2 3 4<br>3<br><strong>样例输出</strong><br>2<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> index;</span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	Node(){}</span><br><span class="line">	Node(<span class="keyword">int</span> Index,<span class="keyword">int</span> Data):index(Index),data(Data){}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;tmp) <span class="keyword">const</span>{</span><br><span class="line">		<span class="keyword">return</span> data&lt;tmp.data;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; vec;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findIndexOfx</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> left=<span class="number">0</span>,right=n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(left&lt;=right){</span><br><span class="line">		<span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(vec[mid].data==x) <span class="keyword">return</span> vec[mid].index;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(vec[mid].data&gt;x) right=mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		vec.resize(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;vec[i].data;</span><br><span class="line">			vec[i].index=i;</span><br><span class="line">		}</span><br><span class="line">		sort(vec.begin(),vec.end());</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;findIndexOfx(x)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="打印极值点坐标"><a href="#打印极值点坐标" class="headerlink" title="打印极值点坐标"></a>打印极值点坐标</h2><p><strong>描述</strong><br>在一个整数数组上，对于下标为i的整数，如果它大于所有它相邻的整数，或者小于所有它相邻的整数，则称为该整数为一个极值点，极值点的下标就是i。<br><strong>输入</strong><br>有2×n+1行输入：第一行是要处理的数组的个数n；对其余2×n行，第一行是此数组的元素个数k(4&lt;k&lt;80)，第二行是k个整数，每两个整数之间用空格分隔。<br><strong>输出</strong><br>输出为n行：每行对应于相应数组的所有极值点下标值，下标值之间用空格分隔。<br><strong>样例输入</strong><br>3<br>10<br>10 12 12 11 11 12 23 24 12 12<br>15<br>12 12 122 112 222 211 222 221 76 36 31 234 256 76 76<br>15<br>12 14 122 112 222 222 222 221 76 36 31 234 256 76 73<br><strong>样例输出</strong><br>0 7<br>2 3 4 5 6 10 12<br>0 2 3 10 12 14<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nCase;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;nCase;</span><br><span class="line">	<span class="keyword">while</span>(nCase--){</span><br><span class="line">		<span class="keyword">int</span> nCount;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;nCount;</span><br><span class="line">		vec.resize(nCount);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nCount;i++) <span class="built_in">cin</span>&gt;&gt;vec[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">bool</span> bFirst=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span>(vec[<span class="number">0</span>]!=vec[<span class="number">1</span>]) {</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line">			bFirst=<span class="literal">false</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nCount<span class="number">-1</span>;i++){</span><br><span class="line">			<span class="keyword">if</span>((vec[i]&gt;vec[i+<span class="number">1</span>]&amp;&amp;vec[i]&gt;vec[i<span class="number">-1</span>])</span><br><span class="line">				||(vec[i]&lt;vec[i+<span class="number">1</span>]&amp;&amp;vec[i]&lt;vec[i<span class="number">-1</span>])){</span><br><span class="line">				<span class="keyword">if</span>(bFirst) bFirst=<span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;i;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(vec[nCount<span class="number">-1</span>]!=vec[nCount<span class="number">-2</span>]){</span><br><span class="line">			<span class="keyword">if</span>(bFirst) bFirst=<span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;nCount<span class="number">-1</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><p><strong>题目描述</strong><br>输入数组长度 n<br>输入数组 a[1…n]<br>输入查找个数m<br>输入查找数字b[1…m]<br>输出 YES or NO 查找有则YES 否则NO 。<br><strong>输入</strong><br>输入有多组数据。<br>每组输入n，然后输入n个整数，再输入m，然后再输入m个整数（1&lt;=m&lt;=n&lt;=100）。<br><strong>输出</strong><br>如果在n个数组中输出YES否则输出NO。<br><strong>样例输入</strong><br>6<br>3 2 5 4 7 8<br>2<br>3 6<br><strong>样例输出</strong><br>YES<br>NO<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">int</span> nCount;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findX</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> left=<span class="number">0</span>,right=nCount<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(left&lt;=right){</span><br><span class="line">		<span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(vec[mid]==x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(vec[mid]&gt;x) right=mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;nCount){</span><br><span class="line">		vec.resize(nCount);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nCount;i++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;vec[i];</span><br><span class="line">		}</span><br><span class="line">		sort(vec.begin(),vec.end());</span><br><span class="line">		<span class="keyword">int</span> nFind;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;nFind;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nFind;i++){</span><br><span class="line">			<span class="keyword">int</span> x;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">			<span class="keyword">if</span>(findX(x)){</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="Two-Pointers"><a href="#Two-Pointers" class="headerlink" title="Two Pointers"></a>Two Pointers</h1></blockquote><h2 id="二路归并排序-mergesort-递归法-2"><a href="#二路归并排序-mergesort-递归法-2" class="headerlink" title="二路归并排序(mergesort)递归法 [2*+]"></a>二路归并排序(mergesort)递归法 [2*+]</h2><p><strong>题目描述</strong><br>二路归并排序(mergesort)递归法<br>用递归法进行二路归并排序<br><strong>输入</strong><br>第一行一个数据n，表示有n个数要排序。接下来n行每行一个&lt;=10^7的整数。<br><strong>输出</strong><br>n行，由小到大排序后的数据<br>数据规模：n&lt;=10^5<br>思考：两个递归都会被执行吗？<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Warning: server error</span></span><br><span class="line"><span class="comment">Runtime error 20%</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ERROR=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec,<span class="keyword">int</span> L1,<span class="keyword">int</span> R1,<span class="keyword">int</span> L2,<span class="keyword">int</span> R2)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> start=L1;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">	temp.resize(R2-L1+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(L1&lt;=R1&amp;&amp;L2&lt;=R2){</span><br><span class="line">		<span class="keyword">if</span>(vec[L1]&lt;=vec[L2]) temp[index++]=vec[L1++];</span><br><span class="line">		<span class="keyword">else</span> temp[index++]=vec[L2++];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">while</span>(L1&lt;=R1) temp[index++]=vec[L1++];</span><br><span class="line">	<span class="keyword">while</span>(L2&lt;=R2) temp[index++]=vec[L2++];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.size();i++){</span><br><span class="line">		vec[start++]=temp[i];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"><span class="function">Status <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(left&lt;right){</span><br><span class="line">		<span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">		mergeSort(vec,left,mid);</span><br><span class="line">		mergeSort(vec,mid+<span class="number">1</span>,right);</span><br><span class="line">		merge(vec,left,mid,mid+<span class="number">1</span>,right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		vec.resize(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;vec[i];</span><br><span class="line">		}</span><br><span class="line">		mergeSort(vec,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=vec.begin();</span><br><span class="line">		<span class="keyword">while</span>(it!=vec.end()){</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			it++;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="基础排序III：归并排序"><a href="#基础排序III：归并排序" class="headerlink" title="基础排序III：归并排序"></a>基础排序III：归并排序</h2><p><strong>题目描述</strong><br>归并排序是一个时间复杂度为O(nlogn)的算法，对于大量数据远远优于冒泡排序与插入排序。<br>这是一道排序练习题，数据量较大，请使用归并排序完成。<br><strong>输入</strong><br>第一行一个数字n，代表输入的组数<br>其后每组第一行输入一个数字m，代表待排序数字的个数<br>其后m行每行一个数据，大小在1～100000之间，互不相等，最多有10万个数据。<br><strong>输出</strong><br>升序输出排好序的数据，每行一个数字<br><strong>样例输入</strong><br>1<br>10<br>10<br>9<br>8<br>7<br>6<br>5<br>4<br>3<br>2<br>1<br><strong>样例输出</strong><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ERROR=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec,<span class="keyword">int</span> L1,<span class="keyword">int</span> R1,<span class="keyword">int</span> L2,<span class="keyword">int</span> R2)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> start=L1;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">	temp.resize(R2-L1+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(L1&lt;=R1&amp;&amp;L2&lt;=R2){</span><br><span class="line">		<span class="keyword">if</span>(vec[L1]&lt;=vec[L2]) temp[index++]=vec[L1++];</span><br><span class="line">		<span class="keyword">else</span> temp[index++]=vec[L2++];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">while</span>(L1&lt;=R1) temp[index++]=vec[L1++];</span><br><span class="line">	<span class="keyword">while</span>(L2&lt;=R2) temp[index++]=vec[L2++];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.size();i++){</span><br><span class="line">		vec[start++]=temp[i];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"><span class="function">Status <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(left&lt;right){</span><br><span class="line">		<span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">		mergeSort(vec,left,mid);</span><br><span class="line">		mergeSort(vec,mid+<span class="number">1</span>,right);</span><br><span class="line">		merge(vec,left,mid,mid+<span class="number">1</span>,right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> nCase;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"> 	<span class="built_in">cin</span>&gt;&gt;nCase;</span><br><span class="line">	<span class="keyword">while</span>(nCase--){</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		vec.resize(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;vec[i];</span><br><span class="line">		}</span><br><span class="line">		mergeSort(vec,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=vec.begin();</span><br><span class="line">		<span class="keyword">while</span>(it!=vec.end()){</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			it++;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="快速排序-qsort-2"><a href="#快速排序-qsort-2" class="headerlink" title="快速排序 qsort [2*]"></a>快速排序 qsort [2*]</h2><p><strong>题目描述</strong><br>输入n个整数，用快速排序的方法进行排序<br><strong>Input</strong><br>第一行数字n 代表接下来有n个整数<br>接下来n行，每行一个整数<br><strong>Output</strong><br>升序输出排序结果<br>每行一个数据<br><strong>Sample Input</strong><br>5<br>12<br>18<br>14<br>13<br>16<br><strong>Sample Output</strong><br>12<br>13<br>14<br>16<br>18<br><strong>Procedure</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ERROR=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> temp=vec[left];</span><br><span class="line">	<span class="keyword">while</span>(left&lt;right){</span><br><span class="line">		<span class="keyword">while</span>(left&lt;right&amp;&amp;vec[right]&gt;=temp) right--;</span><br><span class="line">		vec[left]=vec[right];</span><br><span class="line">		<span class="keyword">while</span>(left&lt;right&amp;&amp;vec[left]&lt;=temp) left++;</span><br><span class="line">		vec[right]=vec[left];</span><br><span class="line">	}</span><br><span class="line">	vec[left]=temp;</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(left&lt;right){</span><br><span class="line">		<span class="keyword">int</span> pos=partition(vec,left,right);</span><br><span class="line">		quickSort(vec,left,pos<span class="number">-1</span>);</span><br><span class="line">		quickSort(vec,pos+<span class="number">1</span>,right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		vec.resize(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;vec[i];</span><br><span class="line">		quickSort(vec,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=vec.begin();it!=vec.end();it++){</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二分递归快排（Qsort）-2"><a href="#二分递归快排（Qsort）-2" class="headerlink" title="二分递归快排（Qsort） [2*]"></a>二分递归快排（Qsort） [2*]</h2><p><strong>题目描述</strong><br>二分递归快排（Qsort）<br>用二分递归的方法实现快排<br><strong>输入</strong><br>第一行一个数据n，表示有n个数要排序。接下来n行每行一个&lt;=10^7的整数。<br><strong>输出</strong><br>n行，由小到大排序后的数据<br>数据规模：n&lt;=10^5<br>思考：两个递归都会被执行吗？有几种可能？<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ERROR=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> index=left+rand()%(right-left+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> temp=vec[index];</span><br><span class="line">	swap(vec[index],vec[left]);</span><br><span class="line">	<span class="keyword">while</span>(left&lt;right){</span><br><span class="line">		<span class="keyword">while</span>(left&lt;right&amp;&amp;vec[right]&gt;=temp) right--;</span><br><span class="line">		vec[left]=vec[right];</span><br><span class="line">		<span class="keyword">while</span>(left&lt;right&amp;&amp;vec[left]&lt;=temp) left++;</span><br><span class="line">		vec[right]=vec[left];</span><br><span class="line">	}</span><br><span class="line">	vec[left]=temp;</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(left&lt;right){</span><br><span class="line">		<span class="keyword">int</span> pos=partition(vec,left,right);</span><br><span class="line">		quickSort(vec,left,pos<span class="number">-1</span>);</span><br><span class="line">		quickSort(vec,pos+<span class="number">1</span>,right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		vec.resize(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;vec[i];</span><br><span class="line">		quickSort(vec,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=vec.begin();it!=vec.end();it++){</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="其他高效技巧与算法"><a href="#其他高效技巧与算法" class="headerlink" title="其他高效技巧与算法"></a>其他高效技巧与算法</h1></blockquote><h2 id="求第k大的数"><a href="#求第k大的数" class="headerlink" title="求第k大的数"></a>求第k大的数</h2><p>给定一个长度为n（1≤n≤1,000,000）的无序正整数序列，以及另一个数k（1≤k≤1,000,000）（关于第k大的数：例如序列{1,2,3,4,5,6}中第3大的数是4。）<br><strong>输入</strong><br>第一行两个正整数m,n。<br>第二行为n个正整数。<br><strong>输出</strong><br>第k大的数。<br><strong>样例输入</strong><br>6 3<br>1 2 3 4 5 6<br><strong>样例输出</strong><br>4<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ERROR=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> index=rand()%(right-left+<span class="number">1</span>)+left;</span><br><span class="line">	<span class="keyword">int</span> temp=vec[index];</span><br><span class="line">	swap(vec[index],vec[left]);</span><br><span class="line">	<span class="keyword">while</span>(left&lt;right){</span><br><span class="line">		<span class="keyword">while</span>(left&lt;right&amp;&amp;vec[right]&gt;=temp) right--;</span><br><span class="line">		vec[left]=vec[right];</span><br><span class="line">		<span class="keyword">while</span>(left&lt;right&amp;&amp;vec[left]&lt;=temp) left++;</span><br><span class="line">		vec[right]=vec[left];</span><br><span class="line">	}</span><br><span class="line">	vec[left]=temp;</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randSelect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> k)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> len=vec.size();</span><br><span class="line">	<span class="keyword">int</span> pos=partition(vec,left,right);</span><br><span class="line">	<span class="keyword">while</span>(pos+k!=len){</span><br><span class="line">		<span class="keyword">if</span>(pos&lt;len-k){</span><br><span class="line">			pos=partition(vec,pos+<span class="number">1</span>,right);</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			pos=partition(vec,left,pos<span class="number">-1</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> vec[pos];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k){</span><br><span class="line">		vec.resize(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;vec[i];</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;randSelect(vec,<span class="number">0</span>,n<span class="number">-1</span>,k)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="简单数学"><a href="#简单数学" class="headerlink" title="简单数学"></a>简单数学</h1></blockquote><h2 id="守形数"><a href="#守形数" class="headerlink" title="守形数"></a>守形数</h2><p><strong>题目描述</strong><br>守形数是这样一种整数，它的平方的低位部分等于它本身。<br>比如25的平方是625，低位部分是25，因此25是一个守形数。<br>编一个程序，判断N是否为守形数。</p><p><strong>输入</strong><br>输入包括1个整数N，2&lt;=N&lt;100。</p><p><strong>输出</strong><br>可能有多组测试数据，对于每组数据，<br>输出”Yes!”表示N是守形数。<br>输出”No!”表示N不是守形数。</p><p><strong>样例输入</strong><br>6<br>11<br><strong>样例输出</strong><br>Yes!<br>No!<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++){</span><br><span class="line">		n=n*<span class="number">10</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line">	}</span><br><span class="line">	n*=n;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; vec;</span><br><span class="line">	<span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(n!=<span class="number">0</span>&amp;&amp;count!=str.length()){</span><br><span class="line">		<span class="keyword">int</span> tmp=n%<span class="number">10</span>;</span><br><span class="line">		vec.push_back(tmp+<span class="string">'0'</span>);</span><br><span class="line">		n/=<span class="number">10</span>;</span><br><span class="line">		count++;</span><br><span class="line">	}</span><br><span class="line">	reverse(vec.begin(),vec.end());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(vec.size()!=str.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span>{</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++){</span><br><span class="line">			<span class="keyword">if</span>(vec[i]!=str[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str){</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(judge(str)) <span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"No!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="反序数"><a href="#反序数" class="headerlink" title="反序数"></a>反序数</h2><p><strong>题目描述</strong><br>设N是一个四位数，它的9倍恰好是其反序数（例如：1234的反序数是4321）<br>求N的值<br><strong>输入</strong><br>程序无任何输入数据。<br><strong>输出</strong><br>输出题目要求的四位数，如果结果有多组，则每组结果之间以回车隔开。<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; transform(<span class="keyword">int</span> x){</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">	<span class="keyword">while</span>(x!=<span class="number">0</span>){</span><br><span class="line">		<span class="keyword">int</span> tmp=x%<span class="number">10</span>;</span><br><span class="line">		vec.push_back(tmp);</span><br><span class="line">		x/=<span class="number">10</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> vec;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecOne,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecTwo)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(vecOne.size()!=vecTwo.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vecOne.size();i++){</span><br><span class="line">		<span class="keyword">if</span>(vecOne[i]!=vecTwo[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	transform(<span class="number">1000</span>);</span><br><span class="line">	<span class="keyword">bool</span> bFirst=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1000</span>;i&lt;<span class="number">10000</span>;i++){</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecOne=transform(i);</span><br><span class="line">		reverse(vecOne.begin(),vecOne.end());</span><br><span class="line"></span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecTwo=transform(i*<span class="number">9</span>);</span><br><span class="line">		<span class="keyword">if</span>(judge(vecOne,vecTwo)){</span><br><span class="line">			<span class="keyword">if</span>(bFirst){</span><br><span class="line">				bFirst=<span class="literal">false</span>;</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">","</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;i;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="百鸡问题"><a href="#百鸡问题" class="headerlink" title="百鸡问题"></a>百鸡问题</h2><p><strong>题目描述</strong><br>用小于等于n元去买100只鸡，大鸡5元/只，小鸡3元/只,还有1/3元每只的一种小鸡，分别记为x只,y只,z只。编程求解x,y,z所有可能解。<br><strong>输入</strong><br>测试数据有多组，输入n。<br><strong>输出</strong><br>对于每组输入,请输出x,y,z所有可行解，按照x，y，z依次增大的顺序输出。<br><strong>样例输入</strong><br>45<br><strong>样例输出</strong><br>x=0,y=0,z=100<br>x=0,y=1,z=99<br>x=0,y=2,z=98<br>x=0,y=3,z=97<br>x=0,y=4,z=96<br>x=1,y=0,z=99<br>x=1,y=1,z=98<br>x=1,y=2,z=97<br>x=2,y=0,z=98<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">100</span>;i++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">100</span>-i;j++){</span><br><span class="line">			<span class="keyword">double</span> cost=i*<span class="number">5</span>+j*<span class="number">3</span>+<span class="number">1</span>/<span class="number">3.0</span>*(<span class="number">100</span>-i-j);</span><br><span class="line">			<span class="keyword">if</span>(cost&lt;=n){</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"x="</span>&lt;&lt;i&lt;&lt;<span class="string">",y="</span>&lt;&lt;j&lt;&lt;<span class="string">",z="</span>&lt;&lt;<span class="number">100</span>-i-j&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		calculate(n);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="abc"><a href="#abc" class="headerlink" title="abc"></a>abc</h2><p><strong>题目描述</strong><br>设a、b、c均是0到9之间的数字，abc、bcc是两个三位数，且有：abc+bcc=532。求满足条件的所有a、b、c的值。<br><strong>输入</strong><br>题目没有任何输入。<br><strong>输出</strong><br>请输出所有满足题目条件的a、b、c的值。<br>a、b、c之间用空格隔开。<br>每个输出占一行。<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">1</span>;a&lt;<span class="number">10</span>;a++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> b=<span class="number">1</span>;b&lt;<span class="number">10</span>;b++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;<span class="number">10</span>;c++){</span><br><span class="line">				<span class="keyword">int</span> abc=a*<span class="number">100</span>+b*<span class="number">10</span>+c;</span><br><span class="line">				<span class="keyword">int</span> bcc=b*<span class="number">100</span>+c*<span class="number">10</span>+c;</span><br><span class="line">				<span class="keyword">if</span>(abc+bcc==<span class="number">532</span>) <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">" "</span>&lt;&lt;b&lt;&lt;<span class="string">" "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="众数"><a href="#众数" class="headerlink" title="众数"></a>众数</h2><p><strong>题目描述</strong><br>输入20个数，每个数都在1-10之间，求1-10中的众数（众数就是出现次数最多的数，如果存在一样多次数的众数，则输出权值较小的那一个）。<br><strong>输入</strong><br>测试数据有多组，每组输入20个1-10之间的数。<br><strong>输出</strong><br>对于每组输入,请输出1-10中的众数。<br>注意如果存在一样多次数的众数，则输出权值较小的那一个。<br><strong>样例输入</strong><br>8 9 6 4 6 3 10 4 7 4 2 9 1 6 5 6 2 2 3 8<br><strong>样例输出</strong><br>6<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Hash[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> tmp;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;tmp){</span><br><span class="line">		fill(Hash,Hash+<span class="number">11</span>,<span class="number">0</span>);</span><br><span class="line">		Hash[tmp]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">20</span>;i++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">			Hash[tmp]++;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> maxIndex=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++){</span><br><span class="line">			<span class="keyword">if</span>(Hash[i]&gt;max){</span><br><span class="line">				max=Hash[i];</span><br><span class="line">				maxIndex=i;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;maxIndex&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="整数和"><a href="#整数和" class="headerlink" title="整数和"></a>整数和</h2><p><strong>题目描述</strong><br>编写程序，读入一个整数N。若N为非负数，则计算N 到2N 之间的整数和；若N为一个负数，则求2N 到N 之间的整数和。<br>输入<br>第一行表示样例数m，接下来m行每行一个整数N，N的绝对值不超过100。<br><strong>输出</strong><br>输出m行，每行表示对应的题目所求。<br><strong>样例输入</strong><br>2<br>2<br>-1<br><strong>样例输出</strong><br>9<br>-3<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(m--){</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="keyword">int</span> a,b;</span><br><span class="line">		<span class="keyword">if</span>(n&gt;=<span class="number">0</span>){</span><br><span class="line">			a=n;</span><br><span class="line">			b=<span class="number">2</span>*n;</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			a=<span class="number">2</span>*n;</span><br><span class="line">			b=n;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=a;i&lt;=b;i++){</span><br><span class="line">			sum+=i;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="多项式的值"><a href="#多项式的值" class="headerlink" title="多项式的值"></a>多项式的值</h2><p><strong>题目描述</strong><br>实现一个多项式的类（a+b<em>x+c</em>x^2+d<em>x^3+…+），要求输入该多项式的系数和x<br>的值后打印出这个多项式的值。<br>*</em>输入**<br>输入第一行为样例数m，对于每个样例，第一行为多项式最高项次数n，接下来n+1个整数表示每项系数，最后一个整数x，n不超过10。<br><strong>输出</strong><br>输出m行，表示个多项式代入x后的值。<br><strong>样例输入</strong><br>1<br>2<br>1 2 3<br>2<br><strong>样例输出</strong><br>17<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(m--){</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		vec.resize(n+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++) <span class="built_in">cin</span>&gt;&gt;vec[i];</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">		<span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++){</span><br><span class="line">			value+=vec[i]*(<span class="keyword">int</span>)<span class="built_in">pow</span>(x,i);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;value&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="迭代求立方根"><a href="#迭代求立方根" class="headerlink" title="迭代求立方根"></a>迭代求立方根</h2><p><strong>题目描述</strong><br>立方根的逼近迭代方程是 y(n+1) = y(n)<em>2/3 + x/(3</em>y(n)<em>y(n)),其中y0=x.求给定的x经过n次迭代后立方根的值。<br>*</em>输入**<br>输入有多组数据。<br>每组一行，输入x n。<br><strong>输出</strong><br>迭代n次后的立方根，double精度,保留小数点后面六位。<br><strong>样例输入</strong><br>4654684 1<br>65461 23<br><strong>样例输出</strong><br>3103122.666667<br>40.302088<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">double</span> x;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;n){</span><br><span class="line">		<span class="keyword">double</span> y[n+<span class="number">1</span>];</span><br><span class="line">		y[<span class="number">0</span>]=x;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			y[i+<span class="number">1</span>]=y[i]*<span class="number">2</span>/<span class="number">3.0</span>+x/(<span class="number">3</span>*y[i]*y[i]);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.6f\n"</span>,y[n]);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="与7无关的数"><a href="#与7无关的数" class="headerlink" title="与7无关的数"></a>与7无关的数</h2><p><strong>题目描述</strong><br>一个正整数,如果它能被7整除,或者它的十进制表示法中某个位数上的数字为7,<br>则称其为与7相关的数.现求所有小于等于n(n&lt;100)的与7无关的正整数的平方和。<br><strong>输入</strong><br>案例可能有多组。对于每个测试案例输入为一行,正整数n,(n&lt;100)<br><strong>输出</strong><br>对于每个测试案例输出一行，输出小于等于n的与7无关的正整数的平方和。<br><strong>样例输入</strong><br>6<br>12<br>18<br><strong>样例输出</strong><br>91<br>601<br>1575<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRelative</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(x%<span class="number">7</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(x%<span class="number">10</span>==<span class="number">7</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	x/=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">7</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		vec.clear();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">			<span class="keyword">if</span>(!isRelative(i)){</span><br><span class="line">				vec.push_back(i);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size();i++){</span><br><span class="line">			sum+=(<span class="keyword">int</span>)<span class="built_in">pow</span>(vec[i],<span class="number">2</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="鸡兔同笼"><a href="#鸡兔同笼" class="headerlink" title="鸡兔同笼"></a>鸡兔同笼</h2><p><strong>题目描述</strong><br>一个笼子里面关了鸡和兔子（鸡有2只脚，兔子有4只脚，没有例外）。已经知道了笼子里面脚的总数a，问笼子里面至少有多少只动物，至多有多少只动物。<br><strong>输入</strong><br>第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，每行一个正整数a (a &lt; 32768)<br><strong>输出</strong><br>输出包含n行，每行对应一个输入,包含两个正整数，第一个是最少的动物数，第二个是最多的动物数，两个正整数用一个空格分开<br>如果没有满足要求的答案，则输出两个0。<br><strong>样例输入</strong><br>2<br>18<br>5<br><strong>样例输出</strong><br>5 9<br>0 0<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">while</span>(n--){</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">		<span class="keyword">int</span> min=<span class="number">0</span>,max=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(x&amp;<span class="number">1</span>!=<span class="number">0</span>) {</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">int</span> tmp=x;</span><br><span class="line">		<span class="keyword">while</span>(tmp&gt;=<span class="number">4</span>){</span><br><span class="line">			tmp-=<span class="number">4</span>;</span><br><span class="line">			min++;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(tmp&gt;<span class="number">0</span>) min++;</span><br><span class="line">		tmp=x;</span><br><span class="line">		<span class="keyword">while</span>(tmp&gt;=<span class="number">2</span>){</span><br><span class="line">			tmp-=<span class="number">2</span>;</span><br><span class="line">			max++;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;min&lt;&lt;<span class="string">" "</span>&lt;&lt;max&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="最大公因数与最小公倍数"><a href="#最大公因数与最小公倍数" class="headerlink" title="最大公因数与最小公倍数"></a>最大公因数与最小公倍数</h1></blockquote><h2 id="Least-Common-multiple"><a href="#Least-Common-multiple" class="headerlink" title="Least Common multiple"></a>Least Common multiple</h2><p><strong>Description</strong><br>The least common multiple (LCM) of a set of positive integers is the smallest positive integer which is divisible by all the numbers in the set. For example, the LCM of 5, 7 and 15 is 105.</p><p><strong>Input</strong><br>Input will consist of multiple problem instances. The first line of the input will contain a single integer indicating the number of problem instances. Each instance will consist of a single line of the form m n1 n2 n3 … nm where m is the number of integers in the set and n1 … nm are the integers. All integers will be positive and lie within the range of a 32-bit integer.</p><p><strong>Output</strong><br>For each problem instance, output a single line containing the corresponding LCM. All results will lie in the range of a 32-bit integer.</p><p><strong>Sample Input</strong><br>2<br>2 3 5<br>3 4 6 12<br><strong>Sample Output</strong><br>15<br>12<br><strong>Procedure</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(y==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> gcd(y,x%y);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">while</span>(n--){</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> m;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">		vec.resize(m);</span><br><span class="line">		<span class="keyword">long</span> result=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;vec[i];</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">0</span>){</span><br><span class="line">				result=vec[i];</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span>{</span><br><span class="line">				result=result*vec[i]/gcd(result,vec[i]);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;result&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="分数的四则运算"><a href="#分数的四则运算" class="headerlink" title="分数的四则运算"></a>分数的四则运算</h1></blockquote><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fraction</span>{</span></span><br><span class="line">	<span class="keyword">int</span> up;    <span class="comment">//Numerator</span></span><br><span class="line">	<span class="keyword">int</span> down;  <span class="comment">//Denominator</span></span><br><span class="line">  Fraction(){} <span class="comment">//Default Constructor</span></span><br><span class="line">	Fraction(<span class="keyword">int</span> Up,<span class="keyword">int</span> Down):up(Up),down(Down){} <span class="comment">//</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//Return the least common mutiple of x and y</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line">	<span class="keyword">return</span> !y? x:gcd(y,x%y);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Reduce the fraction</span></span><br><span class="line"><span class="comment">//1.Denominator is non-negative: if the fraction is negative, just make the numerator negative</span></span><br><span class="line"><span class="comment">//2.if the fraction is zero, just up=0, down=1</span></span><br><span class="line"><span class="comment">//3.The greatest common divisor of numerator and denominator must be '1'.</span></span><br><span class="line"><span class="function">Fraction <span class="title">reduction</span><span class="params">(Fraction fraction)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(fraction.down&lt;<span class="number">0</span>){</span><br><span class="line">		fraction.up=-fraction.up;</span><br><span class="line">		fraction.down=-fraction.down;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(fraction.up==<span class="number">0</span>){</span><br><span class="line">		fraction.down=<span class="number">1</span>;</span><br><span class="line">	}<span class="keyword">else</span>{</span><br><span class="line">		<span class="keyword">int</span> gcd=d(<span class="built_in">abs</span>(fraction.up),<span class="built_in">abs</span>(fraction.down));</span><br><span class="line">		fraction.up/=d;</span><br><span class="line">		fraction.down/=d;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> fraction;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Addition</span></span><br><span class="line"><span class="function">Fraction <span class="title">addition</span><span class="params">(Fraction f1,Fraction f2)</span></span>{</span><br><span class="line">	Fraction fraction;</span><br><span class="line">	fraction.up=f1.up*f2.down+f2.up*f1.down;</span><br><span class="line">	fraction.down=f1.down*f2.down;</span><br><span class="line">	<span class="keyword">return</span> reduction(fraction);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Subtraction</span></span><br><span class="line"><span class="function">Fraction <span class="title">subtraction</span><span class="params">(Fraction f1,Fraction f2)</span></span>{</span><br><span class="line">	Fraction fraction;</span><br><span class="line">	fraction.up=f1.up*f2.down-f2.up*f1.down;</span><br><span class="line">	fraction.down=f1.down*f2.down;</span><br><span class="line">	<span class="keyword">return</span> reduction(fraction);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Multiplication</span></span><br><span class="line"><span class="function">Fraction <span class="title">multiplication</span><span class="params">(Fraction f1,Fraction f2)</span></span>{</span><br><span class="line">	Fraction fraction;</span><br><span class="line">	fraction.up=f1.up*f2.up;</span><br><span class="line">	fraction.down=f1.down*f2.down;</span><br><span class="line">	<span class="keyword">return</span> reduction(fraction);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Division</span></span><br><span class="line"><span class="function">Fraction <span class="title">division</span><span class="params">(Fraction f1,Fraction f2)</span></span>{</span><br><span class="line">	Fraction fraction;</span><br><span class="line">	fraction.up=f1.up*f2.down;</span><br><span class="line">	fraction.down=f1.down*f2.up;</span><br><span class="line">	<span class="keyword">return</span> reduction(fraction);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="分数矩阵"><a href="#分数矩阵" class="headerlink" title="分数矩阵"></a>分数矩阵</h2><p><strong>题目描述</strong><br>我们定义如下矩阵：<br>1/1 1/2 1/3<br>1/2 1/1 1/2<br>1/3 1/2 1/1<br>矩阵对角线上的元素始终是1/1，对角线两边分数的分母逐个递增。<br>请求出这个矩阵的总和。<br><strong>输入</strong><br>输入包含多组测试数据。每行给定整数N（N&lt;50000），表示矩阵为N<em>N。当N=0时，输入结束。<br>*</em>输出**<br>输出答案，结果保留2位小数。<br><strong>样例输入</strong><br>1<br>2<br>3<br>4<br>0<br><strong>样例输出</strong><br>1.00<br>3.00<br>5.67<br>8.83<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n!=<span class="number">0</span>){</span><br><span class="line">		<span class="keyword">double</span> result=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="keyword">double</span> tmp=(n-i)*<span class="number">1.0</span>/(i+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(i!=<span class="number">0</span>) tmp*=<span class="number">2</span>;</span><br><span class="line">			result+=tmp;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>,result);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1062-最简分数-20"><a href="#1062-最简分数-20" class="headerlink" title="1062. 最简分数(20)"></a>1062. 最简分数(20)</h2><p>一个分数一般写成两个整数相除的形式：N/M，其中M不为0。最简分数是指分子和分母没有公约数的分数表示形式。<br>现给定两个不相等的正分数 N1/M1 和 N2/M2，要求你按从小到大的顺序列出它们之间分母为K的最简分数。<br><strong>输入格式</strong><br>输入在一行中按N/M的格式给出两个正分数，随后是一个正整数分母K，其间以空格分隔。题目保证给出的所有整数都不超过1000。<br><strong>输出格式</strong><br>在一行中按N/M的格式列出两个给定分数之间分母为K的所有最简分数，按从小到大的顺序，其间以1个空格分隔。行首尾不得有多余空格。题目保证至少有1个输出。<br><strong>输入样例</strong><br>7/18 13/20 12<br><strong>输出样例</strong><br>5/12 7/12<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fraction</span>{</span></span><br><span class="line">	<span class="keyword">int</span> up;    <span class="comment">//Numerator</span></span><br><span class="line">	<span class="keyword">int</span> down;  <span class="comment">//Denominator</span></span><br><span class="line">  Fraction(){} <span class="comment">//Default Constructor</span></span><br><span class="line">	Fraction(<span class="keyword">int</span> Up,<span class="keyword">int</span> Down):up(Up),down(Down){} <span class="comment">//</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//Return the least common mutiple of x and y</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line">	<span class="keyword">return</span> !y? x:gcd(y,x%y);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Reduce the fraction</span></span><br><span class="line"><span class="comment">//1.Denominator is non-negative: if the fraction is negative, just make the numerator negative</span></span><br><span class="line"><span class="comment">//2.if the fraction is zero, just up=0, down=1</span></span><br><span class="line"><span class="comment">//3.The greatest common divisor of numerator and denominator must be '1'.</span></span><br><span class="line"><span class="function">Fraction <span class="title">reduction</span><span class="params">(Fraction fraction)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(fraction.down&lt;<span class="number">0</span>){</span><br><span class="line">		fraction.up=-fraction.up;</span><br><span class="line">		fraction.down=-fraction.down;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(fraction.up==<span class="number">0</span>){</span><br><span class="line">		fraction.down=<span class="number">1</span>;</span><br><span class="line">	}<span class="keyword">else</span>{</span><br><span class="line">		<span class="keyword">int</span> d=gcd(<span class="built_in">abs</span>(fraction.up),<span class="built_in">abs</span>(fraction.down));</span><br><span class="line">		fraction.up/=d;</span><br><span class="line">		fraction.down/=d;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> fraction;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Addition</span></span><br><span class="line"><span class="function">Fraction <span class="title">addition</span><span class="params">(Fraction f1,Fraction f2)</span></span>{</span><br><span class="line">	Fraction fraction;</span><br><span class="line">	fraction.up=f1.up*f2.down+f2.up*f1.down;</span><br><span class="line">	fraction.down=f1.down*f2.down;</span><br><span class="line">	<span class="keyword">return</span> reduction(fraction);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Subtraction</span></span><br><span class="line"><span class="function">Fraction <span class="title">subtraction</span><span class="params">(Fraction f1,Fraction f2)</span></span>{</span><br><span class="line">	Fraction fraction;</span><br><span class="line">	fraction.up=f1.up*f2.down-f2.up*f1.down;</span><br><span class="line">	fraction.down=f1.down*f2.down;</span><br><span class="line">	<span class="keyword">return</span> reduction(fraction);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Multiplication</span></span><br><span class="line"><span class="function">Fraction <span class="title">multiplication</span><span class="params">(Fraction f1,Fraction f2)</span></span>{</span><br><span class="line">	Fraction fraction;</span><br><span class="line">	fraction.up=f1.up*f2.up;</span><br><span class="line">	fraction.down=f1.down*f2.down;</span><br><span class="line">	<span class="keyword">return</span> reduction(fraction);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Division</span></span><br><span class="line"><span class="function">Fraction <span class="title">division</span><span class="params">(Fraction f1,Fraction f2)</span></span>{</span><br><span class="line">	Fraction fraction;</span><br><span class="line">	fraction.up=f1.up*f2.down;</span><br><span class="line">	fraction.down=f1.down*f2.up;</span><br><span class="line">	<span class="keyword">return</span> reduction(fraction);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//f1&lt;f2</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Fraction f1,Fraction f2)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> d=gcd(f1.down,f2.down);</span><br><span class="line">	<span class="keyword">int</span> lcm=f1.down*f2.down/d;</span><br><span class="line">	f1.up*=lcm/f1.down;</span><br><span class="line">	f2.up*=lcm/f2.down;</span><br><span class="line">	<span class="keyword">if</span>(f1.up&lt;f2.up) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	Fraction f1,f2;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d/%d %d/%d %d"</span>,&amp;f1.up,&amp;f1.down,&amp;f2.up,&amp;f2.down,&amp;k)!=EOF){</span><br><span class="line">		<span class="keyword">if</span>(!cmp(f1,f2)) swap(f1,f2);</span><br><span class="line">		<span class="keyword">bool</span> bFirst=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++){</span><br><span class="line">			<span class="function">Fraction <span class="title">fraction</span><span class="params">(i,k)</span></span>;</span><br><span class="line">			<span class="keyword">if</span>(cmp(f1,fraction)&amp;&amp;cmp(fraction,f2)){</span><br><span class="line">				fraction=reduction(fraction);</span><br><span class="line">				<span class="keyword">if</span>(fraction.down==k){</span><br><span class="line">					<span class="keyword">if</span>(bFirst){</span><br><span class="line">						bFirst=<span class="literal">false</span>;</span><br><span class="line">					}<span class="keyword">else</span>{</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">					}</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"%d/%d"</span>,fraction.up,fraction.down);</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h1></blockquote><h2 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//Judge whether the x is a prime number</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=x;i++){</span><br><span class="line">		<span class="keyword">if</span>(x%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}<span class="comment">//O(sprt(n))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Record all prime numbers between 1 to x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Eratosthenes</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> prime[MAXN];</span><br><span class="line"><span class="keyword">bool</span> bMarked[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Eratosthenes</span><span class="params">()</span></span>{</span><br><span class="line">	fill(bMarked,bMarked+MAXN,<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> nCount=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;MAXN;i++){</span><br><span class="line">		<span class="keyword">if</span>(!bMarked[i]){</span><br><span class="line">			prime[nCount++]=i;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i+i;j&lt;MAXN;j+=i){</span><br><span class="line">				bMarked[j]=<span class="literal">true</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}<span class="comment">//O(nloglogn)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Euler</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> prime[MAXN];</span><br><span class="line"><span class="keyword">bool</span> bMarked[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler</span><span class="params">()</span></span>{</span><br><span class="line">	fill(bMarked,bMarked+MAXN,<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> nCount=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;MAXN;i++){</span><br><span class="line">		<span class="keyword">if</span>(!bMarked[i]){</span><br><span class="line">			bMarked[i]=<span class="literal">true</span>;</span><br><span class="line">			prime[nCount++]=i;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nCount&amp;&amp;i*prime[j]&lt;MAXN;j++){</span><br><span class="line">			bMarked[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}O(n)</span><br></pre></td></tr></tbody></table></figure><h2 id="素数-1"><a href="#素数-1" class="headerlink" title="素数"></a>素数</h2><p><strong>题目描述</strong><br>输入一个整数n(2&lt;=n&lt;=10000)，要求输出所有从1到这个整数之间(不包括1和这个整数)个位为1的素数，如果没有则输出-1。<br><strong>输入</strong><br>输入有多组数据。<br>每组一行，输入n。<br><strong>输出</strong><br>输出所有从1到这个整数之间(不包括1和这个整数)个位为1的素数(素数之间用空格隔开，最后一个素数后面没有空格)，如果没有则输出-1。<br><strong>样例输入</strong><br>70<br><strong>样例输出</strong><br>11 31 41 61<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">10001</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">int</span> bMarked[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler</span><span class="params">()</span></span>{</span><br><span class="line">	fill(bMarked,bMarked+MAXN,<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;MAXN;i++){</span><br><span class="line">		<span class="keyword">if</span>(!bMarked[i]){</span><br><span class="line">			bMarked[i]=<span class="literal">true</span>;</span><br><span class="line">			vec.push_back(i);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vec.size()&amp;&amp;i*vec[j]&lt;MAXN;j++){</span><br><span class="line">			bMarked[i*vec[j]]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%vec[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	Euler();</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		<span class="keyword">bool</span> bFirst=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size()&amp;&amp;vec[i]&lt;n;i++){</span><br><span class="line">			<span class="keyword">int</span> tmp=vec[i]%<span class="number">10</span>;</span><br><span class="line">			<span class="keyword">if</span>(tmp==<span class="number">1</span>){</span><br><span class="line">				<span class="keyword">if</span>(bFirst) bFirst=<span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;vec[i];</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(bFirst) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Prime-Number"><a href="#Prime-Number" class="headerlink" title="Prime Number"></a>Prime Number</h2><p><strong>题目描述</strong><br>Output the k-th prime number.<br><strong>输入</strong><br>k≤10000<br><strong>输出</strong><br>The k-th prime number.<br><strong>样例输入</strong><br>10<br>50<br><strong>样例输出</strong><br>29<br>229<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> MAXN=<span class="number">9999999</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">bool</span> bMarked[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler</span><span class="params">()</span></span>{</span><br><span class="line">	fill(bMarked,bMarked+MAXN,<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">2</span>;vec.size()&lt;<span class="number">10001</span>;i++){</span><br><span class="line">		<span class="keyword">if</span>(!bMarked[i]){</span><br><span class="line">			bMarked[i]=<span class="literal">true</span>;</span><br><span class="line">			vec.push_back(i);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vec.size()&amp;&amp;i*vec[j]&lt;MAXN;j++){</span><br><span class="line">			bMarked[i*vec[j]]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%vec[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	Euler();</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;k){</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;vec[k<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Goldbach’s-Conjecture"><a href="#Goldbach’s-Conjecture" class="headerlink" title="Goldbach’s Conjecture"></a>Goldbach’s Conjecture</h2><p><strong>Description</strong><br>Goldbach’s Conjecture: For any even number n greater than or equal to 4, there exists at least one pair of prime numbers p1 and p2 such that $n = p1 + p2$.<br>This conjecture has not been proved nor refused yet. No one is sure whether this conjecture actually holds. However, one can find such a pair of prime numbers, if any, for a given even number. The problem here is to write a program that reports the number of all the pairs of prime numbers satisfying the condition in the conjecture for a given even number.<br>A sequence of even numbers is given as input. Corresponding to each number, the program should output the number of pairs mentioned above. Notice that we are interested in the number of essentially different pairs and therefore you should not count $(p1, p2)$ and $(p2, p1)$ separately as two different pairs.<br><strong>Input</strong><br>An integer is given in each input line. You may assume that each integer is even, and is greater than or equal to 4 and less than $2^{15}$. The end of the input is indicated by a number 0.<br><strong>Output</strong><br>Each output line should contain an integer number. No other characters should appear in the output.<br><strong>Sample Input</strong><br>4<br>10<br>16<br>0<br><strong>Sample Output</strong><br>1<br>2<br>2<br><strong>Procedure</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">32768</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">bool</span> bMarked[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">	fill(bMarked,bMarked+MAXN,<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;MAXN;i++){</span><br><span class="line">		<span class="keyword">if</span>(!bMarked[i]){</span><br><span class="line">			bMarked[i]=<span class="literal">true</span>;</span><br><span class="line">			vec.push_back(i);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vec.size()&amp;&amp;i*vec[j]&lt;MAXN;j++){</span><br><span class="line">			bMarked[i*vec[j]]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%vec[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=x;i++){</span><br><span class="line">		<span class="keyword">if</span>(x%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	Euler();</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n!=<span class="number">0</span>){</span><br><span class="line">		<span class="keyword">int</span> nCount=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size()&amp;&amp;vec[i]&lt;=n/<span class="number">2</span>;i++){</span><br><span class="line">			<span class="keyword">if</span>(isPrime(n-vec[i])) nCount++;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;nCount&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="完数"><a href="#完数" class="headerlink" title="完数"></a>完数</h2><p><strong>题目描述</strong><br>求1-n内的完数，所谓的完数是这样的数，它的所有因子相加等于它自身，比如6有3个因子1,2,3,1+2+3=6，那么6是完数。即完数是等于其所有因子相加和的数。<br><strong>输入</strong><br>测试数据有多组，输入n，n数据范围不大。<br><strong>输出</strong><br>对于每组输入,请输出1-n内所有的完数。如有案例输出有多个数字，用空格隔开，输出最后不要有多余的空格。<br><strong>样例输入</strong><br>6<br><strong>样例输出</strong><br>6<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPerfect</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*i&lt;=x;i++){</span><br><span class="line">		<span class="keyword">if</span>(x%i==<span class="number">0</span>){</span><br><span class="line">			<span class="keyword">if</span>(i&lt;x) sum+=i;</span><br><span class="line">			<span class="keyword">if</span>(x/i&lt;x) sum+=x/i;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(sum&gt;x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(sum==x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">bool</span> bFirst=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">			<span class="keyword">if</span>(isPerfect(i)){</span><br><span class="line">				<span class="keyword">if</span>(bFirst) bFirst=<span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;i;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="质因数的个数"><a href="#质因数的个数" class="headerlink" title="质因数的个数"></a>质因数的个数</h2><p><strong>题目描述</strong><br>求正整数N(N&gt;1)的质因数的个数。<br>相同的质因数需要重复计算。如120=2<em>2</em>2<em>3</em>5，共有5个质因数。<br>输入<br>可能有多组测试数据，每组测试数据的输入是一个正整数N，(1&lt;N&lt;10^9)。<br><strong>输出</strong><br>对于每组数据，输出N的质因数的个数。<br><strong>样例输入</strong><br>120<br>200<br><strong>样例输出</strong><br>5<br>5<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">①2~sqrt(n)如果n不等于1，说明n有且仅有一个大于sqrt(n)的质因数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100000</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">bool</span> bMarked[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler</span><span class="params">()</span></span>{</span><br><span class="line">	fill(bMarked,bMarked+MAXN,<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;MAXN;i++){</span><br><span class="line">		<span class="keyword">if</span>(!bMarked[i]){</span><br><span class="line">			bMarked[i]=<span class="literal">true</span>;</span><br><span class="line">			vec.push_back(i);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vec.size()&amp;&amp;i*vec[j]&lt;MAXN;j++){</span><br><span class="line">			bMarked[i*vec[j]]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%vec[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	Euler();</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		<span class="keyword">int</span> nCount=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size();i++){</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span>(n%vec[i]==<span class="number">0</span>){</span><br><span class="line">				nCount++;</span><br><span class="line">				n/=vec[i];</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(n!=<span class="number">1</span>) nCount++;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;nCount&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="约数的个数"><a href="#约数的个数" class="headerlink" title="约数的个数"></a>约数的个数</h2><p><strong>题目描述</strong><br>输入n个整数,依次输出每个数的约数的个数。<br><strong>输入</strong><br>输入的第一行为N，即数组的个数(N&lt;=1000)<br>接下来的1行包括N个整数，其中每个数的范围为(1&lt;=Num&lt;=1000000000)<br>当N=0时输入结束。<br><strong>输出</strong><br>可能有多组输入数据，对于每组输入数据，<br>输出N行，其中每一行对应上面的一个数的约数的个数。<br><strong>样例输入</strong><br>6<br>1 4 6 8 10 12<br>0<br><strong>样例输出</strong><br>1<br>3<br>4<br>4<br>4<br>6<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*i&lt;=x;i++){</span><br><span class="line">		<span class="keyword">if</span>(x%i==<span class="number">0</span>){</span><br><span class="line">			<span class="keyword">if</span>(i*i==x) sum+=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> sum+=<span class="number">2</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n!=<span class="number">0</span>){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="keyword">int</span> tmp;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tmp);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,count(tmp));</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="完数与盈数"><a href="#完数与盈数" class="headerlink" title="完数与盈数"></a>完数与盈数</h2><p><strong>题目描述</strong><br>一个数如果恰好等于它的各因子（该数本身除外）子和，如：6=3+2+1，则称其为“完数”；<br>若因子之和大于该数，则称其为“盈数”。求出2 到60 之间所有“完数”和“盈数”，并以如<br>下形式输出： E: e1 e2 e3 ……(ei 为完数) G: g1 g2 g3 ……(gi 为盈数)<br><strong>输入</strong><br>无<br><strong>输出</strong><br>按描述要求输出（注意EG后面的冒号之后有一个空格）。<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecE;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecG;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPerfect</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*i&lt;=x;i++){</span><br><span class="line">		<span class="keyword">if</span>(x%i==<span class="number">0</span>){</span><br><span class="line">			sum+=i;</span><br><span class="line">			<span class="keyword">if</span>(x/i&lt;x) sum+=x/i;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(sum&gt;x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(sum!=x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">60</span>;i++){</span><br><span class="line">		<span class="keyword">if</span>(isPerfect(i)) vecE.push_back(i);</span><br><span class="line">		<span class="keyword">else</span> vecG.push_back(i);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"E:"</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=vecE.begin();it!=vecE.end();it++){</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;*it;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"G:"</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=vecG.begin();it!=vecG.end();it++){</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;*it;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="大整数"><a href="#大整数" class="headerlink" title="大整数"></a>大整数</h1></blockquote><h2 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigInteger</span>{</span></span><br><span class="line">	<span class="keyword">int</span> b[<span class="number">1000</span>];  <span class="comment">//数组</span></span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">	BigInteger(){</span><br><span class="line">		<span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line">		len=<span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	BigInteger(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str){</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		len=str.length();</span><br><span class="line">		<span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++){</span><br><span class="line">			b[i]=str[len-i<span class="number">-1</span>]-<span class="string">'0'</span>;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;b[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;len&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>{</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;b[i]&lt;&lt;<span class="string">":"</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(BigInteger big1,BigInteger big2)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(big1.len&gt;big2.len) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(big1.len&lt;big2.len) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span>{</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=big1.len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">			<span class="keyword">if</span>(big1.b[i]&gt;big2.b[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(big1.b[i]&lt;big2.b[i]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">BigInteger <span class="title">addition</span><span class="params">(BigInteger big1,BigInteger big2)</span></span>{</span><br><span class="line">	BigInteger big;</span><br><span class="line">	<span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;big1.len||i&lt;big2.len;i++){</span><br><span class="line">		<span class="keyword">int</span> temp=big1.b[i]+big2.b[i]+carry;</span><br><span class="line">		big.b[big.len++]=temp%<span class="number">10</span>;</span><br><span class="line">		carry=temp/<span class="number">10</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(carry!=<span class="number">0</span>){</span><br><span class="line">		big.b[big.len++]=carry;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> big;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">BigInteger <span class="title">subtraction</span><span class="params">(BigInteger big1,BigInteger big2)</span></span>{</span><br><span class="line">	BigInteger big;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;big1.len||i&lt;big2.len;i++){</span><br><span class="line">		<span class="keyword">if</span>(big1.b[i]&lt;big2.b[i]){</span><br><span class="line">			big1.b[i+<span class="number">1</span>]--;</span><br><span class="line">			big1.b[i]+=<span class="number">10</span>;</span><br><span class="line">		}</span><br><span class="line">		big.b[big.len++]=big1.b[i]-big2.b[i];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">while</span>(big.len&gt;<span class="number">1</span>&amp;&amp;big.b[big.len<span class="number">-1</span>]==<span class="number">0</span>){</span><br><span class="line">		big.len--;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> big;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">BigInteger <span class="title">mutiple</span><span class="params">(BigInteger big1,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">	BigInteger big;</span><br><span class="line">	<span class="keyword">int</span> carry=<span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;big1.len;i++){</span><br><span class="line">		<span class="keyword">int</span> temp=big1.b[i]*b+carry;</span><br><span class="line">		big.b[big.len++]=tem%<span class="number">10</span>;</span><br><span class="line">		carry=temp/<span class="number">10</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">while</span>(carry!=<span class="number">0</span>){</span><br><span class="line">		big.b[big.len++]=carry%<span class="number">10</span>;</span><br><span class="line">		carry/=<span class="number">10</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> big;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">BigInteger <span class="title">division</span><span class="params">(BigInteger big1, <span class="keyword">int</span> b)</span></span>{</span><br><span class="line">	BigInteger big;</span><br><span class="line">	<span class="keyword">int</span> rest=<span class="number">0</span>;</span><br><span class="line">	big.len=big1.len;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=big1.len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">		rest=rest*<span class="number">10</span>+big1.b[i];</span><br><span class="line">		<span class="keyword">if</span>(rest&gt;=b){</span><br><span class="line">			big.b[i]=rest/b;</span><br><span class="line">			rest=rest%b;</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			big.b[i]=<span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">while</span>(big.len&gt;<span class="number">1</span>&amp;&amp;big.b[big.len<span class="number">-1</span>]==<span class="number">0</span>){</span><br><span class="line">		big.len--;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> big;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="a-b"><a href="#a-b" class="headerlink" title="a+b"></a>a+b</h2><p><strong>题目描述</strong><br>实现一个加法器，使其能够输出a+b的值。<br><strong>输入</strong><br>输入包括两个数a和b，其中a和b的位数不超过1000位。<br><strong>输出</strong><br>可能有多组测试数据，对于每组数据，<br>输出a+b的值。<br><strong>样例输入</strong><br>6 8<br>2000000000 30000000000000000000<br><strong>样例输出</strong><br>14<br>30000000002000000000<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigInteger</span>{</span></span><br><span class="line">	<span class="keyword">int</span> b[<span class="number">1001</span>];</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">	BigInteger(){</span><br><span class="line">		<span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line">		len=<span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	BigInteger(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str){</span><br><span class="line">		<span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line">		len=str.length();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++){</span><br><span class="line">			b[i]=str[str.length()<span class="number">-1</span>-i]-<span class="string">'0'</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	BigInteger(<span class="keyword">const</span> BigInteger &amp;big){</span><br><span class="line">		<span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line">		len=big.len;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++){</span><br><span class="line">			b[i]=big.b[i];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	BigInteger&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> BigInteger &amp; big){</span><br><span class="line">		<span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line">		len=big.len;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++){</span><br><span class="line">			b[i]=big.b[i];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>{</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;b[i];</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(BigInteger big1,BigInteger big2)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(big1.len&gt;big2.len) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(big1.len&lt;big2.len) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span>{</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=big1.len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">			<span class="keyword">if</span>(big1.b[i]&gt;big2.b[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(big1.b[i]&lt;big2.b[i]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">BigInteger <span class="title">addition</span><span class="params">(BigInteger big1,BigInteger big2)</span></span>{</span><br><span class="line">	BigInteger big;</span><br><span class="line">	<span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;big1.len||i&lt;big2.len;i++){</span><br><span class="line">		<span class="keyword">int</span> temp=big1.b[i]+big2.b[i]+carry;</span><br><span class="line">		big.b[big.len++]=temp%<span class="number">10</span>;</span><br><span class="line">		carry=temp/<span class="number">10</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(carry!=<span class="number">0</span>){</span><br><span class="line">		big.b[big.len++]=carry;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> big;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">BigInteger <span class="title">subtraction</span><span class="params">(BigInteger big1,BigInteger big2)</span></span>{</span><br><span class="line">	BigInteger big;</span><br><span class="line">	<span class="keyword">int</span> lend=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;big1.len||big2.len;i++){</span><br><span class="line">		big1.b[i]-=lend;</span><br><span class="line">		<span class="keyword">if</span>(big1.b[i]&lt;big2.b[i]){</span><br><span class="line">			lend=<span class="number">1</span>;</span><br><span class="line">			big1.b[i]+=<span class="number">10</span>;</span><br><span class="line">		}</span><br><span class="line">		big.b[big.len++]=big1.b[i]-big2.b[i];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">while</span>(big.len&gt;=<span class="number">2</span>&amp;&amp;big.b[big.len<span class="number">-1</span>]==<span class="number">0</span>){</span><br><span class="line">		big.len--;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> big;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">string</span> a,b;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b){</span><br><span class="line">		<span class="keyword">bool</span> flag1,flag2;</span><br><span class="line">		flag1=flag2=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="string">'-'</span>) {</span><br><span class="line">			flag1=<span class="literal">false</span>;</span><br><span class="line">			a=a.substr(<span class="number">1</span>,a.length()<span class="number">-1</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(b[<span class="number">0</span>]==<span class="string">'-'</span>){</span><br><span class="line">			flag2=<span class="literal">false</span>;</span><br><span class="line">			b=b.substr(<span class="number">1</span>,b.length()<span class="number">-1</span>);</span><br><span class="line">		}</span><br><span class="line">		BigInteger big1(a),big2(b);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(flag1==flag2){</span><br><span class="line">			BigInteger big=addition(big1,big2);</span><br><span class="line">			<span class="keyword">if</span>(!flag1) <span class="built_in">cout</span>&lt;&lt;<span class="string">"-"</span>;</span><br><span class="line">			big.print();</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			<span class="keyword">bool</span> former=compare(big1,big2);</span><br><span class="line">			BigInteger big;</span><br><span class="line">			<span class="keyword">bool</span> flag;</span><br><span class="line">			<span class="keyword">if</span>(former){</span><br><span class="line">				flag=flag1;</span><br><span class="line">				big=subtraction(big1,big2);</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				flag=flag2;</span><br><span class="line">				big=subtraction(big2,big1);</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span>(big.len!=<span class="number">1</span>){</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"-"</span>;</span><br><span class="line">			}</span><br><span class="line">			big.print();</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h1></blockquote><h2 id="n！含质因子p的个数"><a href="#n！含质因子p的个数" class="headerlink" title="n！含质因子p的个数"></a>n！含质因子p的个数</h2><p>1.公式$n/p+n/p^{2}+n/p^{3}+…$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>{</span><br><span class="line">  <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(n!=<span class="number">0</span>){</span><br><span class="line">    ans+=n/p;</span><br><span class="line">    n/=p;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2.公式$f(n)=(n/p+f(n/p))$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(n&lt;p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> n/p+cal(n/p,p);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h1></blockquote><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p><strong>题目描述</strong><br>排列与组合是常用的数学方法。<br>先给一个正整数 ( 1 &lt; = n &lt; = 10 )<br>例如n＝3，所有组合,并且按字典序输出：<br>1 2 3<br>1 3 2<br>2 1 3<br>2 3 1<br>3 1 2<br>3 2 1<br><strong>输入</strong><br>输入一个整数n( 1&lt;=n&lt;=10)<br><strong>输出</strong><br>输出所有全排列<br>每个全排列一行，相邻两个数用空格隔开（最后一个数后面没有空格）<br><strong>样例输入</strong><br>3<br><strong>样例输出</strong><br>1 2 3<br>1 3 2<br>2 1 3<br>2 3 1<br>3 1 2<br>3 2 1<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> bVisited[<span class="number">11</span>];</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(str.length()==n){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="keyword">if</span>(i!=<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;str[i];</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">		<span class="keyword">if</span>(!bVisited[i]){</span><br><span class="line">			str+=i+<span class="string">'0'</span>;</span><br><span class="line">			bVisited[i]=<span class="literal">true</span>;</span><br><span class="line">			DFS();</span><br><span class="line">			str.erase(str.length()<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">			bVisited[i]=<span class="literal">false</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		DFS();</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="组合的输出"><a href="#组合的输出" class="headerlink" title="组合的输出"></a>组合的输出</h2><p><strong>题目描述</strong><br>排列与组合是常用的数学方法，其中组合就是从n个元素中抽出r个元素(不分顺序且r &lt; ＝ n)，我们可以简单地将n个元素理解为自然数1，2，…，n，从中任取r个数。<br>现要求你不用递归的方法输出所有组合。<br>例如n ＝ 5 ，r ＝ 3 ，所有组合为：<br>1 2 3<br>1 2 4<br>1 2 5<br>1 3 4<br>1 3 5<br>1 4 5<br>2 3 4<br>2 3 5<br>2 4 5<br>3 4 5<br><strong>输入</strong><br>一行两个自然数n、r ( 1 &lt; n &lt; 21，1 &lt; ＝ r &lt; ＝ n )。<br><strong>输出</strong><br>所有的组合，每一个组合占一行且其中的元素按由小到大的顺序排列，所有的组合也按字典顺序。<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> i)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(str.length()==r){</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;i++){</span><br><span class="line">			<span class="keyword">if</span>(i!=<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;str[i]-<span class="string">'0'</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(i&lt;=n){</span><br><span class="line">		str+=i+<span class="string">'0'</span>;</span><br><span class="line">		DFS(i+<span class="number">1</span>);</span><br><span class="line">		str.erase(str.length()<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">		DFS(i+<span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;r){</span><br><span class="line">		DFS(<span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="组合-判断素数"><a href="#组合-判断素数" class="headerlink" title="组合+判断素数"></a>组合+判断素数</h2><p><strong>题目描述</strong><br>已知 n 个整数b1,b2,…,bn以及一个整数 k（k＜n）。<br>从 n 个整数中任选 k 个整数相加，可分别得到一系列的和。<br>例如当 n=4，k＝3，4 个整数分别为 3，7，12，19 时，可得全部的组合与它们的和为：<br>3＋7＋12=22　　3＋7＋19＝29　　7＋12＋19＝38　　3＋12＋19＝34。<br>现在，要求你计算出和为素数共有多少种。例如上例，只有一种的和为素数：3＋7＋19＝29。<br><strong>输入</strong><br>第一行两个整数：n , k （1&lt;=n&lt;=20，k＜n）<br>第二行n个整数：x1,x2，…,xn （1&lt;=xi&lt;=5000000）<br><strong>输出</strong><br>一个整数（满足条件的方案数）。<br><em>样例输入*</em><br>4 3<br>3 7 12 19<br><strong>样例输出</strong><br>1<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> nCount;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=x;i++){</span><br><span class="line">		<span class="keyword">if</span>(x%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> i)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(dq.size()==k){</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dq.size();i++){</span><br><span class="line">			sum+=dq[i];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(isPrime(sum)){</span><br><span class="line">			nCount++;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(i&lt;n){</span><br><span class="line">		dq.push_back(vec[i]);</span><br><span class="line">		DFS(i+<span class="number">1</span>);</span><br><span class="line">		dq.pop_back();</span><br><span class="line">		DFS(i+<span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k){</span><br><span class="line">		vec.resize(n);</span><br><span class="line">		nCount=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;vec[i];</span><br><span class="line">		}</span><br><span class="line">		DFS(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;nCount&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="深度优先搜多"><a href="#深度优先搜多" class="headerlink" title="深度优先搜多"></a>深度优先搜多</h1></blockquote><h2 id="n皇后问题"><a href="#n皇后问题" class="headerlink" title="n皇后问题"></a>n皇后问题</h2><p><strong>题目描述</strong><br>会下国际象棋的人都很清楚：皇后可以在横、竖、斜线上不限步数地吃掉其他棋子。如何将8个皇后放在棋盘上（有8 * 8个方格），使它们谁也不能被吃掉！这就是著名的八皇后问题。<br><strong>输入</strong><br>一个整数n（ 1 &lt; = n &lt; = 10 )<br><strong>输出</strong><br>每行输出对应一种方案，按字典序输出所有方案。每种方案顺序输出皇后所在的列号，相邻两数之间用空格隔开。如果一组可行方案都没有，输出“no solute!”<br><strong>样例输入</strong><br>4<br><strong>样例输出</strong><br>2 4 1 3<br>3 1 4 2<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> bMarked[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">int</span> result[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">int</span> nCount;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> row)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(row==n+<span class="number">1</span>){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">			<span class="keyword">if</span>(i!=<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;result[i];</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		nCount++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">		<span class="keyword">if</span>(!bMarked[i]){</span><br><span class="line">			<span class="keyword">bool</span> bPass=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;row;j++){</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">abs</span>(result[j]-i)==<span class="built_in">abs</span>(row-j)){</span><br><span class="line">					bPass=<span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span>(bPass){</span><br><span class="line">				result[row]=i;</span><br><span class="line">				bMarked[i]=<span class="literal">true</span>;</span><br><span class="line">				DFS(row+<span class="number">1</span>);</span><br><span class="line">				bMarked[i]=<span class="literal">false</span>;</span><br><span class="line">				result[row]=<span class="number">0</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		fill(bMarked,bMarked+<span class="number">11</span>,<span class="literal">false</span>);</span><br><span class="line">		fill(result,result+<span class="number">11</span>,<span class="number">0</span>);</span><br><span class="line">		nCount=<span class="number">0</span>;</span><br><span class="line">		DFS(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(nCount==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"no solute!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="出栈序列统计"><a href="#出栈序列统计" class="headerlink" title="出栈序列统计"></a>出栈序列统计</h2><p><strong>题目描述</strong><br>栈是常用的一种数据结构，有n令元素在栈顶端一侧等待进栈，栈顶端另一侧是出栈序列。你已经知道栈的操作有两•种：push和pop，前者是将一个元素进栈，后者是将栈顶元素弹出。现在要使用这两种操作，由一个操作序列可以得到一系列的输出序列。请你编程求出对于给定的n，计算并输出由操作数序列1，2，…，n，经过一系列操作可能得到的输出序列总数。<br><strong>输入</strong><br>一个整数n（1&lt;=n&lt;=15）<br><strong>输出</strong><br>一个整数，即可能输出序列的总数目。<br><strong>样例输入</strong><br>3<br><strong>样例输出</strong><br>5<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设f(i,j,k)，i表示入栈数，j表示未入栈数，k表示出栈数</span></span><br><span class="line"><span class="comment">那么对于当前栈：</span></span><br><span class="line"><span class="comment">①如果栈非空，则可以出栈和入栈</span></span><br><span class="line"><span class="comment">②栈空，只能入栈</span></span><br><span class="line"><span class="comment">所以对应出栈序列总数：</span></span><br><span class="line"><span class="comment">①f(i,j,k)=f(i-1,j,k+1)+f(i+1,j-1,k)</span></span><br><span class="line"><span class="comment">② f(i,j,k)=f(i+1,j-1,k)</span></span><br><span class="line"><span class="comment">边界条件：f(i,0,k)=1 入栈数为空，则出栈序列一定！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">simulate</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(j==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(i&gt;<span class="number">0</span>) <span class="keyword">return</span> simulate(i<span class="number">-1</span>,j,k+<span class="number">1</span>)+simulate(i+<span class="number">1</span>,j<span class="number">-1</span>,k);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> simulate(i+<span class="number">1</span>,j<span class="number">-1</span>,k);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;simulate(<span class="number">0</span>,n,<span class="number">0</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果是让求出栈序列，代码如下</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">①栈非空；</span></span><br><span class="line"><span class="comment">当前栈顶元素，要么出栈，要么不出栈，新元素入栈</span></span><br><span class="line"><span class="comment">②栈空：</span></span><br><span class="line"><span class="comment">只能新元素入栈</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">函数参数i表示新元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当i等于n+1时，表示所有元素已经操作完毕，递归截止</span></span><br><span class="line"><span class="comment">否则：</span></span><br><span class="line"><span class="comment">	①栈空，新元素入栈，进入下一次递归</span></span><br><span class="line"><span class="comment">	②栈非空，</span></span><br><span class="line"><span class="comment">		1.栈顶元素最多可以出栈x次至空栈，然后入栈</span></span><br><span class="line"><span class="comment">		2.复位，新元素入栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> nCount;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simulate</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(n==N+<span class="number">1</span>){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nCount;i++){</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;vec[i];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=dq.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;dq[i];</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(dq.empty()){</span><br><span class="line">		dq.push_back(n);</span><br><span class="line">		simulate(n+<span class="number">1</span>,dq);</span><br><span class="line">	}<span class="keyword">else</span>{</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=dq.size();i++){</span><br><span class="line">			<span class="keyword">int</span> tmpI=i;</span><br><span class="line">			<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; tmpDq=dq;</span><br><span class="line">			<span class="keyword">while</span>(tmpI){</span><br><span class="line">				vec[nCount++]=tmpDq.back();</span><br><span class="line">				tmpDq.pop_back();</span><br><span class="line">				tmpI--;</span><br><span class="line">			}</span><br><span class="line">			tmpDq.push_back(n);</span><br><span class="line">			simulate(n+<span class="number">1</span>,tmpDq);</span><br><span class="line">			nCount-=i;</span><br><span class="line">		}</span><br><span class="line">		dq.push_back(n);</span><br><span class="line">		simulate(n+<span class="number">1</span>,dq);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;N){</span><br><span class="line">		nCount=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">		vec.resize(N);</span><br><span class="line">		simulate(<span class="number">1</span>,dq);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="走迷宫"><a href="#走迷宫" class="headerlink" title="走迷宫"></a>走迷宫</h2><p><strong>题目描述</strong><br>　　有一个n<em>m格的迷宫(表示有n行、m列)，其中有可走的也有不可走的，如果用1表示可以走，0表示不可以走，文件读入这n</em>m个数据和起始点、结束点(起始点和结束点都是用两个数据来描述的，分别表示这个点的行号和列号)。现在要你编程找出所有可行的道路，要求所走的路中没有重复的点，走时只能是上下左右四个方向。如果一条路都不可行，则输出相应信息(用-l表示无路)。<br>　　请统一用 左上右下的顺序拓展，也就是 (0,-1),(-1,0),(0,1),(1,0)<br><strong>输入**</strong><br>第一行是两个数n，m( 1 &lt; n ， m &lt; 15 )，接下来是m行n列由1和0组成的数据，最后两行是起始点和结束点。</p><p><strong>输出</strong><br>　　所有可行的路径，描述一个点时用(x，y)的形式，除开始点外，其他的都要用“-&gt;”表示方向。<br>　　如果没有一条可行的路则输出-1。</p><p><strong>样例输入</strong><br>5 6<br>1 0 0 1 0 1<br>1 1 1 1 1 1<br>0 0 1 1 1 0<br>1 1 1 1 1 0<br>1 1 1 0 1 1<br>1 1<br>5 6<br><strong>样例输出</strong><br>(1,1)-&gt;(2,1)-&gt;(2,2)-&gt;(2,3)-&gt;(2,4)-&gt;(2,5)-&gt;(3,5)-&gt;(3,4)-&gt;(3,3)-&gt;(4,3)-&gt;(4,4)-&gt;(4,5)-&gt;(5,5)-&gt;(5,6)<br>(1,1)-&gt;(2,1)-&gt;(2,2)-&gt;(2,3)-&gt;(2,4)-&gt;(2,5)-&gt;(3,5)-&gt;(3,4)-&gt;(4,4)-&gt;(4,5)-&gt;(5,5)-&gt;(5,6)<br>(1,1)-&gt;(2,1)-&gt;(2,2)-&gt;(2,3)-&gt;(2,4)-&gt;(2,5)-&gt;(3,5)-&gt;(4,5)-&gt;(5,5)-&gt;(5,6)<br>(1,1)-&gt;(2,1)-&gt;(2,2)-&gt;(2,3)-&gt;(2,4)-&gt;(3,4)-&gt;(3,3)-&gt;(4,3)-&gt;(4,4)-&gt;(4,5)-&gt;(5,5)-&gt;(5,6)<br>(1,1)-&gt;(2,1)-&gt;(2,2)-&gt;(2,3)-&gt;(2,4)-&gt;(3,4)-&gt;(3,5)-&gt;(4,5)-&gt;(5,5)-&gt;(5,6)<br>(1,1)-&gt;(2,1)-&gt;(2,2)-&gt;(2,3)-&gt;(2,4)-&gt;(3,4)-&gt;(4,4)-&gt;(4,5)-&gt;(5,5)-&gt;(5,6)<br>(1,1)-&gt;(2,1)-&gt;(2,2)-&gt;(2,3)-&gt;(3,3)-&gt;(3,4)-&gt;(2,4)-&gt;(2,5)-&gt;(3,5)-&gt;(4,5)-&gt;(5,5)-&gt;(5,6)<br>(1,1)-&gt;(2,1)-&gt;(2,2)-&gt;(2,3)-&gt;(3,3)-&gt;(3,4)-&gt;(3,5)-&gt;(4,5)-&gt;(5,5)-&gt;(5,6)<br>(1,1)-&gt;(2,1)-&gt;(2,2)-&gt;(2,3)-&gt;(3,3)-&gt;(3,4)-&gt;(4,4)-&gt;(4,5)-&gt;(5,5)-&gt;(5,6)<br>(1,1)-&gt;(2,1)-&gt;(2,2)-&gt;(2,3)-&gt;(3,3)-&gt;(4,3)-&gt;(4,4)-&gt;(3,4)-&gt;(2,4)-&gt;(2,5)-&gt;(3,5)-&gt;(4,5)-&gt;(5,5)-&gt;(5,6)<br>(1,1)-&gt;(2,1)-&gt;(2,2)-&gt;(2,3)-&gt;(3,3)-&gt;(4,3)-&gt;(4,4)-&gt;(3,4)-&gt;(3,5)-&gt;(4,5)-&gt;(5,5)-&gt;(5,6)<br>(1,1)-&gt;(2,1)-&gt;(2,2)-&gt;(2,3)-&gt;(3,3)-&gt;(4,3)-&gt;(4,4)-&gt;(4,5)-&gt;(5,5)-&gt;(5,6)<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按固定顺序搜索！看清题目！垃圾OJ！</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">	Node(){}</span><br><span class="line">	Node(<span class="keyword">int</span> X,<span class="keyword">int</span> Y):x(X),y(Y){}</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>{</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"("</span>&lt;&lt;x+<span class="number">1</span>&lt;&lt;<span class="string">","</span>&lt;&lt;y+<span class="number">1</span>&lt;&lt;<span class="string">")"</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">int</span> iMap[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="keyword">bool</span> bVisited[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="built_in">deque</span>&lt;Node&gt; dq;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">Node node_Enter,node_Exit;</span><br><span class="line"><span class="keyword">bool</span> bExist;</span><br><span class="line"><span class="keyword">int</span> step[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">	<span class="number">0</span>,<span class="number">-1</span>,</span><br><span class="line">	<span class="number">-1</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line">	<span class="number">1</span>,<span class="number">0</span></span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPass</span><span class="params">(Node node)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(node.x&lt;<span class="number">0</span>||node.x&gt;=n||node.y&lt;<span class="number">0</span>||node.y&gt;=m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(iMap[node.x][node.y]==<span class="number">0</span>||bVisited[node.x][node.y]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Node node)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(node.x==node_Exit.x&amp;&amp;node.y==node_Exit.y){</span><br><span class="line">		bExist=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dq.size();i++){</span><br><span class="line">			<span class="keyword">if</span>(i!=<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"-&gt;"</span>;</span><br><span class="line">			dq[i].print();</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line">		Node tmp;</span><br><span class="line">		tmp.x=node.x+step[i][<span class="number">0</span>];</span><br><span class="line">		tmp.y=node.y+step[i][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(isPass(tmp)){</span><br><span class="line">			bVisited[tmp.x][tmp.y]=<span class="literal">true</span>;</span><br><span class="line">			dq.push_back(tmp);</span><br><span class="line">			DFS(tmp);</span><br><span class="line">			bVisited[tmp.x][tmp.y]=<span class="literal">false</span>;</span><br><span class="line">			dq.pop_back();</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m){</span><br><span class="line">		<span class="built_in">memset</span>(iMap,<span class="number">0</span>,<span class="keyword">sizeof</span>(iMap));</span><br><span class="line">		<span class="built_in">memset</span>(bVisited,<span class="literal">false</span>,<span class="keyword">sizeof</span>(bVisited));</span><br><span class="line">		dq.clear();</span><br><span class="line">		bExist=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++){</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;iMap[i][j];</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;node_Enter.x&gt;&gt;node_Enter.y;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;node_Exit.x&gt;&gt;node_Exit.y;</span><br><span class="line"></span><br><span class="line">		node_Enter.x--; node_Enter.y--;</span><br><span class="line">		node_Exit.x--; node_Exit.y--;</span><br><span class="line"></span><br><span class="line">		bVisited[node_Enter.x][node_Enter.y]=<span class="literal">true</span>;</span><br><span class="line">		dq.push_back(node_Enter); <span class="comment">//入口进队列</span></span><br><span class="line">		DFS(node_Enter);</span><br><span class="line">		<span class="keyword">if</span>(!bExist) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1></blockquote><h2 id="Jugs"><a href="#Jugs" class="headerlink" title="Jugs"></a>Jugs</h2><p><strong>Description</strong><br>In the movie “Die Hard 3”, Bruce Willis and Samuel L. Jackson were confronted with the following puzzle. They were given a 3-gallon jug and a 5-gallon jug and were asked to fill the 5-gallon jug with exactly 4 gallons. This problem generalizes that puzzle.</p><p>You have two jugs, A and B, and an infinite supply of water. There are three types of actions that you can use: (1) you can fill a jug, (2) you can empty a jug, and (3) you can pour from one jug to the other. Pouring from one jug to the other stops when the first jug is empty or the second jug is full, whichever comes first. For example, if A has 5 gallons and B has 6 gallons and a capacity of 8, then pouring from A to B leaves B full and 3 gallons in A.</p><p>A problem is given by a triple (Ca,Cb,N), where Ca and Cb are the capacities of the jugs A and B, respectively, and N is the goal. A solution is a sequence of steps that leaves exactly N gallons in jug B. The possible steps are</p><p>fill A<br>fill B<br>empty A<br>empty B<br>pour A B<br>pour B A<br>success</p><p>where “pour A B” means “pour the contents of jug A into jug B”, and “success” means that the goal has been accomplished.</p><p>You may assume that the input you are given does have a solution.<br><strong>Input</strong><br>Input to your program consists of a series of input lines each defining one puzzle. Input for each puzzle is a single line of three positive integers: Ca, Cb, and N. Ca and Cb are the capacities of jugs A and B, and N is the goal. You can assume 0 &lt; Ca &lt;= Cb and N &lt;= Cb &lt;=1000 and that A and B are relatively prime to one another.<br><strong>Output</strong><br>Output from your program will consist of a series of instructions from the list of the potential output lines which will result in either of the jugs containing exactly N gallons of water. The last line of output for each puzzle should be the line “success”. Output lines start in column 1 and there should be no empty lines nor any trailing spaces.<br><strong>Sample Input</strong><br>3 5 4<br>5 7 3<br><strong>Sample Output</strong><br>fill B<br>pour B A<br>empty A<br>pour B A<br>fill B<br>pour B A<br>success<br>fill A<br>pour A B<br>fill A<br>pour A B<br>empty B<br>pour A B<br>success<br><strong>Procedure</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A,B,N;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">int</span> father;</span><br><span class="line">	<span class="keyword">int</span> operators;</span><br><span class="line">	Node(){}</span><br><span class="line">	Node(<span class="keyword">int</span> ii,<span class="keyword">int</span> jj,<span class="keyword">int</span> ff,<span class="keyword">int</span> oo):i(ii),j(jj),father(ff),operators(oo){}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">deque</span>&lt;Node&gt; que;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; vec;</span><br><span class="line"><span class="keyword">bool</span> bVisited[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="built_in">string</span> result[<span class="number">6</span>]={</span><br><span class="line">	<span class="string">"fill A"</span>,</span><br><span class="line">	<span class="string">"fill B"</span>,</span><br><span class="line">	<span class="string">"empty A"</span>,</span><br><span class="line">	<span class="string">"empty B"</span>,</span><br><span class="line">	<span class="string">"pour A B"</span>,</span><br><span class="line">	<span class="string">"pour B A"</span></span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node tmp)</span></span>{</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">	<span class="keyword">while</span>(tmp.father!=<span class="number">-1</span>){</span><br><span class="line">		v.push_back(result[tmp.operators]);</span><br><span class="line">		tmp=vec[tmp.father];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::reverse_iterator it=v.rbegin();it!=v.rend();it++){</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"success"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">memset</span>(bVisited,<span class="literal">false</span>,<span class="keyword">sizeof</span>(bVisited));</span><br><span class="line">	que.clear();</span><br><span class="line">	vec.clear();</span><br><span class="line">	<span class="keyword">int</span> index=<span class="number">-1</span>;</span><br><span class="line">	bVisited[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">	que.push_back(Node(<span class="number">0</span>,<span class="number">0</span>,index,<span class="number">-1</span>));</span><br><span class="line">	vec.push_back(Node(<span class="number">0</span>,<span class="number">0</span>,index,<span class="number">-1</span>));</span><br><span class="line">	index++;</span><br><span class="line">	<span class="keyword">while</span>(!que.empty()){</span><br><span class="line"><span class="comment">//		for(int i=0;i&lt;vec.size();i++){</span></span><br><span class="line"><span class="comment">//			cout&lt;&lt;vec[i].i&lt;&lt;":"&lt;&lt;vec[i].j&lt;&lt;":"&lt;&lt;vec[i].father&lt;&lt;":"&lt;&lt;vec[i].operators&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//		}</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;"---"&lt;&lt;endl;</span></span><br><span class="line">		Node tmp=que.front();</span><br><span class="line">		<span class="keyword">int</span> i=tmp.i;</span><br><span class="line">		<span class="keyword">int</span> j=tmp.j;</span><br><span class="line">		que.pop_front();</span><br><span class="line">		<span class="keyword">if</span>(tmp.j==N){</span><br><span class="line">			print(tmp);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">6</span>;k++){</span><br><span class="line">			<span class="keyword">switch</span>(k){</span><br><span class="line">				<span class="keyword">case</span> <span class="number">0</span>:{</span><br><span class="line">					<span class="keyword">if</span>(!bVisited[A][j]){</span><br><span class="line">						bVisited[A][j]=<span class="literal">true</span>;</span><br><span class="line">						que.push_back(Node(A,j,index,<span class="number">0</span>));</span><br><span class="line">						vec.push_back(Node(A,j,index,<span class="number">0</span>));</span><br><span class="line">					}</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">case</span> <span class="number">1</span>:{</span><br><span class="line">					<span class="keyword">if</span>(!bVisited[i][B]){</span><br><span class="line">						bVisited[i][B]=<span class="literal">true</span>;</span><br><span class="line">						que.push_back(Node(i,B,index,<span class="number">1</span>));</span><br><span class="line">						vec.push_back(Node(i,B,index,<span class="number">1</span>));</span><br><span class="line">					}</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">case</span> <span class="number">2</span>:{</span><br><span class="line">					<span class="keyword">if</span>(!bVisited[<span class="number">0</span>][j]){</span><br><span class="line">						bVisited[<span class="number">0</span>][j]=<span class="literal">true</span>;</span><br><span class="line">						que.push_back(Node(<span class="number">0</span>,j,index,<span class="number">2</span>));</span><br><span class="line">						vec.push_back(Node(<span class="number">0</span>,j,index,<span class="number">2</span>));</span><br><span class="line">					}</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">case</span> <span class="number">3</span>:{</span><br><span class="line">					<span class="keyword">if</span>(!bVisited[i][<span class="number">0</span>]){</span><br><span class="line">						bVisited[i][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">						que.push_back(Node(i,<span class="number">0</span>,index,<span class="number">3</span>));</span><br><span class="line">						vec.push_back(Node(i,<span class="number">0</span>,index,<span class="number">3</span>));</span><br><span class="line">					}</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">case</span> <span class="number">4</span>:{</span><br><span class="line">					<span class="keyword">if</span>(i+j&gt;B){</span><br><span class="line">						<span class="keyword">if</span>(!bVisited[i-B+j][B]){</span><br><span class="line">							bVisited[i-B+j][B]=<span class="literal">true</span>;</span><br><span class="line">							que.push_back(Node(i-B+j,B,index,<span class="number">4</span>));</span><br><span class="line">							vec.push_back(Node(i-B+j,B,index,<span class="number">4</span>));</span><br><span class="line">						}</span><br><span class="line">					}<span class="keyword">else</span>{</span><br><span class="line">						<span class="keyword">if</span>(!bVisited[<span class="number">0</span>][i+j]){</span><br><span class="line">							bVisited[<span class="number">0</span>][i+j]=<span class="literal">true</span>;</span><br><span class="line">							que.push_back(Node(<span class="number">0</span>,i+j,index,<span class="number">4</span>));</span><br><span class="line">							vec.push_back(Node(<span class="number">0</span>,i+j,index,<span class="number">4</span>));</span><br><span class="line">						}</span><br><span class="line">					}</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">case</span> <span class="number">5</span>:{</span><br><span class="line">					<span class="keyword">if</span>(i+j&gt;A){</span><br><span class="line">						<span class="keyword">if</span>(!bVisited[A][j-A+i]){</span><br><span class="line">							bVisited[A][j-A+i]=<span class="literal">true</span>;</span><br><span class="line">							que.push_back(Node(A,j-A+i,index,<span class="number">5</span>));</span><br><span class="line">							vec.push_back(Node(A,j-A+i,index,<span class="number">5</span>));</span><br><span class="line">						}</span><br><span class="line">					}<span class="keyword">else</span>{</span><br><span class="line">						<span class="keyword">if</span>(!bVisited[i+j][<span class="number">0</span>]){</span><br><span class="line">							bVisited[i+j][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">							que.push_back(Node(i+j,<span class="number">0</span>,index,<span class="number">5</span>));</span><br><span class="line">							vec.push_back(Node(i+j,<span class="number">0</span>,index,<span class="number">5</span>));</span><br><span class="line">						}</span><br><span class="line">					}</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		index++;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;A&gt;&gt;B&gt;&gt;N){</span><br><span class="line">		BFS();</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1></blockquote><h2 id="通信系统"><a href="#通信系统" class="headerlink" title="通信系统"></a>通信系统</h2><p><strong>题目描述</strong><br>某市计划建设一个通信系统。按照规划，这个系统包含若干端点，这些端点由通信线缆链接。消息可以在任何一个端点产生，并且只能通过线缆传送。每个端点接收消息后会将消息传送到与其相连的端点，除了那个消息发送过来的端点。如果某个端点是产生消息的端点，那么消息将被传送到与其相连的每一个端点。<br>为了提高传送效率和节约资源，要求当消息在某个端点生成后，其余各个端点均能接收到消息，并且每个端点均不会重复收到消息。<br>现给你通信系统的描述，你能判断此系统是否符合以上要求吗？<br><strong>输入</strong><br>输入包含多组测试数据。每两组输入数据之间由空行分隔。<br>每组输入首先包含2个整数N和M，N（1&lt;=N&lt;=1000）表示端点个数，M（0&lt;=M&lt;=N<em>(N-1)/2）表示通信线路个数。<br>接下来M行每行输入2个整数A和B（1&lt;=A，B&lt;=N），表示端点A和B由一条通信线缆相连。两个端点之间至多由一条线缆直接相连，并且没有将某个端点与其自己相连的线缆。<br>当N和M都为0时，输入结束。<br>*</em>输出**<br>对于每组输入，如果所给的系统描述符合题目要求，则输出Yes，否则输出No。<br><strong>样例输入</strong><br>4 3<br>1 2<br>2 3<br>3 4</p><p>3 1<br>2 3</p><p>0 0<br><strong>样例输出</strong><br>Yes<br>No<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//并查集</span></span><br><span class="line"><span class="comment">//需要判断是否成环：</span></span><br><span class="line"><span class="comment">//如果两个点已在同一个集合中，在连接一条边比成环；</span></span><br><span class="line"><span class="comment">//否则不成环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> M,N;</span><br><span class="line"><span class="keyword">bool</span> isLoop;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeSet</span><span class="params">()</span></span>{</span><br><span class="line">	count=M;</span><br><span class="line">	isLoop=<span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++){</span><br><span class="line">		father[i]=i;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> i)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(i!=father[i]){</span><br><span class="line">		father[i]=findFather(father[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> father[i];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionSet</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> fa=findFather(i);</span><br><span class="line">	<span class="keyword">int</span> fb=findFather(j);</span><br><span class="line">	<span class="keyword">if</span>(fa==fb){</span><br><span class="line">		isLoop=<span class="literal">true</span>;</span><br><span class="line">	}<span class="keyword">else</span>{</span><br><span class="line">		count--;</span><br><span class="line">		father[fa]=fb;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;M&gt;&gt;N&amp;&amp;(M!=<span class="number">0</span>||N!=<span class="number">0</span>)){</span><br><span class="line">		makeSet();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line">			<span class="keyword">int</span> x,y;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">			unionSet(x,y);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(count==<span class="number">1</span>&amp;&amp;!isLoop){</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="畅通工程"><a href="#畅通工程" class="headerlink" title="畅通工程"></a>畅通工程</h2><p><strong>题目描述</strong><br>某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？<br><strong>输入</strong><br>测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。<br> 注意:两个城市之间可以有多条道路相通,也就是说<br> 3 3<br> 1 2<br> 1 2<br> 2 1<br> 这种输入也是合法的<br> 当N为0时，输入结束，该用例不被处理。<br><strong>输出</strong><br>对每个测试用例，在1行里输出最少还需要建设的道路数目。<br><strong>样例输入</strong><br>5 3<br>1 2<br>3 2<br>4 5<br>0<br><strong>样例输出</strong><br>1<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="keyword">int</span> city[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeSet</span><span class="params">()</span></span>{</span><br><span class="line">	count=N;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++){</span><br><span class="line">		city[i]=i;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> i)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(i!=city[i]){</span><br><span class="line">		city[i]=findFather(city[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> city[i];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionSet</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> fa=findFather(i);</span><br><span class="line">	<span class="keyword">int</span> fb=findFather(j);</span><br><span class="line">	<span class="keyword">if</span>(fa!=fb){</span><br><span class="line">		city[fa]=fb;</span><br><span class="line">		count--;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;N&amp;&amp;N!=<span class="number">0</span>){</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;M;</span><br><span class="line">		makeSet();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++){</span><br><span class="line">			<span class="keyword">int</span> x,y;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">			unionSet(x,y);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;count<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="How-Many-Tables"><a href="#How-Many-Tables" class="headerlink" title="How Many Tables"></a>How Many Tables</h2><p><strong>Description</strong><br>Today is Ignatius’ birthday. He invites a lot of friends. Now it’s dinner time. Ignatius wants to know how many tables he needs at least. You have to notice that not all the friends know each other, and all the friends do not want to stay with strangers.<br>One important rule for this problem is that if I tell you A knows B, and B knows C, that means A, B, C know each other, so they can stay in one table.<br>For example: If I tell you A knows B, B knows C, and D knows E, so A, B, C can stay in one table, and D, E have to stay in the other one. So Ignatius needs 2 tables at least.<br><strong>Input</strong><br>The input starts with an integer T(1&lt;=T&lt;=25) which indicate the number of test cases. Then T test cases follow. Each test case starts with two integers N and M(1&lt;=N,M&lt;=1000). N indicates the number of friends, the friends are marked from 1 to N. Then M lines follow. Each line consists of two integers A and B(A!=B), that means friend A and friend B know each other. There will be a blank line between two cases.<br><strong>Output</strong><br>For each test case, just output how many tables Ignatius needs at least. Do NOT print any blanks.<br><strong>Sample Inout</strong><br>2<br>6 4<br>1 2<br>2 3<br>3 4<br>1 4</p><p>8 10<br>1 2<br>2 3<br>5 6<br>7 5<br>4 6<br>3 6<br>6 7<br>2 5<br>2 4<br>4 3<br><strong>Sample Output</strong><br>3<br>2<br><strong>Procedure</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="keyword">int</span> city[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeSet</span><span class="params">()</span></span>{</span><br><span class="line">	count=N;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++){</span><br><span class="line">		city[i]=i;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> i)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(i!=city[i]){</span><br><span class="line">		city[i]=findFather(city[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> city[i];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionSet</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> fa=findFather(i);</span><br><span class="line">	<span class="keyword">int</span> fb=findFather(j);</span><br><span class="line">	<span class="keyword">if</span>(fa!=fb){</span><br><span class="line">		city[fa]=fb;</span><br><span class="line">		count--;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;N&amp;&amp;N!=<span class="number">0</span>){</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;M;</span><br><span class="line">		makeSet();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++){</span><br><span class="line">			<span class="keyword">int</span> x,y;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">			unionSet(x,y);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;count<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="More-is-better"><a href="#More-is-better" class="headerlink" title="More is better"></a>More is better</h2><p><strong>Description</strong><br>Mr Wang wants some boys to help him with a project. Because the project is rather complex, the more boys come, the better it will be. Of course there are certain requirements.Mr Wang selected a room big enough to hold the boys. The boy who are not been chosen has to leave the room immediately. There are 10000000 boys in the room numbered from 1 to 10000000 at the very beginning. After Mr Wang’s selection any two of them who are still in this room should be friends (direct or indirect), or there is only one boy left. Given all the direct friend-pairs, you should decide the best way.<br><strong>Input</strong><br>The first line of the input contains an integer n (0 ≤ n ≤ 100 000) - the number of direct friend-pairs. The following n lines each contains a pair of numbers A and B separated by a single space that suggests A and B are direct friends. (A ≠ B, 1 ≤ A, B ≤ 10000000)<br><strong>Output</strong><br>The output in one line contains exactly one integer equals to the maximum number of boys Mr Wang may keep.<br><strong>Sample Input</strong><br>3<br>1 3<br>1 5<br>2 5<br>4<br>3 2<br>3 4<br>1 6<br>2 6<br><strong>Sample Output</strong><br>4<br>5<br><strong>Procedure</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> father;</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">	Node(){}</span><br><span class="line">	Node(<span class="keyword">int</span> f,<span class="keyword">int</span> c):father(f),count(c){}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">10000001</span>;</span><br><span class="line">Node nodes[MAX];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> maxN;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeSet</span><span class="params">()</span></span>{</span><br><span class="line">	maxN=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;MAX;i++){</span><br><span class="line">		nodes[i].father=i;</span><br><span class="line">		nodes[i].count=<span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> i)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(i!=nodes[i].father){</span><br><span class="line">		nodes[i].father=findFather(nodes[i].father);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> nodes[i].father;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionSet</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> fa=findFather(i);</span><br><span class="line">	<span class="keyword">int</span> fb=findFather(j);</span><br><span class="line">	<span class="keyword">if</span>(fa!=fb){</span><br><span class="line">		nodes[fa].father=fb;</span><br><span class="line">		nodes[fb].count+=nodes[fa].count;</span><br><span class="line">		<span class="keyword">if</span>(nodes[fb].count&gt;maxN){</span><br><span class="line">			maxN=nodes[fb].count;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		makeSet();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="keyword">int</span> x,y;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">			unionSet(x,y);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;maxN&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="PAT1034-Head-of-a-Gang"><a href="#PAT1034-Head-of-a-Gang" class="headerlink" title="PAT1034 Head of a Gang"></a>PAT1034 Head of a Gang</h2><p><strong>Description</strong><br>One way that the police finds the head of a gang is to check people’s phone calls. If there is a phone call between A and B, we say that A and B is related. The weight of a relation is defined to be the total time length of all the phone calls made between the two persons. A “Gang” is a cluster of more than 2 persons who are related to each other with total relation weight being greater than a given threthold K. In each gang, the one with maximum total weight is the head. Now given a list of phone calls, you are supposed to find the gangs and the heads.<br><strong>Input Specification</strong><br>Each input file contains one test case. For each case, the first line contains two positive numbers N and K (both less than or equal to 1000), the number of phone calls and the weight threthold, respectively. Then N lines follow, each in the following format:<br>Name1 Name2 Time<br>where Name1 and Name2 are the names of people at the two ends of the call, and Time is the length of the call. A name is a string of three capital letters chosen from A-Z. A time length is a positive integer which is no more than 1000 minutes.<br><strong>Output Specification</strong><br>For each test case, first print in a line the total number of gangs. Then for each gang, print in a line the name of the head and the total number of the members. It is guaranteed that the head is unique for each gang. The output must be sorted according to the alphabetical order of the names of the heads.<br><strong>Sample Input 1</strong><br>8 59<br>AAA BBB 10<br>BBB AAA 20<br>AAA CCC 40<br>DDD EEE 5<br>EEE DDD 70<br>FFF GGG 30<br>GGG HHH 20<br>HHH FFF 10<br><strong>Sample Output 1</strong><br>2<br>AAA 3<br>GGG 3<br><strong>Sample Input 2</strong><br>8 70<br>AAA BBB 10<br>BBB AAA 20<br>AAA CCC 40<br>DDD EEE 5<br>EEE DDD 70<br>FFF GGG 30<br>GGG HHH 20<br>HHH FFF 10<br><strong>Sample Output 2</strong><br>0<br><strong>Procedure</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">2001</span>;</span><br><span class="line"><span class="keyword">int</span> weight[MAXV];</span><br><span class="line"><span class="keyword">int</span> N,K;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; stringToInt;<span class="comment">//姓名-编号</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; intToString;<span class="comment">//编号-姓名</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; gangs;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> father;</span><br><span class="line">	<span class="keyword">int</span> head;</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">	<span class="keyword">int</span> totalWeight;</span><br><span class="line">};</span><br><span class="line">Node nodes[MAXV];</span><br><span class="line"><span class="keyword">int</span> numPersons;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeSet</span><span class="params">()</span></span>{</span><br><span class="line">	numPersons=<span class="number">0</span>;</span><br><span class="line">	stringToInt.clear();</span><br><span class="line">	intToString.clear();</span><br><span class="line">	gangs.clear();</span><br><span class="line">	<span class="built_in">memset</span>(weight,<span class="number">0</span>,<span class="keyword">sizeof</span>(weight));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAXV;i++){</span><br><span class="line">		nodes[i].father=i;</span><br><span class="line">		nodes[i].head=i;</span><br><span class="line">		nodes[i].count=<span class="number">1</span>;</span><br><span class="line">		nodes[i].totalWeight=weight[i];</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> i)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(i!=nodes[i].father){</span><br><span class="line">		nodes[i].father=findFather(nodes[i].father);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> nodes[i].father;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionSet</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> w)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> fa=findFather(i);</span><br><span class="line">	<span class="keyword">int</span> fb=findFather(j);</span><br><span class="line">	<span class="keyword">if</span>(fa!=fb){</span><br><span class="line">		nodes[fa].father=fb;</span><br><span class="line">		nodes[fb].totalWeight+=w+nodes[fa].totalWeight;</span><br><span class="line">		nodes[fb].count+=nodes[fa].count;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//每次更新，head会在原有两个结合中的 head以及两个端点中选择 ，下同</span></span><br><span class="line">		nodes[fb].head=(weight[nodes[fa].head]&gt;weight[nodes[fb].head])?nodes[fa].head:nodes[fb].head;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> wI=weight[i];</span><br><span class="line">		<span class="keyword">int</span> wJ=weight[j];</span><br><span class="line">		<span class="keyword">if</span>(wI&gt;weight[nodes[fb].head]) nodes[fb].head=i;</span><br><span class="line">		<span class="keyword">if</span>(wJ&gt;weight[nodes[fb].head]) nodes[fb].head=j;</span><br><span class="line"></span><br><span class="line"><span class="comment">//		cout&lt;&lt;"fb-&gt;head:"&lt;&lt;nodes[fb].head&lt;&lt;":"&lt;&lt;intToString[nodes[fb].head]&lt;&lt;" weight:"&lt;&lt;weight[nodes[fb].head]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//		system("pause");</span></span><br><span class="line">	}<span class="keyword">else</span>{</span><br><span class="line">		nodes[fa].totalWeight+=w;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> wI=weight[i];</span><br><span class="line">		<span class="keyword">int</span> wJ=weight[j];</span><br><span class="line">		<span class="keyword">if</span>(wI&gt;weight[nodes[fa].head]) nodes[fa].head=i;</span><br><span class="line">		<span class="keyword">if</span>(wJ&gt;weight[nodes[fa].head]) nodes[fa].head=j;</span><br><span class="line"><span class="comment">//		cout&lt;&lt;"fa&gt;head:"&lt;&lt;nodes[fa].head&lt;&lt;":"&lt;&lt;intToString[nodes[fa].head]&lt;&lt;" weight:"&lt;&lt;weight[nodes[fa].head]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//		system("pause");</span></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNumber</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(stringToInt.find(str)!=stringToInt.end()){</span><br><span class="line">		<span class="keyword">return</span> stringToInt[str];</span><br><span class="line">	}<span class="keyword">else</span>{</span><br><span class="line">		stringToInt[str]=numPersons;</span><br><span class="line">		intToString[numPersons]=str;</span><br><span class="line">		<span class="keyword">return</span> numPersons++;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;N&gt;&gt;K){</span><br><span class="line">		makeSet();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line">			<span class="built_in">string</span> name1,name2;</span><br><span class="line">			<span class="keyword">int</span> w;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;name1&gt;&gt;name2&gt;&gt;w;</span><br><span class="line">			<span class="keyword">int</span> num1=getNumber(name1);</span><br><span class="line">			<span class="keyword">int</span> num2=getNumber(name2);</span><br><span class="line">			weight[num1]+=w;</span><br><span class="line">			weight[num2]+=w;</span><br><span class="line">			unionSet(num1,num2,w);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numPersons;i++){</span><br><span class="line">			<span class="keyword">int</span> f=findFather(i);</span><br><span class="line">			<span class="keyword">if</span>(s.count(f)==<span class="number">0</span>){</span><br><span class="line">				s.insert(f);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=s.begin();it!=s.end();it++){</span><br><span class="line">			<span class="keyword">int</span> head=nodes[*it].head;</span><br><span class="line">			<span class="keyword">if</span>(nodes[*it].count&gt;<span class="number">2</span>&amp;&amp;nodes[*it].totalWeight&gt;K){</span><br><span class="line">				gangs[intToString[head]]=nodes[*it].count;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;gangs.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator it=gangs.begin();it!=gangs.end();it++){</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="string">" "</span>&lt;&lt;it-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1></blockquote><table><thead><tr><th align="center">问题</th><th align="center">递推公式</th></tr></thead><tbody><tr><td align="center">经典数塔问题</td><td align="center">$dp[i][j]=max\lbrace dp[i+1][j],dp[i+1][j+1]\rbrace +data[i][j]$</td></tr><tr><td align="center">最大连续子序列和</td><td align="center">$dp[i]=max\lbrace data[i], dp[i-1]+data[i]\rbrace, dp[0]=data[0], maxSeq=max\lbrace dp[i]\rbrace$</td></tr><tr><td align="center">最长不下降子序列<br>(Longest Increasing Sequence, LIS)</td><td align="center">$dp[i]=max\lbrace dp[j]+1 \rbrace, start: dp[i]=1$</td></tr><tr><td align="center">最长公共子序列<br>(Longest Common Subsequence, LCS)</td><td align="center">$$dp[i][j]=\begin{cases} dp[i-1][j-1]+1, &amp; \text{$A[i]==B[i]$} \\ \max\lbrace dp[i-1][j], dp[i][j-1]\rbrace, &amp; \text{$A[i]!=B[i]$} \end{cases}$$</td></tr><tr><td align="center">最长回文子串</td><td align="center">$$dp[i][j]=\begin{cases} dp[i+1][j-1], &amp; \text{$S[i]==S[j]$} \\ 0, &amp; \text{$S[i]!=S[j]$} \end{cases}$$</td></tr><tr><td align="center">01背包-二维-正序or逆序</td><td align="center">$$dp[i][v]=\max\lbrace dp[i-1][v], dp[i-1][v-w[i]]+c[i]\rbrace$$</td></tr><tr><td align="center">01背包-一维优化-逆序</td><td align="center">$$dp[v]=\max\lbrace dp[v], dp[v-w[i]]+c[i]\rbrace$$</td></tr><tr><td align="center">完全背包-二维-正序</td><td align="center">$$dp[i][v]=\max\lbrace dp[i-1][v], dp[i][v-w[i]]+c[i]\rbrace$$</td></tr><tr><td align="center">完全背包-一维-正序</td><td align="center">$$dp[v]=\max\lbrace dp[v], dp[v-w[i]]+c[i]\rbrace$$</td></tr></tbody></table><h2 id="最大连续子序列"><a href="#最大连续子序列" class="headerlink" title="最大连续子序列"></a>最大连续子序列</h2><p><strong>题目描述</strong><br>给定K个整数的序列{ N1, N2, …, NK }，其任意连续子序列可表示为{ Ni, Ni+1, …, Nj }，其中 1 &lt;= i &lt;= j &lt;= K。最大连续子序列是所有连续子序列中元素和最大的一个，例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{ 11, -4, 13 }，最大和为20。现在增加一个要求，即还需要输出该子序列的第一个和最后一个元素。<br><strong>输入</strong><br>测试输入包含若干测试用例，每个测试用例占2行，第1行给出正整数K( K&lt;= 10000 )，第2行给出K个整数，中间用空格分隔，每个数的绝对值不超过100。当K为0时，输入结束，该用例不被处理。<br><strong>输出</strong><br>对每个测试用例，在1行里输出最大和、最大连续子序列的第一个和最后一个元素，中间用空格分隔。如果最大连续子序列不唯一，则输出序号i和j最小的那个（如输入样例的第2、3组）。若所有K个元素都是负数，则定义其最大和为0，输出整个序列的首尾元素。<br><strong>样例输入</strong><br>5<br>-3 9 -2 5 -4<br>3<br>-2 -3 -1<br>0<br><strong>样例输出</strong><br>12 9 5<br>0 -2 -1<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">10001</span>;</span><br><span class="line"><span class="keyword">int</span> maxSum,s,e;</span><br><span class="line"><span class="keyword">int</span> DP[MAXN];</span><br><span class="line"><span class="keyword">int</span> A[MAXN];</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> s,e;</span><br><span class="line">};</span><br><span class="line">Node Pos[MAXN];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DP[i]=max(A[i],DP[i-1]+A[i])</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;k&amp;&amp;k!=<span class="number">0</span>){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span>(A[<span class="number">0</span>]&gt;=<span class="number">0</span>) flag=<span class="literal">false</span>;</span><br><span class="line">		DP[<span class="number">0</span>]=A[<span class="number">0</span>];</span><br><span class="line">		Pos[<span class="number">0</span>].s=Pos[<span class="number">0</span>].e=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++){</span><br><span class="line">			<span class="keyword">if</span>(A[i]&gt;=<span class="number">0</span>) flag=<span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span>(A[i]&gt;DP[i<span class="number">-1</span>]+A[i]){</span><br><span class="line">				DP[i]=A[i];</span><br><span class="line">				Pos[i].s=Pos[i].e=i;</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				DP[i]=DP[i<span class="number">-1</span>]+A[i];</span><br><span class="line">				Pos[i].s=Pos[i<span class="number">-1</span>].s;</span><br><span class="line">				Pos[i].e=i;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">		maxSum=DP[index];</span><br><span class="line">		s=Pos[index].s;</span><br><span class="line">		e=Pos[index].e;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++){</span><br><span class="line">			<span class="keyword">if</span>(DP[i]&gt;maxSum){</span><br><span class="line">				maxSum=DP[i];</span><br><span class="line">				s=Pos[i].s;</span><br><span class="line">				e=Pos[i].e;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(flag){</span><br><span class="line">			maxSum=<span class="number">0</span>;</span><br><span class="line">			s=<span class="number">0</span>;</span><br><span class="line">			e=k<span class="number">-1</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;maxSum&lt;&lt;<span class="string">" "</span>&lt;&lt;A[s]&lt;&lt;<span class="string">" "</span>&lt;&lt;A[e]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><p><strong>题目描述</strong><br>一个数列ai如果满足条件a1 &lt; a2 &lt; … &lt; aN，那么它是一个有序的上升数列。我们取数列(a1, a2, …, aN)的任一子序列(ai1, ai2, …, aiK)使得1 &lt;= i1 &lt; i2 &lt; … &lt; iK &lt;= N。例如，数列(1, 7, 3, 5, 9, 4, 8)的有序上升子序列，像(1, 7)， (3, 4, 8)和许多其他的子序列。在所有的子序列中，最长的上升子序列的长度是4，如(1, 3, 5, 8)。<br>现在你要写一个程序，从给出的数列中找到它的最长上升子序列。<br><strong>输入</strong><br>输入包含两行，第一行只有一个整数N（1 &lt;= N &lt;= 1000），表示数列的长度。<br>第二行有N个自然数ai，0 &lt;= ai &lt;= 10000，两个数之间用空格隔开。<br><strong>输出</strong><br>输出只有一行，包含一个整数，表示最长上升子序列的长度。<br><strong>样例输入</strong><br>7<br>1 7 3 5 9 4 8<br><strong>样例输出</strong><br>4<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DP[i]表示以第i个元素为结尾的最长子序列长度</span></span><br><span class="line"><span class="comment">//DP[i]=max(DP[i],DP[j]+1) j&lt;i且A[j]&lt;A[i]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">1001</span>;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> DP[MAX];</span><br><span class="line"><span class="keyword">int</span> A[MAX];</span><br><span class="line"><span class="keyword">int</span> maxN;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;N){</span><br><span class="line">		fill(DP,DP+MAX,<span class="number">1</span>);</span><br><span class="line">		maxN=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++){</span><br><span class="line">				<span class="keyword">if</span>(A[j]&lt;A[i]){</span><br><span class="line">					DP[i]=max(DP[i],DP[j]+<span class="number">1</span>);</span><br><span class="line">					maxN=max(maxN,DP[i]);</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;maxN&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p><strong>题目描述</strong><br>给你一个序列X和另一个序列Z，当Z中的所有元素都在X中存在，并且在X中的下标顺序是严格递增的，那么就把Z叫做X的子序列。<br>例如：Z=&lt;a,b,f,c&gt;是序列X=&lt;a,b,c,f,b,c&gt;的一个子序列，Z中的元素在X中的下标序列为&lt;1,2,4,6&gt;。<br>现给你两个序列X和Y，请问它们的最长公共子序列的长度是多少？<br><strong>输入</strong><br>输入包含多组测试数据。每组输入占一行，为两个字符串，由若干个空格分隔。每个字符串的长度不超过100。<br><strong>输出</strong><br>对于每组输入，输出两个字符串的最长公共子序列的长度。<br><strong>样例输入</strong><br>abcfbc abfcab<br>programming contest<br>abcd mnp<br><strong>样例输出</strong><br>4<br>2<br>0<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DP[i][j]表示A的前i个字符串和B的前j个字符串的最大公共序列长</span></span><br><span class="line"><span class="comment">//假设DP[i-1][j-1]已知；</span></span><br><span class="line"><span class="comment">//那么DP[i][j]:</span></span><br><span class="line"><span class="comment">//比较A的第i个字符与B的第j个字符是否相等:</span></span><br><span class="line"><span class="comment">//①如果相等，直接DP[i][j]=DP[i-1][j-1];</span></span><br><span class="line"><span class="comment">//②如果不相等，那么比较取i，j-1和i-1，j两种情况的大小，即</span></span><br><span class="line"><span class="comment">//if(A[i]==B[i]) DP[i][j]=D[i-1][j-1]+1;</span></span><br><span class="line"><span class="comment">//else DP[i][j]=max(DP[i-1][j],DP[i][j-1]);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">101</span>;</span><br><span class="line"><span class="built_in">string</span> A,B;</span><br><span class="line"><span class="keyword">int</span> DP[MAX][MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;A&gt;&gt;B){</span><br><span class="line">		<span class="built_in">memset</span>(DP,<span class="number">0</span>,<span class="keyword">sizeof</span>(DP));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=A.size();i++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=B.size();j++){</span><br><span class="line">				<span class="keyword">if</span>(A[i<span class="number">-1</span>]==B[j<span class="number">-1</span>]){</span><br><span class="line">					DP[i][j]=DP[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">				}<span class="keyword">else</span>{</span><br><span class="line">					DP[i][j]=max(DP[i<span class="number">-1</span>][j],DP[i][j<span class="number">-1</span>]);</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;DP[A.size()][B.size()]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p><strong>题目描述</strong><br>输入一个字符串，求出其中最长的回文子串。子串的含义是：在原串中连续出现的字符串片段。回文的含义是：正着看和倒着看相同。如abba和yyxyy。在判断回文时，应该忽略所有标点符号和空格，且忽略大小写，但输出应保持原样（在回文串的首部和尾部不要输出多余字符）。输入字符串长度不超过5000，且占据单独的一行。应该输出最长的回文串，如果有多个，输出起始位置最靠左的。<br><strong>输入</strong><br>一行字符串，字符串长度不超过5000。<br><strong>输出</strong><br>字符串中的最长回文子串。<br><strong>样例输入</strong><br>Confuciuss say:Madam,I’m Adam.<br><strong>样例输出</strong><br>Madam,I’m Adam<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DP[i][j]表示字符从i到j是否为回文串，是则为1，否为0；</span></span><br><span class="line"><span class="comment">//if(S[i]=S[j]) DP[i][j]=DP[i+1][j-1];</span></span><br><span class="line"><span class="comment">//else DP[i][j]=0;</span></span><br><span class="line"><span class="comment">//边界：</span></span><br><span class="line"><span class="comment">//DP[i][i]=1;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">int</span> pos[<span class="number">5001</span>];</span><br><span class="line"><span class="keyword">int</span> DP[<span class="number">5001</span>][<span class="number">5001</span>];</span><br><span class="line"><span class="keyword">int</span> s,e,maxL;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(getline(<span class="built_in">cin</span>,str)){</span><br><span class="line">		<span class="built_in">memset</span>(DP,<span class="number">0</span>,<span class="keyword">sizeof</span>(DP));</span><br><span class="line">		<span class="built_in">string</span> ss;</span><br><span class="line">		<span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++){</span><br><span class="line">			<span class="keyword">if</span>((str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">				||(str[i]&gt;=<span class="string">'a'</span>&amp;&amp;str[i]&lt;=<span class="string">'z'</span>)){</span><br><span class="line">				ss+=str[i];</span><br><span class="line">				pos[index++]=i;</span><br><span class="line">			}<span class="keyword">else</span> <span class="keyword">if</span>(str[i]&gt;=<span class="string">'A'</span>&amp;&amp;str[i]&lt;=<span class="string">'Z'</span>){</span><br><span class="line">				ss+=str[i]+<span class="string">'a'</span>-<span class="string">'A'</span>;</span><br><span class="line">				pos[index++]=i;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//边界</span></span><br><span class="line">		maxL=<span class="number">1</span>;</span><br><span class="line">		s=e=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ss.length();i++){</span><br><span class="line">			DP[i][i]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;ss.length()<span class="number">-1</span>){</span><br><span class="line">				<span class="keyword">if</span>(ss[i]==ss[i+<span class="number">1</span>]){</span><br><span class="line">					DP[i][i+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">					maxL=<span class="number">2</span>;</span><br><span class="line">					s=i;</span><br><span class="line">					e=i+<span class="number">1</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//DP</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> L=<span class="number">3</span>;L&lt;=ss.length();L++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+L<span class="number">-1</span>&lt;ss.length();i++){</span><br><span class="line">				<span class="keyword">int</span> j=i+L<span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">if</span>(ss[i]==ss[j]&amp;&amp;DP[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="number">1</span>){</span><br><span class="line">					DP[i][j]=<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">if</span>(L&gt;maxL){</span><br><span class="line">						maxL=L;</span><br><span class="line">						s=i;</span><br><span class="line">						e=j;</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;str.substr(pos[s],pos[e]-pos[s]+<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="DAG最长路"><a href="#DAG最长路" class="headerlink" title="DAG最长路"></a>DAG最长路</h2><h3 id="不固定起点与终点"><a href="#不固定起点与终点" class="headerlink" title="不固定起点与终点"></a>不固定起点与终点</h3><p>dp[i]表示从i号顶点出发能获得的最长路径长度<br>初始化：dp[i]=0;</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> i)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(dp[i]&gt;<span class="number">0</span>) <span class="keyword">return</span> dp[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">    <span class="keyword">if</span>(G[i][j]!=INF){</span><br><span class="line">      dp[i]=max(dp[i],DP(j)+G[i][j]);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> dp[i];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>打印路径：later数组，当有多条则使用vector数组</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> i)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(dp[i]&gt;<span class="number">0</span>) <span class="keyword">return</span> dp[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">    <span class="keyword">if</span>(G[i][j]!=INF){</span><br><span class="line">      <span class="keyword">int</span> temp=DP(j)+G[i][j];</span><br><span class="line">      <span class="keyword">if</span>(temp&gt;dp[i]){</span><br><span class="line">        dp[i]=temp;</span><br><span class="line">        later[i]=j;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> dp[i];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPath</span><span class="params">(<span class="keyword">int</span> i)</span></span>{</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;i;</span><br><span class="line">  <span class="keyword">while</span>(later[i]!=<span class="number">-1</span>){</span><br><span class="line">    i=later[i];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"-&gt;"</span>&lt;&lt;i;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="固定终点"><a href="#固定终点" class="headerlink" title="固定终点"></a>固定终点</h3><p>dp[i]表示从i号顶点出发到达终点T能获得的最长路径长度<br>初始化：dp[T]=0,其他dp[j]=-INF;</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> i)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(vis[i]) <span class="keyword">return</span> dp[i];</span><br><span class="line">  vis[i]=<span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">    <span class="keyword">if</span>(G[i][j]!=INF){</span><br><span class="line">        dp[i]=max(dp[i],DP(i)+G[i][j]);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> dp[i];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="矩形嵌套"><a href="#矩形嵌套" class="headerlink" title="矩形嵌套"></a>矩形嵌套</h3><p><strong>题目描述</strong><br>有n个矩形，每个矩形可以用a,b来描述，表示长和宽。矩形X(a,b)可以嵌套在矩形Y(c,d)中当且仅当a&lt;c,b&lt;d或者b&lt;c,a&lt;d（相当于旋转X90度）。例如（1,5）可以嵌套在（6,2）内，但不能嵌套在（3,4）中。你的任务是选出尽可能多的矩形排成一行，使得除最后一个外，每一个矩形都可以嵌套在下一个矩形内。<br><strong>输入</strong><br>第一行是一个正正数N(0&lt;N&lt;10)，表示测试数据组数，<br>每组测试数据的第一行是一个正正数n，表示该组测试数据中含有矩形的个数(n&lt;=1000)<br>随后的n行，每行有两个数a,b(0&lt;a,b&lt;100)，表示矩形的长和宽<br><strong>输出</strong><br>每组测试数据都输出一个数，表示最多符合条件的矩形数目，每组输出占一行<br><strong>样例输入</strong><br>1<br>10<br>1 2<br>2 4<br>5 8<br>6 10<br>7 9<br>3 1<br>5 8<br>12 10<br>9 7<br>2 2<br><strong>样例输出</strong><br>5<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1001</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	<span class="keyword">int</span> h;</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; vec;</span><br><span class="line"><span class="keyword">int</span> DP[MAXV];</span><br><span class="line"><span class="keyword">int</span> N,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(Node a,Node b)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>((a.w&lt;b.w&amp;&amp;a.h&lt;b.h)</span><br><span class="line">	||(a.h&lt;b.w&amp;&amp;a.w&lt;b.h)){</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">	<span class="keyword">while</span>(N--){</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		vec.clear();</span><br><span class="line">		vec.resize(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;vec[i].w&gt;&gt;vec[i].h;</span><br><span class="line">			DP[i]=<span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++){</span><br><span class="line">				<span class="keyword">if</span>(judge(vec[j],vec[i])){</span><br><span class="line">					DP[i]=max(DP[i],DP[j]+<span class="number">1</span>);</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			result=max(DP[i],result);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;result&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><ul><li>DP[0][v]=0,DP[i][v]=max(DP[i-1][v],DP[i-1][v-w[i]]+c[i]) 正序</li><li>DP[v]=0, DP[v]=max(DP[v],DP[v-w[i-1]]+c[i]) 逆序<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> w[MAX];</span><br><span class="line"><span class="keyword">int</span> c[MAX];</span><br><span class="line"><span class="comment">//通常写法</span></span><br><span class="line"><span class="comment">//边界DP[0][v]=0</span></span><br><span class="line"><span class="keyword">int</span> DP[MAX][MAX];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> v=w[i];v&lt;=V;v++){</span><br><span class="line">    DP[i][v]=max(DP[i<span class="number">-1</span>][v],DP[i<span class="number">-1</span>][v-w[i]]+c[i]);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//滚动数组</span></span><br><span class="line"><span class="comment">//边界DP[v]=0</span></span><br><span class="line"><span class="keyword">int</span> DP[MAX]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">  <span class="keyword">for</span>(v=V;v&gt;=w[i];v--){</span><br><span class="line">    DP[v]=max(DP[v],DP[v-w[i]]+c[i]);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> W[MAXN],C[MAXN],DP[MAXV];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="keyword">int</span> n,V;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;V;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;w[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line">  <span class="comment">//边界</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;=V;v++) DP[v]=<span class="number">0</span>;</span><br><span class="line">  <span class="comment">//DP</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=V;v&gt;=w[i];v--){</span><br><span class="line">      DP[v]=max(DP[v],DP[v-W[i]]);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//寻找最大值</span></span><br><span class="line">  <span class="keyword">int</span> MAX=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;=V;v++) MAX=DP[v]&gt;MAX?DP[v]:MAX;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;MAX&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3></li><li>DP[i][v]=max(DP[i-1][v],DP[i][v-w[i]]+c[i]) 正序</li><li>DP[v]=max(DP[v],DP[v-w[i]]+c[i]) 正序<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> v=w[i];v&lt;=V;v++){</span><br><span class="line">    DP[i][v]=max(DP[i<span class="number">-1</span>][v],DP[i][v-w[i]]+c[i]);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> v=w[i];v&lt;=V;v++){</span><br><span class="line">    DP[v]=max(DP[v],DP[v-w[i]]+c[i]);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="装箱问题"><a href="#装箱问题" class="headerlink" title="装箱问题"></a>装箱问题</h3></li></ul><p><strong>题目描述</strong><br>有一个箱子的容量为V（V为正整数，且满足0≤V≤20000），同时有n件物品（0的体积值为正整数。<br>要求从n件物品中，选取若干装入箱内，使箱子的剩余空间最小。<br>输入：1行整数，第1个数表示箱子的容量，第2个数表示有n件物品，后面n个数分别表示这n件<br>物品各自的体积。<br><strong>输出</strong><br>1个整数，表示箱子剩余空间。<br><strong>输入</strong><br>24 6 8 3 12 7 9 7<br><strong>输出</strong><br>0<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,V;</span><br><span class="line"><span class="keyword">int</span> DP[MAXV];</span><br><span class="line"><span class="keyword">int</span> c[MAXV];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;V&gt;&gt;n){</span><br><span class="line">		<span class="built_in">memset</span>(DP,<span class="number">0</span>,<span class="keyword">sizeof</span>(DP));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> v=V;v&gt;=c[i];v--){</span><br><span class="line">				DP[v]=max(DP[v],DP[v-c[i]]+c[i]);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">int</span> Max=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;=V;v++){</span><br><span class="line">			Max=Max&gt;DP[v]?Max:DP[v];</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;V-Max&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="采药"><a href="#采药" class="headerlink" title="采药"></a>采药</h3><p><strong>题目描述</strong><br>辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。<br>医师为了判断他的资质，给他出了一个难题。<br>医 师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间， 在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”<br>如果你是辰辰，你能完成这个任务吗？<br><strong>输入</strong><br>第一行有两个整数T（1 &lt;= T &lt;= 1000）和M（1 &lt;= M &lt;= 100），用一个空格隔开，<br>T代表总共能够用来采药的时间，M代表山洞里的草药的数目。<br>接下来的M行每行包括两个在1到100之间（包括1和100）的整 数，分别表示采摘某株草药的时间和这株草药的价值。<br><strong>输出</strong><br>一个整数，表示在规定的时间内，可以采到的草药的最大总价值。<br><strong>样例输入</strong><br>70 3<br>71 100<br>69 1<br>1 2<br><strong>样例输出</strong><br>3<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T,M;</span><br><span class="line"><span class="keyword">int</span> DP[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;T&gt;&gt;M){</span><br><span class="line">		<span class="built_in">memset</span>(DP,<span class="number">0</span>,<span class="keyword">sizeof</span>(DP));</span><br><span class="line">		<span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line">		<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++) <span class="built_in">cin</span>&gt;&gt;c[i]&gt;&gt;v[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> t=T;t&gt;=c[i];t--){</span><br><span class="line">				DP[t]=max(DP[t],DP[t-c[i]]+v[i]);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">    <span class="keyword">int</span> Max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;=T;t++)  Max=Max&gt;DP[t]?Max:DP[t];</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;Max&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="货币系统"><a href="#货币系统" class="headerlink" title="货币系统"></a>货币系统</h3><p><strong>题目描述</strong><br>母牛们不但创建了他们自己的政府而且选择了建立了自己的货币系统。<br>[In their own rebellious way],，他们对货币的数值感到好奇。<br>传统地，一个货币系统是由1,5,10,20 或 25,50, 和 100的单位面值组成的。<br>母牛想知道有多少种不同的方法来用货币系统中的货币来构造一个确定的数值。<br>举例来说, 使用一个货币系统 {1,2,5,10,…}产生 18单位面值的一些可能的方法是:18x1, 9x2, 8x2+2x1, 3x5+2+1,等等其它。<br>写一个程序来计算有多少种方法用给定的货币系统来构造一定数量的面值。<br>保证总数将会适合long long (C/C++) 和 Int64 (Free Pascal)。<br><strong>输入</strong><br>输入包含多组测试数据<br>货币系统中货币的种类数目是 V 。 (1&lt;= V&lt;=25)<br>要构造的数量钱是 N 。 (1&lt;= N&lt;=10,000)<br>第 1 行: 二整数， V 和 N<br>第 2 ..V+1行： 可用的货币 V 个整数　(每行一个　每行没有其它的数)。<br><strong>输出</strong><br>单独的一行包含那个可能的构造的方案数。<br><strong>样例输入</strong><br>3 10<br>1 2 5<br><strong>样例输出</strong><br>10<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> DP[<span class="number">26</span>][<span class="number">10001</span>];</span><br><span class="line"><span class="comment">//DP[i][v]=DP[i-1][v]+DP[i][v-w[i]]</span></span><br><span class="line"><span class="comment">//DP[0][v]=0;</span></span><br><span class="line"><span class="comment">//DP[i][0]=1;</span></span><br><span class="line"><span class="keyword">int</span> w[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> V,N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;V&gt;&gt;N){</span><br><span class="line">		<span class="built_in">memset</span>(DP,<span class="number">0</span>,<span class="keyword">sizeof</span>(DP));</span><br><span class="line">		<span class="built_in">memset</span>(w,<span class="number">0</span>,<span class="keyword">sizeof</span>(w));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;i++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;w[i];</span><br><span class="line">			DP[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;i++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">1</span>;v&lt;=N;v++){</span><br><span class="line">				<span class="keyword">if</span>(v&lt;w[i]) DP[i][v]=DP[i<span class="number">-1</span>][v];</span><br><span class="line">				<span class="keyword">else</span> DP[i][v]=DP[i<span class="number">-1</span>][v]+DP[i][v-w[i]];</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;DP[V][N]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1></blockquote><h2 id="图的深度优先搜索DFS"><a href="#图的深度优先搜索DFS" class="headerlink" title="图的深度优先搜索DFS"></a>图的深度优先搜索DFS</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,G[MAXV][MAXV];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXV]={<span class="literal">false</span>};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTravese</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++){</span><br><span class="line">		<span class="keyword">if</span>(!vis[u]){</span><br><span class="line">			DFS(u);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span></span>{</span><br><span class="line">	vis[u]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++){</span><br><span class="line">		<span class="keyword">if</span>(!vis[v]&amp;&amp;G[u][v]!=INF){</span><br><span class="line">			DFS(v);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXV]={<span class="literal">false</span>};</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTravese</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++){</span><br><span class="line">    <span class="keyword">if</span>(!vis[u]){</span><br><span class="line">      DFS(u);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span></span>{</span><br><span class="line">  vis[u]=<span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();i++){</span><br><span class="line">    <span class="keyword">int</span> v=G[u][i];</span><br><span class="line">    <span class="keyword">if</span>(!vis[v]){</span><br><span class="line">      DFS(v);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="PAT1034-Head-of-a-Gang-1"><a href="#PAT1034-Head-of-a-Gang-1" class="headerlink" title="PAT1034 Head of a Gang"></a>PAT1034 Head of a Gang</h3><p><strong>Description</strong><br>One way that the police finds the head of a gang is to check people’s phone calls. If there is a phone call between A and B, we say that A and B is related. The weight of a relation is defined to be the total time length of all the phone calls made between the two persons. A “Gang” is a cluster of more than 2 persons who are related to each other with total relation weight being greater than a given threthold K. In each gang, the one with maximum total weight is the head. Now given a list of phone calls, you are supposed to find the gangs and the heads.<br><strong>Input Specification</strong><br>Each input file contains one test case. For each case, the first line contains two positive numbers N and K (both less than or equal to 1000), the number of phone calls and the weight threthold, respectively. Then N lines follow, each in the following format:<br>Name1 Name2 Time<br>where Name1 and Name2 are the names of people at the two ends of the call, and Time is the length of the call. A name is a string of three capital letters chosen from A-Z. A time length is a positive integer which is no more than 1000 minutes.<br><strong>Output Specification</strong><br>For each test case, first print in a line the total number of gangs. Then for each gang, print in a line the name of the head and the total number of the members. It is guaranteed that the head is unique for each gang. The output must be sorted according to the alphabetical order of the names of the heads.<br><strong>Sample Input 1</strong><br>8 59<br>AAA BBB 10<br>BBB AAA 20<br>AAA CCC 40<br>DDD EEE 5<br>EEE DDD 70<br>FFF GGG 30<br>GGG HHH 20<br>HHH FFF 10<br><strong>Sample Output 1</strong><br>2<br>AAA 3<br>GGG 3<br><strong>Sample Input 2</strong><br>8 70<br>AAA BBB 10<br>BBB AAA 20<br>AAA CCC 40<br>DDD EEE 5<br>EEE DDD 70<br>FFF GGG 30<br>GGG HHH 20<br>HHH FFF 10<br><strong>Sample Output 2</strong><br>0<br><strong>Procedure</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">2001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> G[MAXV][MAXV];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXV];</span><br><span class="line"><span class="keyword">int</span> weight[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; stringToInt;<span class="comment">//姓名-&gt;编号</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; intToString;<span class="comment">//编号-&gt;姓名</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; gangs;<span class="comment">//Head，人数</span></span><br><span class="line"><span class="keyword">int</span> numPersons;</span><br><span class="line"><span class="keyword">int</span> N,K;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> &amp;head,<span class="keyword">int</span> &amp;totalWeight,<span class="keyword">int</span> &amp;members)</span></span>{</span><br><span class="line">	vis[u]=<span class="literal">true</span>;</span><br><span class="line">	members++;</span><br><span class="line">	<span class="keyword">if</span>(weight[u]&gt;weight[head]){</span><br><span class="line">		head=u;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;numPersons;v++){</span><br><span class="line"><span class="comment">//ERROR:注意环！如果先判断vis则导致有边权未统计</span></span><br><span class="line"><span class="comment">//		if(!vis[v]&amp;&amp;G[u][v]!=0){</span></span><br><span class="line"><span class="comment">//			totalWeight+=G[u][v];</span></span><br><span class="line"><span class="comment">//			DFS(v,head,totalWeight,members);</span></span><br><span class="line"><span class="comment">//		}</span></span><br><span class="line">		<span class="keyword">if</span>(G[u][v]!=<span class="number">0</span>){</span><br><span class="line">			totalWeight+=G[u][v];</span><br><span class="line">			G[u][v]=G[v][u]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(!vis[v]){</span><br><span class="line">				DFS(v,head,totalWeight,members);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;numPersons;u++){</span><br><span class="line">		<span class="keyword">if</span>(!vis[u]){</span><br><span class="line">			<span class="keyword">int</span> head=u;</span><br><span class="line">			<span class="keyword">int</span> totalWeight=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> members=<span class="number">0</span>;</span><br><span class="line">			DFS(u,head,totalWeight,members);</span><br><span class="line">			<span class="keyword">if</span>(members&gt;<span class="number">2</span>&amp;&amp;totalWeight&gt;K){</span><br><span class="line">				gangs[intToString[head]]=members;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//获取编号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNumber</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(stringToInt.find(str)!=stringToInt.end()){</span><br><span class="line">		<span class="keyword">return</span> stringToInt[str];</span><br><span class="line">	}<span class="keyword">else</span>{</span><br><span class="line">		stringToInt[str]=numPersons;</span><br><span class="line">		intToString[numPersons]=str;</span><br><span class="line">		<span class="keyword">return</span> numPersons++;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;N&gt;&gt;K){</span><br><span class="line">		<span class="comment">//初始化</span></span><br><span class="line">		numPersons=<span class="number">0</span>;</span><br><span class="line">		gangs.clear();</span><br><span class="line">		intToString.clear();</span><br><span class="line">		stringToInt.clear();</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">		<span class="built_in">memset</span>(weight,<span class="number">0</span>,<span class="keyword">sizeof</span>(weight));</span><br><span class="line">		<span class="built_in">memset</span>(G,<span class="number">0</span>,<span class="keyword">sizeof</span>(G));</span><br><span class="line">		<span class="comment">//输入</span></span><br><span class="line">		<span class="built_in">string</span> name1,name2;</span><br><span class="line">		<span class="keyword">int</span> w;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;name1&gt;&gt;name2&gt;&gt;w;</span><br><span class="line">			<span class="keyword">int</span> num1=getNumber(name1);</span><br><span class="line">			<span class="keyword">int</span> num2=getNumber(name2);</span><br><span class="line">			weight[num1]+=w;</span><br><span class="line">			weight[num2]+=w;</span><br><span class="line">			G[num1][num2]+=w; <span class="comment">//重复边</span></span><br><span class="line">			G[num2][num1]+=w;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//运算</span></span><br><span class="line">		DFSTraverse();</span><br><span class="line">		<span class="comment">//输出</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;gangs.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator it=gangs.begin();it!=gangs.end();it++){</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="string">" "</span>&lt;&lt;it-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p><strong>题目描述</strong><br>该题的目的是要你统计图的连通分支数。<br><strong>输入</strong><br>每个输入文件包含若干行，每行两个整数i,j，表示节点i和j之间存在一条边。<br><strong>输出</strong><br>输出每个图的联通分支数。<br><strong>样例输入</strong><br>1 4<br>4 3<br>5 5<br><strong>样例输出</strong><br>2<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000001</span>;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Adj[MAXV];</span><br><span class="line"><span class="keyword">bool</span> bVisited[MAXV];</span><br><span class="line"><span class="keyword">bool</span> bExist[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span></span>{</span><br><span class="line">	bVisited[u]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">		<span class="keyword">int</span> v=Adj[u][i];</span><br><span class="line">		<span class="keyword">if</span>(!bVisited[v]){</span><br><span class="line">			DFS(v);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFSTraverse</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> numBranches=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;MAXV;i++){</span><br><span class="line">		<span class="keyword">if</span>(!bVisited[i]&amp;&amp;bExist[i]){</span><br><span class="line">			DFS(i);</span><br><span class="line">			numBranches++;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> numBranches;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(bVisited,<span class="literal">false</span>,<span class="keyword">sizeof</span>(bVisited));</span><br><span class="line">	<span class="built_in">memset</span>(bExist,<span class="literal">false</span>,<span class="keyword">sizeof</span>(bExist));</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v){</span><br><span class="line">		bExist[u]=<span class="literal">true</span>;</span><br><span class="line">		bExist[v]=<span class="literal">true</span>;</span><br><span class="line">		Adj[u].push_back(v);</span><br><span class="line">		Adj[v].push_back(u);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;DFSTraverse()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h3><p><strong>题目描述</strong><br>给定一个无向图和其中的所有边，判断这个图是否所有顶点都是连通的。<br><strong>输入</strong><br>每组数据的第一行是两个整数 n 和 m（0&lt;=n&lt;=1000）。n 表示图的顶点数目，m 表示图中边的数目。如果 n 为 0 表示输入结束。随后有 m 行数据，每行有两个值 x 和 y（0&lt;x, y &lt;=n），表示顶点 x 和 y 相连，顶点的编号从 1 开始计算。输入不保证这些边是否重复。<br><strong>输出</strong><br>对于每组输入数据，如果所有顶点都是连通的，输出”YES”，否则输出”NO”。<br><strong>样例输入</strong><br>4 3<br>4 3<br>1 2<br>1 3<br>5 7<br>3 5<br>2 3<br>1 3<br>3 2<br>2 5<br>3 4<br>4 1<br>7 3<br>6 2<br>3 1<br>5 6<br>0 0<br><strong>样例输出</strong><br>YES<br>YES<br>NO<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1001</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> G[MAXV][MAXV];</span><br><span class="line"><span class="keyword">bool</span> bVis[MAXV];</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span></span>{</span><br><span class="line">	bVis[u]=<span class="literal">true</span>;</span><br><span class="line">	num++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">		<span class="keyword">if</span>(!bVis[i]&amp;&amp;G[u][i]!=<span class="number">0</span>){</span><br><span class="line">			DFS(i);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DFSTraverse</span><span class="params">()</span></span>{</span><br><span class="line">	num=<span class="number">0</span>;</span><br><span class="line">	DFS(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(num!=n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&amp;&amp;n!=<span class="number">0</span>){</span><br><span class="line">		<span class="keyword">int</span> x,y;</span><br><span class="line">		<span class="built_in">memset</span>(G,<span class="number">0</span>,<span class="keyword">sizeof</span>(G));</span><br><span class="line">		<span class="built_in">memset</span>(bVis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(bVis));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">			G[x][y]=G[y][x]=<span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(DFSTraverse()) <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1001</span>;</span><br><span class="line"><span class="keyword">int</span> father[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> i)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(i!=father[i]){</span><br><span class="line">		father[i]=findFather(father[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> father[i];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeSet</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAXV;i++){</span><br><span class="line">		father[i]=i;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionSet</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> fa=findFather(x);</span><br><span class="line">	<span class="keyword">int</span> fb=findFather(y);</span><br><span class="line">	<span class="keyword">if</span>(fa!=fb){</span><br><span class="line">		father[fb]=fa;</span><br><span class="line">		n--;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&amp;&amp;n!=<span class="number">0</span>){</span><br><span class="line">		<span class="keyword">int</span> x,y;</span><br><span class="line">		makeSet();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">			unionSet(x,y);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="图的广度优先搜索"><a href="#图的广度优先搜索" class="headerlink" title="图的广度优先搜索"></a>图的广度优先搜索</h2><h3 id="邻接矩阵-1"><a href="#邻接矩阵-1" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> n,G[MAXV][MAXV];</span><br><span class="line"><span class="keyword">bool</span> bInq[MAXV]={<span class="literal">false</span>};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> u)</span></span>{</span><br><span class="line">  bInq[u]=<span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;ine&gt; q;</span><br><span class="line">  q.push(u);</span><br><span class="line">  <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">    <span class="keyword">int</span> u=q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++){</span><br><span class="line">      <span class="keyword">if</span>(!bInq[v]&amp;&amp;G[u][v]!=INF){</span><br><span class="line">        q.push(v);</span><br><span class="line">        bInq[v]=<span class="literal">true</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++){</span><br><span class="line">    <span class="keyword">if</span>(!bInq[u]){</span><br><span class="line">      BFS(u);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="邻接表-1"><a href="#邻接表-1" class="headerlink" title="邻接表"></a>邻接表</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">101</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Adj[MAXV];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> bInq[MAXV]={<span class="literal">false</span>};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> u)</span></span>{</span><br><span class="line">  bInq[u]=<span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  q.push(u);</span><br><span class="line">  <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">    <span class="keyword">int</span> u=q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">      <span class="keyword">int</span> v=Adj[u][i];</span><br><span class="line">      <span class="keyword">if</span>(!bInq[v]){</span><br><span class="line">        q.push(v);</span><br><span class="line">        bInq[v]=<span class="literal">true</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++){</span><br><span class="line">    <span class="keyword">if</span>(!bInq[u]){</span><br><span class="line">        BFS(u);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="PAT-A1076-Forwards-on-Weibo"><a href="#PAT-A1076-Forwards-on-Weibo" class="headerlink" title="PAT-A1076 Forwards on Weibo"></a>PAT-A1076 Forwards on Weibo</h3><p><strong>Description</strong><br>Weibo is known as the Chinese version of Twitter. One user on Weibo may have many followers, and may follow many other users as well. Hence a social network is formed with followers relations. When a user makes a post on Weibo, all his/her followers can view and forward his/her post, which can then be forwarded again by their followers. Now given a social network, you are supposed to calculate the maximum potential amount of forwards for any specific user, assuming that only L levels of indirect followers are counted.<br><strong>Input Specification</strong><br>Each input file contains one test case. For each case, the first line contains 2 positive integers: N (≤1000), the number of users; and L (≤6), the number of levels of indirect followers that are counted. Hence it is assumed that all the users are numbered from 1 to N. Then N lines follow, each in the format:<br>M[i] user_list[i]<br>where M[i] (≤100) is the total number of people that user[i] follows; and user_list[i] is a list of the M[i] users that followed by user[i]. It is guaranteed that no one can follow oneself. All the numbers are separated by a space.<br>Then finally a positive K is given, followed by K UserID’s for query.<br><strong>Output Specification</strong><br>For each UserID, you are supposed to print in one line the maximum potential amount of forwards this user can trigger, assuming that everyone who can view the initial post will forward it once, and that only L levels of indirect followers are counted.<br><strong>Sample Input</strong><br>7 3<br>3 2 3 4<br>0<br>2 5 6<br>2 3 1<br>2 3 4<br>1 4<br>1 5<br>2 2 6<br><strong>Sample Output</strong><br>4<br>5<br><strong>Procedure</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1001</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> vertex;</span><br><span class="line">	<span class="keyword">int</span> layer;</span><br><span class="line">	Node(){}</span><br><span class="line">	Node(<span class="keyword">int</span> v,<span class="keyword">int</span> l):vertex(v),layer(l){}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,L;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXV];</span><br><span class="line"><span class="keyword">bool</span> bInq[MAXV];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> u)</span></span>{</span><br><span class="line">	<span class="built_in">memset</span>(bInq,<span class="literal">false</span>,<span class="keyword">sizeof</span>(bInq));</span><br><span class="line">	<span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">	bInq[u]=<span class="literal">true</span>;</span><br><span class="line">	q.push(Node(u,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty()){</span><br><span class="line">		Node tmp=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">int</span> u=tmp.vertex;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">			Node v=Adj[u][i];</span><br><span class="line">			v.layer=tmp.layer+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(!bInq[v.vertex]&amp;&amp;v.layer&lt;=L){</span><br><span class="line">				num++;</span><br><span class="line">				q.push(v);</span><br><span class="line">				bInq[v.vertex]=<span class="literal">true</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;N&gt;&gt;L;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++){</span><br><span class="line">		<span class="keyword">int</span> m;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++){</span><br><span class="line">			<span class="keyword">int</span> v;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;v;</span><br><span class="line">			Adj[v].push_back(Node(i,<span class="number">1</span>));</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++){</span><br><span class="line">		<span class="keyword">int</span> v;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;v;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;BFS(v)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1></blockquote><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><h3 id="邻接矩阵-O-V-2"><a href="#邻接矩阵-O-V-2" class="headerlink" title="邻接矩阵 O(V^{2})"></a>邻接矩阵 O(V^{2})</h3><p>适用于V不超过1000</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,G[MAXV][MAXV];</span><br><span class="line"><span class="keyword">bool</span> bVis[MAXV];</span><br><span class="line"><span class="keyword">int</span> dist[MAXV];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">  fill(dist,dist+MAXV,INF);</span><br><span class="line">  fill(bVis,bVis+MAXV,<span class="literal">false</span>);</span><br><span class="line">  dist[s]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">      <span class="keyword">if</span>(!bVis[j]&amp;&amp;dist[j]&lt;MIN){</span><br><span class="line">        u=j;</span><br><span class="line">        MIN=dist[j];</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>; <span class="comment">//源点不连通</span></span><br><span class="line">    bVis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++){</span><br><span class="line">      <span class="keyword">if</span>(!bVis[v]&amp;&amp;G[u][v]!=INF&amp;&amp;dist[u]+G[u][v]&lt;dist[v]){</span><br><span class="line">        dist[v]=dist[u]+G[u][v];</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="邻接表-O-V-2-E"><a href="#邻接表-O-V-2-E" class="headerlink" title="邻接表 O(V^{2}+E)"></a>邻接表 O(V^{2}+E)</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">  <span class="keyword">int</span> v;</span><br><span class="line">  <span class="keyword">int</span> dis;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;　Adj[MAXV];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dist[MAXV];</span><br><span class="line"><span class="keyword">bool</span> bVis[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">  fill(dist,dist+MAXV,INF);</span><br><span class="line">  fill(bVis,bVis+MAXV,<span class="literal">false</span>);</span><br><span class="line">  dist[s]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    <span class="keyword">int</span> u=-s,MIN=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">      <span class="keyword">if</span>(!bVis[j]&amp;&amp;dist[j]&lt;MIN){</span><br><span class="line">        u=j;</span><br><span class="line">        MIN=dist[j];</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;Adj[u].size();k++){</span><br><span class="line">      <span class="keyword">int</span> v=Adj[u][k].v;</span><br><span class="line">      <span class="keyword">if</span>(!bVis[v]&amp;&amp;Adj[u][k].dis+MIN&lt;dist[v]){</span><br><span class="line">        dist[v]=Adj[u][k].dis+MIN;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="堆优化-O-VlogV-E"><a href="#堆优化-O-VlogV-E" class="headerlink" title="堆优化 O(VlogV+E)"></a>堆优化 O(VlogV+E)</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1001</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">  <span class="keyword">int</span> v;</span><br><span class="line">  <span class="keyword">int</span> dis;</span><br><span class="line">  Node(){}</span><br><span class="line">  Node(<span class="keyword">int</span> vv,<span class="keyword">int</span> dd):v(vv),dis(dd){}</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; tmp) <span class="keyword">const</span>{</span><br><span class="line">    <span class="keyword">return</span> dis&lt;tmp.dist;</span><br><span class="line">  }</span><br><span class="line">}；</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXV];</span><br><span class="line"><span class="keyword">int</span> dist[MAXV];</span><br><span class="line"><span class="keyword">int</span> bVis[MAXV];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijstra_mini</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">  fill(bVis,bVis+MAXV,<span class="literal">false</span>);</span><br><span class="line">  fill(dist,dist+MAXV,INF);</span><br><span class="line">  priority_queue&lt;Node&gt; pq;</span><br><span class="line">  dist[s]=<span class="number">0</span>;</span><br><span class="line">  pq.push(Node(s,<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">int</span> nDone=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(nDone&lt;n&amp;&amp;!pq.empty()){</span><br><span class="line">    Node top=pq.top();</span><br><span class="line">    pq.pop();</span><br><span class="line">    <span class="keyword">if</span>(!bVis[top.v]){</span><br><span class="line">      nDone++;</span><br><span class="line">        bVis[top.v]=<span class="literal">true</span>;</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[top.v].size();i++){</span><br><span class="line">      <span class="keyword">int</span>  v=Adj[top.v][i];</span><br><span class="line">      <span class="keyword">int</span> dis=Adj[top.v][i].dis;</span><br><span class="line">      <span class="keyword">if</span>(!bVist[v]&amp;&amp;dis+top.dis&lt;dist[v]){</span><br><span class="line">        dist[v]=dis+top.dis;</span><br><span class="line">        pq.push(Node(v,dist[v]));</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h3><h4 id="新增边权（比如花费）求最短路径下的花费最小"><a href="#新增边权（比如花费）求最短路径下的花费最小" class="headerlink" title="新增边权（比如花费）求最短路径下的花费最小"></a>新增边权（比如花费）求最短路径下的花费最小</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++){</span><br><span class="line">  <span class="keyword">if</span>(!bVis[v]&amp;&amp;G[u][v]!=INF){</span><br><span class="line">    <span class="keyword">if</span>(dist[u]+G[u][v]&lt;dist[v]){</span><br><span class="line">      dist[v]=dist[u]+G[u][v];</span><br><span class="line">      c[v]=c[u]+cost[u][v];</span><br><span class="line">    }<span class="keyword">else</span> <span class="keyword">if</span>(dist[u]+G[u][v]==dist[v]&amp;&amp;c[u]+cost[u][v]&lt;c[v]){</span><br><span class="line">      c[v]=c[u]+cost[u][v];</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="新增点权（比如物资）求最短路径下的收集的物资最大"><a href="#新增点权（比如物资）求最短路径下的收集的物资最大" class="headerlink" title="新增点权（比如物资）求最短路径下的收集的物资最大"></a>新增点权（比如物资）求最短路径下的收集的物资最大</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++){</span><br><span class="line">  <span class="keyword">if</span>(!bVis[v]&amp;&amp;G[u][v]!=INF){</span><br><span class="line">    <span class="keyword">if</span>(dist[u]+G[u][v]&lt;dist[v]){</span><br><span class="line">      dis[v]=dist[u]+G[u][v];</span><br><span class="line">      w[v]=w[u]+weight[v];</span><br><span class="line">    }<span class="keyword">else</span> <span class="keyword">if</span>(dist[u]+G[u][v]==dist[v]&amp;&amp;w[u]+weight[v]&gt;w[v]){</span><br><span class="line">      w[v]=w[u]+weight[v];</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><h4 id="求最短路径条数"><a href="#求最短路径条数" class="headerlink" title="求最短路径条数"></a>求最短路径条数</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++){</span><br><span class="line">  <span class="keyword">if</span>(!bVis[u]&amp;&amp;G[u][v]!=INF){</span><br><span class="line">    <span class="keyword">if</span>(dist[u]+G[u][v]&lt;dist[v]){</span><br><span class="line">      dist[v]=dist[u]+G[u][v];</span><br><span class="line">      num[v]=num[u];</span><br><span class="line">    }<span class="keyword">else</span> <span class="keyword">if</span>(dist[u]+G[u][v]==dist[v]){</span><br><span class="line">      num[v]+=num[u];</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="求路径"><a href="#求路径" class="headerlink" title="求路径"></a>求路径</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) pre[i]=i;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++){</span><br><span class="line">  <span class="keyword">if</span>(!bVis[v]&amp;&amp;G[u][v]!=INF&amp;&amp;dist[u]+G[u][v]&lt;dist[v]){</span><br><span class="line">    dist[v]=dist[u]+G[u][v];</span><br><span class="line">    pre[v]=u;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归打路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> v)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(s==v){</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">  DFS(s,pre[v]);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;v&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Dijkstra-DFS"><a href="#Dijkstra-DFS" class="headerlink" title="Dijkstra+DFS"></a>Dijkstra+DFS</h3><p>上述几种变形都满足贪心的最优子结构，但实际情况可能出现一些逻辑更复杂的计算边权或点权的方式，上述方法就不一定能够算出正确的结果<br>故介绍一种更加通用、又模板化的解决方法：<br>现在Dijkstra算法中记录所有最短路径，然后从这些最短路径中选出一条满足第二标尺的路径！<br>不妨把pre数组定义为vector<int> pre[MAXV];，这样对每个节点v来说，pre[v]就是一个边长的数组vetor，里面用来存放点v的所有能产生最短路径的前驱节点。<br>那么，在原有Dijkstra算法基础上更改代码即可：</int></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(dist[u]+G[u][v]&lt;dist[v]){</span><br><span class="line">  dist[v]=dist[u]+G[u][v];</span><br><span class="line">  pre[v].clear();</span><br><span class="line">  pre[v].push_back(u);</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(dist[u]+G[u][v]==dist[v]){</span><br><span class="line">  pre[v].push_back(u);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="PAT-A1003-Emergency（25）"><a href="#PAT-A1003-Emergency（25）" class="headerlink" title="PAT-A1003 Emergency（25）"></a>PAT-A1003 Emergency（25）</h3><p>As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.<br><strong>Input Specification</strong><br>Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (≤500) - the number of cities (and the cities are numbered from 0 to N−1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1<br>​​ , c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2.<br><strong>Output Specification</strong><br>For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.<br><strong>Sample Input</strong><br>5 6 0 2<br>1 2 1 5 3<br>0 1 1<br>0 2 2<br>0 3 1<br>1 2 1<br>2 4 1<br>3 4 1<br><strong>Sample Output</strong><br>2 4<br><strong>Procedure</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">501</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s,e;</span><br><span class="line"><span class="keyword">int</span> G[MAXV][MAXV];</span><br><span class="line"><span class="keyword">bool</span> bVis[MAXV];</span><br><span class="line"><span class="keyword">int</span> dist[MAXV];</span><br><span class="line"><span class="keyword">int</span> num[MAXV];</span><br><span class="line"><span class="keyword">int</span> weight[MAXV];</span><br><span class="line"><span class="keyword">int</span> w[MAXV];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">	<span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">	<span class="built_in">memset</span>(bVis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(bVis));</span><br><span class="line">	<span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">	<span class="built_in">memset</span>(w,<span class="number">0</span>,<span class="keyword">sizeof</span>(w));</span><br><span class="line">	w[s]=weight[s];</span><br><span class="line">	num[s]=<span class="number">1</span>;</span><br><span class="line">	dist[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">		<span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">			<span class="keyword">if</span>(!bVis[j]&amp;&amp;dist[j]&lt;MIN){</span><br><span class="line">				u=j;</span><br><span class="line">				MIN=dist[j];</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">		bVis[u]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++){</span><br><span class="line">			<span class="keyword">if</span>(!bVis[v]&amp;&amp;G[u][v]!=INF){</span><br><span class="line">				<span class="keyword">if</span>(dist[u]+G[u][v]&lt;dist[v]){</span><br><span class="line">					dist[v]=dist[u]+G[u][v];</span><br><span class="line">					w[v]=w[u]+weight[v];</span><br><span class="line">					num[v]=num[u];</span><br><span class="line">				}<span class="keyword">else</span> <span class="keyword">if</span>(dist[u]+G[u][v]==dist[v]){</span><br><span class="line">					num[v]+=num[u];</span><br><span class="line">					<span class="keyword">if</span>(w[u]+weight[v]&gt;w[v]){</span><br><span class="line">						w[v]=w[u]+weight[v];</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;e;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;weight[i];</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">memset</span>(G,INF,<span class="keyword">sizeof</span>(G));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">		<span class="keyword">int</span> s,e,l;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;e&gt;&gt;l;</span><br><span class="line">		G[s][e]=G[e][s]=l;</span><br><span class="line">	}</span><br><span class="line">	Dijkstra(s);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;num[e]&lt;&lt;<span class="string">" "</span>&lt;&lt;w[e]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">501</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s,e;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> dis;</span><br><span class="line">	Node(){}</span><br><span class="line">	Node(<span class="keyword">int</span> vv,<span class="keyword">int</span> dd):v(vv),dis(dd){}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">int</span> dist[MAXV];</span><br><span class="line"><span class="keyword">bool</span> bVis[MAXV];</span><br><span class="line"><span class="keyword">int</span> num[MAXV];</span><br><span class="line"><span class="keyword">int</span> weight[MAXV];</span><br><span class="line"><span class="keyword">int</span> w[MAXV];</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXV];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">	<span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">	<span class="built_in">memset</span>(bVis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(bVis));</span><br><span class="line">	<span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">	<span class="built_in">memset</span>(w,<span class="number">0</span>,<span class="keyword">sizeof</span>(w));</span><br><span class="line">	num[s]=<span class="number">1</span>;</span><br><span class="line">	w[s]=weight[s];</span><br><span class="line">	dist[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">		<span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">			<span class="keyword">if</span>(!bVis[j]&amp;&amp;dist[j]&lt;MIN){</span><br><span class="line">				u=j;</span><br><span class="line">				MIN=dist[j];</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">		bVis[u]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++){</span><br><span class="line">			<span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line">			<span class="keyword">int</span> dis=Adj[u][j].dis;</span><br><span class="line">			<span class="keyword">if</span>(!bVis[v]){</span><br><span class="line">				<span class="keyword">if</span>(dist[u]+dis&lt;dist[v]){</span><br><span class="line">					dist[v]=dist[u]+dis;</span><br><span class="line">					w[v]=w[u]+weight[v];</span><br><span class="line">					num[v]=num[u];</span><br><span class="line">				}<span class="keyword">else</span> <span class="keyword">if</span>(dist[u]+dis==dist[v]){</span><br><span class="line">					num[v]+=num[u];</span><br><span class="line">					<span class="keyword">if</span>(w[u]+weight[v]&gt;w[v]){</span><br><span class="line">						w[v]=w[u]+weight[v];</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;e;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;weight[i];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">		<span class="keyword">int</span> s,e,l;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;e&gt;&gt;l;</span><br><span class="line">		Adj[s].push_back(Node(e,l));</span><br><span class="line">		Adj[e].push_back(Node(s,l));</span><br><span class="line">	}</span><br><span class="line">	Dijkstra(s);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;num[e]&lt;&lt;<span class="string">" "</span>&lt;&lt;w[e]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表+堆</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">501</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0X3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s,e;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> dis;</span><br><span class="line">	Node(){}</span><br><span class="line">	Node(<span class="keyword">int</span> vv,<span class="keyword">int</span> dd):v(vv),dis(dd){}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; tmp) <span class="keyword">const</span>{</span><br><span class="line">		<span class="keyword">return</span> dis&gt;tmp.dis;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXV];</span><br><span class="line"><span class="keyword">int</span> num[MAXV];</span><br><span class="line"><span class="keyword">int</span> weight[MAXV];</span><br><span class="line"><span class="keyword">int</span> w[MAXV];</span><br><span class="line"><span class="keyword">int</span> dist[MAXV];</span><br><span class="line"><span class="keyword">bool</span> bVis[MAXV];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">	<span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">	<span class="built_in">memset</span>(w,<span class="number">0</span>,<span class="keyword">sizeof</span>(w));</span><br><span class="line">	<span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">	<span class="built_in">memset</span>(bVis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(bVis));</span><br><span class="line">	num[s]=<span class="number">1</span>;</span><br><span class="line">	w[s]=weight[s];</span><br><span class="line">	dist[s]=<span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;Node&gt; pq;</span><br><span class="line">	pq.push(Node(s,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">int</span> iChecked=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty()&amp;&amp;iChecked&lt;n){</span><br><span class="line">		Node top=pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		bVis[top.v]=<span class="literal">true</span>;</span><br><span class="line">		iChecked++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[top.v].size();i++){</span><br><span class="line">			<span class="keyword">int</span> v=Adj[top.v][i].v;</span><br><span class="line">			<span class="keyword">int</span> dis=Adj[top.v][i].dis;</span><br><span class="line">			<span class="keyword">if</span>(!bVis[v]){</span><br><span class="line">				<span class="keyword">if</span>(dis+dist[top.v]&lt;dist[v]){</span><br><span class="line">					dist[v]=dis+dist[top.v];</span><br><span class="line">					num[v]=num[top.v];</span><br><span class="line">					w[v]=w[top.v]+weight[v];</span><br><span class="line">					pq.push(Node(v,dist[v]));</span><br><span class="line">				}<span class="keyword">else</span> <span class="keyword">if</span>(dis+dist[top.v]==dist[v]){</span><br><span class="line">					num[v]+=num[top.v];</span><br><span class="line">					<span class="keyword">if</span>(w[top.v]+weight[v]&gt;w[v]){</span><br><span class="line">						w[v]=w[top.v]+weight[v];</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;e;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;weight[i];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">		<span class="keyword">int</span> s,e,l;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;e&gt;&gt;l;</span><br><span class="line">		Adj[s].push_back(Node(e,l));</span><br><span class="line">		Adj[e].push_back(Node(s,l));</span><br><span class="line">	}</span><br><span class="line">	Dijkstra(s);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;num[e]&lt;&lt;<span class="string">" "</span>&lt;&lt;w[e]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1030-Travel-Plan-30"><a href="#1030-Travel-Plan-30" class="headerlink" title="1030 Travel Plan (30)"></a>1030 Travel Plan (30)</h3><p>A traveler’s map gives the distances between cities along the highways, together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique.<br><strong>Input Specification</strong><br>Each input file contains one test case. Each case starts with a line containing 4 positive integers N, M, S, and D, where N (≤500) is the number of cities (and hence the cities are numbered from 0 to N−1); M is the number of highways; S and D are the starting and the destination cities, respectively. Then M lines follow, each provides the information of a highway, in the format:<br>City1 City2 Distance Cost<br>where the numbers are all integers no more than 500, and are separated by a space.<br><strong>Output Specification</strong><br>For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output.<br><strong>Sample Input</strong><br>4 5 0 3<br>0 1 1 20<br>1 3 2 30<br>0 3 4 10<br>0 2 2 20<br>2 3 1 20<br><strong>Sample Output</strong><br>0 2 3 3 40<br><strong>Procedure</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dijkstra+堆</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">501</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> dis;</span><br><span class="line">	<span class="keyword">int</span> cost;</span><br><span class="line">	Node(){}</span><br><span class="line">	Node(<span class="keyword">int</span> vv,<span class="keyword">int</span> dd,<span class="keyword">int</span> cc):v(vv),dis(dd),cost(cc){}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; tmp) <span class="keyword">const</span>{</span><br><span class="line">		<span class="keyword">if</span>(dis!=tmp.dis){</span><br><span class="line">			<span class="keyword">return</span> dis&gt;tmp.dis;</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			<span class="keyword">return</span> cost&gt;tmp.cost;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXV];</span><br><span class="line"><span class="keyword">int</span> pre[MAXV];</span><br><span class="line"><span class="keyword">int</span> dist[MAXV];</span><br><span class="line"><span class="keyword">bool</span> bVis[MAXV];</span><br><span class="line"><span class="keyword">int</span> cost[MAXV];</span><br><span class="line"><span class="keyword">int</span> n,m,s,d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> v)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(v==s){</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;s;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	print(pre[v]);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;v;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">	<span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">	<span class="built_in">memset</span>(bVis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(bVis));</span><br><span class="line">	<span class="built_in">memset</span>(cost,INF,<span class="keyword">sizeof</span>(cost));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) pre[i]=i;</span><br><span class="line">	dist[s]=<span class="number">0</span>;</span><br><span class="line">	cost[s]=<span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;Node&gt; pq;</span><br><span class="line">	pq.push(Node(s,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">int</span> nChecked=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty()&amp;&amp;nChecked&lt;n){</span><br><span class="line">		Node top=pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		bVis[top.v]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[top.v].size();i++){</span><br><span class="line">			<span class="keyword">int</span> v=Adj[top.v][i].v;</span><br><span class="line">			<span class="keyword">int</span> dis=Adj[top.v][i].dis;</span><br><span class="line">			<span class="keyword">int</span> <span class="built_in">cos</span>=Adj[top.v][i].cost;</span><br><span class="line">			<span class="keyword">if</span>(!bVis[v]){</span><br><span class="line">				<span class="keyword">if</span>(dist[top.v]+dis&lt;dist[v]){</span><br><span class="line">					dist[v]=dist[top.v]+dis;</span><br><span class="line">					pre[v]=top.v;</span><br><span class="line">					cost[v]=cost[top.v]+<span class="built_in">cos</span>;</span><br><span class="line">					pq.push(Node(v,dist[v],cost[v]));</span><br><span class="line">				}<span class="keyword">else</span> <span class="keyword">if</span>(dist[top.v]+dis==dist[v]){</span><br><span class="line">					<span class="keyword">if</span>(cost[top.v]+<span class="built_in">cos</span>&lt;cost[v]){</span><br><span class="line">						pre[v]=top.v;</span><br><span class="line">						cost[v]=cost[top.v]+<span class="built_in">cos</span>;</span><br><span class="line">						pq.push(Node(v,dist[v],cost[v]));</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;d;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">		<span class="keyword">int</span> u,v,dis,<span class="built_in">cos</span>;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;dis&gt;&gt;<span class="built_in">cos</span>;</span><br><span class="line">		Adj[u].push_back(Node(v,dis,<span class="built_in">cos</span>));</span><br><span class="line">		Adj[v].push_back(Node(u,dis,<span class="built_in">cos</span>));</span><br><span class="line">	}</span><br><span class="line">	Dijkstra(s);</span><br><span class="line">	print(d);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;dist[d]&lt;&lt;<span class="string">" "</span>&lt;&lt;cost[d]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dijkstra+DFS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">501</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> dis;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">cos</span>;</span><br><span class="line">	Node(){}</span><br><span class="line">	Node(<span class="keyword">int</span> vv,<span class="keyword">int</span> dd,<span class="keyword">int</span> cc):v(vv),dis(dd),<span class="built_in">cos</span>(cc){}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; tmp) <span class="keyword">const</span>{</span><br><span class="line">		<span class="keyword">return</span> dis&gt;tmp.dis;</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXV];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre[MAXV];</span><br><span class="line"><span class="keyword">int</span> bVis[MAXV];</span><br><span class="line"><span class="keyword">int</span> dist[MAXV];</span><br><span class="line"><span class="keyword">int</span> optCost=INF;</span><br><span class="line"><span class="keyword">int</span> n,m,s,d;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path,tmpPath;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findUV</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">		<span class="keyword">if</span>(Adj[u][i].v==v){</span><br><span class="line">			<span class="keyword">return</span> Adj[u][i].<span class="built_in">cos</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(v==s){</span><br><span class="line">		tmpPath.push_back(v);</span><br><span class="line">		<span class="keyword">int</span> tmpCost=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=tmpPath.size()<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--){</span><br><span class="line">			<span class="keyword">int</span> u=tmpPath[i],v=tmpPath[i<span class="number">-1</span>];</span><br><span class="line">			tmpCost+=findUV(u,v);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(tmpCost&lt;optCost){</span><br><span class="line">			optCost=tmpCost;</span><br><span class="line">			path=tmpPath;</span><br><span class="line">		}</span><br><span class="line">		tmpPath.pop_back();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	tmpPath.push_back(v);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pre[v].size();i++){</span><br><span class="line">		DFS(pre[v][i]);</span><br><span class="line">	}</span><br><span class="line">	tmpPath.pop_back();</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">	<span class="built_in">memset</span>(bVis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(bVis));</span><br><span class="line">	<span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">	dist[s]=<span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;Node&gt; pq;</span><br><span class="line">	pq.push(Node(s,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">int</span> nChecked=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty()&amp;&amp;nChecked&lt;n){</span><br><span class="line">		Node top=pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		bVis[top.v]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[top.v].size();i++){</span><br><span class="line">			<span class="keyword">int</span> v=Adj[top.v][i].v;</span><br><span class="line">			<span class="keyword">int</span> dis=Adj[top.v][i].dis;</span><br><span class="line">			<span class="keyword">if</span>(!bVis[v]){</span><br><span class="line">				<span class="keyword">if</span>(dist[top.v]+dis&lt;dist[v]){</span><br><span class="line">					dist[v]=dist[top.v]+dis;</span><br><span class="line">					pre[v].clear();</span><br><span class="line">					pre[v].push_back(top.v);</span><br><span class="line">					pq.push(Node(v,dist[v],<span class="number">0</span>));</span><br><span class="line">				}<span class="keyword">else</span> <span class="keyword">if</span>(dist[top.v]+dis==dist[v]){</span><br><span class="line">					pre[v].push_back(top.v);</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;d;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">		<span class="keyword">int</span> s,e,d,c;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;e&gt;&gt;d&gt;&gt;c;</span><br><span class="line">		Adj[s].push_back(Node(e,d,c));</span><br><span class="line">		Adj[e].push_back(Node(s,d,c));</span><br><span class="line">	}</span><br><span class="line">	Dijkstra(s);</span><br><span class="line">	DFS(d);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=path.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;path[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;dist[d]&lt;&lt;<span class="string">" "</span>&lt;&lt;optCost&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Bellman-Ford算法-O-VE"><a href="#Bellman-Ford算法-O-VE" class="headerlink" title="Bellman-Ford算法 O(VE)"></a>Bellman-Ford算法 O(VE)</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">  <span class="keyword">int</span> v;</span><br><span class="line">  <span class="keyword">int</span> dis;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXV];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dist[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bellman</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">  <span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">  dist[s]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">bool</span> bChange=<span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++){</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++){</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++){</span><br><span class="line">        <span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line">        <span class="keyword">int</span> dis=Adj[u][j].dis;</span><br><span class="line">        <span class="keyword">if</span>(dist[u]+dis&lt;dist[v]){</span><br><span class="line">          dist[v]=dist[u]+dis;</span><br><span class="line">          bChange=<span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(!bChange) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++){</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++){</span><br><span class="line">      <span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line">      <span class="keyword">int</span> dis=Adj[u][j].dis;</span><br><span class="line">      <span class="keyword">if</span>(dist[u]+dis&lt;dist[v]){</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="PAT-A1003-Emergency（25）-1"><a href="#PAT-A1003-Emergency（25）-1" class="headerlink" title="PAT-A1003 Emergency（25）"></a>PAT-A1003 Emergency（25）</h3><p>As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.<br><strong>Input Specification</strong><br>Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (≤500) - the number of cities (and the cities are numbered from 0 to N−1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1<br>​​ , c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2.<br><strong>Output Specification</strong><br>For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.<br><strong>Sample Input</strong><br>5 6 0 2<br>1 2 1 5 3<br>0 1 1<br>0 2 2<br>0 3 1<br>1 2 1<br>2 4 1<br>3 4 1<br><strong>Sample Output</strong><br>2 4<br><strong>Procedure</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">501</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> dis;</span><br><span class="line">	Node(){}</span><br><span class="line">	Node(<span class="keyword">int</span> vv,<span class="keyword">int</span> dd):v(vv),dis(dd){}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXV];</span><br><span class="line"><span class="keyword">int</span> num[MAXV];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; pre[MAXV];</span><br><span class="line"><span class="keyword">int</span> dist[MAXV];</span><br><span class="line"><span class="keyword">int</span> weight[MAXV];</span><br><span class="line"><span class="keyword">int</span> w[MAXV];</span><br><span class="line"><span class="keyword">int</span> N,M,s,e;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bellman_Ford</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">	<span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">	<span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">	<span class="built_in">memset</span>(w,INF,<span class="keyword">sizeof</span>(w));</span><br><span class="line">	w[s]=weight[s];</span><br><span class="line">	dist[s]=<span class="number">0</span>;</span><br><span class="line">	num[s]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">bool</span> bChange=<span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N<span class="number">-1</span>;i++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;N;u++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++){</span><br><span class="line">				<span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line">				<span class="keyword">int</span> dis=Adj[u][j].dis;</span><br><span class="line">				<span class="keyword">if</span>(dist[u]+dis&lt;dist[v]){</span><br><span class="line">					dist[v]=dist[u]+dis;</span><br><span class="line">					num[v]=num[u];</span><br><span class="line">					w[v]=w[u]+weight[v];</span><br><span class="line">					pre[v].clear();</span><br><span class="line">					pre[v].insert(u);</span><br><span class="line">					bChange=<span class="literal">true</span>;</span><br><span class="line">				}<span class="keyword">else</span> <span class="keyword">if</span>(dist[u]+dis==dist[v]){</span><br><span class="line">					<span class="keyword">if</span>(w[u]+weight[v]&gt;w[v]){</span><br><span class="line">						w[v]=w[u]+weight[v];</span><br><span class="line">					}</span><br><span class="line">					pre[v].insert(u);</span><br><span class="line">					num[v]=<span class="number">0</span>;</span><br><span class="line">					<span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=pre[v].begin();it!=pre[v].end();it++){</span><br><span class="line">						num[v]+=num[*it];</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(!bChange) <span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;N&gt;&gt;M&gt;&gt;s&gt;&gt;e;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) <span class="built_in">cin</span>&gt;&gt;weight[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++){</span><br><span class="line">		<span class="keyword">int</span> s,e,l;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;e&gt;&gt;l;</span><br><span class="line">		Adj[s].push_back(Node(e,l));</span><br><span class="line">		Adj[e].push_back(Node(s,l));</span><br><span class="line">	}</span><br><span class="line">	Bellman_Ford(s);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;num[e]&lt;&lt;<span class="string">" "</span>&lt;&lt;w[e]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="SPFA算法-O-kE"><a href="#SPFA算法-O-kE" class="headerlink" title="SPFA算法 O(kE)"></a>SPFA算法 O(kE)</h2><ul><li>期望时间复杂度O(kE),多数情况下k不超过2，可见该算法大部分数据异常高效，并经常性地优于堆优化的Dijkstra算法。<br>然而，如果存在负环则会退化到O(VE)</li><li>SPFA算法可以判断是否存在从源点可达的负环，如果负环从源点不可达，则需要添加一个辅助顶点C，并添加一条从源点到达C的有向边以及V-1从C到达除源点外各顶点的有向边才能判断负环是否存在</li><li>SPFA十分灵活，其内部的写法可以根据具体场景的不同进行调整：<br>①优先队列实现<br>②双端队列实现<br>③栈实现</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXV];</span><br><span class="line"><span class="keyword">int</span> n,dist[MAXV],num[MAXV];</span><br><span class="line"><span class="keyword">bool</span> inq[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">  <span class="built_in">memset</span>(inq,<span class="literal">false</span>,<span class="keyword">sizeof</span>(inq));</span><br><span class="line">  <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">  fill(d,d+MAXV,INF);</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">  Q.push(s);</span><br><span class="line">  <span class="keyword">while</span>(!Q.empty()){</span><br><span class="line">    <span class="keyword">int</span> u=Q.front();</span><br><span class="line">    Q.pop();</span><br><span class="line">    inq[u]=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++){</span><br><span class="line">      <span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line">      <span class="keyword">int</span> dis=Adj[u][j].dis;</span><br><span class="line">      <span class="keyword">if</span>(dist[u]+dis&lt;dist[v]){</span><br><span class="line">        dist[v]=dist[u]+dis;</span><br><span class="line">        <span class="keyword">if</span>(!inq[v]){</span><br><span class="line">          Q.push(v);</span><br><span class="line">          intq[v]=<span class="literal">true</span>;</span><br><span class="line">          num[v]++;  <span class="comment">//v的入队次数</span></span><br><span class="line">          <span class="keyword">if</span>(num[v]&gt;=n) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//有可达负环</span></span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num[MAXV];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cmp</span>{</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span><span class="keyword">const</span></span>{</span><br><span class="line">		<span class="keyword">return</span> dist[a]&gt;dist[b];</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">	<span class="built_in">memset</span>(dist, INF, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">	<span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	dist[s]=<span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, Cmp&gt; pq;</span><br><span class="line">	pq.push(s);</span><br><span class="line">	<span class="keyword">int</span> nDone=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(nDone&lt;n&amp;&amp;!pq.empty()){</span><br><span class="line">		<span class="keyword">int</span> u=pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		<span class="keyword">if</span>(!vis[u]){</span><br><span class="line">			vis[u]=<span class="literal">true</span>;</span><br><span class="line">			nDone++;</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++){</span><br><span class="line">			<span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line">			<span class="keyword">int</span> dis=Adj[u][j].dis;</span><br><span class="line">			<span class="keyword">if</span>(!vis[v]&amp;&amp;dist[u]+dis&lt;dist[v]){</span><br><span class="line">				dist[v]=dist[u]+dis;</span><br><span class="line">				num[v]++;</span><br><span class="line">        pq.push(v);</span><br><span class="line">				<span class="keyword">if</span>(num[v]&gt;=n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="PAT-A1003-Emergency（25）-2"><a href="#PAT-A1003-Emergency（25）-2" class="headerlink" title="PAT-A1003 Emergency（25）"></a>PAT-A1003 Emergency（25）</h3><p>As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.<br><strong>Input Specification</strong><br>Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (≤500) - the number of cities (and the cities are numbered from 0 to N−1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1<br>​​ , c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2.<br><strong>Output Specification</strong><br>For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.<br><strong>Sample Input</strong><br>5 6 0 2<br>1 2 1 5 3<br>0 1 1<br>0 2 2<br>0 3 1<br>1 2 1<br>2 4 1<br>3 4 1<br><strong>Sample Output</strong><br>2 4<br><strong>Procedure</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">501</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> dis;</span><br><span class="line">	Node(){}</span><br><span class="line">	Node(<span class="keyword">int</span> vv,<span class="keyword">int</span> dd):v(vv),dis(dd){}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXV];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; pre[MAXV];</span><br><span class="line"><span class="keyword">int</span> num[MAXV];</span><br><span class="line"><span class="keyword">int</span> dist[MAXV];</span><br><span class="line"><span class="keyword">int</span> weight[MAXV];</span><br><span class="line"><span class="keyword">int</span> w[MAXV];</span><br><span class="line"><span class="keyword">bool</span> bInq[MAXV];</span><br><span class="line"><span class="keyword">int</span> N,M,s,e;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">	<span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">	<span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">	<span class="built_in">memset</span>(w,INF,<span class="keyword">sizeof</span>(w));</span><br><span class="line">	<span class="built_in">memset</span>(bInq,<span class="literal">false</span>,<span class="keyword">sizeof</span>(bInq));</span><br><span class="line">	w[s]=weight[s];</span><br><span class="line">	num[s]=<span class="number">1</span>;</span><br><span class="line">	dist[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.push(s);</span><br><span class="line">	bInq[s]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(!Q.empty()){</span><br><span class="line">	 	<span class="keyword">int</span> u=Q.front();</span><br><span class="line">	 	Q.pop();</span><br><span class="line">	 	bInq[u]=<span class="literal">false</span>;</span><br><span class="line">	 	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">	 		<span class="keyword">int</span> v=Adj[u][i].v;</span><br><span class="line">	 		<span class="keyword">int</span> dis=Adj[u][i].dis;</span><br><span class="line">	 		<span class="keyword">if</span>(dist[u]+dis&lt;dist[v]){</span><br><span class="line">	 			dist[v]=dist[u]+dis;</span><br><span class="line">	 			w[v]=w[u]+weight[v];</span><br><span class="line">	 			num[v]=num[u];</span><br><span class="line">	 			pre[v].clear();</span><br><span class="line">				pre[v].insert(u);</span><br><span class="line">	 			<span class="keyword">if</span>(!bInq[v]){</span><br><span class="line">	 				Q.push(v);</span><br><span class="line">					bInq[v]=<span class="literal">true</span>;</span><br><span class="line">				}</span><br><span class="line">			 }<span class="keyword">else</span> <span class="keyword">if</span>(dist[u]+dis==dist[v]){</span><br><span class="line">			 	<span class="keyword">if</span>(!bInq[v]){</span><br><span class="line">	 				Q.push(v);</span><br><span class="line">					bInq[v]=<span class="literal">true</span>;</span><br><span class="line">				}</span><br><span class="line">			 	num[v]=<span class="number">0</span>;</span><br><span class="line">			 	pre[v].insert(u);</span><br><span class="line">			 	<span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=pre[v].begin();it!=pre[v].end();it++){</span><br><span class="line">					num[v]+=num[*it]; 		</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">if</span>(w[u]+weight[v]&gt;w[v]){</span><br><span class="line">					w[v]=w[u]+weight[v];</span><br><span class="line">				}</span><br><span class="line">			 }</span><br><span class="line">		 }</span><br><span class="line">	 }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;N&gt;&gt;M&gt;&gt;s&gt;&gt;e;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) <span class="built_in">cin</span>&gt;&gt;weight[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++){</span><br><span class="line">		<span class="keyword">int</span> s,e,l;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;e&gt;&gt;l;</span><br><span class="line">		Adj[s].push_back(Node(e,l));</span><br><span class="line">		Adj[e].push_back(Node(s,l));</span><br><span class="line">	}</span><br><span class="line">	SPFA(s);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;num[e]&lt;&lt;<span class="string">" "</span>&lt;&lt;w[e]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1030-Travel-Plan-30-1"><a href="#1030-Travel-Plan-30-1" class="headerlink" title="1030 Travel Plan (30)"></a>1030 Travel Plan (30)</h3><p>A traveler’s map gives the distances between cities along the highways, together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique.<br><strong>Input Specification</strong><br>Each input file contains one test case. Each case starts with a line containing 4 positive integers N, M, S, and D, where N (≤500) is the number of cities (and hence the cities are numbered from 0 to N−1); M is the number of highways; S and D are the starting and the destination cities, respectively. Then M lines follow, each provides the information of a highway, in the format:<br>City1 City2 Distance Cost<br>where the numbers are all integers no more than 500, and are separated by a space.<br><strong>Output Specification</strong><br>For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output.<br><strong>Sample Input</strong><br>4 5 0 3<br>0 1 1 20<br>1 3 2 30<br>0 3 4 10<br>0 2 2 20<br>2 3 1 20<br><strong>Sample Output</strong><br>0 2 3 3 40<br><strong>Procedure</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">501</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> dis;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">cos</span>;</span><br><span class="line">	Node(){}</span><br><span class="line">	Node(<span class="keyword">int</span> vv,<span class="keyword">int</span> dd,<span class="keyword">int</span> cc):v(vv),dis(dd),<span class="built_in">cos</span>(cc){}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXV];</span><br><span class="line"><span class="keyword">int</span> pre[MAXV];</span><br><span class="line"><span class="keyword">int</span> dist[MAXV];</span><br><span class="line"><span class="keyword">int</span> cost[MAXV];</span><br><span class="line"><span class="keyword">bool</span> bInq[MAXV];</span><br><span class="line"><span class="keyword">int</span> N,M,S,E;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">	<span class="built_in">memset</span>(cost,INF,<span class="keyword">sizeof</span>(cost));</span><br><span class="line">	<span class="built_in">memset</span>(bInq,<span class="literal">false</span>,<span class="keyword">sizeof</span>(bInq));</span><br><span class="line">	<span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">	dist[s]=<span class="number">0</span>;</span><br><span class="line">	cost[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.push(s);</span><br><span class="line">	bInq[s]=<span class="literal">true</span>;</span><br><span class="line">	pre[s]=s;</span><br><span class="line">	<span class="keyword">while</span>(!Q.empty()){</span><br><span class="line">		<span class="keyword">int</span> u=Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		bInq[u]=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">			<span class="keyword">int</span> v=Adj[u][i].v;</span><br><span class="line">			<span class="keyword">int</span> dis=Adj[u][i].dis;</span><br><span class="line">			<span class="keyword">int</span> <span class="built_in">cos</span>=Adj[u][i].<span class="built_in">cos</span>;</span><br><span class="line">			<span class="keyword">if</span>(dist[u]+dis&lt;dist[v]){</span><br><span class="line">				dist[v]=dist[u]+dis;</span><br><span class="line">				cost[v]=cost[u]+<span class="built_in">cos</span>;</span><br><span class="line">				pre[v]=u;</span><br><span class="line">				<span class="keyword">if</span>(!bInq[v]){</span><br><span class="line">					Q.push(v);</span><br><span class="line">					bInq[v]=<span class="literal">true</span>;</span><br><span class="line">				}</span><br><span class="line">			}<span class="keyword">else</span> <span class="keyword">if</span>(dist[u]+dis==dist[v]){</span><br><span class="line">				<span class="keyword">if</span>(!bInq[v]){</span><br><span class="line">					Q.push(v);</span><br><span class="line">					bInq[v]=<span class="literal">true</span>;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">if</span>(cost[u]+<span class="built_in">cos</span>&lt;cost[v]){</span><br><span class="line">					cost[v]=cost[u]+<span class="built_in">cos</span>;</span><br><span class="line">					pre[v]=u;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> e)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(pre[e]==e){</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;e;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	print(pre[e]);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;e;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;N&gt;&gt;M&gt;&gt;S&gt;&gt;E;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++){</span><br><span class="line">		<span class="keyword">int</span> s,e,d,c;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;e&gt;&gt;d&gt;&gt;c;</span><br><span class="line">		Adj[s].push_back(Node(e,d,c));</span><br><span class="line">		Adj[e].push_back(Node(s,d,c));</span><br><span class="line">	}</span><br><span class="line">	SPFA(S);</span><br><span class="line">	print(E);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;dist[E]&lt;&lt;<span class="string">" "</span>&lt;&lt;cost[E]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Floyd算法-O-n-3"><a href="#Floyd算法-O-n-3" class="headerlink" title="Floyd算法 $O(n^{3})$"></a>Floyd算法 $O(n^{3})$</h2><p>解决全源最短路问题，即对给定的图G(V,E)，求任意两点u,v之间的最短路径长度，时间复杂度$O(n^{3})$。由于其复杂度决定了顶点数n限制约在200以内，因此使用邻接矩阵实现。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">200</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dis[MAXV][MAXV];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++){</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">        <span class="keyword">if</span>(dis[i][k]!=INF&amp;&amp;dis[k][j]!=INF&amp;&amp;dis[i][k]+dis[k][j]&lt;dis[i][j]){</span><br><span class="line">          dis[i][j]=dis[i][k]+dis[k][j];</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="keyword">int</span> u,v,w;</span><br><span class="line">  <span class="built_in">memset</span>(dis,INF,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    dis[i][i]=<span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">    dis[u][v]=w;</span><br><span class="line">  }</span><br><span class="line">  Floyd();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;dist[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="算法7-15：迪杰斯特拉最短路径算法"><a href="#算法7-15：迪杰斯特拉最短路径算法" class="headerlink" title="算法7-15：迪杰斯特拉最短路径算法"></a>算法7-15：迪杰斯特拉最短路径算法</h3><p><strong>题目描述</strong><br>在带权有向图G中，给定一个源点v，求从v到G中的其余各顶点的最短路径问题，叫做单源点的最短路径问题。<br>在常用的单源点最短路径算法中，迪杰斯特拉算法是最为常用的一种，是一种按照路径长度递增的次序产生最短路径的算法。<br>在本题中，读入一个有向图的带权邻接矩阵（即数组表示），建立有向图并按照以上描述中的算法求出源点至每一个其它顶点的最短路径长度。<br><strong>输入</strong><br>输入的第一行包含2个正整数n和s，表示图中共有n个顶点，且源点为s。其中n不超过50，s小于n。<br>以后的n行中每行有n个用空格隔开的整数。对于第i行的第j个整数，如果大于0，则表示第i个顶点有指向第j个顶点的有向边，且权值为对应的整数值；如果这个整数为0，则表示没有i指向j的有向边。当i和j相等的时候，保证对应的整数为0。<br><strong>输出</strong><br>只有一行，共有n-1个整数，表示源点至其它每一个顶点的最短路径长度。如果不存在从源点至相应顶点的路径，输出-1。<br>请注意行尾输出换行。<br><strong>样例输入</strong><br>4 1<br>0 3 0 1<br>0 0 4 0<br>2 0 0 0<br>0 0 1 0<br><strong>样例输出</strong><br>6 4 7<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">51</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> G[MAXV][MAXV];</span><br><span class="line"><span class="keyword">bool</span> bVis[MAXV];</span><br><span class="line"><span class="keyword">int</span> dist[MAXV];</span><br><span class="line"><span class="keyword">int</span> n,s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">	<span class="keyword">return</span> a&gt;b;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">	dist[s]=<span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line">	pq.push(s);</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty()){</span><br><span class="line">		<span class="keyword">int</span> u=pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		bVis[u]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++){</span><br><span class="line">			<span class="keyword">if</span>(G[u][v]!=<span class="number">0</span>){</span><br><span class="line">				<span class="keyword">if</span>(dist[u]+G[u][v]&lt;dist[v]){</span><br><span class="line">					dist[v]=dist[u]+G[u][v];</span><br><span class="line">					pq.push(v);</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">memset</span>(G,<span class="number">0</span>,<span class="keyword">sizeof</span>(G));</span><br><span class="line">	<span class="built_in">memset</span>(bVis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(bVis));</span><br><span class="line">	<span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;G[i][j];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	Dijkstra(s);</span><br><span class="line">	<span class="keyword">bool</span> bFirst=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">		<span class="keyword">if</span>(i!=s){</span><br><span class="line">			<span class="keyword">if</span>(bFirst){</span><br><span class="line">				bFirst=<span class="literal">false</span>;</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span>(dist[i]==INF) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;dist[i];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="算法7-16：弗洛伊德最短路径算法"><a href="#算法7-16：弗洛伊德最短路径算法" class="headerlink" title="算法7-16：弗洛伊德最短路径算法"></a>算法7-16：弗洛伊德最短路径算法</h3><p><strong>题目描述</strong><br>在带权有向图G中，求G中的任意一对顶点间的最短路径问题，也是十分常见的一种问题。<br>解决这个问题的一个方法是执行n次迪杰斯特拉算法，这样就可以求出每一对顶点间的最短路径，执行的时间复杂度为O(n3)。<br>而另一种算法是由弗洛伊德提出的，时间复杂度同样是O(n3)，但算法的形式简单很多。<br>在本题中，读入一个有向图的带权邻接矩阵（即数组表示），建立有向图并按照以上描述中的算法求出每一对顶点间的最短路径长度。<br><strong>输入</strong><br>输入的第一行包含1个正整数n，表示图中共有n个顶点。其中n不超过50。<br>以后的n行中每行有n个用空格隔开的整数。对于第i行的第j个整数，如果大于0，则表示第i个顶点有指向第j个顶点的有向边，且权值为对应的整数值；如果这个整数为0，则表示没有i指向j的有向边。当i和j相等的时候，保证对应的整数为0。<br><strong>输出</strong><br>共有n行，每行有n个整数，表示源点至每一个顶点的最短路径长度。如果不存在从源点至相应顶点的路径，输出-1。对于某个顶点到其本身的最短路径长度，输出0。<br>请在每个整数后输出一个空格，并请注意行尾输出换行。<br><strong>样例输入</strong><br>4<br>0 3 0 1<br>0 0 4 0<br>2 0 0 0<br>0 0 1 0<br><strong>样例输出</strong><br>0 3 2 1<br>6 0 4 7<br>2 5 0 3<br>3 6 1 0<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">51</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> dist[MAXV][MAXV];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">				<span class="keyword">if</span>(dist[i][k]!=INF&amp;&amp;dist[k][j]!=INF&amp;&amp;dist[i][k]+dist[k][j]&lt;dist[i][j]){</span><br><span class="line">					dist[i][j]=dist[i][k]+dist[k][j];</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;dist[i][j];</span><br><span class="line">			<span class="keyword">if</span>(i!=j&amp;&amp;dist[i][j]==<span class="number">0</span>) dist[i][j]=INF;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	Floyd();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">			<span class="keyword">if</span>(j!=<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">			<span class="keyword">if</span>(dist[i][j]==INF){</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;dist[i][j];</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="最短路径-1"><a href="#最短路径-1" class="headerlink" title="最短路径"></a>最短路径</h3><p><strong>题目描述</strong><br>N个城市，标号从0到N-1，M条道路，第K条道路（K从0开始）的长度为2^K，求编号为0的城市到其他城市的最短距离。<br><strong>输入</strong><br>第一行两个正整数N（2&lt;=N&lt;=100）M(M&lt;=500),表示有N个城市，M条道路，<br>接下来M行两个整数，表示相连的两个城市的编号。<br><strong>输出</strong><br>N-1行，表示0号城市到其他城市的最短路，如果无法到达，输出-1，数值太大的以MOD 100000 的结果输出。<br><strong>样例输入</strong><br>4 3<br>0 1<br>1 2<br>2 0<br><strong>样例输出</strong><br>1<br>3<br>-1<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WA代码</span></span><br><span class="line"><span class="comment">//需要高精度，这里不写了</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">501</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> dis;</span><br><span class="line">	Node(){}</span><br><span class="line">	Node(<span class="keyword">int</span> vv,<span class="keyword">int</span> dd):v(vv),dis(dd){}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;tmp) <span class="keyword">const</span>{</span><br><span class="line">		<span class="keyword">return</span> dis&gt;tmp.dis;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXV];</span><br><span class="line"><span class="keyword">bool</span> bInq[MAXV];</span><br><span class="line"><span class="keyword">int</span> dist[MAXV];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">	<span class="built_in">memset</span>(bInq,<span class="literal">false</span>,<span class="keyword">sizeof</span>(bInq));</span><br><span class="line">	<span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">	dist[s]=<span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;Node&gt; pq;</span><br><span class="line">	pq.push(Node(s,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty()){</span><br><span class="line">		Node top=pq.top();</span><br><span class="line">		<span class="keyword">int</span> u=top.v;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;"dis:"&lt;&lt;top.dis&lt;&lt;endl;</span></span><br><span class="line">		pq.pop();</span><br><span class="line">		bInq[u]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">			<span class="keyword">int</span> v=Adj[u][i].v;</span><br><span class="line">			<span class="keyword">int</span> dis=Adj[u][i].dis;</span><br><span class="line">			<span class="keyword">if</span>(!bInq[v]&amp;&amp;dist[u]+dis&lt;dist[v]){</span><br><span class="line">				dist[v]=dist[u]+dis;</span><br><span class="line">				dist[v]%=<span class="number">100000</span>;</span><br><span class="line">				pq.push(Node(v,dist[v]));</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">cos</span>[MAXV];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> k)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">cos</span>[k]!=INF) <span class="keyword">return</span> <span class="built_in">cos</span>[k];</span><br><span class="line">	<span class="keyword">if</span>(k==<span class="number">0</span>){</span><br><span class="line">		<span class="built_in">cos</span>[k]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">cos</span>[k];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(k%<span class="number">2</span>==<span class="number">1</span>){</span><br><span class="line">		<span class="built_in">cos</span>[k]=<span class="number">2</span>*cal(k<span class="number">-1</span>)%<span class="number">100000</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">cos</span>[k];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span>{</span><br><span class="line">		<span class="keyword">int</span> mul=cal(k/<span class="number">2</span>)%<span class="number">100000</span>;</span><br><span class="line">		<span class="built_in">cos</span>[k]=mul*mul%<span class="number">100000</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">cos</span>[k];</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">memset</span>(<span class="built_in">cos</span>,INF,<span class="keyword">sizeof</span>(<span class="built_in">cos</span>));</span><br><span class="line"><span class="comment">//	for(int i=0;i&lt;100;i++){</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;i&lt;&lt;":"&lt;&lt;cal(i)&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//		system("pause");</span></span><br><span class="line"><span class="comment">//	}</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;k++){</span><br><span class="line">		<span class="keyword">int</span> u,v;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		Adj[u].push_back(Node(v,cal(k)));</span><br><span class="line">		Adj[v].push_back(Node(u,cal(k)));</span><br><span class="line">	}</span><br><span class="line">	Dijkstra(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">		<span class="keyword">if</span>(dist[i]==INF) dist[i]=<span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;dist[i]%<span class="number">100000</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="最短路径-2"><a href="#最短路径-2" class="headerlink" title="最短路径"></a>最短路径</h3><p><strong>题目描述</strong><br>有n个城市m条道路（n&lt;1000, m&lt;10000)，每条道路有个长度，请找到从起点s到终点t的最短距离和经过的城市名。<br><strong>输入</strong><br>输入包含多组测试数据。<br>每组第一行输入四个数，分别为n，m，s，t。<br>接下来m行，每行三个数，分别为两个城市名和距离。<br><strong>输出</strong><br>每组输出占两行。<br>第一行输出起点到终点的最短距离。<br>第二行输出最短路径上经过的城市名，如果有多条最短路径，输出字典序最小的那条。若不存在从起点到终点的路径，则输出“can’t arrive”。<br><strong>样例输入</strong><br>3 3 1 3<br>1 3 3<br>1 2 1<br>2 3 1<br><strong>样例输出</strong><br>2<br>1 2 3<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> dis;</span><br><span class="line">	Node(){}</span><br><span class="line">	Node(<span class="keyword">int</span> vv,<span class="keyword">int</span> dd):v(vv),dis(dd){}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;tmp) <span class="keyword">const</span>{</span><br><span class="line">		<span class="keyword">return</span> dis&gt;tmp.dis;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;Node&gt; &gt; Adj;</span><br><span class="line"><span class="keyword">int</span> dist[MAXV];</span><br><span class="line"><span class="keyword">int</span> pre[MAXV];</span><br><span class="line"><span class="keyword">bool</span> bInq[MAXV];</span><br><span class="line"><span class="keyword">int</span> n,m,s,t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">	<span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">	<span class="built_in">memset</span>(bInq,<span class="literal">false</span>,<span class="keyword">sizeof</span>(bInq));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAXV;i++) pre[i]=i;</span><br><span class="line">	pre[s]=s;</span><br><span class="line">	dist[s]=<span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;Node&gt; pq;</span><br><span class="line">	pq.push(Node(s,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty()){</span><br><span class="line">		Node top=pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		<span class="keyword">int</span> u=top.v;</span><br><span class="line">		bInq[u]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">			<span class="keyword">int</span> v=Adj[u][i].v;</span><br><span class="line">			<span class="keyword">int</span> dis=Adj[u][i].dis;</span><br><span class="line">			<span class="keyword">if</span>(!bInq[v]){</span><br><span class="line">				<span class="keyword">if</span>(dist[u]+dis&lt;dist[v]){</span><br><span class="line">					dist[v]=dist[u]+dis;</span><br><span class="line">					pre[v]=u;</span><br><span class="line">					pq.push(Node(v,dist[v]));</span><br><span class="line">				}<span class="keyword">else</span> <span class="keyword">if</span>(dist[u]+dis==dist[v]){</span><br><span class="line">					<span class="keyword">if</span>(u&lt;pre[v]){</span><br><span class="line">						pre[v]=u;</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> v)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(v==pre[v]){</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;v;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	print(pre[v]);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;v;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPush</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e,<span class="keyword">int</span> l,<span class="keyword">int</span>&amp; index)</span></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[s].size();i++){</span><br><span class="line">		<span class="keyword">int</span> v=Adj[s][i].v;</span><br><span class="line">		<span class="keyword">if</span>(v==e){</span><br><span class="line">			index=i;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t){</span><br><span class="line">		Adj.clear();  <span class="comment">//注意resize改变vector的size大小，但是尽可能保留原有元素！</span></span><br><span class="line">		Adj.resize(n+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">			<span class="keyword">int</span> s,e,l;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;e&gt;&gt;l;</span><br><span class="line">			<span class="keyword">int</span> index;</span><br><span class="line">			<span class="keyword">if</span>(isPush(s,e,l,index)){</span><br><span class="line">				<span class="keyword">int</span> dis=Adj[s][index].dis;</span><br><span class="line">				<span class="keyword">if</span>(dis&gt;l){</span><br><span class="line">					Adj[s][index].dis=l;</span><br><span class="line">				}</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				Adj[s].push_back(Node(e,l));</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span>(isPush(e,s,l,index)){</span><br><span class="line">				<span class="keyword">int</span> dis=Adj[e][index].dis;</span><br><span class="line">				<span class="keyword">if</span>(dis&gt;l){</span><br><span class="line">					Adj[e][index].dis=l;</span><br><span class="line">				}</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				Adj[e].push_back(Node(s,l));</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">		}</span><br><span class="line">		Dijkstra(s);</span><br><span class="line">		<span class="keyword">if</span>(dist[t]==INF) <span class="built_in">cout</span>&lt;&lt;<span class="string">"can't arrive"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span>{</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;dist[t]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			print(t);</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h3><p><strong>题目描述</strong><br>给你n个点，m条无向边，每条边都有长度d和花费p，给你起点s终点t，要求输出起点到终点的最短距离及其花费，如果最短距离有多条路线，则输出花费最少的。<br><strong>输入</strong><br>输入n,m，点的编号是1~n,然后是m行，每行4个数 a,b,d,p，表示a和b之间有一条边，且其长度为d，花费为p。最后一行是两个数 s,t;起点s，终点t。n和m为0时输入结束。(1&lt;n&lt;=1000, 0&lt;m&lt;100000, s != t)<br><strong>输出</strong><br>输出 一行有两个数， 最短距离及其花费。<br><strong>样例输入</strong><br>3 2<br>1 2 5 6<br>2 3 4 5<br>1 3<br>0 0<br><strong>样例输出</strong><br>9 11<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> dis;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">cos</span>;</span><br><span class="line">	Node(){}</span><br><span class="line">	Node(<span class="keyword">int</span> vv,<span class="keyword">int</span> dd,<span class="keyword">int</span> cc):v(vv),dis(dd),<span class="built_in">cos</span>(cc){}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;tmp) <span class="keyword">const</span>{</span><br><span class="line">		<span class="keyword">return</span> dis&gt;tmp.dis;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;Node&gt; &gt;Adj;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t;</span><br><span class="line"><span class="keyword">int</span> dist[MAXV];</span><br><span class="line"><span class="keyword">int</span> cost[MAXV];</span><br><span class="line"><span class="keyword">bool</span> bInq[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">	<span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">	<span class="built_in">memset</span>(cost,INF,<span class="keyword">sizeof</span>(cost));</span><br><span class="line">	<span class="built_in">memset</span>(bInq,<span class="literal">false</span>,<span class="keyword">sizeof</span>(bInq));</span><br><span class="line">	dist[s]=<span class="number">0</span>;</span><br><span class="line">	cost[s]=<span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;Node&gt; pq;</span><br><span class="line">	pq.push(Node(s,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty()){</span><br><span class="line">		Node top=pq.top();</span><br><span class="line">		<span class="keyword">int</span> u=top.v;</span><br><span class="line">		pq.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">			<span class="keyword">int</span> v=Adj[u][i].v;</span><br><span class="line">			<span class="keyword">int</span> dis=Adj[u][i].dis;</span><br><span class="line">			<span class="keyword">int</span> <span class="built_in">cos</span>=Adj[u][i].<span class="built_in">cos</span>;</span><br><span class="line">			<span class="keyword">if</span>(!bInq[v]){</span><br><span class="line">				<span class="keyword">if</span>(dist[u]+dis&lt;dist[v]){</span><br><span class="line">					dist[v]=dist[u]+dis;</span><br><span class="line">					cost[v]=cost[u]+<span class="built_in">cos</span>;</span><br><span class="line">					pq.push(Node(v,dist[v],cost[v]));</span><br><span class="line">				}<span class="keyword">else</span> <span class="keyword">if</span>(dist[u]+dis==dist[v]){</span><br><span class="line">					<span class="keyword">if</span>(cost[u]+<span class="built_in">cos</span>&lt;cost[v]){</span><br><span class="line">						cost[v]=cost[u]+<span class="built_in">cos</span>;</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPush</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e,<span class="keyword">int</span> d,<span class="keyword">int</span>&amp; index)</span></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[s].size();i++){</span><br><span class="line">		<span class="keyword">int</span> v=Adj[s][i].v;</span><br><span class="line">		<span class="keyword">if</span>(v==e){</span><br><span class="line">			index=i;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&amp;&amp;n!=<span class="number">0</span>&amp;&amp;m!=<span class="number">0</span>){</span><br><span class="line">		Adj.clear();</span><br><span class="line">		Adj.resize(n+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">			<span class="keyword">int</span> s,e,d,c;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;e&gt;&gt;d&gt;&gt;c;</span><br><span class="line">			<span class="keyword">int</span> index;</span><br><span class="line">			<span class="keyword">if</span>(isPush(s,e,d,index)){</span><br><span class="line">				<span class="keyword">int</span> dis=Adj[s][index].dis;</span><br><span class="line">				<span class="keyword">if</span>(dis&gt;d){</span><br><span class="line">					Adj[s][index].dis=d;</span><br><span class="line">				}</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				Adj[s].push_back(Node(e,d,c));</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span>(isPush(e,s,d,index)){</span><br><span class="line">				<span class="keyword">int</span> dis=Adj[e][index].dis;</span><br><span class="line">				<span class="keyword">if</span>(dis&gt;d){</span><br><span class="line">					Adj[e][index].dis=d;</span><br><span class="line">				}</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				Adj[e].push_back(Node(s,d,c));</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t;</span><br><span class="line">		Dijkstra(s);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;dist[t]&lt;&lt;<span class="string">" "</span>&lt;&lt;cost[t]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> dis;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">cos</span>;</span><br><span class="line">	Node(){}</span><br><span class="line">	Node(<span class="keyword">int</span> vv,<span class="keyword">int</span> dd,<span class="keyword">int</span> cc):v(vv),dis(dd),<span class="built_in">cos</span>(cc){}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">int</span> n,m,s,t;</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;Node&gt; &gt; Adj;</span><br><span class="line"><span class="keyword">int</span> dist[MAXV];</span><br><span class="line"><span class="keyword">int</span> num[MAXV];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXV];</span><br><span class="line"><span class="keyword">int</span> cost[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">	<span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(cost,INF,<span class="keyword">sizeof</span>(cost));</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	q.push(s);</span><br><span class="line">	dist[s]=<span class="number">0</span>;</span><br><span class="line">	cost[s]=<span class="number">0</span>;</span><br><span class="line">	vis[s]=<span class="literal">true</span>;</span><br><span class="line">	num[s]++;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty()){</span><br><span class="line">		<span class="keyword">int</span> u=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		vis[u]=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">			<span class="keyword">int</span> v=Adj[u][i].v;</span><br><span class="line">			<span class="keyword">int</span> dis=Adj[u][i].dis;</span><br><span class="line">			<span class="keyword">int</span> <span class="built_in">cos</span>=Adj[u][i].<span class="built_in">cos</span>;</span><br><span class="line">			<span class="keyword">if</span>(dist[u]+dis&lt;dist[v]){</span><br><span class="line">				dist[v]=dist[u]+dis;</span><br><span class="line">				cost[v]=cost[u]+<span class="built_in">cos</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span>(!vis[v]){</span><br><span class="line">					q.push(v);</span><br><span class="line">					vis[v]=<span class="literal">true</span>;</span><br><span class="line">					num[v]++;</span><br><span class="line">					<span class="keyword">if</span>(num[v]==n) <span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">			}<span class="keyword">else</span> <span class="keyword">if</span>(dist[u]+dis==dist[v]){</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span>(cost[u]+<span class="built_in">cos</span>&lt;cost[v]){</span><br><span class="line">					cost[v]=cost[u]+<span class="built_in">cos</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&amp;&amp;n!=<span class="number">0</span>){</span><br><span class="line">		Adj.clear();</span><br><span class="line">		Adj.resize(n+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">			<span class="keyword">int</span> a,b,d,p;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;d&gt;&gt;p;</span><br><span class="line">			Adj[a].push_back(Node(b,d,p));</span><br><span class="line">			Adj[b].push_back(Node(a,d,p));</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t;</span><br><span class="line">		SPFA();</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;dist[t]&lt;&lt;<span class="string">" "</span>&lt;&lt;cost[t]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1></blockquote><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><h3 id="邻接矩阵-O-V-2-1"><a href="#邻接矩阵-O-V-2-1" class="headerlink" title="邻接矩阵 $O(V^{2})$"></a>邻接矩阵 $O(V^{2})$</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,G[MAXV][MAXV];</span><br><span class="line"><span class="keyword">int</span> dist[MAXV];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Prim</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">  <span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">  <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">  dist[s]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    <span class="keyword">int</span> u=-s,MIN=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">      <span class="keyword">if</span>(!vis[j]&amp;&amp;dist[j]&lt;MIN){</span><br><span class="line">        u=j;</span><br><span class="line">        MIN=dist[j];</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    ans+=dist[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++){</span><br><span class="line">      <span class="keyword">if</span>(!vis[v]&amp;&amp;G[u][v]!=INF&amp;&amp;G[u][v]&lt;dist[v]){</span><br><span class="line">        dist[v]=G[u][v];</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="邻接表-O-V-2-E-1"><a href="#邻接表-O-V-2-E-1" class="headerlink" title="邻接表 $O(V^{2}+E)$"></a>邻接表 $O(V^{2}+E)$</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">  <span class="keyword">int</span> v;</span><br><span class="line">  <span class="keyword">int</span> dis;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXV];</span><br><span class="line"><span class="keyword">int</span> dist[MAXV];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Prim</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">  <span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">  <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">  dist[s]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">      <span class="keyword">if</span>(!vis[j]&amp;&amp;dist[j]&lt;MIN){</span><br><span class="line">        u=j;</span><br><span class="line">        MIN=dist[j];</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ans+=dist[u];</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++){</span><br><span class="line">      <span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line">      <span class="keyword">int</span> dis=Adj[u][j].dis;</span><br><span class="line">      <span class="keyword">if</span>(!vis[v]&amp;&amp;dis&lt;dist[v]){</span><br><span class="line">        dist[v]=dis;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="堆优化-O-VlogV-E-1"><a href="#堆优化-O-VlogV-E-1" class="headerlink" title="堆优化 $O(VlogV+E)$"></a>堆优化 $O(VlogV+E)$</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">  <span class="keyword">int</span> v;</span><br><span class="line">  <span class="keyword">int</span> dis;</span><br><span class="line">  Node(){}</span><br><span class="line">  Node(<span class="keyword">int</span> vv,<span class="keyword">int</span> dd):v(vv).dis(dd){}</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;tmp) <span class="keyword">const</span>{</span><br><span class="line">    <span class="keyword">return</span> dis&gt;tmp.dis;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXV];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dist[MAXV];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Prim</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">  <span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">  <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">  dist[s]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> numVertex=<span class="number">0</span>;</span><br><span class="line">  priority_queue&lt;Node&gt; pq;</span><br><span class="line">  pq.push(Node(s,<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">while</span>(!pq.empty()){</span><br><span class="line">    Node top=pq.top();</span><br><span class="line">    pq.pop();</span><br><span class="line">    <span class="keyword">int</span> u=top.v;</span><br><span class="line">    <span class="keyword">if</span>(!vis[u]){</span><br><span class="line">      ans+=top.dis;</span><br><span class="line">      numVertex++;</span><br><span class="line">      <span class="keyword">if</span>(numVertex==n) <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">      <span class="keyword">int</span> v=Adj[u][i].v;</span><br><span class="line">      <span class="keyword">int</span> dis=Adj[u][i].dis;</span><br><span class="line">      <span class="keyword">if</span>(!vis[v]&amp;&amp;dis&lt;dist[v]){</span><br><span class="line">        dist[v]=dis;</span><br><span class="line">        pq.push(Node(v,dist[v]));</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span>(numVertex!=n) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//不连通</span></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Kruskal算法-O-ElogE"><a href="#Kruskal算法-O-ElogE" class="headerlink" title="Kruskal算法 $O(ElogE)$"></a>Kruskal算法 $O(ElogE)$</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXE=<span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>{</span></span><br><span class="line">  <span class="keyword">int</span> u,v;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">cos</span>;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;tmp) <span class="keyword">const</span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cos</span>&lt;tmp.<span class="built_in">cos</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="keyword">int</span> father[MAXV];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeSet</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAXV;i++){</span><br><span class="line">    father[i]=i;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(x==father[x]){</span><br><span class="line">    father[x]=findFather(father[x]);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> father[x];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>{</span><br><span class="line">  <span class="keyword">int</span> ans=<span class="number">0</span>,numEdge=<span class="number">0</span>;</span><br><span class="line">  makeSet();</span><br><span class="line">  sort(edges.begin(),edges.end());</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">    <span class="keyword">int</span> fa=findFather(edges[i].u);</span><br><span class="line">    <span class="keyword">int</span> fb=findFather(edges[i].v);</span><br><span class="line">    <span class="keyword">if</span>(fa!=fb){</span><br><span class="line">      father[fa]=fb;</span><br><span class="line">      ans+=edges[i].<span class="built_in">cos</span>;</span><br><span class="line">      numEdge++;</span><br><span class="line">      <span class="keyword">if</span>(numEdge==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span>(numEdge!=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="还是畅通工程"><a href="#还是畅通工程" class="headerlink" title="还是畅通工程"></a>还是畅通工程</h3><p><strong>题目描述</strong><br>某省调查乡村交通状况，得到的统计表中列出了任意两村庄间的距离。省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可），并要求铺设的公路总长度为最小。请计算最小的公路总长度。<br><strong>输入</strong><br>测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( &lt; 100 )；随后的N(N-1)/2行对应村庄间的距离，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间的距离。为简单起见，村庄从1到N编号。<br>当N为0时，输入结束，该用例不被处理。<br><strong>输出</strong><br>对每个测试用例，在1行里输出最小的公路总长度。<br><strong>样例输入</strong><br>8<br>1 2 42<br>1 3 68<br>1 4 35<br>1 5 1<br>1 6 70<br>1 7 25<br>1 8 79<br>2 3 59<br>2 4 63<br>2 5 65<br>2 6 6<br>2 7 46<br>2 8 82<br>3 4 28<br>3 5 62<br>3 6 92<br>3 7 96<br>3 8 43<br>4 5 28<br>4 6 37<br>4 7 92<br>4 8 5<br>5 6 3<br>5 7 54<br>5 8 93<br>6 7 83<br>6 8 22<br>7 8 17<br>0<br><strong>样例输出</strong><br>82<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXE=<span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> dis;</span><br><span class="line">	Node(){}</span><br><span class="line">	Node(<span class="keyword">int</span> vv,<span class="keyword">int</span> dd):v(vv),dis(dd){}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;tmp) <span class="keyword">const</span>{</span><br><span class="line">		<span class="keyword">return</span> dis&gt;tmp.dis;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;Node&gt; &gt; Adj;</span><br><span class="line"><span class="keyword">int</span> dist[MAXV];</span><br><span class="line"><span class="keyword">int</span> vis[MAXV];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">	<span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	dist[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> numVertex=<span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;Node&gt; pq;</span><br><span class="line">	pq.push(Node(s,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty()){</span><br><span class="line">		Node top=pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		<span class="keyword">int</span> u=top.v;</span><br><span class="line">		<span class="keyword">if</span>(!vis[u]){</span><br><span class="line">			vis[u]=<span class="literal">true</span>;</span><br><span class="line">			ans+=top.dis;</span><br><span class="line">			numVertex++;</span><br><span class="line">			<span class="keyword">if</span>(numVertex==n) <span class="keyword">break</span>;</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">			<span class="keyword">int</span> v=Adj[u][i].v;</span><br><span class="line">			<span class="keyword">int</span> dis=Adj[u][i].dis;</span><br><span class="line">			<span class="keyword">if</span>(!vis[v]&amp;&amp;dis&lt;dist[v]){</span><br><span class="line">				dist[v]=dis;</span><br><span class="line">				pq.push(Node(v,dist[v]));</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(numVertex!=n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n!=<span class="number">0</span>){</span><br><span class="line">		Adj.clear();</span><br><span class="line">		Adj.resize(n+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n*(n<span class="number">-1</span>)/<span class="number">2</span>;i++){</span><br><span class="line">			<span class="keyword">int</span> s,e,d;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;e&gt;&gt;d;</span><br><span class="line">			Adj[s].push_back(Node(e,d));</span><br><span class="line">			Adj[e].push_back(Node(s,d));</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;Kruskal(<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>{</span></span><br><span class="line">	<span class="keyword">int</span> u,v;</span><br><span class="line">	<span class="keyword">int</span> dis;</span><br><span class="line">	Edge(){}</span><br><span class="line">	Edge(<span class="keyword">int</span> uu,<span class="keyword">int</span> vv,<span class="keyword">int</span> dd):u(uu),v(vv),dis(dd){}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;tmp) <span class="keyword">const</span>{</span><br><span class="line">		<span class="keyword">return</span> dis&lt;tmp.dis;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> father[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(x!=father[x]){</span><br><span class="line">		father[x]=findFather(father[x]);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> father[x];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n!=<span class="number">0</span>){</span><br><span class="line">		edges.clear();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) father[i]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n*(n<span class="number">-1</span>)/<span class="number">2</span>;i++){</span><br><span class="line">			<span class="keyword">int</span> s,e,d;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;e&gt;&gt;d;</span><br><span class="line">			edges.push_back(Edge(s,e,d));</span><br><span class="line">		}</span><br><span class="line">		sort(edges.begin(),edges.end());</span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> numEdge=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges.size();i++){</span><br><span class="line">			<span class="keyword">int</span> fa=findFather(edges[i].u);</span><br><span class="line">			<span class="keyword">int</span> fb=findFather(edges[i].v);</span><br><span class="line">			<span class="keyword">if</span>(fa!=fb){</span><br><span class="line">				father[fa]=fb;</span><br><span class="line">				ans+=edges[i].dis;</span><br><span class="line">				numEdge++;</span><br><span class="line">				<span class="keyword">if</span>(numEdge==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(numEdge!=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Freckles"><a href="#Freckles" class="headerlink" title="Freckles"></a>Freckles</h3><p><strong>题目描述</strong><br>In an episode of the Dick Van Dyke show, little Richie connects the freckles on his Dad’s back to form a picture of the Liberty Bell. Alas, one of the freckles turns out to be a scar, so his Ripley’s engagement falls through.<br>Consider Dick’s back to be a plane with freckles at various (x,y) locations. Your job is to tell Richie how to connect the dots so as to minimize the amount of ink used. Richie connects the dots by drawing straight lines between pairs, possibly lifting the pen between lines. When Richie is done there must be a sequence of connected lines from any freckle to any other freckle.<br><strong>输入</strong><br>The first line contains 0 &lt; n &lt;= 100, the number of freckles on Dick’s back. For each freckle, a line follows; each following line contains two real numbers indicating the (x,y) coordinates of the freckle.<br><strong>输出</strong><br>Your program prints a single real number to two decimal places: the minimum total length of ink lines that can connect all the freckles.<br><strong>样例输入</strong><br>3<br>2723.62 7940.81<br>8242.67 11395.00<br>4935.54 6761.32<br>9<br>10519.52 11593.66<br>12102.35 2453.15<br>7235.61 10010.83<br>211.13 4283.23<br>5135.06 1287.85<br>2337.48 2075.61<br>6279.72 13928.13<br>65.79 1677.86<br>5324.26 125.56<br>0<br><strong>样例输出</strong><br>8199.56<br>32713.73<br><strong>程序</strong><br>本站第二个样例结果应该是.74而非.73，因此WA<br>牛客网同样的题，Accepted！</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXE=<span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dot</span>{</span></span><br><span class="line">	<span class="keyword">double</span> x,y;</span><br><span class="line">	Dot(){}</span><br><span class="line">	Dot(<span class="keyword">double</span> xx,<span class="keyword">double</span> yy):x(xx),y(yy){}</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">double</span> dis;</span><br><span class="line">	Node(){}</span><br><span class="line">	Node(<span class="keyword">int</span> vv,<span class="keyword">double</span> dd):v(vv),dis(dd){}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;tmp) <span class="keyword">const</span>{</span><br><span class="line">		<span class="keyword">return</span> dis&gt;tmp.dis;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;Dot&gt; dots;</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;Node&gt; &gt; Adj;</span><br><span class="line"><span class="keyword">double</span> dist[MAXV];</span><br><span class="line"><span class="keyword">int</span> vis[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Prim</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAXV;i++) dist[i]=INF;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;dist[0]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	system("pause");</span></span><br><span class="line">	dist[s]=<span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;Node&gt; pq;</span><br><span class="line">	pq.push(Node(s,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">int</span> nCount=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty()){</span><br><span class="line">		Node top=pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		<span class="keyword">int</span> u=top.v;</span><br><span class="line">		<span class="keyword">if</span>(!vis[u]){</span><br><span class="line">			ans+=top.dis;</span><br><span class="line">			vis[u]=<span class="literal">true</span>;</span><br><span class="line">			nCount++;</span><br><span class="line">			<span class="keyword">if</span>(nCount==n) <span class="keyword">break</span>;</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">			<span class="keyword">int</span> v=Adj[u][i].v;</span><br><span class="line">			<span class="keyword">double</span> dis=Adj[u][i].dis;</span><br><span class="line">			<span class="keyword">if</span>(!vis[v]&amp;&amp;dis&lt;dist[v]){</span><br><span class="line">				dist[v]=dis;</span><br><span class="line">				pq.push(Node(v,dist[v]));</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(nCount!=n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calDis</span><span class="params">(Dot a, Dot b)</span></span>{</span><br><span class="line">	<span class="keyword">double</span> dis;</span><br><span class="line">	dis=<span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a.x-b.x,<span class="number">2</span>)+<span class="built_in">pow</span>(a.y-b.y,<span class="number">2</span>));</span><br><span class="line">	<span class="keyword">return</span> dis;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n!=<span class="number">0</span>){</span><br><span class="line">		Adj.clear();</span><br><span class="line">		Adj.resize(n);</span><br><span class="line">		dots.clear();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="keyword">double</span> x,y;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">			dots.push_back(Dot(x,y));</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">				<span class="keyword">if</span>(i!=j){</span><br><span class="line">					<span class="keyword">double</span> dis=calDis(dots[i],dots[j]);</span><br><span class="line"></span><br><span class="line">					Adj[i].push_back(Node(j,dis));</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>,Prim(<span class="number">0</span>));</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dot</span>{</span></span><br><span class="line">	<span class="keyword">double</span> x,y;</span><br><span class="line">	Dot(){}</span><br><span class="line">	Dot(<span class="keyword">double</span> xx,<span class="keyword">double</span> yy):x(xx),y(yy){}</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>{</span></span><br><span class="line">	<span class="keyword">int</span> u,v;</span><br><span class="line">	<span class="keyword">double</span> dis;</span><br><span class="line">	Edge(){}</span><br><span class="line">	Edge(<span class="keyword">int</span> uu,<span class="keyword">int</span> vv,<span class="keyword">double</span> dd):u(uu),v(vv),dis(dd){}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;tmp) <span class="keyword">const</span>{</span><br><span class="line">		<span class="keyword">return</span> dis&lt;tmp.dis;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Dot&gt; dots;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> father[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(x!=father[x]){</span><br><span class="line">		father[x]=findFather(father[x]);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> father[x];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calDis</span><span class="params">(Dot a, Dot b)</span></span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a.x-b.x,<span class="number">2</span>)+<span class="built_in">pow</span>(a.y-b.y,<span class="number">2</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n!=<span class="number">0</span>){</span><br><span class="line">		dots.clear();</span><br><span class="line">		dots.resize(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;dots[i].x&gt;&gt;dots[i].y;</span><br><span class="line">		}</span><br><span class="line">		edges.clear();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">				<span class="keyword">if</span>(i!=j){</span><br><span class="line">					<span class="keyword">double</span> dis=calDis(dots[i],dots[j]);</span><br><span class="line">					edges.push_back(Edge(i,j,dis));</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) father[i]=i;</span><br><span class="line">		sort(edges.begin(),edges.end());</span><br><span class="line">		<span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> numEdge=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges.size();i++){</span><br><span class="line">			<span class="keyword">int</span> fa=findFather(edges[i].u);</span><br><span class="line">			<span class="keyword">int</span> fb=findFather(edges[i].v);</span><br><span class="line">			<span class="keyword">if</span>(fa!=fb){</span><br><span class="line">				father[fa]=fb;</span><br><span class="line">				ans+=edges[i].dis;</span><br><span class="line">				numEdge++;</span><br><span class="line">				<span class="keyword">if</span>(numEdge==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(numEdge!=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>,ans);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="畅通工程-1"><a href="#畅通工程-1" class="headerlink" title="畅通工程"></a>畅通工程</h3><p><strong>题目描述</strong><br>省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可）。经过调查评估，得到的统计表中列出了有可能建设公路的若干条道路的成本。现请你编写程序，计算出全省畅通需要的最低成本。<br><strong>输入</strong><br>测试输入包含若干测试用例。每个测试用例的第1行给出评估的道路条数 N、村庄数目M (N, M &lt;=100 )；随后的 N 行对应村庄间道路的成本，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间道路的成本（也是正整数）。为简单起见，村庄从1到M编号。当N为0时，全部输入结束，相应的结果不要输出。<br><strong>输出</strong><br>对每个测试用例，在1行里输出全省畅通需要的最低成本。若统计数据不足以保证畅通，则输出“?”。<br><strong>样例输入</strong><br>3 4<br>1 2 1<br>2 3 2<br>3 4 3<br>2 4<br>1 2 1<br>3 4 2<br>0 5<br><strong>样例输出</strong><br>6<br>?<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> dis;</span><br><span class="line">	Node(){}</span><br><span class="line">	Node(<span class="keyword">int</span> vv,<span class="keyword">int</span> dd):v(vv),dis(dd){}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;tmp) <span class="keyword">const</span>{</span><br><span class="line">		<span class="keyword">return</span> dis&gt;tmp.dis;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dist[MAXV];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXV];</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;Node&gt; &gt; Adj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Prim</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">	<span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	dist[s]=<span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;Node&gt; pq;</span><br><span class="line">	pq.push(Node(s,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> nCount=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty()){</span><br><span class="line">		Node top=pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		<span class="keyword">int</span> u=top.v;</span><br><span class="line">		<span class="keyword">if</span>(!vis[u]){</span><br><span class="line">			vis[u]=<span class="literal">true</span>;</span><br><span class="line">			ans+=top.dis;</span><br><span class="line">			nCount++;</span><br><span class="line">			<span class="keyword">if</span>(nCount==m) <span class="keyword">break</span>;</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">			<span class="keyword">int</span> v=Adj[u][i].v;</span><br><span class="line">			<span class="keyword">int</span> dis=Adj[u][i].dis;</span><br><span class="line">			<span class="keyword">if</span>(!vis[v]&amp;&amp;dis&lt;dist[v]){</span><br><span class="line">				dist[v]=dis;</span><br><span class="line">				pq.push(Node(v,dist[v]));</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(nCount!=m) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&amp;&amp;n!=<span class="number">0</span>){</span><br><span class="line">		Adj.clear();</span><br><span class="line">		Adj.resize(m+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="keyword">int</span> s,e,l;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;e&gt;&gt;l;</span><br><span class="line">			Adj[s].push_back(Node(e,l));</span><br><span class="line">			Adj[e].push_back(Node(s,l));</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">int</span> dis=Prim(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(dis==<span class="number">-1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"?"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;dis&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>{</span></span><br><span class="line">	<span class="keyword">int</span> u,v;</span><br><span class="line">	<span class="keyword">int</span> dis;</span><br><span class="line">	Edge(){}</span><br><span class="line">	Edge(<span class="keyword">int</span> uu,<span class="keyword">int</span> vv,<span class="keyword">int</span> dd):u(uu),v(vv),dis(dd){}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;tmp) <span class="keyword">const</span>{</span><br><span class="line">		<span class="keyword">return</span> dis&lt;tmp.dis;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> father[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(x!=father[x]){</span><br><span class="line">		father[x]=findFather(father[x]);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> father[x];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&amp;&amp;n!=<span class="number">0</span>){</span><br><span class="line">		edges.clear();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="keyword">int</span> s,e,d;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;e&gt;&gt;d;</span><br><span class="line">			edges.push_back(Edge(s,e,d));</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) father[i]=i;</span><br><span class="line">		sort(edges.begin(),edges.end());</span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> numEdge=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges.size();i++){</span><br><span class="line">			<span class="keyword">int</span> fa=findFather(edges[i].u);</span><br><span class="line">			<span class="keyword">int</span> fb=findFather(edges[i].v);</span><br><span class="line">			<span class="keyword">if</span>(fa!=fb){</span><br><span class="line">				father[fa]=fb;</span><br><span class="line">				ans+=edges[i].dis;</span><br><span class="line">				numEdge++;</span><br><span class="line">				<span class="keyword">if</span>(numEdge==m<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(numEdge!=m<span class="number">-1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"?"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="继续畅通工程"><a href="#继续畅通工程" class="headerlink" title="继续畅通工程"></a>继续畅通工程</h3><p><strong>题目描述</strong><br>省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可）。现得到城镇道路统计表，表中列出了任意两城镇间修建道路的费用，以及该道路是否已经修通的状态。现请你编写程序，计算出全省畅通需要的最低成本。<br><strong>输入</strong><br>测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( 1 &lt; N &lt; 100 )；随后的 N(N-1)/2 行对应村庄间道路的成本及修建状态，每行给4个正整数，分别是两个村庄的编号（从1编号到N），此两村庄间道路的成本，以及修建状态：1表示已建，0表示未建。<br>当N为0时输入结束。<br><strong>输出</strong><br>每个测试用例的输出占一行，输出全省畅通需要的最低成本。<br><strong>样例输入</strong><br>4<br>1 2 1 1<br>1 3 6 0<br>1 4 2 1<br>2 3 3 0<br>2 4 5 0<br>3 4 4 0<br>3<br>1 2 1 1<br>2 3 2 1<br>1 3 1 0<br>0<br><strong>样例输出</strong><br>3<br>0<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> dis;</span><br><span class="line">	Node(){}</span><br><span class="line">	Node(<span class="keyword">int</span> vv,<span class="keyword">int</span> dd):v(vv),dis(dd){}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;tmp) <span class="keyword">const</span>{</span><br><span class="line">		<span class="keyword">return</span> dis&gt;tmp.dis;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;Node&gt; &gt; Adj;</span><br><span class="line"><span class="keyword">int</span> dist[MAXV];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n!=<span class="number">0</span>){</span><br><span class="line">		<span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">		priority_queue&lt;Node&gt; pq;</span><br><span class="line">		Adj.clear();</span><br><span class="line">		Adj.resize(n+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">bool</span> bStart=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n*(n<span class="number">-1</span>)/<span class="number">2</span>;i++){</span><br><span class="line">			<span class="keyword">int</span> s,e,d,f;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;e&gt;&gt;d&gt;&gt;f;</span><br><span class="line">			<span class="keyword">if</span>(f==<span class="number">1</span>){</span><br><span class="line">				pq.push(Node(s,<span class="number">0</span>));</span><br><span class="line">				pq.push(Node(e,<span class="number">0</span>));</span><br><span class="line">				bStart=<span class="literal">true</span>;</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				Adj[s].push_back(Node(e,d));</span><br><span class="line">				Adj[e].push_back(Node(s,d));</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(!bStart){</span><br><span class="line">			dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">			pq.push(Node(<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> nCount=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(!pq.empty()){</span><br><span class="line">			Node top=pq.top();</span><br><span class="line">			pq.pop();</span><br><span class="line">			<span class="keyword">int</span> u=top.v;</span><br><span class="line">			<span class="keyword">if</span>(!vis[u]){</span><br><span class="line">				vis[u]=<span class="literal">true</span>;</span><br><span class="line">				ans+=top.dis;</span><br><span class="line">				nCount++;</span><br><span class="line">				<span class="keyword">if</span>(nCount==n) <span class="keyword">break</span>;</span><br><span class="line">			}<span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">				<span class="keyword">int</span> v=Adj[u][i].v;</span><br><span class="line">				<span class="keyword">int</span> dis=Adj[u][i].dis;</span><br><span class="line">				<span class="keyword">if</span>(!vis[v]&amp;&amp;dis&lt;dist[v]){</span><br><span class="line">					dist[v]=dis;</span><br><span class="line">					pq.push(Node(v,dist[v]));</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(nCount!=n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>{</span></span><br><span class="line">	<span class="keyword">int</span> u,v;</span><br><span class="line">	<span class="keyword">int</span> dis;</span><br><span class="line">	Edge(){}</span><br><span class="line">	Edge(<span class="keyword">int</span> uu,<span class="keyword">int</span> vv,<span class="keyword">int</span> dd):u(uu),v(vv),dis(dd){}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;tmp) <span class="keyword">const</span>{</span><br><span class="line">		<span class="keyword">return</span> dis&lt;tmp.dis;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> father[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(x!=father[x]){</span><br><span class="line">		father[x]=findFather(father[x]);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> father[x];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n!=<span class="number">0</span>){</span><br><span class="line">		edges.clear();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) father[i]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n*(n<span class="number">-1</span>)/<span class="number">2</span>;i++){</span><br><span class="line">			<span class="keyword">int</span> s,e,d,k;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;e&gt;&gt;d&gt;&gt;k;</span><br><span class="line">			<span class="keyword">if</span>(k==<span class="number">1</span>){</span><br><span class="line">				<span class="keyword">int</span> fa=findFather(s);</span><br><span class="line">				<span class="keyword">int</span> fb=findFather(e);</span><br><span class="line">				<span class="keyword">if</span>(fa!=fb){</span><br><span class="line">					father[fa]=fb;</span><br><span class="line">				}</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				edges.push_back(Edge(s,e,d));</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		sort(edges.begin(),edges.end());</span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges.size();i++){</span><br><span class="line">			<span class="keyword">int</span> fa=findFather(edges[i].u);</span><br><span class="line">			<span class="keyword">int</span> fb=findFather(edges[i].v);</span><br><span class="line">			<span class="keyword">if</span>(fa!=fb){</span><br><span class="line">				father[fa]=fb;</span><br><span class="line">				ans+=edges[i].dis;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Jungle-Roads"><a href="#Jungle-Roads" class="headerlink" title="Jungle Roads"></a>Jungle Roads</h3><p><strong>题目描述</strong><br><img src="/assets/img/algorithm/Jungle_Roads_01.jpg" alt="图示"><br>The Head Elder of the tropical island of Lagrishan has a problem. A burst of foreign aid money was spent on extra roads between villages some years ago. But the jungle overtakes roads relentlessly, so the large road network is too expensive to maintain. The Council of Elders must choose to stop maintaining some roads. The map above on the left shows all the roads in use now and the cost in aacms per month to maintain them. Of course there needs to be some way to get between all the villages on maintained roads, even if the route is not as short as before. The Chief Elder would like to tell the Council of Elders what would be the smallest amount they could spend in aacms per month to maintain roads that would connect all the villages. The villages are labeled A through I in the maps above. The map on the right shows the roads that could be maintained most cheaply, for 216 aacms per month. Your task is to write a program that will solve such problems.<br><strong>输入</strong><br>The input consists of one to 100 data sets, followed by a final line containing only 0. Each data set starts with a line containing only a number n, which is the number of villages, 1 &lt; n &lt; 27, and the villages are labeled with the first n letters of the alphabet, capitalized. Each data set is completed with n-1 lines that start with village labels in alphabetical order. There is no line for the last village. Each line for a village starts with the village label followed by a number, k, of roads from this village to villages with labels later in the alphabet. If k is greater than 0, the line continues with data for each of the k roads. The data for each road is the village label for the other end of the road followed by the monthly maintenance cost in aacms for the road. Maintenance costs will be positive integers less than 100. All data fields in the row are separated by single blanks. The road network will always allow travel between all the villages. The network will never have more than 75 roads. No village will have more than 15 roads going to other villages (before or after in the alphabet). In the sample input below, the first data set goes with the map above.<br><strong>输出</strong><br>The output is one integer per line for each data set: the minimum cost in aacms per month to maintain a road system that connect all the villages. Caution: A brute force solution that examines every possible set of roads will not finish within the one minute time limit.<br><strong>样例输入</strong><br>3<br>A 1 B 42<br>B 1 C 87<br>6<br>A 2 B 13 E 55<br>B 1 C 1<br>C 1 D 20<br>D 1 E 4<br>E 1 F 76<br>0<br><strong>样例输出</strong><br>129<br>114<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> dis;</span><br><span class="line">	Node(){}</span><br><span class="line">	Node(<span class="keyword">int</span> vv,<span class="keyword">int</span> dd):v(vv),dis(dd){}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;tmp)<span class="keyword">const</span>{</span><br><span class="line">		<span class="keyword">return</span> dis&gt;tmp.dis;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;Node&gt; &gt; Adj;</span><br><span class="line"><span class="keyword">int</span> dist[MAXV];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXV];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Prim</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">	<span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	dist[s]=<span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;Node&gt; pq;</span><br><span class="line">	pq.push(Node(s,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> nCount=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty()){</span><br><span class="line">		Node top=pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		<span class="keyword">int</span> u=top.v;</span><br><span class="line">		<span class="keyword">if</span>(!vis[u]){</span><br><span class="line">			vis[u]=<span class="literal">true</span>;</span><br><span class="line">			nCount++;</span><br><span class="line">			ans+=top.dis;</span><br><span class="line">			<span class="keyword">if</span>(nCount==n) <span class="keyword">break</span>;</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">			<span class="keyword">int</span> v=Adj[u][i].v;</span><br><span class="line">			<span class="keyword">int</span> dis=Adj[u][i].dis;</span><br><span class="line">			<span class="keyword">if</span>(!vis[v]&amp;&amp;dis&lt;dist[v]){</span><br><span class="line">				dist[v]=dis;</span><br><span class="line">				pq.push(Node(v,dist[v]));</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(nCount!=n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n!=<span class="number">0</span>){</span><br><span class="line">		Adj.clear();</span><br><span class="line">		Adj.resize(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++){</span><br><span class="line">			<span class="keyword">char</span> s,e;</span><br><span class="line">			<span class="keyword">int</span> k,d;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;k;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++){</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;e&gt;&gt;d;</span><br><span class="line">				Adj[s-<span class="string">'A'</span>].push_back(Node(e-<span class="string">'A'</span>,d));</span><br><span class="line">				Adj[e-<span class="string">'A'</span>].push_back(Node(s-<span class="string">'A'</span>,d));</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;Prim(<span class="number">0</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>{</span></span><br><span class="line">	<span class="keyword">int</span> u,v;</span><br><span class="line">	<span class="keyword">int</span> dis;</span><br><span class="line">	Edge(){}</span><br><span class="line">	Edge(<span class="keyword">int</span> uu,<span class="keyword">int</span> vv,<span class="keyword">int</span> dd):u(uu),v(vv),dis(dd){}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;tmp) <span class="keyword">const</span>{</span><br><span class="line">		<span class="keyword">return</span> dis&lt;tmp.dis;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> father[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(x!=father[x]){</span><br><span class="line">		father[x]=findFather(father[x]);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> father[x];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n!=<span class="number">0</span>){</span><br><span class="line">		edges.clear();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) father[i]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++){</span><br><span class="line">			<span class="keyword">char</span> s,e;</span><br><span class="line">			<span class="keyword">int</span> k,d;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;k;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++){</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;e&gt;&gt;d;</span><br><span class="line">				edges.push_back(Edge(s-<span class="string">'A'</span>,e-<span class="string">'A'</span>,d));</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		sort(edges.begin(),edges.end());</span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges.size();i++){</span><br><span class="line">			<span class="keyword">int</span> fa=findFather(edges[i].u);</span><br><span class="line">			<span class="keyword">int</span> fb=findFather(edges[i].v);</span><br><span class="line">			<span class="keyword">if</span>(fa!=fb){</span><br><span class="line">				father[fa]=fb;</span><br><span class="line">				ans+=edges[i].dis;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1></blockquote><p>如果一个有向图的任意顶点都无法通过一些有向边回到自身，那么称这个有向图为有向无环图（Directed Acyclic Grah, DAG）</p><ul><li>算法思路：</li><li>①定义一个队列Q，并把所有入度为0的节点加入队列</li><li>②取队首节点，输出。然后删除所有从它出发的边，并令这些边到达的顶点入度减1，如果某个顶点的入度减为0，则将其加入队列。</li><li>③反复进行②操作，直到队列为空。如果队列为空时入过队的节点数目恰好为N，说明拓扑排序成功，图G为有向无环图；否则，拓扑排序失败，图G中有环。<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Adj[MAXV];</span><br><span class="line"><span class="keyword">int</span> n,m,inDegree[MAXV];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topologicalSort</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    <span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>){</span><br><span class="line">      p.push(i);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">    <span class="keyword">int</span> u=q.front();</span><br><span class="line">    <span class="comment">//cout&lt;&lt;u;</span></span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">      <span class="keyword">int</span> v=Adj[u][i];</span><br><span class="line">      inDegree[v]--;</span><br><span class="line">      <span class="keyword">if</span>(inDegree[v]==<span class="number">0</span>){</span><br><span class="line">        q.push(v);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//Adj[u].clear();</span></span><br><span class="line">    num++;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span>(num!=n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="算法7-12：有向无环图的拓扑排序"><a href="#算法7-12：有向无环图的拓扑排序" class="headerlink" title="算法7-12：有向无环图的拓扑排序"></a>算法7-12：有向无环图的拓扑排序</h2></li></ul><p><strong>题目描述</strong><br>由某个集合上的一个偏序得到该集合上的一个全序，这个操作被称为拓扑排序。偏序和全序的定义分别如下：<br>若集合X上的关系R是自反的、反对称的和传递的，则称R是集合X上的偏序关系。<br>设R是集合X上的偏序，如果对每个x,y∈X必有xRy或yRx，则称R是集合X上的全序关系。<br>由偏序定义得到拓扑有序的操作便是拓扑排序。<br>拓扑排序的流程如下：<br>1.在有向图中选一个没有前驱的顶点并且输出之；<br>2.从图中删除该顶点和所有以它为尾的弧。<br>重复上述两步，直至全部顶点均已输出，或者当前图中不存在无前驱的顶点为止。后一种情况则说明有向图中存在环。<br>在本题中，读入一个有向图的邻接矩阵（即数组表示），建立有向图并按照以上描述中的算法判断此图是否有回路，如果没有回路则输出拓扑有序的顶点序列。<br><strong>输入</strong><br>输入的第一行包含一个正整数n，表示图中共有n个顶点。其中n不超过50。<br>以后的n行中每行有n个用空格隔开的整数0或1，对于第i行的第j个整数，如果为1，则表示第i个顶点有指向第j个顶点的有向边，0表示没有i指向j的有向边。当i和j相等的时候，保证对应的整数为0。<br><strong>输出</strong><br>如果读入的有向图含有回路，请输出“ERROR”，不包括引号。<br>如果读入的有向图不含有回路，请按照题目描述中的算法依次输出图的拓扑有序序列，每个整数后输出一个空格。<br>请注意行尾输出换行。<br><strong>样例输入</strong><br>4<br>0 1 0 0<br>0 0 1 0<br>0 0 0 0<br>0 0 1 0<br><strong>样例输出</strong><br>3 0 1 2<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Adj;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="keyword">int</span> inDegree[MAXV];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topologicalSort</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">		<span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>){</span><br><span class="line">			s.push(i);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!s.empty()){</span><br><span class="line">		<span class="keyword">int</span> u=s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">		result.push_back(u);</span><br><span class="line">		num++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">			<span class="keyword">int</span> v=Adj[u][i];</span><br><span class="line">			inDegree[v]--;</span><br><span class="line">			<span class="keyword">if</span>(inDegree[v]==<span class="number">0</span>) s.push(v);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(num!=n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		Adj.clear();</span><br><span class="line">		Adj.resize(n);</span><br><span class="line">		<span class="built_in">memset</span>(inDegree,<span class="number">0</span>,<span class="keyword">sizeof</span>(inDegree));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">				<span class="keyword">int</span> tmp;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">				<span class="keyword">if</span>(tmp!=<span class="number">0</span>){</span><br><span class="line">					Adj[i].push_back(j);</span><br><span class="line">					inDegree[j]++;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(topologicalSort()){</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;result.size();i++){</span><br><span class="line">				<span class="keyword">if</span>(i!=<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;result[i];</span><br><span class="line">			}</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"ERROR"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="确定比赛名次"><a href="#确定比赛名次" class="headerlink" title="确定比赛名次"></a>确定比赛名次</h2><p><strong>题目描述</strong><br>有N个比赛队（1&lt;=N&lt;=500），编号依次为1，2，3，。。。。，N进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即P1赢P2，用P1，P2表示，排名时P1在P2之前。现在请你编程序确定排名。<br><strong>输入</strong><br>输入有若干组，每组中的第一行为二个数N（1&lt;=N&lt;=500），M；其中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1，P2表示即P1队赢了P2队。<br><strong>输出</strong><br>给出一个符合要求的排名。输出时队伍号之间有空格，最后一名后面没有空格。<br>其他说明：符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。<br><strong>样例输入</strong><br>3 2<br>3 1<br>3 2<br>17 16<br>16 1<br>13 2<br>7 3<br>12 4<br>12 5<br>17 6<br>10 7<br>11 8<br>11 9<br>16 10<br>13 11<br>15 12<br>15 13<br>17 14<br>17 15<br>17 16<br>0 0<br><strong>样例输出</strong><br>3 1 2<br>17 6 14 15 12 4 5 13 2 11 8 9 16 1 10 7 3<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">501</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Adj;</span><br><span class="line"><span class="keyword">int</span> inDegree[MAXV];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyCmp</span>{</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a,<span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span> <span class="keyword">const</span></span>{</span><br><span class="line">		<span class="keyword">return</span> a&gt;b;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topologicalSort</span><span class="params">()</span></span>{</span><br><span class="line">	priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,MyCmp&gt; pq;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">		<span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>){</span><br><span class="line">			pq.push(i);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">bool</span> bFirst=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty()){</span><br><span class="line">		<span class="keyword">int</span> u=pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		<span class="keyword">if</span>(!bFirst) <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		<span class="keyword">else</span> bFirst=<span class="literal">false</span>;</span><br><span class="line">		num++;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;u;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">			<span class="keyword">int</span> v=Adj[u][i];</span><br><span class="line">			inDegree[v]--;</span><br><span class="line">			<span class="keyword">if</span>(inDegree[v]==<span class="number">0</span>){</span><br><span class="line">				pq.push(v);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(num==n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&amp;&amp;n!=<span class="number">0</span>){</span><br><span class="line">		Adj.clear();</span><br><span class="line">		Adj.resize(n+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">memset</span>(inDegree,<span class="number">0</span>,<span class="keyword">sizeof</span>(inDegree));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">			<span class="keyword">int</span> s,e;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;e;</span><br><span class="line">			Adj[s].push_back(e);</span><br><span class="line">			inDegree[e]++;</span><br><span class="line">		}</span><br><span class="line">		topologicalSort();</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Legal-or-Not"><a href="#Legal-or-Not" class="headerlink" title="Legal or Not"></a>Legal or Not</h2><p><strong>题目描述</strong><br>ACM-DIY is a large QQ group where many excellent acmers get together. It is so harmonious that just like a big family. Every day,many “holy cows” like HH, hh, AC, ZT, lcc, BF, Qinz and so on chat on-line to exchange their ideas. When someone has questions, many warm-hearted cows like Lost will come to help. Then the one being helped will call Lost “master”, and Lost will have a nice “prentice”. By and by, there are many pairs of “master and prentice”. But then problem occurs: there are too many masters and too many prentices, how can we know whether it is legal or not?We all know a master can have many prentices and a prentice may have a lot of masters too, it’s legal. Nevertheless，some cows are not so honest, they hold illegal relationship. Take HH and 3xian for instant, HH is 3xian’s master and, at the same time, 3xian is HH’s master,which is quite illegal! To avoid this,please help us to judge whether their relationship is legal or not. Please note that the “master and prentice” relation is transitive. It means that if A is B’s master ans B is C’s master, then A is C’s master.<br><strong>输入</strong><br>The input consists of several test cases. For each case, the first line contains two integers, N (members to be tested) and M (relationships to be tested)(2 &lt;= N, M &lt;= 100). Then M lines follow, each contains a pair of (x, y) which means x is y’s master and y is x’s prentice. The input is terminated by N = 0.TO MAKE IT SIMPLE, we give every one a number (0, 1, 2,…, N-1). We use their numbers instead of their names.<br><strong>输出</strong><br>For each test case, print in one line the judgement of the messy relationship.If it is legal, output “YES”, otherwise “NO”.<br><strong>样例输入</strong><br>4 3<br>0 1<br>1 2<br>2 3<br>3 3<br>0 1<br>1 2<br>2 0<br>0 1<br><strong>样例输出</strong><br>YES<br>NO<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">101</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Adj;</span><br><span class="line"><span class="keyword">int</span> inDegree[MAXV];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topologicalSort</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">		<span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>) q.push(i);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty()){</span><br><span class="line">		<span class="keyword">int</span> u=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		num++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">			<span class="keyword">int</span> v=Adj[u][i];</span><br><span class="line">			inDegree[v]--;</span><br><span class="line">			<span class="keyword">if</span>(inDegree[v]==<span class="number">0</span>) q.push(v);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(num!=n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&amp;&amp;n!=<span class="number">0</span>){</span><br><span class="line">		Adj.clear();</span><br><span class="line">		Adj.resize(n);</span><br><span class="line">		<span class="built_in">memset</span>(inDegree,<span class="number">0</span>,<span class="keyword">sizeof</span>(inDegree));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">			<span class="keyword">int</span> s,e;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;e;</span><br><span class="line">			Adj[s].push_back(e);</span><br><span class="line">			inDegree[e]++;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(topologicalSort()) <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="剑指-Offer-II-114-外星文字典"><a href="#剑指-Offer-II-114-外星文字典" class="headerlink" title="剑指 Offer II 114. 外星文字典"></a>剑指 Offer II 114. 外星文字典</h2><p><strong>Description</strong><br>现有一种使用英语字母的外星文语言，这门语言的字母顺序与英语顺序不同。</p><p>给定一个字符串列表 words ，作为这门语言的词典，words 中的字符串已经 按这门新语言的字母顺序进行了排序 。</p><p>请你根据该词典还原出此语言中已知的字母顺序，并 按字母递增顺序 排列。若不存在合法字母顺序，返回 “” 。若存在多种可能的合法字母顺序，返回其中 任意一种 顺序即可。</p><p>字符串 s 字典顺序小于 字符串 t 有两种情况：</p><p>在第一个不同字母处，如果 s 中的字母在这门外星语言的字母顺序中位于 t 中字母之前，那么 s 的字典顺序小于 t 。<br>如果前面 min(s.length, t.length) 字母都相同，那么 s.length &lt; t.length 时，s 的字典顺序也小于 t 。</p><p><strong>Example</strong><br>示例 1：<br>输入：words = [“wrt”,”wrf”,”er”,”ett”,”rftt”]<br>输出：”wertf”</p><p>示例 2：<br>输入：words = [“z”,”x”]<br>输出：”zx”</p><p>示例 3：<br>输入：words = [“z”,”x”,”z”]<br>输出：””<br>解释：不存在合法字母顺序，因此返回 “” 。</p><p>提示：<br>1 &lt;= words.length &lt;= 100<br>1 &lt;= words[i].length &lt;= 100<br>words[i] 仅由小写英文字母组成</p><p><strong>Program</strong></p><p><strong>拓扑排序</strong><br>关键是构图，理解错了，还以为只是每个word排了序，原来是words排序。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; Adj;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inDegree;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; cToi;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; iToc;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">statisticChars</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> str:words){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> ch:str){</span><br><span class="line">                <span class="keyword">if</span>(cToi.find(ch) == cToi.end()){</span><br><span class="line">                    cToi[ch] = cnt;</span><br><span class="line">                    iToc[cnt ++] = ch;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">alienOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>{</span><br><span class="line">        <span class="comment">// 统计出现的字符数并进行编码</span></span><br><span class="line">        statisticChars(words);</span><br><span class="line">        </span><br><span class="line">        Adj.resize(cnt);</span><br><span class="line">        inDegree.resize(cnt, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构造邻接表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; words.size(); i ++){</span><br><span class="line">            <span class="keyword">int</span> n = min(words[i - <span class="number">1</span>].length(), words[i].length());</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; n){</span><br><span class="line">                <span class="keyword">char</span> ch1 = words[i - <span class="number">1</span>][j], ch2 = words[i][j];</span><br><span class="line">                <span class="keyword">if</span>(ch1 != ch2){</span><br><span class="line">                    Adj[cToi[ch1]].push_back(cToi[ch2]);</span><br><span class="line">                    inDegree[cToi[ch2]] ++;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">//后面无法判断</span></span><br><span class="line">                }</span><br><span class="line">                j ++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(j == n &amp;&amp; words[i - <span class="number">1</span>].length() &gt; words[i].length()) <span class="keyword">return</span> {}; <span class="comment">//["abc", "ab"] 这种样例真恶心</span></span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 拓扑排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; cnt; u ++){</span><br><span class="line">            <span class="keyword">if</span>(inDegree[u] == <span class="number">0</span>) q.push(u);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">            res += iToc[u];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v:Adj[u]){</span><br><span class="line">                inDegree[v] --;</span><br><span class="line">                <span class="keyword">if</span>(inDegree[v] == <span class="number">0</span>) q.push(v);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res.length() == cnt ? res : <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="剑指-Offer-II-115-重建序列"><a href="#剑指-Offer-II-115-重建序列" class="headerlink" title="剑指 Offer II 115. 重建序列"></a>剑指 Offer II 115. 重建序列</h2><p><strong>Description</strong><br>请判断原始的序列 org 是否可以从序列集 seqs 中唯一地 重建 。</p><p>序列 org 是 1 到 n 整数的排列，其中 1 ≤ n ≤ 104。重建 是指在序列集 seqs 中构建最短的公共超序列，即 seqs 中的任意序列都是该最短序列的子序列。</p><p><strong>Example</strong><br>示例 1：<br>输入: org = [1,2,3], seqs = [[1,2],[1,3]]<br>输出: false<br>解释：[1,2,3] 不是可以被重建的唯一的序列，因为 [1,3,2] 也是一个合法的序列。</p><p>示例 2：<br>输入: org = [1,2,3], seqs = [[1,2]]<br>输出: false<br>解释：可以重建的序列只有 [1,2]。</p><p>示例 3：<br>输入: org = [1,2,3], seqs = [[1,2],[1,3],[2,3]]<br>输出: true<br>解释：序列 [1,2], [1,3] 和 [2,3] 可以被唯一地重建为原始的序列 [1,2,3]。</p><p>示例 4：<br>输入: org = [4,1,5,2,6,3], seqs = [[5,2,6,3],[4,1,5,2]]<br>输出: true</p><p>提示：<br>1 &lt;= n &lt;= 104<br>org 是数字 1 到 n 的一个排列<br>1 &lt;= segs[i].length &lt;= 105<br>seqs[i][j] 是 32 位有符号整数</p><p><strong>Program</strong></p><p><strong>拓扑排序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; Adj;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inDegree;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">sequenceReconstruction</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; org, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; seqs)</span> </span>{</span><br><span class="line">        n = org.size();</span><br><span class="line">        <span class="comment">// 判断seqs内的元素是否是[1, n]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec:seqs){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x:vec){</span><br><span class="line">                st.insert(x);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(st.begin(), st.end());</span><br><span class="line">        <span class="comment">// 判断是否非法</span></span><br><span class="line">        <span class="keyword">if</span>(vec.size() != n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++){</span><br><span class="line">            <span class="keyword">if</span>(vec[i - <span class="number">1</span>] != i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拓扑排序</span></span><br><span class="line">        <span class="comment">// 构建邻接表</span></span><br><span class="line">        Adj.resize(n + <span class="number">1</span>);</span><br><span class="line">        inDegree.resize(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec:seqs){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vec.size(); i ++){</span><br><span class="line">                <span class="keyword">int</span> u = vec[i - <span class="number">1</span>], v = vec[i];</span><br><span class="line">                Adj[u].push_back(v);</span><br><span class="line">                inDegree[v] ++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; u ++){</span><br><span class="line">            <span class="keyword">if</span>(inDegree[u] == <span class="number">0</span>) q.push(u);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty() &amp;&amp; q.size() == <span class="number">1</span>){</span><br><span class="line">            <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">            res.push_back(u);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v:Adj[u]){</span><br><span class="line">                inDegree[v] --;</span><br><span class="line">                <span class="keyword">if</span>(inDegree[v] == <span class="number">0</span>) q.push(v);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res.size() == n &amp;&amp; res == org;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="1632-矩阵转换后的秩"><a href="#1632-矩阵转换后的秩" class="headerlink" title="1632. 矩阵转换后的秩"></a>1632. 矩阵转换后的秩</h2><p><strong>Description</strong><br>给你一个 m x n 的矩阵 matrix ，请你返回一个新的矩阵 answer ，其中 answer[row][col] 是 matrix[row][col] 的秩。</p><p>每个元素的 秩 是一个整数，表示这个元素相对于其他元素的大小关系，它按照如下规则计算：</p><p>秩是从 1 开始的一个整数。<br>如果两个元素 p 和 q 在 同一行 或者 同一列 ，那么：</p><ul><li>如果 p &lt; q ，那么 rank(p) &lt; rank(q)</li><li>如果 p == q ，那么 rank(p) == rank(q)</li><li>如果 p &gt; q ，那么 rank(p) &gt; rank(q)</li><li>秩 需要越 小 越好。</li></ul><p>题目保证按照上面规则 answer 数组是唯一的。</p><p><strong>Example</strong><br>示例 1：<br>输入：matrix = [[1,2],[3,4]]<br>输出：[[1,2],[2,3]]<br>解释：<br>matrix[0][0] 的秩为 1 ，因为它是所在行和列的最小整数。<br>matrix[0][1] 的秩为 2 ，因为 matrix[0][1] &gt; matrix[0][0] 且 matrix[0][0] 的秩为 1 。<br>matrix[1][0] 的秩为 2 ，因为 matrix[1][0] &gt; matrix[0][0] 且 matrix[0][0] 的秩为 1 。<br>matrix[1][1] 的秩为 3 ，因为 matrix[1][1] &gt; matrix[0][1]， matrix[1][1] &gt; matrix[1][0] 且 matrix[0][1] 和 matrix[1][0] 的秩都为 2 。</p><p>示例 2：<br>输入：matrix = [[7,7],[7,7]]<br>输出：[[1,1],[1,1]]</p><p>示例 3：<br>输入：matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]<br>输出：[[4,2,3],[1,3,4],[5,1,6],[1,3,4]]</p><p>示例 4：<br>输入：matrix = [[7,3,6],[1,4,5],[9,8,2]]<br>输出：[[5,1,4],[1,2,3],[6,3,1]]</p><p>提示：<br>m == matrix.length<br>n == matrix[i].length<br>1 &lt;= m, n &lt;= 500<br>$-10^9 &lt;= matrix[row][col] &lt;= 10^9$</p><p><strong>Program</strong><br><strong>优先队列 + 标记数组（错误思路）</strong><br>详见代码，不啰嗦；<br>错误原因，虽然优先队列保证值小的先出队列，但是不能保证同行同列中同值的秩相同！</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> r, c;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        Node(<span class="keyword">int</span> _r, <span class="keyword">int</span> _c, <span class="keyword">int</span> _val):r(_r), c(_c), val(_val){}</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; other) <span class="keyword">const</span>{</span><br><span class="line">            <span class="keyword">return</span> val &gt; other.val;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; rowMarked, colMarked;</span><br><span class="line">    priority_queue&lt;Node&gt; pq;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrixRankTransform(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) {</span><br><span class="line">        m = matrix.size(), n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        rowMarked.resize(m, {INT_MIN, <span class="number">0</span>});</span><br><span class="line">        colMarked.resize(n, {INT_MIN, <span class="number">0</span>});</span><br><span class="line">        res.resize(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++){</span><br><span class="line">                pq.push({i, j, matrix[i][j]});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty()){</span><br><span class="line">            Node cur = pq.top(); pq.pop();</span><br><span class="line">            <span class="keyword">int</span> r = cur.r, c = cur.c, val = cur.val;</span><br><span class="line">            <span class="keyword">int</span> valRow = val == rowMarked[r].first ? rowMarked[r].second : rowMarked[r].second + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> valCol = val == colMarked[c].first ? colMarked[c].second : colMarked[c].second + <span class="number">1</span>;</span><br><span class="line">            res[r][c] = max(valRow, valCol);</span><br><span class="line">            rowMarked[r].first = colMarked[c].first = val;</span><br><span class="line">            rowMarked[r].second = colMarked[c].second = res[r][c];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>并查集+拓扑排序</strong><br>详见高赞题解；<br>（1）先将同行同列相同元素合并；<br>（2）然后对每行每列的元素进行排序建边构图；<br>（3）最后拓扑排序计算秩；</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionSet</span>{</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionSet(<span class="keyword">int</span> n){</span><br><span class="line">        father.resize(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) father[i] = i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(x != father[x]) father[x] = findFather(father[x]);</span><br><span class="line">        <span class="keyword">return</span> father[x];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> fa = findFather(x);</span><br><span class="line">        <span class="keyword">int</span> fb = findFather(y);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(fa != fb){</span><br><span class="line">            father[fa] = fb;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrixRankTransform(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) {</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="function">UnionSet <span class="title">ust</span><span class="params">(m * n)</span></span>; <span class="comment">// 并查集</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将每行相同元素合并</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++){</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ump;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++){</span><br><span class="line">                ump[matrix[i][j]].push_back(j);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [val, vec]:ump){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k + <span class="number">1</span> &lt; vec.size(); k ++){ <span class="comment">// 只需要相邻元素合并即可</span></span><br><span class="line">                    ust.merge(i * n + vec[k], i * n + vec[k + <span class="number">1</span>]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将每列相同元素合并</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++){</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ump;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++){</span><br><span class="line">                ump[matrix[i][j]].push_back(i);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [val, vec]:ump){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k + <span class="number">1</span> &lt; vec.size(); k ++){</span><br><span class="line">                    ust.merge(vec[k] * n + j, vec[k + <span class="number">1</span>] * n + j);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构图</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; Adj(m * n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inDegree(m * n, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每行进行排序和连边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++){</span><br><span class="line">            <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; vec; <span class="comment">// 按照val排序，然后根据坐标连边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++){</span><br><span class="line">                vec.push_back({matrix[i][j], j});</span><br><span class="line">            }</span><br><span class="line">            sort(vec.begin(), vec.end());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k + <span class="number">1</span> &lt; vec.size(); k ++){</span><br><span class="line">                <span class="keyword">if</span>(vec[k].first != vec[k + <span class="number">1</span>].first){</span><br><span class="line">                    <span class="keyword">int</span> u = ust.findFather(i * n + vec[k].second);</span><br><span class="line">                    <span class="keyword">int</span> v = ust.findFather(i * n + vec[k + <span class="number">1</span>].second);</span><br><span class="line">                    Adj[u].push_back(v);</span><br><span class="line">                    inDegree[v] ++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每列进行排序和连边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++){</span><br><span class="line">            <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++){</span><br><span class="line">                vec.push_back({matrix[i][j], i});</span><br><span class="line">            }</span><br><span class="line">            sort(vec.begin(), vec.end());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k + <span class="number">1</span> &lt; vec.size(); k ++){</span><br><span class="line">                <span class="keyword">if</span>(vec[k].first != vec[k + <span class="number">1</span>].first){</span><br><span class="line">                    <span class="keyword">int</span> u = ust.findFather(vec[k].second * n + j);</span><br><span class="line">                    <span class="keyword">int</span> v = ust.findFather(vec[k + <span class="number">1</span>].second * n + j);</span><br><span class="line">                    Adj[u].push_back(v);</span><br><span class="line">                    inDegree[v] ++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拓扑排序</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(m * n, <span class="number">1</span>); <span class="comment">// 记录每个集合根位置的秩</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; m * n; u ++){</span><br><span class="line">            <span class="keyword">if</span>(u == ust.findFather(u) &amp;&amp; inDegree[u] == <span class="number">0</span>) q.push(u);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v:Adj[u]){</span><br><span class="line">                inDegree[v] --;</span><br><span class="line">                ans[v] = max(ans[v], ans[u] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(inDegree[v] == <span class="number">0</span>){</span><br><span class="line">                    q.push(v);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据集合根元素的秩还原矩阵元素的秩</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++){</span><br><span class="line">                <span class="keyword">int</span> u = i * n + j;</span><br><span class="line">                res[i][j] = ans[ust.findFather(u)];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="1591-奇怪的打印机-II"><a href="#1591-奇怪的打印机-II" class="headerlink" title="1591. 奇怪的打印机 II"></a>1591. 奇怪的打印机 II</h2><p><strong>Description</strong><br>给你一个奇怪的打印机，它有如下两个特殊的打印规则：</p><p>每一次操作时，打印机会用同一种颜色打印一个矩形的形状，每次打印会覆盖矩形对应格子里原本的颜色。<br>一旦矩形根据上面的规则使用了一种颜色，那么 相同的颜色不能再被使用 。<br>给你一个初始没有颜色的 m x n 的矩形 targetGrid ，其中 targetGrid[row][col] 是位置 (row, col) 的颜色。</p><p>如果你能按照上述规则打印出矩形 targetGrid ，请你返回 true ，否则返回 false 。</p><p><strong>Example</strong><br>示例 1：<br>输入：targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]<br>输出：true</p><p>示例 2：<br>输入：targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]]<br>输出：true</p><p>示例 3：<br>输入：targetGrid = [[1,2,1],[2,1,2],[1,2,1]]<br>输出：false<br>解释：没有办法得到 targetGrid ，因为每一轮操作使用的颜色互不相同。</p><p>示例 4：<br>输入：targetGrid = [[1,1,1],[3,1,3]]<br>输出：false</p><p>提示：<br>m == targetGrid.length<br>n == targetGrid[i].length<br>1 &lt;= m, n &lt;= 60<br>1 &lt;= targetGrid[row][col] &lt;= 60</p><p><strong>Program</strong><br><strong>拓扑排序</strong><br>详见高赞题解。<br>思路如下：<br>首先，题目需要确认一个涂色顺序，使得最终结果为给定矩阵；<br>其次，如果一种颜色v的格子落在另一种颜色u的矩形内，那么说明u先于v涂色，u -&gt; v有边相连；<br>最后，判断是否能够形成拓扑排序。<br>具体步骤：<br>（1）遍历每个格子的颜色，判断每种颜色的上下左右矩形边界；<br>（2）根据每个格子是否在其他颜色矩形内构图；<br>（3）拓扑排序判断是否无环。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Adj[<span class="number">61</span>]; <span class="comment">//邻接表</span></span><br><span class="line">    <span class="keyword">int</span> margin[<span class="number">4</span>][<span class="number">61</span>]; <span class="comment">//0, 1, 2, 3,分别对应矩形上下左右边</span></span><br><span class="line">    <span class="keyword">bool</span> isConnect[<span class="number">61</span>][<span class="number">61</span>]; <span class="comment">//是否已经连边</span></span><br><span class="line">    <span class="keyword">int</span> inDegree[<span class="number">61</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPrintable</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; targetGrid)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m = targetGrid.size(), n = targetGrid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">memset</span>(margin, <span class="number">-1</span>, <span class="keyword">sizeof</span>(margin));</span><br><span class="line">        <span class="built_in">memset</span>(isConnect, <span class="literal">false</span>, <span class="keyword">sizeof</span>(isConnect));</span><br><span class="line">        <span class="built_in">memset</span>(inDegree, <span class="number">0</span>, <span class="keyword">sizeof</span>(inDegree));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算每个颜色矩形的上下左右边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++){</span><br><span class="line">                <span class="keyword">int</span> curColor = targetGrid[i][j];</span><br><span class="line">                margin[<span class="number">0</span>][curColor] = margin[<span class="number">0</span>][curColor] == <span class="number">-1</span> ? i : min(margin[<span class="number">0</span>][curColor], i);</span><br><span class="line">                margin[<span class="number">1</span>][curColor] = margin[<span class="number">1</span>][curColor] == <span class="number">-1</span> ? i : max(margin[<span class="number">1</span>][curColor], i);</span><br><span class="line">                margin[<span class="number">2</span>][curColor] = margin[<span class="number">2</span>][curColor] == <span class="number">-1</span> ? j : min(margin[<span class="number">2</span>][curColor], j);</span><br><span class="line">                margin[<span class="number">3</span>][curColor] = margin[<span class="number">3</span>][curColor] == <span class="number">-1</span> ? j : max(margin[<span class="number">3</span>][curColor], j);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构图，如果一种颜色v的格子落在另一种颜色u的矩形内，那么说明u先于v涂色，u -&gt; v有边相连；</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++){</span><br><span class="line">                <span class="keyword">int</span> curColor = targetGrid[i][j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> color = <span class="number">1</span>; color &lt;= <span class="number">60</span>; color ++){</span><br><span class="line">                    <span class="keyword">if</span>(color != curColor &amp;&amp; !isConnect[color][curColor]</span><br><span class="line">                    &amp;&amp; margin[<span class="number">0</span>][color] &lt;= i &amp;&amp; i &lt;= margin[<span class="number">1</span>][color]</span><br><span class="line">                    &amp;&amp; margin[<span class="number">2</span>][color] &lt;= j &amp;&amp; j &lt;= margin[<span class="number">3</span>][color]){</span><br><span class="line">                        isConnect[color][curColor] = <span class="literal">true</span>;</span><br><span class="line">                        Adj[color].push_back(curColor);</span><br><span class="line">                        inDegree[curColor] ++;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> color = <span class="number">0</span>; color &lt;= <span class="number">60</span>; color ++){</span><br><span class="line">            <span class="keyword">if</span>(inDegree[color] == <span class="number">0</span>){</span><br><span class="line">                q.push(color);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v:Adj[u]){</span><br><span class="line">                inDegree[v] --;</span><br><span class="line">                <span class="keyword">if</span>(inDegree[v] == <span class="number">0</span>){</span><br><span class="line">                    q.push(v);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> color = <span class="number">1</span>; color &lt;= <span class="number">60</span>; color ++) ans += inDegree[color] == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans == <span class="number">60</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1></blockquote><p><strong>顶点活动</strong>（Activity On Vertec, AOV）网是指用顶点表示活动，而用边集表示活动间优先关系的有向图。<br><strong>边活动</strong>（Activity On Edge, AOE）网是指用带权的边集表示活动，而用顶点表示事件的有向图，其中边权表示完成活动需要的事件。<br>AOE网中的最长路径被称为<strong>关键路径</strong>，而关键路径上的活动称为<strong>关键活动</strong><br>活动Ar的最早开始时间和最晚开始时间e[r]和l[r]，事件Vi的最早开始时间和最晚开始时间ve[i]和vl[i]。</p><ul><li>Vi–Ar–Vj</li><li>e[r]=ve[i]</li><li>l[r]=vl[j]-length[r]<br>所以，只需要求出ve和vl这两个数组，就可以通过上面的公式得到e和l这两个数组。<br>求解ve和vl：<br><img src="/assets/img/algorithm/CriticalPath_01.png" alt="关键路径图示1"></li></ul><p><strong>在访问某个节点时保证它的前驱节点都已经访问完毕</strong><br>拓扑排序：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; topOrder;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拓扑排序，顺便求ve数组</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topologicalSort</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="built_in">memset</span>(ve,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="number">0</span>));</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    <span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>){</span><br><span class="line">      q.push(i);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">    <span class="keyword">int</span> u=q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    topOrder.push(u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">      <span class="keyword">int</span> v=Adj[u][i].v;</span><br><span class="line">      <span class="keyword">int</span> len=Adj[u][i].dis;</span><br><span class="line">      inDegree[v]--;</span><br><span class="line">      <span class="keyword">if</span>(inDegree[v]==<span class="number">0</span>) q.push[v];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(ve[u]+len&gt;ve[v]){</span><br><span class="line">        ve[v]=ve[u]+len;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span>(topOrder.size()==n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/assets/img/algorithm/CriticalPath_02.png" alt="关键路径图示2"><br><strong>在访问某个节点时保证它的后继节点都已经访问完毕</strong><br>逆拓扑排序：<br>汇点确定与否：<br>汇点不确定时，肯定ve最大的为汇点</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fill(vl,vl+n,ve[n<span class="number">-1</span>]); <span class="comment">//适用于汇点确定且唯一的情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//适用于汇点不确定</span></span><br><span class="line"><span class="keyword">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">  <span class="keyword">if</span>(ve[i]&gt;maxLen) maxLen=ve[i];</span><br><span class="line">}</span><br><span class="line">fill(vl,vl+n,maxLen);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CriticalPath</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="built_in">memset</span>(ve,<span class="number">0</span>,<span class="keyword">sizeof</span>(ve));</span><br><span class="line">  <span class="comment">//拓扑排序求事件最早开始时间ve</span></span><br><span class="line">  <span class="keyword">if</span>(!topologicalSort()) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//不是有向无环图</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    <span class="keyword">if</span>(ve[i]&gt;maxLen) maxLen=ve[i];</span><br><span class="line">  }</span><br><span class="line">  fill(vl,vl+n,maxLen);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//逆拓扑排序求事件最晚开始时间vl</span></span><br><span class="line">  <span class="keyword">while</span>(!topOrder.empty()){</span><br><span class="line">    <span class="keyword">int</span> u=topOrder.top();</span><br><span class="line">    topOrder.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">      <span class="keyword">int</span> v=Adj[u][i].v;</span><br><span class="line">      <span class="keyword">int</span> len=Adj[u][i].dis;</span><br><span class="line">      <span class="keyword">if</span>(vl[v]-len&lt;vl[u]){</span><br><span class="line">        vl[u]=vl[v]-len;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">//遍历所有边，求关键活动</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++){</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">      <span class="keyword">int</span> v=Adj[u][i].v;</span><br><span class="line">      <span class="keyword">int</span> len=Adj[u][i].dis;</span><br><span class="line">      <span class="keyword">int</span> e=ve[u],l=vl[v]-len;</span><br><span class="line">      <span class="keyword">if</span>(e==l) <span class="built_in">cout</span>&lt;&lt;<span class="string">"u-&gt;v"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> maxLen; <span class="comment">//返回关键路径长度</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意：如果需要输出最短路径，则构建邻接表进行DFS！</p><h2 id="关键路径-1"><a href="#关键路径-1" class="headerlink" title="关键路径"></a>关键路径</h2><p><strong>题目描述</strong><br>图的连接边上的数据表示其权值，带权值的图称作网。<br>上图可描述为顶点集为（a,b,c,d,e)<br>边集及其权值为(始点，终点 权值）：<br>a b 3<br>a c 2<br>b d 5<br>c d 7<br>c e 4<br>d e 6<br>网的源点是入度为0的顶点，汇点是出度为0的顶点。网的关键路径是指从源点到汇点的所有路径中，具有最大路径长度的路径。上图中的关键路径为a-&gt;c-&gt;d-&gt;e，其权值之和为关键路径的长度为15。<br>本题的要求是根据给出的网的邻接矩阵求该网的关键路径及其长度。<br><strong>输入</strong><br>第一行输入一个正整数n（1&lt;=n&lt;=5)，其代表测试数据数目，即图的数目<br>第二行输入x(1&lt;=x&lt;=15)代表顶点个数，y(1&lt;=y&lt;=19)代表边的条数<br>第三行给出图中的顶点集，共x个小写字母表示顶点<br>接下来每行给出一条边的始点和终点及其权值，用空格相隔，每行代表一条边。<br><strong>输出</strong><br>第一个输出是图的关键路径（用给出的字母表示顶点， 用括号将边括起来，顶点逗号相隔）<br>第二个输出是关键路径的长度<br>每个矩阵对应上面两个输出，两个输出在同一行用空格间隔，每个矩阵的输出占一行。<br><strong>样例输入</strong><br>2<br>5 6<br>abcde<br>a b 3<br>a c 2<br>b d 5<br>c d 7<br>c e 4<br>d e 6<br>4 5<br>abcd<br>a b 2<br>a c 3<br>a d 4<br>b d 1<br>c d 3<br><strong>样例输出</strong><br>(a,c) (c,d) (d,e) 15<br>(a,c) (c,d) 6<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//题目有问题，始终50%</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> G[MAXV][MAXV];</span><br><span class="line"><span class="keyword">int</span> n,x,y;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; cToi;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; iToc;</span><br><span class="line"><span class="keyword">int</span> inDegree[MAXV];</span><br><span class="line"><span class="keyword">int</span> ve[MAXV],vl[MAXV];</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Adj;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vEnds; <span class="comment">//汇点</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; topOrder;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topologicalSort</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">memset</span>(ve,<span class="number">0</span>,<span class="keyword">sizeof</span>(ve));</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x;i++){</span><br><span class="line">		<span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>){</span><br><span class="line">			q.push(i);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">while</span>(!topOrder.empty()) topOrder.pop();</span><br><span class="line">	<span class="keyword">while</span>(!q.empty()){</span><br><span class="line">		<span class="keyword">int</span> u=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		topOrder.push(u);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;x;v++){</span><br><span class="line">			inDegree[v]--;</span><br><span class="line">			<span class="keyword">if</span>(inDegree[v]==<span class="number">0</span>) q.push(v);</span><br><span class="line">			<span class="keyword">if</span>(G[u][v]!=INF&amp;&amp;ve[u]+G[u][v]&gt;ve[v]){</span><br><span class="line">				ve[v]=ve[u]+G[u][v];</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(topOrder.size()!=x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CriticalPath</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!topologicalSort()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x;i++){</span><br><span class="line">		<span class="keyword">if</span>(ve[i]&gt;maxLen){</span><br><span class="line">			maxLen=ve[i];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	fill(vl,vl+x,maxLen);</span><br><span class="line">	<span class="keyword">while</span>(!topOrder.empty()){</span><br><span class="line">		<span class="keyword">int</span> u=topOrder.top();</span><br><span class="line">		topOrder.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;x;v++){</span><br><span class="line">			<span class="keyword">if</span>(G[u][v]!=INF){</span><br><span class="line">				<span class="keyword">int</span> len=G[u][v];</span><br><span class="line">				<span class="keyword">if</span>(vl[v]-len&lt;vl[u]){</span><br><span class="line">					vl[u]=vl[v]-len;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	Adj.clear();</span><br><span class="line">	Adj.resize(x);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;x;u++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;x;v++){</span><br><span class="line">			<span class="keyword">if</span>(G[u][v]!=INF){</span><br><span class="line">				<span class="keyword">int</span> e=ve[u],l=vl[v]-G[u][v];</span><br><span class="line">				<span class="keyword">if</span>(e==l){</span><br><span class="line">					Adj[v].push_back(u);</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	vEnds.clear();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x;i++){</span><br><span class="line">		<span class="keyword">if</span>(ve[i]==maxLen) vEnds.push_back(i);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> maxLen;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Adj[u].size();i++){</span><br><span class="line">		<span class="keyword">int</span> v=Adj[u][i];</span><br><span class="line">		path.push_back(v);</span><br><span class="line">		DFS(v);</span><br><span class="line">		path.pop_back();</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">0</span>){</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmpPath=path;</span><br><span class="line">		reverse(tmpPath.begin(),tmpPath.end());</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tmpPath.size()<span class="number">-1</span>;i++){</span><br><span class="line">			<span class="keyword">int</span> a=tmpPath[i],b=tmpPath[i+<span class="number">1</span>];</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"("</span>&lt;&lt;iToc[a]&lt;&lt;<span class="string">","</span>&lt;&lt;iToc[b]&lt;&lt;<span class="string">") "</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPath</span><span class="params">()</span></span>{</span><br><span class="line">	path.clear();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vEnds.size();i++){</span><br><span class="line">		path.push_back(vEnds[i]);</span><br><span class="line">		DFS(vEnds[i]);</span><br><span class="line">		path.pop_back();</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">while</span>(n--){</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		cToi.clear();</span><br><span class="line">		iToc.clear();</span><br><span class="line">		<span class="built_in">memset</span>(G,INF,<span class="keyword">sizeof</span>(G));</span><br><span class="line">		<span class="built_in">memset</span>(inDegree,<span class="number">0</span>,<span class="keyword">sizeof</span>(inDegree));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x;i++){</span><br><span class="line">			<span class="keyword">char</span> c;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">			cToi[c]=i;</span><br><span class="line">			iToc[i]=c;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;y;i++){</span><br><span class="line">			<span class="keyword">char</span> a,b;</span><br><span class="line">			<span class="keyword">int</span> l;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;l;</span><br><span class="line">			G[cToi[a]][cToi[b]]=l;</span><br><span class="line">			inDegree[cToi[b]]++;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(x==<span class="number">1</span>){</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"("</span>&lt;&lt;iToc[<span class="number">0</span>]&lt;&lt;<span class="string">","</span>&lt;&lt;iToc[<span class="number">0</span>]&lt;&lt;<span class="string">") 0"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			<span class="keyword">int</span> len=CriticalPath();</span><br><span class="line">			printPath();</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;len&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1></blockquote><h2 id="动态实现"><a href="#动态实现" class="headerlink" title="动态实现"></a>动态实现</h2><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> TypeName;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">  TypeName data;</span><br><span class="line">  Node* lchild;</span><br><span class="line">  Node* rchild;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>新建节点</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">newNode</span><span class="params">(TypeName v)</span></span>{</span><br><span class="line">  Node* node=<span class="keyword">new</span> Node;</span><br><span class="line">  node-&gt;data=v;</span><br><span class="line">  node-&gt;lchild=node-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="二叉树节点的查找、修改"><a href="#二叉树节点的查找、修改" class="headerlink" title="二叉树节点的查找、修改"></a>二叉树节点的查找、修改</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(Node *root,TypeName x, TypeName newData)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(root-&gt;data==x){</span><br><span class="line">    root-&gt;data=newData;</span><br><span class="line">  }</span><br><span class="line">  search(root-&gt;lchild,x,newData);</span><br><span class="line">  search(root-&gt;rchild,x,newData);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="二叉树节点的插入"><a href="#二叉树节点的插入" class="headerlink" title="二叉树节点的插入"></a>二叉树节点的插入</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node* &amp;root, TypeNmae x)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">NULL</span>){</span><br><span class="line">    root=newNode(x);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span>(由二叉树的性质，x应该插在左子树){</span><br><span class="line">    insert(root-&gt;lchild,x);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span>{</span><br><span class="line">    insert(root-&gt;richld,x);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="二叉树的创建"><a href="#二叉树的创建" class="headerlink" title="二叉树的创建"></a>二叉树的创建</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">create</span><span class="params">(TypeName data[], <span class="keyword">int</span> n)</span></span>{</span><br><span class="line">  Node* root=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    insert(roor,data[i]);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node* root)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">NULL</span>){</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;root-&gt;data;</span><br><span class="line">  preOrder(root-&gt;lchild);</span><br><span class="line">  preOrder(root-&gt;rchild);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node* root)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">NULL</span>){</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">  inOrder(root-&gt;lchild);</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;root-&gt;data;</span><br><span class="line">  inOrder(root-&gt;rchild);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node* root)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">NULL</span>){</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">  postOrder(root-&gt;lchild);</span><br><span class="line">  postOrder(root-&gt;rchild);</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;root-&gt;data;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="先、中、后续遍历非递归实现"><a href="#先、中、后续遍历非递归实现" class="headerlink" title="先、中、后续遍历非递归实现"></a>先、中、后续遍历非递归实现</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTree</span>{</span></span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	BiTree *left, *right;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BiTree* root)</span></span>{</span><br><span class="line">	BiTree* p=root;</span><br><span class="line">	<span class="built_in">stack</span>&lt;BiTree*&gt; st;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>||!st.empty()){</span><br><span class="line">		<span class="keyword">while</span>(p!=<span class="literal">NULL</span>){</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;p-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			st.push(p);</span><br><span class="line">			p=p-&gt;left;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(!st.empty()){</span><br><span class="line">			p=st.top();st.pop();</span><br><span class="line">			p=p-&gt;right;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BiTree* root)</span></span>{</span><br><span class="line">	BiTree* p=root;</span><br><span class="line">	<span class="built_in">stack</span>&lt;BiTree*&gt; st;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>||!st.empty()){</span><br><span class="line">		<span class="keyword">while</span>(p!=<span class="literal">NULL</span>){</span><br><span class="line">			st.push(p);</span><br><span class="line">			p=p-&gt;left;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(!st.empty()){</span><br><span class="line">			p=st.top();st.pop();</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;p-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			p=p-&gt;right;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lastOrder</span><span class="params">(BiTree* root)</span></span>{</span><br><span class="line">	BiTree* p=root, pre=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">stack</span>&lt;BiTree*&gt; st;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>||!st.empty()){</span><br><span class="line">		<span class="keyword">while</span>(p!=<span class="literal">NULL</span>){</span><br><span class="line">			st.push(p);</span><br><span class="line">			p=p-&gt;left;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(!st.empty()){</span><br><span class="line">			p=st.top();</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;right!=<span class="literal">NULL</span>&amp;&amp;pre!=p-&gt;right){</span><br><span class="line">				p=p-&gt;right;</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;p-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				st.pop();</span><br><span class="line">				pre=p;</span><br><span class="line">				p=<span class="literal">NULL</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layerOrder</span><span class="params">(Node* root)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">  q.push(root);</span><br><span class="line">  <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">    Node* now=q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;now-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>(now-&gt;lchild!=<span class="literal">NULL</span>) q.push(now-&gt;lchild);</span><br><span class="line">    <span class="keyword">if</span>(now-&gt;rchild!=<span class="literal">NULL</span>) q.push(now-&gt;rchild);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>计算每个节点所处层次</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> TypeName;</span><br><span class="line">strcut Node{</span><br><span class="line">  TypeName data;</span><br><span class="line">  <span class="keyword">int</span> layer;</span><br><span class="line">  Node* lchild;</span><br><span class="line">  Node* rchild;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layerOder</span><span class="params">(Node* root)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">  root-&gt;layer=<span class="number">1</span>;</span><br><span class="line">  q.push(root);</span><br><span class="line">  <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">    Node* now=q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">if</span>(now-&gt;lchild!=<span class="literal">NULL</span>){</span><br><span class="line">      now-&gt;lchild-&gt;layer=now-&gt;layer+<span class="number">1</span>;</span><br><span class="line">      q.push(now-&gt;lchild);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(now-&gt;rchild!=<span class="literal">NULL</span>){</span><br><span class="line">      now-&gt;rchild-&gt;layer=now-&gt;layer+<span class="number">1</span>;</span><br><span class="line">      q.push(now-&gt;rchild);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="先序中序建树"><a href="#先序中序建树" class="headerlink" title="先序中序建树"></a>先序中序建树</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> TypeName;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100</span>;</span><br><span class="line">TypeName pre[MAX];</span><br><span class="line">TypeName in[MAX];</span><br><span class="line"><span class="function">Node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> preL,<span class="keyword">int</span> preR, <span class="keyword">int</span> inL,<span class="keyword">int</span> inR)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(preL&gt;preR||inL&gt;inR) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  Node* root=<span class="keyword">new</span> Node;</span><br><span class="line">  root-&gt;data=pre[preL];</span><br><span class="line">  <span class="comment">//线性查找，当然可以二分查找</span></span><br><span class="line">  <span class="keyword">int</span> k;</span><br><span class="line">  <span class="keyword">for</span>(k=inL;k&lt;=inR;k++){</span><br><span class="line">    <span class="keyword">if</span>(pre[preL]==in[k]) <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">int</span> numLeft=k-inL;</span><br><span class="line">  root-&gt;lchild=create(preL+<span class="number">1</span>,preL+numLeft,inL,k<span class="number">-1</span>);</span><br><span class="line">  root-&gt;rchild=create(preL+numLeft+<span class="number">1</span>,preR,k+<span class="number">1</span>,inR);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="中序后序建树"><a href="#中序后序建树" class="headerlink" title="中序后序建树"></a>中序后序建树</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> TypeName;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100</span>;</span><br><span class="line">TypeName in[MAX];</span><br><span class="line">TypeName post[MAX];</span><br><span class="line"><span class="function">Node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> inL,<span class="keyword">int</span> inR, <span class="keyword">int</span> pL,<span class="keyword">int</span> pR)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(inL&gt;inR||pL&gt;pR) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  Node* root=<span class="keyword">new</span> Node;</span><br><span class="line">  root-&gt;data=post[pR];</span><br><span class="line">  <span class="keyword">int</span> k;</span><br><span class="line">  <span class="keyword">for</span>(k=inL;k&lt;=inR;k++){</span><br><span class="line">    <span class="keyword">if</span>(post[pR]==in[k]) <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">int</span> numLeft=k-inL;</span><br><span class="line">  root-&gt;lchild=create(inL,k<span class="number">-1</span>,pL,pL+numLeft<span class="number">-1</span>);</span><br><span class="line">  root-&gt;rchild=create(k+<span class="number">1</span>,inR,pl+numLeft,pR);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="中序层序建树"><a href="#中序层序建树" class="headerlink" title="中序层序建树"></a>中序层序建树</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> TypeName;</span><br><span class="line"><span class="built_in">vector</span>&lt;TypeNmae&gt; layer;</span><br><span class="line"><span class="built_in">vector</span>&lt;TypeName&gt; in;</span><br><span class="line"><span class="function">Node* <span class="title">create</span><span class="params">(<span class="built_in">vector</span>&lt;TypeName&gt; layer,<span class="built_in">vector</span>&lt;TypeName&gt; in,<span class="keyword">int</span> inL,<span class="keyword">int</span> inR)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(layer.size()==<span class="number">0</span>||inL&gt;inR) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  Node* root=<span class="keyword">new</span> Node;</span><br><span class="line">  root-&gt;data=layer[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> pos;</span><br><span class="line">  <span class="keyword">for</span>(pos=<span class="number">0</span>;pos&lt;in.size();pos++){</span><br><span class="line">    <span class="keyword">if</span>(layer[<span class="number">0</span>]==in[pos]) <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">vector</span>&lt;TypeName&gt; leftLayer,rightLayer;</span><br><span class="line">  <span class="built_in">vector</span>&lt;TypeName&gt; leftIn,rightIn;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;layer.size();i++){</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;pos;j++){</span><br><span class="line">      <span class="keyword">if</span>(layer[i]==in[j]){</span><br><span class="line">        leftLayer.push_back(layer[i]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(j==pos) rightLayer.push_back(layer[i]);</span><br><span class="line">  }</span><br><span class="line">  root-&gt;lchild=create(leftLayer,in,inL,pos<span class="number">-1</span>);</span><br><span class="line">  root-&gt;rchild=create(rightLayer,in,pos+<span class="number">1</span>,inR);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="静态实现"><a href="#静态实现" class="headerlink" title="静态实现"></a>静态实现</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> TypeName;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">  TypeName data;</span><br><span class="line">  <span class="keyword">int</span> lchild;</span><br><span class="line">  <span class="keyword">int</span> rchild;</span><br><span class="line">}BinaryTree[MAX];</span><br></pre></td></tr></tbody></table></figure><h3 id="新建节点"><a href="#新建节点" class="headerlink" title="新建节点"></a>新建节点</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span></span>{</span><br><span class="line">  BianryTree[index].data=v;</span><br><span class="line">  BianryTree[index].lchild=<span class="number">-1</span>;</span><br><span class="line">  BinaryTree[index].rchild=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> index++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="查找-2"><a href="#查找-2" class="headerlink" title="查找"></a>查找</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> x,<span class="keyword">int</span> newData)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(BinaryTree[root].data==x) BinaryTree[root].data=newData;</span><br><span class="line">  search(BinaryTree[root].lchild,x,newData);</span><br><span class="line">  search(BinaryTree[root].rchild,x,newData);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;root,<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="number">-1</span>){</span><br><span class="line">    root=newNode(x);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span>(由二叉树的性质x应该插在左子树){</span><br><span class="line">    insert(BinaryTree[root].lchild,x);</span><br><span class="line">  }<span class="keyword">else</span>{</span><br><span class="line">    insert(BInaryTree[root].rcchild,x);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">  <span class="keyword">int</span> root=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    insert(root,data[i]);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;BinaryTree[root].data;</span><br><span class="line">  preOrder(BianryTree[root].lchild);</span><br><span class="line">  preOrder(BinaryTree[root].rchild);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">  inOrder(BinaryTree[root].lchild);</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;BInaryTree[root].data;</span><br><span class="line">  inOrder(BInaryTree[root].rchild);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">  postOrder(BianryTree[root].lchild);</span><br><span class="line">  postOrder(BinaryTree[root].rchild);</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;BInaryTree[root].data;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  q.push(root);</span><br><span class="line">  <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">    <span class="keyword">int</span> now=q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;BinaryTree[root].data;</span><br><span class="line">    <span class="keyword">if</span>(BinaryTree[root].lchild!=<span class="number">-1</span>) q.push(BinaryTree[root].lchild);</span><br><span class="line">    <span class="keyword">if</span>(BinaryTree[root].rchild!=<span class="number">-1</span>) q.push(BinaryTree[root].rchild);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="PAT-A1020-Tree-Traversals"><a href="#PAT-A1020-Tree-Traversals" class="headerlink" title="PAT-A1020 Tree Traversals"></a>PAT-A1020 Tree Traversals</h2><p><strong>Description</strong><br>Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are supposed to output the level order traversal sequence of the corresponding binary tree.<br><strong>Input Specification</strong><br>Each input file contains one test case. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space.<br><strong>Output Specification</strong><br>For each test case, print in one line the level order traversal sequence of the corresponding binary tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.<br><strong>Sample Input</strong><br>7<br>2 3 1 5 7 6 4<br>1 2 3 4 5 6 7<br><strong>Sample Output</strong><br>4 1 6 3 5 7 2<br><strong>Procedure</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	Node* lchild;</span><br><span class="line">	Node* rchild;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postOrder;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inOrder;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> inL,<span class="keyword">int</span> inR,<span class="keyword">int</span> pL,<span class="keyword">int</span> pR)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(inL&gt;inR||pL&gt;pR) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	Node* root=<span class="keyword">new</span> Node;</span><br><span class="line">	root-&gt;data=postOrder[pR];</span><br><span class="line">	<span class="keyword">int</span> pos;</span><br><span class="line">	<span class="keyword">for</span>(pos=inL;pos&lt;=inR;pos++){</span><br><span class="line">		<span class="keyword">if</span>(postOrder[pR]==inOrder[pos]) <span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">int</span> numLeft=pos-inL;</span><br><span class="line">	root-&gt;lchild=create(inL,pos<span class="number">-1</span>,pL,pL+numLeft<span class="number">-1</span>);</span><br><span class="line">	root-&gt;rchild=create(pos+<span class="number">1</span>,inR,pL+numLeft,pR<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node* root)</span></span>{</span><br><span class="line">	<span class="built_in">queue</span>&lt;Node*&gt; Q;</span><br><span class="line">	<span class="keyword">if</span>(root!=<span class="literal">NULL</span>) Q.push(root);</span><br><span class="line">	<span class="keyword">bool</span> bFirst=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(!Q.empty()){</span><br><span class="line">		Node* front=Q.front();</span><br><span class="line">		<span class="keyword">if</span>(bFirst){</span><br><span class="line">			bFirst=<span class="literal">false</span>;</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;front-&gt;data;</span><br><span class="line">		Q.pop();</span><br><span class="line">		<span class="keyword">if</span>(front-&gt;lchild!=<span class="literal">NULL</span>) Q.push(front-&gt;lchild);</span><br><span class="line">		<span class="keyword">if</span>(front-&gt;rchild!=<span class="literal">NULL</span>) Q.push(front-&gt;rchild);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		postOrder.clear();</span><br><span class="line">		inOrder.clear();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="keyword">int</span> tmp;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">			postOrder.push_back(tmp);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="keyword">int</span> tmp;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">			inOrder.push_back(tmp);</span><br><span class="line">		}</span><br><span class="line">		Node* root=create(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">		print(root);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="复原二叉树"><a href="#复原二叉树" class="headerlink" title="复原二叉树"></a>复原二叉树</h2><p><strong>题目描述</strong><br>小明在做数据结构的作业，其中一题是给你一棵二叉树的前序遍历和中序遍历结果，要求你写出这棵二叉树的后序遍历结果。<br><strong>输入</strong><br>输入包含多组测试数据。每组输入包含两个字符串，分别表示二叉树的前序遍历和中序遍历结果。每个字符串由不重复的大写字母组成。<br><strong>输出</strong><br>对于每组输入，输出对应的二叉树的后续遍历结果。<br><strong>样例输入</strong><br>DBACEGF ABCDEFG<br>BCAD CBAD<br><strong>样例输出</strong><br>ACBFGED<br>CDAB<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	Node* lchild;</span><br><span class="line">	Node* rchild;</span><br><span class="line">};</span><br><span class="line"><span class="built_in">string</span> preOrder;</span><br><span class="line"><span class="built_in">string</span> inOrder;</span><br><span class="line"><span class="function">Node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> inL,<span class="keyword">int</span> inR,<span class="keyword">int</span> preL,<span class="keyword">int</span> preR)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(inL&gt;inR||preL&gt;preR) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	Node* root=<span class="keyword">new</span> Node;</span><br><span class="line">	root-&gt;data=preOrder[preL];</span><br><span class="line">	<span class="keyword">int</span> pos;</span><br><span class="line">	<span class="keyword">for</span>(pos=inL;pos&lt;=inR;pos++){</span><br><span class="line">		<span class="keyword">if</span>(preOrder[preL]==inOrder[pos])<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">int</span> numLeft=pos-inL;</span><br><span class="line">	root-&gt;lchild=create(inL,pos<span class="number">-1</span>,preL+<span class="number">1</span>,preL+numLeft);</span><br><span class="line">	root-&gt;rchild=create(pos+<span class="number">1</span>,inR,preL+numLeft+<span class="number">1</span>,preR);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node* root)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	postOrder(root-&gt;lchild);</span><br><span class="line">	postOrder(root-&gt;rchild);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;root-&gt;data;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;preOrder&gt;&gt;inOrder){</span><br><span class="line">		Node* root=create(<span class="number">0</span>,preOrder.size()<span class="number">-1</span>,<span class="number">0</span>,inOrder.size()<span class="number">-1</span>);</span><br><span class="line">		postOrder(root);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h2><p><strong>题目描述</strong><br>如上所示，由正整数1，2，3……组成了一颗特殊二叉树。我们已知这个二叉树的最后一个结点是n。现在的问题是，结点m所在的子树中一共包括多少个结点。<br>比如，n = 12，m = 3那么上图中的结点13，14，15以及后面的结点都是不存在的，结点m所在子树中包括的结点有3，6，7，12，因此结点m的所在子树中共有4个结点。<br><strong>输入</strong><br>输入数据包括多行，每行给出一组测试数据，包括两个整数m，n (1 &lt;= m &lt;= n &lt;= 1000000000)。最后一组测试数据中包括两个0，表示输入的结束，这组数据不用处理。<br><strong>输出</strong><br>对于每一组测试数据，输出一行，该行包含一个整数，给出结点m所在子树中包括的结点的数目。<br><strong>样例输入</strong><br>3 7<br>142 6574<br>2 754<br>0 0<br><strong>样例输出</strong><br>3<br>63<br>498<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n&amp;&amp;m!=<span class="number">0</span>){</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> nCount=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> treeH=<span class="built_in">ceil</span>(log2(n+<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">int</span> subH=<span class="built_in">ceil</span>(log2(m+<span class="number">1</span>));</span><br><span class="line">		nCount=<span class="built_in">pow</span>(<span class="number">2</span>,treeH-subH)<span class="number">-1</span>; <span class="comment">//最后一层未计算</span></span><br><span class="line">		<span class="keyword">int</span> h=treeH-subH;</span><br><span class="line">		<span class="keyword">int</span> l,r;</span><br><span class="line">		l=r=m;</span><br><span class="line">		<span class="keyword">while</span>(h!=<span class="number">0</span>){</span><br><span class="line">			l*=<span class="number">2</span>;</span><br><span class="line">			r=r*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">			h--;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(r&lt;=n){</span><br><span class="line">			nCount+=r-l+<span class="number">1</span>;</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">if</span>(l&lt;=n){</span><br><span class="line">			nCount+=n-l+<span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;nCount&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1></blockquote><h2 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> TypeName;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">  TypeNmae data;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;</span><br><span class="line">}Tree[MAX];</span><br></pre></td></tr></tbody></table></figure><h2 id="新建节点-1"><a href="#新建节点-1" class="headerlink" title="新建节点"></a>新建节点</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newNode</span><span class="params">(TypeName v)</span></span>{</span><br><span class="line">  Tree[index].data=v;</span><br><span class="line">  Tree[index].child.clear();</span><br><span class="line">  <span class="keyword">return</span> index++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="先根遍历"><a href="#先根遍历" class="headerlink" title="先根遍历"></a>先根遍历</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span>{</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;Tree[root].data;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Tree[root].child.size();i++){</span><br><span class="line">    preOrder(Tree[root].child[i]);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="层序遍历-1"><a href="#层序遍历-1" class="headerlink" title="层序遍历"></a>层序遍历</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layerOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span>{</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">  Q.push(root);</span><br><span class="line">  <span class="keyword">while</span>(!Q.empty()){</span><br><span class="line">    <span class="keyword">int</span> front=Q.front();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Tree[front].data;</span><br><span class="line">    Q.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Tree[front].child.size();i++){</span><br><span class="line">      Q.push(Tree[front].child[i]);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="层序编号"><a href="#层序编号" class="headerlink" title="层序编号"></a>层序编号</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">  <span class="keyword">int</span> layer;</span><br><span class="line">  TypeName data;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;</span><br><span class="line">}Tree[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layerOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span>{</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">  Q.push(root);</span><br><span class="line">  Tree[root].layer=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(!Q.empty()){</span><br><span class="line">    <span class="keyword">int</span> front=Q.front();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Tree[front].data;</span><br><span class="line">    Q.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Tree[front].child.size();i++){</span><br><span class="line">      <span class="keyword">int</span> childIndex=Tree[front].child[i];</span><br><span class="line">      Tree[childIndex].layer=Tree[front].layer+<span class="number">1</span>;</span><br><span class="line">      Q.push(childIndex);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Pat-A1053-Path-of-Equal-Weight"><a href="#Pat-A1053-Path-of-Equal-Weight" class="headerlink" title="Pat-A1053 Path of Equal Weight"></a>Pat-A1053 Path of Equal Weight</h2><p><strong>Description</strong><br>Given a non-empty tree with root R, and with weight Wi assigned to each tree node Ti. The weight of a path from R to L is defined to be the sum of the weights of all the nodes along the path from R to any leaf node L. Now given any weighted tree, you are supposed to find all the paths with their weights equal to a given number. For example, let’s consider the tree showed in the following figure: for each node, the upper number is the node ID which is a two-digit number, and the lower number is the weight of that node. Suppose that the given number is 24, then there exists 4 different paths which have the same given weight: {10 5 2 7}, {10 4 10}, {10 3 3 6 2} and {10 3 3 6 2}, which correspond to the red edges in the figure.<br><img src="/assets/img/algorithm/tree_traverse_01.jpg" alt="图示"><br><strong>Input Specification</strong><br>Each input file contains one test case. Each case starts with a line containing 0&lt;N≤100, the number of nodes in a tree, M (&lt;N), the number of non-leaf nodes, and 0&lt;S&lt;$2^{30}$, the given weight number. The next line contains N positive numbers where W​i(&lt;1000) corresponds to the tree node Ti. Then M lines follow, each in the format:<br>ID K ID[1] ID[2] … ID[K]<br>where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID’s of its children. For the sake of simplicity, let us fix the root ID to be 00.<br><strong>Output Specification</strong><br>For each test case, print all the paths with weight S in non-increasing order. Each path occupies a line with printed weights from the root to the leaf in order. All the numbers must be separated by a space with no extra space at the end of the line.<br>Note: sequence {A1,A2,⋯,An} is said to be greater than sequence {B1,B2,⋯,B​m} if there exists 1≤k&lt;min{n,m} such that Ai=Bi for i=1,⋯,k, and Ak+1&gt;Bk+1.<br><strong>Sample Input</strong><br>20 9 24<br>10 2 4 3 5 10 2 18 9 7 2 2 1 3 12 1 8 6 2 2<br>00 4 01 02 03 04<br>02 1 05<br>04 2 06 07<br>03 3 11 12 13<br>06 1 09<br>07 2 08 10<br>16 1 15<br>13 3 14 16 17<br>17 2 18 19<br><strong>Sample Output</strong><br>10 5 2 7<br>10 4 10<br>10 3 3 6 2<br>10 3 3 6 2<br><strong>Procedure</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">101</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> weight;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;</span><br><span class="line">}Tree[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">	<span class="keyword">return</span> Tree[a].weight&gt;Tree[b].weight;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> n,m,s;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> sum)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(sum&gt;s) <span class="keyword">return</span>;  <span class="comment">//不符合题意</span></span><br><span class="line">	<span class="keyword">if</span>(sum==s){</span><br><span class="line">		<span class="keyword">if</span>(!Tree[index].child.empty()) <span class="keyword">return</span>; <span class="comment">//非叶子节点</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;path.size();i++){</span><br><span class="line">			<span class="keyword">if</span>(i!=<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;Tree[path[i]].weight;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Tree[index].child.size();i++){</span><br><span class="line">		<span class="keyword">int</span> childIndex=Tree[index].child[i];</span><br><span class="line">		path.push_back(childIndex);</span><br><span class="line">		DFS(childIndex,sum+Tree[childIndex].weight);</span><br><span class="line">		path.pop_back();</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;Tree[i].weight;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">		<span class="keyword">int</span> id,k;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;id&gt;&gt;k;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++){</span><br><span class="line">			<span class="keyword">int</span> child;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;child;</span><br><span class="line">			Tree[id].child.push_back(child);</span><br><span class="line">		}</span><br><span class="line">		sort(Tree[id].child.begin(),Tree[id].child.end(),cmp);</span><br><span class="line">	}</span><br><span class="line">	path.push_back(<span class="number">0</span>);</span><br><span class="line">	DFS(<span class="number">0</span>,Tree[<span class="number">0</span>].weight);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="树查找"><a href="#树查找" class="headerlink" title="树查找"></a>树查找</h2><p><strong>题目描述</strong><br>有一棵树，输出某一深度的所有节点，有则输出这些节点，无则输出EMPTY。该树是完全二叉树。<br><strong>输入</strong><br>输入有多组数据。<br>每组输入一个n(1&lt;=n&lt;=1000)，然后将树中的这n个节点依次输入，再输入一个d代表深度。<br><strong>输出</strong><br>输出该树中第d层得所有节点，节点间用空格隔开，最后一个节点后没有空格。<br><strong>样例输入</strong><br>5<br>1 2 3 4 5<br>7<br>7<br>1 2 3 4 5 6 7<br>2<br>0<br><strong>样例输出</strong><br>EMPTY<br>2 3<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1001</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nodes;</span><br><span class="line"><span class="keyword">int</span> n,h;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n!=<span class="number">0</span>){</span><br><span class="line">		nodes.clear();</span><br><span class="line">		nodes.resize(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;nodes[i];</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;h;</span><br><span class="line">		<span class="keyword">int</span> nowH=<span class="built_in">ceil</span>(log2(n+<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">int</span> numTop=<span class="built_in">pow</span>(<span class="number">2</span>,h<span class="number">-1</span>)<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">int</span> numLev=<span class="built_in">pow</span>(<span class="number">2</span>,h<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span>(h&gt;nowH) <span class="built_in">cout</span>&lt;&lt;<span class="string">"EMPTY"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span>{</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=numTop;i&lt;n&amp;&amp;i&lt;numTop+numLev;i++){</span><br><span class="line">				<span class="keyword">if</span>(i!=numTop) <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;nodes[i];</span><br><span class="line">			}</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="树的高度"><a href="#树的高度" class="headerlink" title="树的高度"></a>树的高度</h2><p><strong>题目描述</strong><br>一棵树有n个节点，其中1号节点为根节点。<br><strong>输入</strong><br>第一行是整数n，表示节点数<br>后面若干行，每行两个整数a b，表示b是a的子节点。<br><strong>输出</strong><br>求这棵树的高度（根节点为第1层）<br><strong>样例输入</strong><br>5<br>1 2<br>1 3<br>3 4<br>3 5<br><strong>样例输出</strong><br>3<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1001</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;</span><br><span class="line">}Tree[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calLevel</span><span class="params">(<span class="keyword">int</span> root)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(Tree[root].child.empty()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> maxLevel=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Tree[root].child.size();i++){</span><br><span class="line">		<span class="keyword">int</span> childIndex=Tree[root].child[i];</span><br><span class="line">		maxLevel=max(maxLevel,calLevel(childIndex)+<span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> maxLevel;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> a,b;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b){</span><br><span class="line">			Tree[a].child.push_back(b);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;calLevel(<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1></blockquote><h2 id="查找-3"><a href="#查找-3" class="headerlink" title="查找"></a>查找</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(Node* root,<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(root-&gt;data==x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;root-&gt;data) <span class="keyword">return</span> search(root-&gt;lchild,x);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> search(root-&gt;rchild,x);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node* &amp;root,<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">NULL</span>){</span><br><span class="line">    root=newNode(x);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span>(x==root-&gt;data){</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;root-&gt;data){</span><br><span class="line">    insert(root-&gt;lchild,x);</span><br><span class="line">  }<span class="keyword">else</span>{</span><br><span class="line">    insert(root-&gt;rchild,x);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="建树-1"><a href="#建树-1" class="headerlink" title="建树"></a>建树</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">  Node* root=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    insert(root,data[i]);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寻找前驱</span></span><br><span class="line"><span class="function">Node* <span class="title">findPre</span><span class="params">(Node* root)</span></span>{</span><br><span class="line">  <span class="keyword">while</span>(root-&gt;rchild!=<span class="literal">NULL</span>){</span><br><span class="line">    root=root-&gt;rchild;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//寻找后继</span></span><br><span class="line"><span class="function">Node* <span class="title">findNext</span><span class="params">(Node* root)</span></span>{</span><br><span class="line">  <span class="keyword">while</span>(root-&gt;lchild!=<span class="literal">NULL</span>){</span><br><span class="line">    root=root-&gt;lchild;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(Node* &amp;root,<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(root-&gt;data==x){</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;lchild==<span class="literal">NULL</span>&amp;&amp;root-&gt;rchild==<span class="literal">NULL</span>){</span><br><span class="line">      root=<span class="literal">NULL</span>;</span><br><span class="line">    }<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;lchild!=<span class="literal">NULL</span>){</span><br><span class="line">      Node* pre=findPre(root-&gt;lchild);</span><br><span class="line">      root-&gt;data=pre-&gt;data;</span><br><span class="line">      deleteNode(root-&gt;lchild,pre-&gt;data);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">      Node* next=findNext(root-&gt;rchild);</span><br><span class="line">      root-&gt;data=next-&gt;data;</span><br><span class="line">      deleteNode(root-&gt;rchild,next-&gt;data);</span><br><span class="line">    }</span><br><span class="line">  }<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;data&gt;x){</span><br><span class="line">    deleteNode(root-&gt;lchild,x);</span><br><span class="line">  }<span class="keyword">else</span>{</span><br><span class="line">    deleteNode(root-&gt;rchild,x);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Pat-A1043-Is-It-a-Binary-Search-Tree"><a href="#Pat-A1043-Is-It-a-Binary-Search-Tree" class="headerlink" title="Pat-A1043 Is It a Binary Search Tree"></a>Pat-A1043 Is It a Binary Search Tree</h2><p><strong>Description</strong><br>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p><ul><li>The left subtree of a node contains only nodes with keys less than the node’s key.</li><li>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.<br>If we swap the left and right subtrees of every node, then the resulting tree is called the Mirror Image of a BST.<br>Now given a sequence of integer keys, you are supposed to tell if it is the preorder traversal sequence of a BST or the mirror image of a BST.</li></ul><p><strong>Input Specification</strong><br>Each input file contains one test case. For each case, the first line contains a positive integer N (≤1000). Then N integer keys are given in the next line. All the numbers in a line are separated by a space.<br><strong>Output Specification</strong><br>For each test case, first print in a line YES if the sequence is the preorder traversal sequence of a BST or the mirror image of a BST, or NO if not. Then if the answer is YES, print in the next line the postorder traversal sequence of that tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.<br><strong>Sample Input 1</strong><br>7<br>8 6 5 7 10 8 11<br><strong>Sample Output 1</strong><br>YES<br>5 7 6 8 11 10 8<br><strong>Sample Input 2</strong><br>7<br>8 10 11 8 6 7 5<br><strong>Sample Output 2</strong><br>YES<br>11 8 10 7 5 6 8<br><strong>Sample Input 3</strong><br>7<br>8 6 8 5 10 9 11<br><strong>Sample Output 3</strong><br>NO<br><strong>Procedure</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	Node* lchild;</span><br><span class="line">	Node* rchild;</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; origin,pre,preMirror,post,postMirror;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node* &amp;root,<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="literal">NULL</span>){</span><br><span class="line">		root=<span class="keyword">new</span> Node;</span><br><span class="line">		root-&gt;data=x;</span><br><span class="line">		root-&gt;lchild=root-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(x&lt;root-&gt;data){</span><br><span class="line">		insert(root-&gt;lchild,x);</span><br><span class="line">	}<span class="keyword">else</span>{</span><br><span class="line">		insert(root-&gt;rchild,x);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function">Node* <span class="title">create</span><span class="params">()</span></span>{</span><br><span class="line">	Node* root=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;origin.size();i++){</span><br><span class="line">		insert(root,origin[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node* root)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	pre.push_back(root-&gt;data);</span><br><span class="line">	preOrder(root-&gt;lchild);</span><br><span class="line">	preOrder(root-&gt;rchild);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node* root)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	postOrder(root-&gt;lchild);</span><br><span class="line">	postOrder(root-&gt;rchild);</span><br><span class="line">	post.push_back(root-&gt;data);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preMirrorOrder</span><span class="params">(Node* root)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	preMirror.push_back(root-&gt;data);</span><br><span class="line">	preMirrorOrder(root-&gt;rchild);</span><br><span class="line">	preMirrorOrder(root-&gt;lchild);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postMirrorOrder</span><span class="params">(Node* root)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	postMirrorOrder(root-&gt;rchild);</span><br><span class="line">	postMirrorOrder(root-&gt;lchild);</span><br><span class="line">	postMirror.push_back(root-&gt;data);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	origin.resize(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;origin[i];</span><br><span class="line">	Node* root=create();</span><br><span class="line"></span><br><span class="line">	preOrder(root);</span><br><span class="line">	postOrder(root);</span><br><span class="line">	preMirrorOrder(root);</span><br><span class="line">	postMirrorOrder(root);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(origin==pre){</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=post.begin();it!=post.end();it++){</span><br><span class="line">			<span class="keyword">if</span>(it!=post.begin()) <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;*it;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}<span class="keyword">else</span> <span class="keyword">if</span>(origin==preMirror){</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=postMirror.begin();it!=postMirror.end();it++){</span><br><span class="line">			<span class="keyword">if</span>(it!=postMirror.begin()) <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;*it;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}<span class="keyword">else</span>{</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1></blockquote><h2 id="存储结构-2"><a href="#存储结构-2" class="headerlink" title="存储结构"></a>存储结构</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">  <span class="keyword">int</span> weight;</span><br><span class="line">  <span class="keyword">int</span> height;</span><br><span class="line">  Node *lchild,*rchild;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="新建节点-2"><a href="#新建节点-2" class="headerlink" title="新建节点"></a>新建节点</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> weight)</span></span>{</span><br><span class="line">  Node* node=<span class="keyword">new</span> Node;</span><br><span class="line">  node-&gt;weight=weight;</span><br><span class="line">  node-&gt;height=<span class="number">1</span>;</span><br><span class="line">  node-&gt;lchild=node-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="获取高度"><a href="#获取高度" class="headerlink" title="获取高度"></a>获取高度</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Node* root)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> root-&gt;height;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="计算平衡因子"><a href="#计算平衡因子" class="headerlink" title="计算平衡因子"></a>计算平衡因子</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalancedFactor</span><span class="params">(Node* root)</span></span>{</span><br><span class="line">  <span class="keyword">return</span> getHeight(root-&gt;lchild)-getHeight(root-&gt;rchild);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="更新高度"><a href="#更新高度" class="headerlink" title="更新高度"></a>更新高度</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateHeight</span><span class="params">(Node* root)</span></span>{</span><br><span class="line">  root-&gt;height=max(getHeight(root-&gt;lchild),getHeight(root-&gt;rchild))+<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="查找-4"><a href="#查找-4" class="headerlink" title="查找"></a>查找</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(Node* root, <span class="keyword">int</span> x)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(x==root-&gt;weight) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;root-&gt;weight) <span class="keyword">return</span> search(root-&gt;lchild,x);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> search(root-&gt;rchild,x);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leftRotation</span><span class="params">(Node* &amp;root)</span></span>{</span><br><span class="line">  Node* tmp=root-&gt;rchild;</span><br><span class="line">  root-&gt;rchild=tmp-&gt;lchild;</span><br><span class="line">  tmp-&gt;lchild=root;</span><br><span class="line">  updateHeight(root);</span><br><span class="line">  updateHeight(tmp);</span><br><span class="line">  root=tmp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rightRotation</span><span class="params">(Node* &amp;root)</span></span>{</span><br><span class="line">  Node* tmp=root-&gt;lchild;</span><br><span class="line">  root-&gt;lchld=tmp-&gt;rchild;</span><br><span class="line">  tmp-&gt;rchild=root;</span><br><span class="line">  updateHeight(root);</span><br><span class="line">  updateHeight(tmp);</span><br><span class="line">  root=tmp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node* &amp;root, <span class="keyword">int</span> weight)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">NULL</span>){</span><br><span class="line">    root=newNode(weight);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span>(weight&lt;root-&gt;weight){</span><br><span class="line">    insert(root-&gt;lchild,weight);</span><br><span class="line">    updateHeight(root);</span><br><span class="line">    <span class="keyword">if</span>(getBalancedFactor(root)==<span class="number">2</span>){</span><br><span class="line">      <span class="keyword">if</span>(getBalancedFactor(root-&gt;lchild)==<span class="number">1</span>){ <span class="comment">//LL型</span></span><br><span class="line">        rightRotation(root);</span><br><span class="line">      }<span class="keyword">else</span>{  <span class="comment">//LR型</span></span><br><span class="line">        leftRotation(root-&gt;lchild);</span><br><span class="line">        rightRotation(root);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }<span class="keyword">else</span>{</span><br><span class="line">    insert(root-&gt;rchild,weight);</span><br><span class="line">    updateHeight(root);</span><br><span class="line">    <span class="keyword">if</span>(getBalancedFactor(root)==<span class="number">-2</span>){</span><br><span class="line">      <span class="keyword">if</span>(getBalancedFactor(root-&gt;rchild)==<span class="number">-1</span>){ <span class="comment">//RR型</span></span><br><span class="line">        leftRotation(root);</span><br><span class="line">      }<span class="keyword">else</span>{  <span class="comment">//RL型</span></span><br><span class="line">        rightRotation(root-&gt;rchild);</span><br><span class="line">        leftRotation(root);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(Node* &amp;root, <span class="keyword">int</span> weight)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(weight==root-&gt;weight){</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;lchild!=<span class="literal">NULL</span>&amp;&amp;root-&gt;rchild!=<span class="literal">NULL</span>){</span><br><span class="line">        Node* pre=findPre(root-&gt;lchild);</span><br><span class="line">        root-&gt;wegiht=pre-&gt;wegiht;</span><br><span class="line">        deleteNode(root-&gt;lchild, pre-&gt;weight);</span><br><span class="line">        updateHeight(root);</span><br><span class="line">        <span class="keyword">if</span>(getBalancedFactor(root)==<span class="number">-2</span>){</span><br><span class="line">          <span class="keyword">if</span>(getBalancedFactor(root-&gt;rchild)==<span class="number">1</span>){ <span class="comment">//RL型</span></span><br><span class="line">            rightRotation(root-&gt;rchild);</span><br><span class="line">            leftRotation(root);</span><br><span class="line">          }<span class="keyword">else</span>{ <span class="comment">//RR型</span></span><br><span class="line">            leftRotation(root);</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">    }<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;lchild==<span class="literal">NULL</span>&amp;&amp;root-&gt;rchild==<span class="literal">NULL</span>){</span><br><span class="line">      root=<span class="literal">NULL</span>;</span><br><span class="line">    }<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;lchild!=<span class="literal">NULL</span>){</span><br><span class="line">      root-&gt;wegiht=root-&gt;lchild-&gt;weight;</span><br><span class="line">      root-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">      root-&gt;weight=root-&gt;rchild-&gt;weight;</span><br><span class="line">      root-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">  }<span class="keyword">else</span> <span class="keyword">if</span>(weight&lt;root-&gt;weight){</span><br><span class="line">    deletNode(root-&gt;lchild, x);</span><br><span class="line">    updateHeight(root);</span><br><span class="line">    <span class="keyword">if</span>(getBalancedFactor(root)==<span class="number">-2</span>){</span><br><span class="line">      <span class="keyword">if</span>(getBalancedFactor(root-&gt;rchild)==<span class="number">1</span>){ <span class="comment">//RL型</span></span><br><span class="line">        rightRotation(root-&gt;rchild);</span><br><span class="line">        leftRotation(root);</span><br><span class="line">      }<span class="keyword">else</span>{ <span class="comment">//RR型</span></span><br><span class="line">        leftRotation(root);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }<span class="keyword">else</span>{</span><br><span class="line">    deleteNode(root-&gt;rchild, x);</span><br><span class="line">    updateHeight(root);</span><br><span class="line">    <span class="keyword">if</span>(getBalancedFactor(root)==<span class="number">2</span>){  </span><br><span class="line">      <span class="keyword">if</span>(getBalancedFactor(root-&gt;lchild==<span class="number">-1</span>)){ <span class="comment">//LR型</span></span><br><span class="line">        leftRotation(root-&gt;lchild);</span><br><span class="line">        rightRotation(root);</span><br><span class="line">      }<span class="keyword">else</span>{ <span class="comment">//LL型</span></span><br><span class="line">        rightRotation(root);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AVL树建立"><a href="#AVL树建立" class="headerlink" title="AVL树建立"></a>AVL树建立</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">  Node* root=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    insert(root,data[i]);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="平衡二叉树的基本操作"><a href="#平衡二叉树的基本操作" class="headerlink" title="平衡二叉树的基本操作"></a>平衡二叉树的基本操作</h2><p><strong>题目描述</strong><br>平衡二叉树又称AVL树，它是一种具有平衡因子的特殊二叉排序树。平衡二叉树或者是一棵空树，或者是具有以下几条性质的二叉树：<br>1.若它的左子树不空，则左子树上所有结点的值均小于它的根节点的值；<br>2.若它的右子树不空，则右子树上所有结点的值均大于它的根节点的值；<br>3.它的左右子树也分别为平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。<br>若将二叉树上结点的平衡因子定义为该结点的左子树深度减去它的右子树的深度，则平衡二叉树上的所有结点的平衡因子只可能为-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则这棵二叉树就是不平衡的。<br>通过平衡二叉树的性质不难得知，其插入、删除、查询都操作的时间复杂度均为O(log2n)。<br>维持平衡二叉树性质的操作可以被称为旋转。其中平衡二叉树的右旋处理可以描述如下：<br>而其左旋处理与右旋正好相反，可以描述如下：<br>在本题中，读入一串整数，首先利用这些整数构造一棵平衡二叉树。另外给定多次查询，利用构造出的平衡二叉树，判断每一次查询是否成功。<br><strong>输入</strong><br>输入的第一行包含2个正整数n和k，分别表示共有n个整数和k次查询。其中n不超过500，k同样不超过500。<br>第二行包含n个用空格隔开的正整数，表示n个整数。<br>第三行包含k个用空格隔开的正整数，表示k次查询的目标。<br><strong>输出</strong><br>只有1行，包含k个整数，分别表示每一次的查询结果。如果在查询中找到了对应的整数，则输出1，否则输出0。<br>请在每个整数后输出一个空格，并请注意行尾输出换行。<br><strong>样例输入</strong><br>8 3<br>1 3 5 7 8 9 10 15<br>9 2 5<br><strong>样例输出</strong><br>1 0 1<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> weight;</span><br><span class="line">	<span class="keyword">int</span> height;</span><br><span class="line">	Node *lchild,*rchild;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Node* root)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> root-&gt;height;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateHeight</span><span class="params">(Node* root)</span></span>{</span><br><span class="line">	root-&gt;height=max(getHeight(root-&gt;lchild),getHeight(root-&gt;rchild))+<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalancedFactor</span><span class="params">(Node* root)</span></span>{</span><br><span class="line">	<span class="keyword">return</span> getHeight(root-&gt;lchild)-getHeight(root-&gt;rchild);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leftRotation</span><span class="params">(Node* &amp;root)</span></span>{</span><br><span class="line">	Node* tmp=root-&gt;rchild;</span><br><span class="line">	root-&gt;rchild=tmp-&gt;lchild;</span><br><span class="line">	tmp-&gt;lchild=root;</span><br><span class="line">	updateHeight(root);</span><br><span class="line">	updateHeight(tmp);</span><br><span class="line">	root=tmp;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rightRotation</span><span class="params">(Node* &amp;root)</span></span>{</span><br><span class="line">	Node* tmp=root-&gt;lchild;</span><br><span class="line">	root-&gt;lchild=tmp-&gt;rchild;</span><br><span class="line">	tmp-&gt;rchild=root;</span><br><span class="line">	updateHeight(root);</span><br><span class="line">	updateHeight(tmp);</span><br><span class="line">	root=tmp;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node* &amp;root,<span class="keyword">int</span> weight)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="literal">NULL</span>){</span><br><span class="line">		root=<span class="keyword">new</span> Node;</span><br><span class="line">		root-&gt;weight=weight;</span><br><span class="line">		root-&gt;height=<span class="number">1</span>;</span><br><span class="line">		root-&gt;lchild=root-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(weight&lt;root-&gt;weight){</span><br><span class="line">		insert(root-&gt;lchild,weight);</span><br><span class="line">		updateHeight(root);</span><br><span class="line">		<span class="keyword">if</span>(getBalancedFactor(root)==<span class="number">2</span>){</span><br><span class="line">			<span class="keyword">if</span>(getBalancedFactor(root-&gt;lchild)==<span class="number">1</span>){</span><br><span class="line">				rightRotation(root);</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				leftRotation(root-&gt;lchild);</span><br><span class="line">				rightRotation(root);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}<span class="keyword">else</span>{</span><br><span class="line">		insert(root-&gt;rchild,weight);</span><br><span class="line">		updateHeight(root);</span><br><span class="line">		<span class="keyword">if</span>(getBalancedFactor(root)==<span class="number">-2</span>){</span><br><span class="line">			<span class="keyword">if</span>(getBalancedFactor(root-&gt;rchild)==<span class="number">-1</span>){</span><br><span class="line">				leftRotation(root);</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				rightRotation(root-&gt;rchild);</span><br><span class="line">				leftRotation(root);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(Node* root, <span class="keyword">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(x==root-&gt;weight) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;root-&gt;weight) <span class="keyword">return</span> search(root-&gt;lchild,x);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> search(root-&gt;rchild,x);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k){</span><br><span class="line">		Node* root=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="keyword">int</span> tmp;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">			insert(root,tmp);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++){</span><br><span class="line">			<span class="keyword">int</span> tmp;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">			<span class="keyword">if</span>(search(root,tmp)) <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1></blockquote><h2 id="存储结构-3"><a href="#存储结构-3" class="headerlink" title="存储结构"></a>存储结构</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; heap;</span><br><span class="line">heap.resize(<span class="number">101</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="向下调整"><a href="#向下调整" class="headerlink" title="向下调整"></a>向下调整</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>{</span><br><span class="line">  <span class="keyword">int</span> i=low,j=i*<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span>(j&lt;=high){</span><br><span class="line">    <span class="keyword">if</span>(j&lt;high&amp;&amp;heap[j+<span class="number">1</span>]&gt;heap[j]){</span><br><span class="line">      j+=<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(heap[j]&gt;heap[i]){</span><br><span class="line">      swap(heap[i],heap[j]);</span><br><span class="line">      i=j;</span><br><span class="line">      j=i*<span class="number">2</span>;</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="keyword">int</span> n=heap.size()<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--){</span><br><span class="line">    downAdjust(i,n);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="删除堆顶元素"><a href="#删除堆顶元素" class="headerlink" title="删除堆顶元素"></a>删除堆顶元素</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTop</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="keyword">int</span> n=heap.size()<span class="number">-1</span>;</span><br><span class="line">  heap[<span class="number">1</span>]=heap[n--];</span><br><span class="line">  heap.pop_back();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--){</span><br><span class="line">    downAdjust(i,n);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="向上调整"><a href="#向上调整" class="headerlink" title="向上调整"></a>向上调整</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>{</span><br><span class="line">  <span class="keyword">int</span> i=high, j=i/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span>(j&gt;=low){</span><br><span class="line">    <span class="keyword">if</span>(heap[j]&lt;heap[i]){</span><br><span class="line">      swap(heap[i],heap[j]);</span><br><span class="line">      i=j;</span><br><span class="line">      j=i/<span class="number">2</span>;</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="插入-2"><a href="#插入-2" class="headerlink" title="插入"></a>插入</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">  heap.push_back(x);</span><br><span class="line">  upAdjust(<span class="number">1</span>,n+<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">()</span></span>{</span><br><span class="line">  createHeap();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">1</span>;i--){</span><br><span class="line">    swap(heap[<span class="number">1</span>],heap[i]);</span><br><span class="line">    downAdjust(<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="算法10-10-10-11：堆排序"><a href="#算法10-10-10-11：堆排序" class="headerlink" title="算法10-10,10-11：堆排序"></a>算法10-10,10-11：堆排序</h2><p><strong>题目描述</strong><br>堆排序是一种利用堆结构进行排序的方法，它只需要一个记录大小的辅助空间，每个待排序的记录仅需要占用一个存储空间。<br>首先建立小根堆或大根堆，然后通过利用堆的性质即堆顶的元素是最小或最大值，从而依次得出每一个元素的位置。<br>在本题中，读入一串整数，将其使用以上描述的堆排序的方法从小到大排序，并输出。<br><strong>输入</strong><br>输入的第一行包含1个正整数n，表示共有n个整数需要参与排序。其中n不超过100000。<br>第二行包含n个用空格隔开的正整数，表示n个需要排序的整数。<br><strong>输出</strong><br>只有1行，包含n个整数，表示从小到大排序完毕的所有整数。<br>请在每个整数后输出一个空格，并请注意行尾输出换行。<br><strong>样例输入</strong><br>10<br>2 8 4 6 1 10 7 3 5 9<br><strong>样例输出</strong><br>1 2 3 4 5 6 7 8 9 10<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100001</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; heap;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> i=low,j=i*<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(j&lt;=high){</span><br><span class="line">		<span class="keyword">if</span>(j&lt;high&amp;&amp;heap[j+<span class="number">1</span>]&gt;heap[j]) j++;</span><br><span class="line">		<span class="keyword">if</span>(heap[j]&gt;heap[i]){</span><br><span class="line">			swap(heap[i],heap[j]);</span><br><span class="line">			i=j;</span><br><span class="line">			j=i*<span class="number">2</span>;</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--){</span><br><span class="line">		downAdjust(i,n);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">()</span></span>{</span><br><span class="line">	createHeap();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--){</span><br><span class="line">		swap(heap[<span class="number">1</span>],heap[i]);</span><br><span class="line">		downAdjust(<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		heap.clear();</span><br><span class="line">		heap.resize(n+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;heap[i];</span><br><span class="line">		heapSort();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cout</span>&lt;&lt;heap[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="序列合并"><a href="#序列合并" class="headerlink" title="序列合并"></a>序列合并</h2><p><strong>题目描述</strong><br>有两个长度都为N的序列A和B，在A和B中各取一个数相加可以得到N2个和，求这N2个和中最小的N个。<br><strong>输入</strong><br>第一行一个正整数N（1 &lt;= N &lt;= 100000）。<br>第二行N个整数Ai，满足Ai &lt;= Ai+1且Ai &lt;= 109<br>第三行N个整数Bi，满足Bi &lt;= Bi+1且Bi &lt;= 109<br><strong>输出</strong><br>输出仅有一行，包含N个整数，从小到大输出这N个最小的和，相邻数字之间用空格隔开。<br><strong>样例输入</strong><br>3<br>2 6 6<br>1 4 8<br><strong>样例输出</strong><br>3 6 7<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; heap,heapA,heapB;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;heap,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> i=low,j=i*<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(j&lt;=high){</span><br><span class="line">		<span class="keyword">if</span>(j&lt;high&amp;&amp;heap[j+<span class="number">1</span>]&lt;heap[j]) j++;</span><br><span class="line">		<span class="keyword">if</span>(heap[j]&lt;heap[i]){</span><br><span class="line">			swap(heap[i],heap[j]);</span><br><span class="line">			i=j;</span><br><span class="line">			j=i*<span class="number">2</span>;</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;heap,<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--){</span><br><span class="line">		downAdjust(heap,i,n);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTop</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;heap,<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	heap[<span class="number">1</span>]=heap[n];</span><br><span class="line">	heap.pop_back();</span><br><span class="line">	downAdjust(heap,<span class="number">1</span>,n<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;heap, <span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;n-N;i--){</span><br><span class="line">		swap(heap[<span class="number">1</span>],heap[i]);</span><br><span class="line">		<span class="keyword">if</span>(i!=n) <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;heap[i];</span><br><span class="line">		downAdjust(heap,<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;N){</span><br><span class="line">		heap.clear();</span><br><span class="line">		heapA.clear();</span><br><span class="line">		heapB.clear();</span><br><span class="line"></span><br><span class="line">		heapA.resize(N+<span class="number">1</span>);</span><br><span class="line">		heapB.resize(N+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) <span class="built_in">cin</span>&gt;&gt;heapA[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) <span class="built_in">cin</span>&gt;&gt;heapB[i];</span><br><span class="line">		heap.push_back(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N&amp;&amp;i&lt;=<span class="number">2</span>;i++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++){</span><br><span class="line">				<span class="keyword">int</span> tmp=heapA[i]+heapB[j];</span><br><span class="line">				heap.push_back(tmp);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		createHeap(heap,heap.size()<span class="number">-1</span>);</span><br><span class="line">		heapSort(heap,heap.size()<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="合并果子（堆）"><a href="#合并果子（堆）" class="headerlink" title="合并果子（堆）"></a>合并果子（堆）</h2><p><strong>题目描述</strong><br>在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。<br>每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过n-1次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。<br>因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。<br>例如有3种果子，数目依次为1，2，9。可以先将 1、2堆合并，新堆数目为3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为 12。所以多多总共耗费体力=3+12=15。可以证明15为最小的体力耗费值。<br><strong>输入</strong><br>输入文件fruit.in包括两行，第一行是一个整数n（1 &lt;= n &lt;= 30000），表示果子的种类数。第二行包含n个整数，用空格分隔，第i个整数ai（1 &lt;= ai &lt;= 20000）是第i种果子的数目。<br><strong>输出</strong><br>输出文件fruit.out包括一行，这一行只包含一个整数，也就是最小的体力耗费值。输入数据保证这个值小于231。<br><strong>样例输入</strong><br>10<br>3 5 1 7 6 4 2 5 4 1<br><strong>样例输出</strong><br>120<br><strong>程序</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myCmp</span>{</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a,<span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span> <span class="keyword">const</span></span>{</span><br><span class="line">		<span class="keyword">return</span> a&gt;b;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,myCmp&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="keyword">int</span> tmp;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">			pq.push(tmp);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(pq.size()!=<span class="number">1</span>){</span><br><span class="line">			<span class="keyword">int</span> top=pq.top();</span><br><span class="line">			pq.pop();</span><br><span class="line">			top+=pq.top();</span><br><span class="line">			sum+=top;</span><br><span class="line">			pq.pop();</span><br><span class="line">			pq.push(top);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; heap;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> i=low,j=i*<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(j&lt;=high){</span><br><span class="line">		<span class="keyword">if</span>(j&lt;high&amp;&amp;heap[j+<span class="number">1</span>]&lt;heap[j]) j++;</span><br><span class="line">		<span class="keyword">if</span>(heap[j]&lt;heap[i]){</span><br><span class="line">			swap(heap[i],heap[j]);</span><br><span class="line">			i=j;</span><br><span class="line">			j=i*<span class="number">2</span>;</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> i=high,j=i/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&gt;=low){</span><br><span class="line">		<span class="keyword">if</span>(heap[i]&lt;heap[j]){</span><br><span class="line">			swap(heap[i],heap[j]);</span><br><span class="line">			i=j;</span><br><span class="line">			j=i/<span class="number">2</span>;</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--){</span><br><span class="line">		downAdjust(i,n);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTop</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	heap[<span class="number">1</span>]=heap[n];</span><br><span class="line">	heap.pop_back();</span><br><span class="line">	downAdjust(<span class="number">1</span>,n<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">	heap.push_back(x);</span><br><span class="line">	upAdjust(<span class="number">1</span>,heap.size()<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		heap.clear();</span><br><span class="line">		heap.resize(n+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;heap[i];</span><br><span class="line">		createHeap(heap.size()<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(heap.size()!=<span class="number">2</span>){</span><br><span class="line">			<span class="keyword">int</span> top=heap[<span class="number">1</span>];</span><br><span class="line">			deleteTop(heap.size()<span class="number">-1</span>);</span><br><span class="line">			top+=heap[<span class="number">1</span>];</span><br><span class="line">			deleteTop(heap.size()<span class="number">-1</span>);</span><br><span class="line">			insert(top);</span><br><span class="line">			sum+=top;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1></blockquote><h2 id="计算带权路径长度WPL"><a href="#计算带权路径长度WPL" class="headerlink" title="计算带权路径长度WPL"></a>计算带权路径长度WPL</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cmp</span>{</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a,<span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span><span class="keyword">const</span></span>{</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getWPL</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">  priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,Cmp&gt; pq;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    pq.push(data[i]);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(pq.size()&gt;<span class="number">1</span>){</span><br><span class="line">    <span class="keyword">int</span> top=pq.top();</span><br><span class="line">    pq.pop();</span><br><span class="line">    top+=pq.top();</span><br><span class="line">    pq.pop();</span><br><span class="line">    pq.push(top);</span><br><span class="line">    sum+=top;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">  <span class="keyword">int</span> weight;</span><br><span class="line">  <span class="keyword">int</span> pos;</span><br><span class="line">  <span class="keyword">int</span> lchild,rchild;</span><br><span class="line">  Node(){}</span><br><span class="line">  Node(<span class="keyword">int</span> w,<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r):weight(w),pos(p),lchild(l),rchild(r){}</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;tmp)<span class="keyword">const</span>{</span><br><span class="line">    <span class="keyword">return</span> weight&gt;tmp.weight;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanTree</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">  index=<span class="number">0</span>;</span><br><span class="line">  tree.clear();</span><br><span class="line">  tree.resize(<span class="number">2</span>*n<span class="number">-1</span>);</span><br><span class="line">  priority_queue&lt;Node&gt; pq;  <span class="comment">//注意与非结构体区别</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    tree[index].weight=data[i];</span><br><span class="line">    tree[index].pos=index;</span><br><span class="line">    tree[index].lchild=tree[index].rchild=<span class="number">-1</span>;</span><br><span class="line">    pq.push(tree[index++]);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">while</span>(pq.size()&gt;<span class="number">1</span>){</span><br><span class="line">    Node top1=pq.top();</span><br><span class="line">    pq.pop();</span><br><span class="line">    Node top2=pq.top();</span><br><span class="line">    pq.pop();</span><br><span class="line">    tree[index]=Node(top1.weight+top2.weight,index,top1.pos,top2.pos);</span><br><span class="line">    pq.push(tree[index++]);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanCode</span><span class="params">(<span class="keyword">int</span> i,<span class="built_in">string</span> code)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(tree[i].lchild==tree[i].rchild&amp;&amp;tree[i].lchild==<span class="number">-1</span>){  <span class="comment">//Huffman树不存在度为1的节点</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;tree[i].weight&lt;&lt;<span class="string">" : "</span>&lt;&lt;code&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//左子树</span></span><br><span class="line">  code+=<span class="string">'0'</span>;</span><br><span class="line">  HuffmanCode(tree[i].lchild,code);</span><br><span class="line">  code.erase(code.length()<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">  <span class="comment">//右子树</span></span><br><span class="line">  code+=<span class="string">'1'</span>;</span><br><span class="line">  HuffmanCode(tree[i].rchild,code);</span><br><span class="line">  code.erase(code.length()<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n){</span><br><span class="line">		<span class="keyword">int</span>* data=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">		HuffmanTree(data,n);</span><br><span class="line">		<span class="built_in">string</span> str=<span class="string">""</span>;</span><br><span class="line">		HuffmanCode(index<span class="number">-1</span>,str);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="字符串专题"><a href="#字符串专题" class="headerlink" title="字符串专题"></a>字符串专题</h1></blockquote><h2 id="字符串Hash"><a href="#字符串Hash" class="headerlink" title="字符串Hash"></a>字符串Hash</h2><h3 id="只有大写或小写字母"><a href="#只有大写或小写字母" class="headerlink" title="只有大写或小写字母"></a>只有大写或小写字母</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">  <span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++) id = id * <span class="number">26</span> + (str[i] - <span class="string">'A'</span>)</span><br><span class="line">  <span class="keyword">return</span> id;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="大小写字母混合"><a href="#大小写字母混合" class="headerlink" title="大小写字母混合"></a>大小写字母混合</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">  <span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++){</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">'A'</span>&lt;=str[i]&lt;=<span class="string">'Z'</span>) id=id*<span class="number">52</span>+(str[i]-<span class="string">'A'</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">'a'</span>&lt;=str[i]&lt;=<span class="string">'z'</span>) id=id*<span class="number">52</span>+(str[i]-<span class="string">'a'</span>)+<span class="number">26</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="大小写字母以及数字"><a href="#大小写字母以及数字" class="headerlink" title="大小写字母以及数字"></a>大小写字母以及数字</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">  <span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++){</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">'A'</span>&lt;=str[i]&lt;=<span class="string">'Z'</span>) id=id*<span class="number">62</span>+(str[i]-<span class="string">'A'</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">'a'</span>&lt;=str[i]&lt;=<span class="string">'z'</span>) id=id*<span class="number">62</span>+(str[i]-<span class="string">'a'</span>)+<span class="number">26</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">'0'</span>&lt;=str[i]&lt;=<span class="string">'9'</span>) id=id*<span class="number">62</span>+(str[i]-<span class="string">'0'</span>)+<span class="number">52</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="如果数字只出现在末尾"><a href="#如果数字只出现在末尾" class="headerlink" title="如果数字只出现在末尾"></a>如果数字只出现在末尾</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">  <span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length() - <span class="number">1</span>;i++) id = id * <span class="number">26</span> + (str[i] - <span class="string">'A'</span>)</span><br><span class="line">  id=id*<span class="number">10</span>+(str[str.length()<span class="number">-1</span>]-<span class="string">'0'</span>);</span><br><span class="line">  <span class="keyword">return</span> id;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="超长字符串Hash（只有小写字母）"><a href="#超长字符串Hash（只有小写字母）" class="headerlink" title="超长字符串Hash（只有小写字母）"></a>超长字符串Hash（只有小写字母）</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">100000019</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">hashFunc</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> H=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++){</span><br><span class="line">    H = (H*P+str[i]-<span class="string">'a'</span>) % MOD;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> H;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="求解子串Hash值H-i…j"><a href="#求解子串Hash值H-i…j" class="headerlink" title="求解子串Hash值H[i…j]"></a>求解子串Hash值H[i…j]</h3><p>$$<br>H[i] = H[i-1] × p + index(str[i])\\<br>H[i] = index(str[i]) × p^{j-i} + index(str[i+1]) × p^{j-i-1} +…+index(str[j]) × p^{0}<br>$$<br>$$<br>\begin{align}<br>H[j] &amp; = H[j-1] × p + index(str[j])\\<br>&amp; = H[j-2] × p^{2} + index(str[j-1]) × p + index(str[j])\\<br>&amp; = …\\<br>&amp; = H[i-1] × p^{j-i+1} +H[i…j]\\<br>\end{align}<br>$$<br>$$<br>So: H[i…j] = H[j] - H[i-1] × p^{j-i+1} \\<br>= \left(H[j] - H[i-1] × p^{j-i+1}\right)　% mod \\<br>= \left(\left(H[j] - H[i-1] × p^{j-i+1}\right)　% mod + mod \right) % mod<br>$$</p><h3 id="输入两个长度均不超过1000的字符串，求它们的最长公共子串的长度"><a href="#输入两个长度均不超过1000的字符串，求它们的最长公共子串的长度" class="headerlink" title="输入两个长度均不超过1000的字符串，求它们的最长公共子串的长度"></a>输入两个长度均不超过1000的字符串，求它们的最长公共子串的长度</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> LL MOD = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> LL P = <span class="number">10000019</span></span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">1010</span>;</span><br><span class="line">LL powP[MAXN], H1[MAXN] ={<span class="number">0</span>}, H2[MAXN]={<span class="number">0</span>};</span><br><span class="line"><span class="built_in">vector</span>&lt;&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; pr1, pr2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> len)</span></span>{</span><br><span class="line">  powP[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++){</span><br><span class="line">    powP[i] = (powP[i<span class="number">-1</span>] * P) % MOD;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calH</span><span class="params">(LL H[], <span class="built_in">string</span> &amp;str)</span></span>{</span><br><span class="line">  H[<span class="number">0</span>] = str[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;str.length();i++){</span><br><span class="line">    H[i]=(H[i<span class="number">-1</span>] * P + str[i]) %MOD;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calSingleSubH</span><span class="params">(LL H[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(i==<span class="number">0</span>) reutrn H[j];</span><br><span class="line">  <span class="keyword">return</span> ((H[j] - H[i<span class="number">-1</span>] * powP[j-i+<span class="number">1</span>]) % MOD + MOD) % MOD;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calSubH</span><span class="params">(LL H[], <span class="keyword">int</span> len, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; &amp;pr)</span></span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++){</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;len;j++){</span><br><span class="line">      <span class="keyword">int</span> hashValue=calSingleSubH(H, i, j);</span><br><span class="line">      pr.push_back(make_pair(hashValue, j-i+<span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pr1.size();i++){</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;pr2.size();j++){</span><br><span class="line">      <span class="keyword">if</span>(pr1[i].first==pr2[j].first){</span><br><span class="line">        ans=max(ans, pr1[i].second);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="built_in">string</span> str1, str2;</span><br><span class="line">  getline(<span class="built_in">cin</span>, str1);</span><br><span class="line">  getline(<span class="built_in">cin</span>, str2);</span><br><span class="line">  init(max(str1.length(), str2.length()));</span><br><span class="line">  calH(H1, str1);</span><br><span class="line">  calH(H2, str2);</span><br><span class="line">  calSubH(H1, str1.length(), pr1);</span><br><span class="line">  calSubH(H2, str2.length(), pr2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ans = %d\n"</span>, getMax());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>KMP算法主要用于解决字符串的匹配问题。即给定两个字符串text与pattern,需要判断pattern是否是text的子串。假设text的长度为n,pattern的长度为m,那么用暴力搜索的算法解决该问题需要的时间复杂度为O(m*n)。这种算法在m,n大于$10^5$级别是无法被接受。而KMP算法需要的时间复杂度仅为$O(m+n)$。</p><h3 id="Next数组-O-left-N-right"><a href="#Next数组-O-left-N-right" class="headerlink" title="Next数组 $O\left(N\right)$"></a>Next数组 $O\left(N\right)$</h3><p><strong>定义：next[i] 表示使该字符串的子串s[0···i]的前缀s[0···k]和后缀s[i-k···i]相等的最大k(其中k&lt;i，因为前后缀可以重合但不能为整个子串)</strong>；如果找不到相等的前后缀组，那么next[i] = -1。<br>也就是说，<strong>next[i]就是所求最长相等前后缀中前缀最后一位的下标！</strong><br>以字符串s = “ababaab”为例，其对应的next数组为[-1,-1,0,1,2,3,-1]。</p><ul><li>当i = 0: 子串为”a”，找不到相等的前后缀（因为前后缀不能包含整个s[i])，因此next[0] = -1;</li><li>当i = 1: 子串为”ab”，找不到相等的前后缀，因此next = -1；</li><li>当i = 2: 子串为”aba”， k = 0时 “a” = “a”; k = 1时，”ab” != “ba”;因此next[2] = 0;<br>依次类推可得到整个next数组。</li></ul><p><strong>Next数组计算：</strong><br>那么如何求解next数组呢？当然暴力的做法是可行的，但不够高效。下面用“递推”的方式来高效求解next数组，即假设已经求出了next[0]…next[i-1]，现在要用它们来退出next[i]。</p><p>以“abababc”为例，next数组为[1,-1,0,1,2,3,-1]。<br>假设已经有了next[0…3]，求next[4]<br><img src="/assets/img/algorithm/KMP_01.png" alt="image"></p><ul><li>①如果s[i]==s[j+1],则next[i]=j+1;</li><li>②否则，j=next[j],回到①，一直到①满足或者j==-1时停止。<br>①②的前提是前后缀s[i-j…i]与s[0…j]相等，</li><li>①的思想好理解，如果s[i]==s[j+1]，，那么增加；</li><li>②的思想是，s[i]!=s[j+1]，那么回退j，但是希望j尽可能大，那么当然希望取s[i-j…i]这一段的最长前后缀了！然后比较s[i]与s[j+1]，如果还不相等继续回退，直到j==-1或者s[i]==s[j+1]为止。<strong>所以从这个角度将，next数组的意义就是当j+1适配是，j应当回退的位置！</strong><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">getNext</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">  <span class="keyword">int</span> len=str.length();</span><br><span class="line">  <span class="keyword">int</span>* next=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">  next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> j=next[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++){</span><br><span class="line">    <span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;str[i]!=str[j+<span class="number">1</span>]){<span class="comment">//回退</span></span><br><span class="line">      j=next[j];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(str[i]==str[j+<span class="number">1</span>]){</span><br><span class="line">      j++;</span><br><span class="line">    }</span><br><span class="line">    next[i]=j;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure> 时间复杂度分析：<br>首先i肯定是$O(n)$的，那么j呢?注意到j只在一个地方增加，最多增加n次，而j在while中的减小最多只能减少n次。因此整个过程中j最多执行n次，那么j也是$O(n)$的，所以整体复杂度$O(n)$<h3 id="KMP算法-O-left-N-M-right"><a href="#KMP算法-O-left-N-M-right" class="headerlink" title="KMP算法 $O\left(N+M\right)$"></a>KMP算法 $O\left(N+M\right)$</h3>KMP算法与next数组的过程十分相似，具体过程如下</li><li>①初始化j=-1，表示pattern当前已被匹配的最后位；</li><li>②让i遍历文本串text，对每个i，执行③④来试图匹配text[i]和pattern[j+1]；</li><li>③不断令j=next[j]，直到j回退为-1，或是text[i]==pattern[j+1]成立；</li><li>④如果text[i]==pattern[j+1]，则令j++。如果j达到了m-1，说明pattern是text的子串。<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> text, <span class="built_in">string</span> pattern)</span></span>{</span><br><span class="line">  <span class="keyword">int</span> n=text.length(), m =pattern.length();</span><br><span class="line">  <span class="keyword">int</span>* next=getNext(pattern);</span><br><span class="line">  <span class="keyword">int</span> j=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    <span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;text[i]!=pattern[j+<span class="number">1</span>]){</span><br><span class="line">      j=next[j];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(text[i]==pattern[j+<span class="number">1</span>]){</span><br><span class="line">      j++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(j==m<span class="number">-1</span>){</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="匹配次数"><a href="#匹配次数" class="headerlink" title="匹配次数"></a>匹配次数</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> text, <span class="built_in">string</span> pattern)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n = text.length(), m =pattern.length();</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span>* next = getNext(pattern);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">		<span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;text[i]!=pattern[j+<span class="number">1</span>]){</span><br><span class="line">			j=next[j];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(text[i]==pattern[j+<span class="number">1</span>]){</span><br><span class="line">			j++;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(j==m<span class="number">-1</span>){ <span class="comment">//相等时回退</span></span><br><span class="line">			ans++;</span><br><span class="line">			j=next[j];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Nextval数组"><a href="#Nextval数组" class="headerlink" title="Nextval数组"></a>Nextval数组</h3>进一步优化next数组，因为当s[j+1]!=s[i]时，如果j=next[j]回退操作还是使得s[i]==s[j+1]，那么没有意义，一个想法是继续回退，但还是存在若干无意义的回退，这里需要修改next数组的含义进行一次回退，即nextval[i]表示当模式串pattern的i+1为失配时，i应当回退到的最佳位置。</li><li>在next记得的next[i]的位置j的基础上，进行优化</li><li>如果j==-1（不需要回退）或者pattern[i+1]!=pattern<a href="">j+1</a><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">getNextval</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">  <span class="keyword">int</span> len=str.length();</span><br><span class="line">  <span class="keyword">int</span>* nextval=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">  nextval[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> j=nextval[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++){</span><br><span class="line">    <span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;str[i]!=str[j+<span class="number">1</span>]){</span><br><span class="line">      j=next[j];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(str[i]==str[j+<span class="number">1</span>]){</span><br><span class="line">      j++;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//不用判断i+1是否超过了len-1，因为从nextval的含义上讲，如果i已经是模式串pattern的最后一位，那么i+1位失配的说法没有意义</span></span><br><span class="line">    <span class="comment">//其次s[len]=='\0'，且j一定小于i，因此一定会失配。</span></span><br><span class="line">    <span class="keyword">if</span>(j==<span class="number">-1</span>||str[i+<span class="number">1</span>]!=str[j+<span class="number">1</span>]){ <span class="comment">//此时回退是无意义的</span></span><br><span class="line">      nextval[i]=j;</span><br><span class="line">    }<span class="keyword">else</span> nextval[i]=nextval[j]; <span class="comment">//此时需要再次回退，因为str[i+1]==str[j+1]，即下一次匹配i与j+1时失配了，回退！因为希望下一次得到的就是最佳位置。</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> nextval;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="问题-A-动物简介-animal"><a href="#问题-A-动物简介-animal" class="headerlink" title="问题 A: 动物简介(animal)"></a>问题 A: 动物简介(animal)</h3></li></ul><p><strong>题目描述</strong><br>到了动物园，琦琦开心得跳起来。哗，这里好多动物呀，有老虎，有狮子……，在开心之余，琦琦也不忘妈妈的教导：观察动物时要认真仔细，还要看动物园附上的动物简介呀。动物的简介原来还有英文版的呢！为了卖弄自己的英文水平，琦琦就告诉妈妈每张动物简介里出现了多少次该动物的名称。注意：琦琦只认识小写字母，而且她只认得动物的单词，因此她认为monkeys或者smonkey或者smonkeys都是出现了monkey这个词。<br>你能编程完成琦琦的任务吗？<br><strong>输入</strong><br>输入文件共n+2行：<br>第1行为数字n（n&lt;=3000），表示该动物的简介共有n行。<br>第2行为一个单词，表示琦琦认识的动物名称。<br>接着是n行，每行为一个长度小于250个字符的字符串，表示动物的简介。<br><strong>输出</strong><br>　输出文件共1行，为简介里出现了多少次琦琦能识别出的动物的单词。<br><strong>样例输入</strong><br>2<br>snake<br>The snake is a long and thin animal.<br>Snakes have no legs or feet.<br><strong>样例输出</strong><br>1</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">251</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> pattern, text;</span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">getNextval</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> len=str.length();</span><br><span class="line">	<span class="keyword">int</span>* nextval=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">	nextval[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> j=nextval[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++){</span><br><span class="line">		<span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;str[i]!=str[j+<span class="number">1</span>]){</span><br><span class="line">			j=nextval[j];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(str[i]==str[j+<span class="number">1</span>]) j++;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">-1</span>||str[i+<span class="number">1</span>]!=str[j+<span class="number">1</span>]) nextval[i]=j;</span><br><span class="line">		<span class="keyword">else</span> nextval[i]=nextval[j];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> nextval;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> text, <span class="built_in">string</span> pattern)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n=text.length(), m=pattern.length();</span><br><span class="line">	<span class="keyword">int</span>* nextval=getNextval(pattern);</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">		<span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;text[i]!=pattern[j+<span class="number">1</span>]){</span><br><span class="line">			j=nextval[j];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(text[i]==pattern[j+<span class="number">1</span>]) j++;</span><br><span class="line">		<span class="keyword">if</span>(j==m<span class="number">-1</span>){</span><br><span class="line">			ans++;</span><br><span class="line">			j=nextval[j];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">delete</span> [] nextval;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	getchar();</span><br><span class="line">	getline(<span class="built_in">cin</span>,pattern);</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">		getline(<span class="built_in">cin</span>,text);</span><br><span class="line">		ans+=KMP(text,pattern);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="问题-B-P2-统计单词数"><a href="#问题-B-P2-统计单词数" class="headerlink" title="问题 B: P2 统计单词数"></a>问题 B: P2 统计单词数</h3><p><strong>题目描述</strong><br>统计单词数 (stat.cpp/c/pas)<br>一般的文本编辑器都有查找单词的功能，该功能可以快速定位特定单词在文章中的位置，有的还能统计出特定单词在文章中的次数。<br>现在，请你编程实现这一功能，具体要求是：给定一个单词，请你输出它在给定的文章中出现的次数和第一次出现的位置。注意：匹配单词时，不区分大小写，但要求完全匹配，即单词必须与文章中某一独立残次在不区分大小写的情况下完全相同（参见样例1），如果给定单词仅是文章中某一单词的一部分则不算匹配（参见样例2）。<br><strong>输入</strong><br>输入文件共2行。<br>第1行为一个字符串，其中只包含字母，表示给定单词；<br>第2行为一个字符串，其中只可能包含字母和空格，表示给定的文章。<br><strong>输出</strong><br>只有1行，如果在文章中找到给定单词则输出两个整数，两个整数之间用一个空格隔开，分别是单词在文章中出现的次数和第一次出现的位置（即在文章中第一次出现时，单词首字母在文章中的位置，位置从0开始）；如果单词在文章中没有出现，则直接输出一个整数-1。<br><strong>样例输入</strong><br>输入样例1：<br>To<br>to be or not to be is a question<br>输入样例2：<br>to<br>Did the Ottoman Empire lose its power at that time<br><strong>样例输出</strong><br>输出样例1：<br>2 0<br>输出样例2：<br>-1</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> pattern, text;</span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">getNextval</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> len=str.length();</span><br><span class="line">	<span class="keyword">int</span>* nextval=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">	nextval[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> j=nextval[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++){</span><br><span class="line">		<span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;str[i]!=str[j+<span class="number">1</span>]){</span><br><span class="line">			j=nextval[j];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(str[i]==str[j+<span class="number">1</span>]){</span><br><span class="line">			j++;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">-1</span>||str[i+<span class="number">1</span>]!=str[j+<span class="number">1</span>]) nextval[i]=j;</span><br><span class="line">		<span class="keyword">else</span> nextval[i]=nextval[j];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> nextval;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> text, <span class="built_in">string</span> pattern, <span class="keyword">int</span> &amp;idx)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n=text.length(), m=pattern.length();</span><br><span class="line">	<span class="keyword">int</span>* nextval=getNextval(pattern);</span><br><span class="line">	<span class="keyword">bool</span> bFirst=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">		<span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;text[i]!=pattern[j+<span class="number">1</span>]){</span><br><span class="line">			j=nextval[j];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(text[i]==pattern[j+<span class="number">1</span>]) j++;</span><br><span class="line">		<span class="keyword">if</span>(j==m<span class="number">-1</span>){</span><br><span class="line">			<span class="keyword">if</span>(((i&lt;n<span class="number">-1</span>&amp;&amp;text[i+<span class="number">1</span>]==<span class="string">' '</span>)||i==n<span class="number">-1</span>)</span><br><span class="line">				&amp;&amp;((i-m&gt;<span class="number">0</span>&amp;&amp;text[i-m]==<span class="string">' '</span>)||i-m+<span class="number">1</span>==<span class="number">0</span>)){</span><br><span class="line">				ans++;</span><br><span class="line">				<span class="keyword">if</span>(bFirst){</span><br><span class="line">					bFirst=<span class="literal">false</span>;</span><br><span class="line">					idx=i-m+<span class="number">1</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			j=nextval[j];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> &amp;str)</span></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++){</span><br><span class="line">		<span class="keyword">if</span>(<span class="string">'a'</span>&lt;=str[i]&amp;&amp;str[i]&lt;=<span class="string">'z'</span>) str[i]-=<span class="string">'a'</span>-<span class="string">'A'</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	getline(<span class="built_in">cin</span>, pattern);</span><br><span class="line">	getline(<span class="built_in">cin</span>, text);</span><br><span class="line">	convert(pattern);</span><br><span class="line">	convert(text);</span><br><span class="line">	<span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ans=KMP(text, pattern, idx);</span><br><span class="line">	<span class="keyword">if</span>(ans!=<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">" "</span>&lt;&lt;idx&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="问题-C-剪花布条"><a href="#问题-C-剪花布条" class="headerlink" title="问题 C: 剪花布条"></a>问题 C: 剪花布条</h3><p><strong>题目描述</strong><br>一块花布条，里面有些图案，另有一块直接可用的小饰条，里面也有一些图案。对于给定的花布条和小饰条，计算一下能从花布条中尽可能剪出几块小饰条来呢？<br><strong>输入</strong><br>输入中含有一些数据，分别是成对出现的花布条和小饰条，其布条都是用可见ASCII字符表示的，可见的ASCII字符有多少个，布条的花纹也有多少种花样。花纹条和小饰条不会超过1000个字符长。如果遇见#字符，则不再进行工作。<br><strong>输出</strong><br>输出能从花纹布中剪出的最多小饰条个数，如果一块都没有，那就老老实实输出0，每个结果之间应换行。<br><strong>样例输入</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abcde a3</span><br><span class="line">aaaaaa  aa</span><br><span class="line">#</span><br></pre></td></tr></tbody></table></figure><p><strong>样例输出</strong><br>0<br>3</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> text, pattern;</span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">getNextval</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> len=str.length();</span><br><span class="line">	<span class="keyword">int</span>* nextval=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">	nextval[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> j=nextval[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++){</span><br><span class="line">		<span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;str[i]!=str[j+<span class="number">1</span>]){</span><br><span class="line">			j=nextval[j];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(str[i]==str[j+<span class="number">1</span>]) j++;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">-1</span>||str[i+<span class="number">1</span>]!=str[j+<span class="number">1</span>]) nextval[i]=j;</span><br><span class="line">		<span class="keyword">else</span> nextval[i]=nextval[j];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> nextval;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> text, <span class="built_in">string</span> pattern)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n=text.length(), m=pattern.length();</span><br><span class="line">	<span class="keyword">int</span>* nextval=getNextval(pattern);</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">		<span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;text[i]!=pattern[j+<span class="number">1</span>]){</span><br><span class="line">			j=nextval[j];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(text[i]==pattern[j+<span class="number">1</span>]){</span><br><span class="line">			j++;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(j==m<span class="number">-1</span>){</span><br><span class="line">			ans++;</span><br><span class="line">			j=<span class="number">-1</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;text&amp;&amp;text!=<span class="string">"#"</span>){</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;pattern;</span><br><span class="line">		<span class="keyword">int</span> ans=KMP(text, pattern);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="最长回文串"><a href="#最长回文串" class="headerlink" title="最长回文串"></a>最长回文串</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：<br>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。</p><p>示例 2：<br>输入: “cbbd”<br>输出: “bb”</p><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><p>设DP[i][j]为[i,j]是否为回文串，是为1，否为0；<br>状态转移方程：DP[i][j]=DP[i+1][j-1]&amp;(s[i]==s[j])<br>时间复杂度：$O(n^2)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; DP;</span><br><span class="line">        DP.resize(n);</span><br><span class="line">        <span class="keyword">int</span> maxLen=<span class="number">1</span>, l=<span class="number">0</span>, r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            DP[i].resize(n, <span class="number">0</span>);</span><br><span class="line">            DP[i][i]=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++){</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[i+<span class="number">1</span>]){</span><br><span class="line">                DP[i][i+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(maxLen==<span class="number">1</span>){</span><br><span class="line">                    maxLen=<span class="number">2</span>;</span><br><span class="line">                    l=i;</span><br><span class="line">                    r=i+<span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">3</span>;len&lt;=n;len++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+len<span class="number">-1</span>&lt;n;i++){</span><br><span class="line">                <span class="keyword">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j]) DP[i][j]=DP[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(DP[i][j]==<span class="number">1</span>&amp;&amp;len&gt;maxLen){</span><br><span class="line">                    maxLen=len;</span><br><span class="line">                    l=i;</span><br><span class="line">                    r=j;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// cout&lt;&lt;l&lt;&lt;" "&lt;&lt;maxLen&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span> s.substr(l, maxLen);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="中心扩展法"><a href="#中心扩展法" class="headerlink" title="中心扩展法"></a>中心扩展法</h3><p><img src="/assets/img/algorithm/Palindrome_01.jpg" alt="image"><br>由于存在奇数的回文串和偶数的回文串，所以需要从一个字符开始扩展或者从两个字符之间进行扩展。<br>时间复杂度：$O(n^2)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">int</span> start, end;</span><br><span class="line">        start=end=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p1=expandAroundCenter(s, i, i);</span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p2=expandAroundCenter(s, i, i+<span class="number">1</span>);</span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p;</span><br><span class="line">            <span class="keyword">if</span>(p1.second-p1.first&gt;=p2.second-p2.first) p=p1;</span><br><span class="line">            <span class="keyword">else</span> p=p2;</span><br><span class="line">            <span class="keyword">if</span>(p.second-p.first&gt;end-start){</span><br><span class="line">                start=p.first;</span><br><span class="line">                end=p.second;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, end-start+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; expandAroundCenter(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right){</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;n&amp;&amp;s[left]==s[right]){</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> {++left, --right};</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="马拉车算法（Manacher’s-Algorithm）"><a href="#马拉车算法（Manacher’s-Algorithm）" class="headerlink" title="马拉车算法（Manacher’s Algorithm）"></a>马拉车算法（Manacher’s Algorithm）</h3><p>（1）首先对原始字符串用其不包含的字符进行扩充，例如用’#’，得到的字符串长度一定为奇数<br>（2）其次设P[i]为处理后的串的每个字符对应的以i为中心的回文串长度，其在原始字符串的起始坐标为(i-P[i])/2<br>（3）利用对称性，更新P[i]、R、C。详见参考：<br><a href="https://www.cxyxiaowu.com/2665.html" target="_blank" rel="noopener">参考链接</a><br>时间复杂度：$O(n)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="built_in">string</span> str=addBoundaries(s, <span class="string">'#'</span>);</span><br><span class="line">        n=str.length();</span><br><span class="line">        <span class="keyword">int</span> P[n];</span><br><span class="line">        <span class="built_in">memset</span>(P, <span class="number">0</span>, <span class="keyword">sizeof</span>(P));</span><br><span class="line">        <span class="keyword">int</span> R=<span class="number">0</span>,C=<span class="number">0</span>; <span class="comment">//右边界与中心点,R=C+P[C],P[i]表示以i为中心点的原始回文串长度，也可以表示处理后的字符串的以i为中心的回文串半径，处理后的字符串长度一定为奇数</span></span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>, end=<span class="number">0</span>; <span class="comment">//最长回文串的起始位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i&lt;R){</span><br><span class="line">                <span class="keyword">int</span> i_mirror = <span class="number">2</span> * C - i;<span class="comment">//i关于center对承德店i_mirror</span></span><br><span class="line">                <span class="comment">//P[i_mirror]的三种情况</span></span><br><span class="line">                <span class="comment">//①P[i_mirror]&lt;R-i,P[i]=P[i_mirror],无需扩展</span></span><br><span class="line">                <span class="comment">//②P[i_mirror]=R-i,P[i]=P[i_mirror]，需要扩展</span></span><br><span class="line">                <span class="comment">//③P[i_mirror]&gt;R-i，P[i]=R-i，无需扩展</span></span><br><span class="line">                <span class="comment">//min精髓，当然后面还要考虑是否中心扩展</span></span><br><span class="line">                P[i]=min(R-i, P[i_mirror]);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> left=i-P[i]<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> right=i+P[i]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;n&amp;&amp;str[left]==str[right]){</span><br><span class="line">                P[i]++;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(i+P[i]&gt;R){ <span class="comment">//更新R,C</span></span><br><span class="line">                R=i+P[i];</span><br><span class="line">                C=i;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(P[i]&gt;end-start+<span class="number">1</span>){</span><br><span class="line">                start=(i-P[i])/<span class="number">2</span>; <span class="comment">//起始点关系</span></span><br><span class="line">                end=start+P[i]<span class="number">-1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, end-start+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBoundaries</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">char</span> divide)</span></span>{ <span class="comment">//分隔符divide必须是字符串中未出现的字符</span></span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            res+=divide;</span><br><span class="line">            res+=s[i];</span><br><span class="line">        }</span><br><span class="line">        res+=divide;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="专题扩展"><a href="#专题扩展" class="headerlink" title="专题扩展"></a>专题扩展</h1></blockquote><h2 id="分块思想"><a href="#分块思想" class="headerlink" title="分块思想"></a>分块思想</h2><p>假设一个非负整数序列$A$，元素个数为$N$（$N\leq 10^{5},A[i]\leq 10^{5}$），随时可能添加和删除元素的情况下，实时查询元素第K大的元素<br>思路：<br>将序列分为$\lceil\sqrt{N}\rceil$块，每块$\lfloor\sqrt{N}\rfloor$个元素，设置一个hash数组table[100001]，其中table[x]表示整数x的当前存在个数<br>设置一个统计数组block[317]，其中block[i]表示第i块中存在的元素的个数：<br>block[0]:0…315<br>block[1]:316…631<br>…<br>block[316]:99856…100000<br>新增元素：table[x]++, block[x/316]++<br>删除元素：table[x]–, block[x/316]]–<br>查找第N大元素，先确定块号，以及能否达到个数N，如果能，块号i，则从i*316开始在table开始从小达到找<br>时间复杂度$O\left(\sqrt{N}\right)$</p><h3 id="A1057-Stack-30"><a href="#A1057-Stack-30" class="headerlink" title="A1057 Stack(30)"></a>A1057 Stack(30)</h3><p><strong>Description</strong><br>Stack is one of the most fundamental data structures, which is based on the principle of Last In First Out (LIFO). The basic operations include Push (inserting an element onto the top position) and Pop (deleting the top element). Now you are supposed to implement a stack with an extra operation: PeekMedian – return the median value of all the elements in the stack. With N elements, the median value is defined to be the (N/2)-th smallest element if N is even, or ((N+1)/2)-th if N is odd.<br><strong>Input Specification</strong><br>Each input file contains one test case. For each case, the first line contains a positive integer N ($≤10^{5}$). Then N lines follow, each contains a command in one of the following 3 formats:<br>Push key<br>Pop<br>PeekMedian<br>where key is a positive integer no more than $10^{5}$.<br><strong>Output Specification</strong><br>For each Push command, insert key into the stack and output nothing. For each Pop or PeekMedian command, print in a line the corresponding returned value. If the command is invalid, print Invalid instead.<br><strong>Sample Input</strong><br>17<br>Pop<br>PeekMedian<br>Push 3<br>PeekMedian<br>Push 2<br>PeekMedian<br>Push 1<br>PeekMedian<br>Pop<br>Pop<br>Push 5<br>Push 4<br>PeekMedian<br>Pop<br>Pop<br>Pop<br>Pop<br><strong>Sample Output</strong><br>Invalid<br>Invalid<br>3<br>2<br>2<br>1<br>2<br>4<br>4<br>5<br>3<br>Invalid<br><strong>Procedure</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SQRN=<span class="number">316</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="keyword">int</span> block[SQRN];</span><br><span class="line"><span class="keyword">int</span> table[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">peekMedian</span><span class="params">(<span class="keyword">int</span> K)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(sum+block[idx]&lt;K){</span><br><span class="line">		sum+=block[idx++];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">int</span> num=idx*SQRN;</span><br><span class="line">	<span class="keyword">while</span>(sum+table[num]&lt;K){</span><br><span class="line">		sum+=table[num++];</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">	st.push(x);</span><br><span class="line">	block[x / SQRN] ++;</span><br><span class="line">	table[x]++;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> x=st.top();</span><br><span class="line">	st.pop();</span><br><span class="line">	block[x /SQRN]--;</span><br><span class="line">	table[x]--;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> x, query;</span><br><span class="line">	<span class="built_in">memset</span>(block, <span class="number">0</span>, <span class="keyword">sizeof</span>(block));</span><br><span class="line">	<span class="built_in">memset</span>(table, <span class="number">0</span>, <span class="keyword">sizeof</span>(table));</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;query;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;query;i++){</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line">		<span class="keyword">if</span>(str==<span class="string">"Push"</span>){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">			Push(x);</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">if</span>(str==<span class="string">"Pop"</span>){</span><br><span class="line">			<span class="keyword">if</span>(st.empty()){</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"Invalid"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			}<span class="keyword">else</span> Pop();</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">if</span>(str==<span class="string">"PeekMedian"</span>){</span><br><span class="line">			<span class="keyword">if</span>(st.empty()) <span class="built_in">cout</span>&lt;&lt;<span class="string">"Invalid"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">else</span>{</span><br><span class="line">				<span class="keyword">int</span> K=st.size();</span><br><span class="line">				<span class="keyword">if</span>(K%<span class="number">2</span>==<span class="number">0</span>) K/=<span class="number">2</span>;</span><br><span class="line">				<span class="keyword">else</span> K=(K+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">				peekMedian(K);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>由于计算机中存储整数一般采用补码，所以一个补码表示的整数x的相反数-x相当于把x的二进制的每一位都取反，然后末位加1。<strong>lowbit(x)=x&amp;(-x)可以理解为取x的二进制最右边的1和它右边所有0，因此其一定是2的幂次，及1、2、4、8等，其也可理解为能整除x的最大2的幂次</strong>。树状数组C，其中C[i]存放数组A中i号位之前lowbit(i)个元素之和，显然C[i]的覆盖长度是lowbit(i)，<strong>注意C[i]下标从1开始</strong></p><table><thead><tr><th align="center">i</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">…</th><th align="center">n</th></tr></thead><tbody><tr><td align="center">lowbit(i)</td><td align="center">1</td><td align="center">2</td><td align="center">1</td><td align="center">4</td><td align="center">…</td><td align="center">n&amp;(-n)</td></tr></tbody></table><p>即C[1]=A[1]<br>C[2]=A[1]+A[2]<br>C[3]=A[3]<br>C[4]=A[1]+A[2]+A[3]+A[4]<br>C[5]=A[5]<br>C[6]=A[5]+A[6]<br>C[7]=A[7]<br><strong>①设计函数getSum(x)，返回前x个数之和A[1]+…A[x]</strong><br>记：$Sum(1,x)=A[1]+…A[x]$<br>而$C[x]=A[x-lowbit(x)+1]+…+A[x]$<br>所以$Sum(1,x)=A[1]+…+A[x-lowbit(x)]+A[x-lowbit(x)+1]+…+A[x]$<br>$=Sum(1,x-lowbit(x))+C[x]$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">  <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;<span class="number">0</span>;i-=lowbit(i)){</span><br><span class="line">    sum+=C[i];</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>时间复杂度：$O\left(\log{N}\right)$<br><strong>②设计函数update(x,v)，实现将第x个数加上一个数v的功能，即A[x]+=v</strong><br>如何找到离$C[x]$最近的能覆盖$C[x]$的$C[y]$呢？<br>首先：$lowbit(y)$必须大于$lowbit(x)$，所以问题等价求一个尽可能校的整数a，使得$lowbit(x+a)&gt;lowbit(x)$，<br>而$lowbit(x)$是取二进制最右边的1的位置，因此如果$lowbit(a)&lt;lowbit(x)$，$lowbit(x+a)$就会小于$lowbit(x)$，因此$lowbit(a)$必须不小于$lowbit(x)$。<br>所以当$a$取$lowbit(x)$时，二进制进位得到$lowbit(x+a)&gt;lowbit(x)$，所以最小的a就是$lowbit(x)$。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=N;i+=lowbit(i)){</span><br><span class="line">    C[i]+=v;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>时间复杂度：$O\left(\log{N}\right)$</p><h3 id="经典应用①"><a href="#经典应用①" class="headerlink" title="经典应用①"></a>经典应用①</h3><p>给定一个有N个正整数的序列$A(N\leq 10^{5}, A[i]\leq 10^{5})$，对序列中的每个数，求出序列中它左边比它小的数的个数。<br>做法一：Hash数组，记录Hash[A[i]]++,最后统计sum=Hash[A[i]]+…+Hash[A[i]-1]，时间复杂度：$O\left(N^{2}\right)$<br>做法二：树状数组，时间复杂度：$O\left(N\log{N}\right)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100010</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(i) ((i)&amp;(-i))</span></span><br><span class="line"><span class="keyword">int</span> C[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=MAXN;i+=lowbit(i)){</span><br><span class="line">    C[i]+=v;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">  <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;<span class="number">0</span>;i-=lowbit(i)){</span><br><span class="line">    sum+=C[x];</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="keyword">int</span> n,x;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">  <span class="built_in">memset</span>(C, <span class="number">0</span>, <span class="keyword">sizeof</span>(C));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">    update(x, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;getSum(x<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如何统计元素左边比该元素大的个数，等价于求Hash[A[i]+1]+…+Hash[A[N]]，所以getSum(N)-getSum(A[i])就是答案。<br>如何统计元素右边比该元素小（或大）的个数，只需要把原始数组从右往左遍历就好了。</p><h3 id="经典应用②"><a href="#经典应用②" class="headerlink" title="经典应用②"></a>经典应用②</h3><p>$A[i]\leq N$不成立，离散化(只适用离线查询，因为需要全部数据确定后才能进行离散化)：<br>{99999999,18,666,88888}对应{4,1,2,3}</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100010</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(i) ((i)&amp;(-i))</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  <span class="keyword">int</span> pos;</span><br><span class="line">}temp[MAXN];</span><br><span class="line"><span class="keyword">int</span> A[MAXN];</span><br><span class="line"><span class="keyword">int</span> C[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;MAXN;i+=lowbit(i)){</span><br><span class="line">    C[i]+=v;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">  <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;<span class="number">0</span>;i-=lowbit(i)){</span><br><span class="line">    sum+=C[x];</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span></span>{</span><br><span class="line">  <span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">  <span class="built_in">memset</span>(C, <span class="number">0</span>, <span class="keyword">sizeof</span>(C));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;temp[i].val;</span><br><span class="line">    temp[i].pos=i;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//离散化</span></span><br><span class="line">  sort(temp, temp+n, cmp);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>||temp[i].val!=temp[i<span class="number">-1</span>].val){</span><br><span class="line">      A[temp[i].pos]=i+<span class="number">1</span>;</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">      A[temp[i].pos]=A[temp[i<span class="number">-1</span>].pos];</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    update(A[i], <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;getSum(A[i]<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="经典应用③"><a href="#经典应用③" class="headerlink" title="经典应用③"></a>经典应用③</h3><p>求序列第K大的数。<br>树状数组二分法：<br>l=1, r=MAXN，求满足$hash[1]+…+hash[i]\geq K$成立的最小i。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthElement</span><span class="params">(<span class="keyword">int</span> K)</span></span>{</span><br><span class="line">  <span class="keyword">int</span> l=<span class="number">1</span>, r=MAN, mid;</span><br><span class="line">  <span class="keyword">while</span>(l&lt;r){</span><br><span class="line">    mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(getSum(mid)&gt;=K) r=mid;</span><br><span class="line">    <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>时间复杂度：$O\left(\log^2{n}\right)$</p><h3 id="二维树状数组"><a href="#二维树状数组" class="headerlink" title="二维树状数组"></a>二维树状数组</h3><p>给定一个二维整数矩阵A，求A[1][1]~A[x][y]这个子矩阵中所有元素之和，以及给单点A[x][y]加上整数v。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> C[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v)</span></span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=MAXN;i+=lowbit(i)){</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=y;j&lt;=MAXN;j+=lowbit(j)){</span><br><span class="line">      C[i][j]+=v;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">  <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;<span class="number">0</span>;i-=lowbit(i)){</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=y;y&gt;<span class="number">0</span>;j-=lowbit(j)){</span><br><span class="line">      sum+=C[i][j];</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="区间更新，单点查询"><a href="#区间更新，单点查询" class="headerlink" title="区间更新，单点查询"></a>区间更新，单点查询</h3><p>之前都是对树状数组进行单点更新，区间查询，这里进行区间更新，单点查询<br><strong>①设计getSum(x)，返回A[x]</strong><br>C[i]不再表示这段区间的元素之和，而是表示这段区间每个数当前被加了多少。<br>例如A[5]=C[5]+C[6]+C[8]+[16]<br>A[i]的值实际上就是覆盖它的若干个“矩形”C[i]的值之和。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">  <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;MAXN;i+=lowbit(i)){</span><br><span class="line">    sum+=C[i];</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>②设计update(x, v)，将A[1]…A[x]的每个数都加上一个数v</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;<span class="number">0</span>;i-=lowbit(i)){</span><br><span class="line">    C[i]+=v;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h3><p><strong>题目描述</strong><br>食堂有N个打饭窗口，现在正到了午饭时间，每个窗口都排了很多的学生，而且每个窗口排队的人数在不断的变化。<br>现在问你第i个窗口到第j个窗口一共有多少人在排队？<br><strong>输入</strong><br>输入的第一行是一个整数T，表示有T组测试数据。<br>每组输入的第一行是一个正整数N（N&lt;=30000），表示食堂有N个窗口。<br>接下来一行输入N个正整数，第i个正整数ai表示第i个窗口最开始有ai个人排队。（1&lt;=ai&lt;=50）<br>接下来每行有一条命令，命令有四种形式：<br>(1)Add i j，i和j为正整数，表示第i个窗口增加j个人（j不超过30）；<br>(2)Sub i j，i和j为正整数，表示第i个窗口减少j个人（j不超过30）；<br>(3)Query i j，i和j为正整数，i&lt;=j，表示询问第i到第j个窗口的总人数；<br>(4)End 表示结束，这条命令在每组数据最后出现；<br>每组数据最多有40000条命令。<br><strong>输出</strong><br>对于每组输入，首先输出样例号，占一行。<br>然后对于每个Query询问，输出一个整数，占一行，表示询问的段中的总人数，这个数保持在int以内。<br><strong>样例输入</strong><br>1<br>10<br>1 2 3 4 5 6 7 8 9 10<br>Query 1 3<br>Add 3 6<br>Query 2 7<br>Sub 10 2<br>Add 6 3<br>Query 3 10<br>End<br><strong>样例输出</strong><br>Case 1:<br>6<br>33<br>59</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(i) ((i)&amp;(-i))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">30001</span>;</span><br><span class="line"><span class="keyword">int</span> C[MAXN];</span><br><span class="line"><span class="keyword">int</span> T, N, x;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;<span class="number">0</span>;i-=lowbit(i)) sum+=C[i];</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;MAXN;i+=lowbit(i)){</span><br><span class="line">		C[i]+=v;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=T;i++){</span><br><span class="line">		<span class="built_in">memset</span>(C,<span class="number">0</span>,<span class="keyword">sizeof</span>(C));</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">			update(j+<span class="number">1</span>, x);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">string</span> str;</span><br><span class="line">		<span class="keyword">int</span> a, b;</span><br><span class="line">		<span class="keyword">bool</span> bFirst=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str&amp;&amp;str!=<span class="string">"End"</span>){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">			<span class="keyword">if</span>(str==<span class="string">"Query"</span>){</span><br><span class="line">				<span class="keyword">if</span>(bFirst){</span><br><span class="line">					bFirst=<span class="literal">false</span>;</span><br><span class="line">					<span class="built_in">cout</span>&lt;&lt;<span class="string">"Case "</span>&lt;&lt;i&lt;&lt;<span class="string">":"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				}</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;getSum(b)-getSum(a<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			}<span class="keyword">else</span> <span class="keyword">if</span>(str==<span class="string">"Add"</span>){</span><br><span class="line">				update(a, b);</span><br><span class="line">			}<span class="keyword">else</span> <span class="keyword">if</span>(str==<span class="string">"Sub"</span>){</span><br><span class="line">				update(a, -b);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="最少的交换"><a href="#最少的交换" class="headerlink" title="最少的交换"></a>最少的交换</h3><p><strong>题目描述</strong><br>现在给你一个由n个互不相同的整数组成的序列，现在要求你任意交换相邻的两个数字，使序列成为升序序列，请问最少的交换次数是多少？<br><strong>输入</strong><br>输入包含多组测试数据。每组输入第一行是一个正整数n（n&lt;500000），表示序列的长度，当n=0时。<br>接下来的n行，每行一个整数a[i]（0&lt;=a[i]&lt;=999999999），表示序列中第i个元素。<br><strong>输出</strong><br>对于每组输入，输出使得所给序列升序的最少交换次数。<br><strong>样例输入</strong><br>5<br>9<br>1<br>0<br>5<br>4<br>3<br>1<br>2<br>3<br>0<br><strong>样例输出</strong><br>6<br>0</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(i) ((i)&amp;(-i))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">500010</span>;</span><br><span class="line"><span class="keyword">int</span> C[MAXN];</span><br><span class="line"><span class="keyword">int</span> A[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">int</span> pos;</span><br><span class="line">};</span><br><span class="line">Node node[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;MAXN;i+=lowbit(i)) C[i]+=v;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;<span class="number">0</span>;i-=lowbit(i)) sum+=C[i];</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span></span>{</span><br><span class="line">	<span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n!=<span class="number">0</span>){</span><br><span class="line">		<span class="built_in">memset</span>(C,<span class="number">0</span>,<span class="keyword">sizeof</span>(C));</span><br><span class="line">		<span class="built_in">memset</span>(A,<span class="number">0</span>,<span class="keyword">sizeof</span>(A));</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;node[i].val;</span><br><span class="line">			node[i].pos=i;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//离散化</span></span><br><span class="line">		sort(node, node+n,cmp);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">0</span>||node[i<span class="number">-1</span>].val!=node[i].val){</span><br><span class="line">				A[node[i].pos]=i+<span class="number">1</span>;</span><br><span class="line">			}<span class="keyword">else</span> A[node[i].pos]=A[node[i<span class="number">-1</span>].pos];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			update(A[i],<span class="number">1</span>);</span><br><span class="line">			sum+=getSum(n)-getSum(A[i]);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="/assets/img/algorithm/Trie.png" alt="image"></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>1、维护字符串集合（即字典）。<br>2、向字符串集合中插入字符串（即建树）。<br>3、查询字符串集合中是否有某个字符串（即查询）。<br>4、统计字符串在集合中出现的个数（即统计）。<br>5、将字符串集合按字典序排序（即字典序排序）。<br>6、求集合内两个字符串的LCP（Longest Common Prefix，最长公共前缀）（即求最长公共前缀）, 逆序字符串即可求后缀。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> numbers;	<span class="comment">//当前字符为字符串结尾的次数</span></span><br><span class="line">	<span class="keyword">bool</span> wordEnd;  <span class="comment">//是否为字符串结尾</span></span><br><span class="line">	Node* next[<span class="number">26</span>];</span><br><span class="line">	Node(){}</span><br><span class="line">};</span><br><span class="line"><span class="function">Node* <span class="title">newNode</span><span class="params">()</span></span>{</span><br><span class="line">	Node* node = <span class="keyword">new</span> Node();</span><br><span class="line">	node-&gt;numbers=<span class="number">0</span>;</span><br><span class="line">	node-&gt;wordEnd=<span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) node-&gt;next[i]=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(Node* root, <span class="built_in">string</span> str)</span></span>{</span><br><span class="line">	Node* node = root;</span><br><span class="line">	<span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> len=str.length();</span><br><span class="line">	<span class="keyword">while</span>(idx&lt;len){</span><br><span class="line">		<span class="keyword">if</span>(node-&gt;next[str[idx]-<span class="string">'a'</span>]==<span class="literal">NULL</span>){</span><br><span class="line">			Node* tmp=newNode();</span><br><span class="line">			node-&gt;next[str[idx]-<span class="string">'a'</span>]=tmp;</span><br><span class="line">		}</span><br><span class="line">		node=node-&gt;next[str[idx]-<span class="string">'a'</span>];</span><br><span class="line">		<span class="keyword">if</span>(idx==len<span class="number">-1</span>){</span><br><span class="line">			node-&gt;numbers++;</span><br><span class="line">			node-&gt;wordEnd=<span class="literal">true</span>;</span><br><span class="line">		}	 </span><br><span class="line">		idx++;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(Node* root, <span class="built_in">string</span> str)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> len=str.length();</span><br><span class="line">	<span class="keyword">while</span>(idx&lt;len){</span><br><span class="line">		<span class="keyword">if</span>(root-&gt;next[str[idx]-<span class="string">'a'</span>]==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		root=root-&gt;next[str[idx]-<span class="string">'a'</span>];</span><br><span class="line">		idx++;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> root-&gt;numbers;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(Node* root)</span></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++){</span><br><span class="line">		<span class="keyword">if</span>(root-&gt;next[i]!=<span class="literal">NULL</span>){</span><br><span class="line">      deleteNode(root-&gt;next[i]);</span><br><span class="line">    }</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">delete</span> root;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="comment">//	int a=1;</span></span><br><span class="line"><span class="comment">//	int b=1;</span></span><br><span class="line"><span class="comment">//	function&lt;void(int, int)&gt; fun = [=,&amp;a](int a, int b)-&gt;void{a=2;b=2;};</span></span><br><span class="line"><span class="comment">//	fun(a, b);</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;a&lt;&lt;b&lt;&lt;endl;</span></span><br><span class="line">	<span class="built_in">string</span> s1=<span class="string">"abc"</span>;</span><br><span class="line">	<span class="built_in">string</span> s2=<span class="string">"ab"</span>;</span><br><span class="line">	<span class="built_in">string</span> s3=<span class="string">"abcd"</span>;</span><br><span class="line">	Node* root=newNode();</span><br><span class="line">	create(root, s1);;</span><br><span class="line">	create(root, s2);</span><br><span class="line">	create(root, s2);</span><br><span class="line">	create(root, s3);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;search(root,s1)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;search(root,s2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;search(root,s3)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;search(root,<span class="string">"cd"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>单调栈实际上就是栈，只是利用一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。</p><p>听起来有点像堆，其实不然，单调栈用途不太广泛，只处理一种典型的问题，叫做<strong>Next Greater Element</strong>。</p><h2 id="Next-Greater-Element"><a href="#Next-Greater-Element" class="headerlink" title="Next Greater Element"></a>Next Greater Element</h2><p>一个数组，找出每个元素右边比其大的第一个元素。<br>这个问题可以抽象为：把数组每个元素想象成并列站立的人，元素值想象成身高，这些人站一列，求右边第一个挡住自己视线的人即可。<br><img src="/assets/img/algorithm/monotonous_stack_01.png" alt="image"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextGreaterElement(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums){</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(nums.size());</span><br><span class="line">  <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">    <span class="keyword">while</span>(!st.empty()&amp;&amp;st.top()&lt;nums[i]) st.pop();<span class="comment">//所有右边比当前元素小的都出栈，因为它们肯定不是</span></span><br><span class="line">    res[i]=st.empty()?<span class="number">-1</span>:st.top();</span><br><span class="line">    st.push(nums[i]); <span class="comment">//入栈</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>时间复杂度：$O(n)$ —— 总体上看，总共n个元素，每个元素最多入栈和出栈一次，所以while的总体复杂度为$O(n)$，所以整个for循环以及while总体都是$O(n)$</p><h2 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h2><p>给你一个数组 T = [73, 74, 75, 71, 69, 72, 76, 73]，这个数组存放的是近几天的天气气温（这气温是铁板烧？不是的，这里用的华氏度）。你返回一个数组，计算：对于每一天，你还要至少等多少天才能等到一个更暖和的气温；如果等不到那一天，填 0 。</p><p>举例：给你 T = [73, 74, 75, 71, 69, 72, 76, 73]，你返回 [1, 1, 4, 2, 1, 1, 0, 0]。<br>解释：第一天 73 华氏度，第二天 74 华氏度，比 73 大，所以对于第一天，只要等一天就能等到一个更暖和的气温。后面的同理。</p><p>你已经对 Next Greater Number 类型问题有些敏感了，这个问题本质上也是找 Next Greater Number，只不过现在不是问你 Next Greater Number 是多少，而是问你当前距离 Next Greater Number 的距离而已。</p><p>相同类型的问题，相同的思路，直接调用单调栈的算法模板，稍作改动就可以啦，直接上代码把。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dailyTemperatures(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T){</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(T.size());</span><br><span class="line">  <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=T.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">    <span class="keyword">while</span>(!st.empty()&amp;&amp;T[st.top()]&lt;T[i]) st.pop();</span><br><span class="line">    res[i]=st.empty()?<span class="number">0</span>:st.top()-i;</span><br><span class="line">    st.push(i);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h1></blockquote><p>「一笔画」问题与欧拉图或者半欧拉图有着紧密的联系，下面给出定义：</p><ul><li>通过图中所有边恰好一次且行遍所有顶点的通路称为欧拉通路。</li><li>通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路。</li><li>具有欧拉回路的无向图称为欧拉图。</li><li>具有欧拉通路但不具有欧拉回路的无向图称为半欧拉图。<br>如果没有保证至少存在一种合理的路径，我们需要判别这张图是否是欧拉图或者半欧拉图，具体地：</li><li>对于无向图 G，G 是欧拉图当且仅当 G 是连通的且没有奇度顶点。</li><li>对于无向图 G，G 是半欧拉图当且仅当 G 是连通的且 G 中恰有 2 个奇度顶点。</li><li>对于有向图 G，G 是欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同。</li><li>对于有向图 G，G 是半欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且</li><li>恰有一个顶点的出度与入度差为 1；</li><li>恰有一个顶点的入度与出度差为 1；</li><li>所有其他顶点的入度和出度相同。<br>注意对于每一个节点，它只有最多一个「死胡同」分支。依据前言中对于半欧拉图的描述，只有那个入度与出度差为 1 的节点会导致死胡同。</li></ul><h2 id="LeetCode-332-重新安排行程"><a href="#LeetCode-332-重新安排行程" class="headerlink" title="LeetCode 332. 重新安排行程"></a>LeetCode 332. 重新安排行程</h2><p><strong>Description</strong><br>给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 出发。<br>说明:</p><ul><li>如果存在多种有效的行程，你可以按字符自然排序返回最小的行程组合。例如，行程 [“JFK”, “LGA”] 与 [“JFK”, “LGB”] 相比就更小，排序更靠前</li><li>所有的机场都用三个大写字母表示（机场代码）。</li><li>假定所有机票至少存在一种合理的行程。</li></ul><p><strong>Example</strong><br>示例 1:<br>输入: [[“MUC”, “LHR”], [“JFK”, “MUC”], [“SFO”, “SJC”], [“LHR”, “SFO”]]<br>输出: [“JFK”, “MUC”, “LHR”, “SFO”, “SJC”]</p><p>示例 2:<br>输入: [[“JFK”,”SFO”],[“JFK”,”ATL”],[“SFO”,”ATL”],[“ATL”,”JFK”],[“ATL”,”SFO”]]<br>输出: [“JFK”,”ATL”,”JFK”,”SFO”,”ATL”,”SFO”]<br>解释: 另一种有效的行程是 [“JFK”,”SFO”,”ATL”,”JFK”,”ATL”,”SFO”]。但是它自然排序更大更靠后。<br><strong>Program</strong><br><strong>思路及算法</strong><br>关键的地方在于如何表示已经访问过的边！<br><strong>Hierholzer算法</strong> 用于在连通图中寻找欧拉路径，其流程如下：</p><ul><li>从起点出发，进行深度优先搜索。</li><li>每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。</li><li>如果没有可移动的路径，则将所在节点加入到栈中，并返回。<br>当我们顺序地考虑该问题时，我们也许很难解决该问题，因为我们无法判断当前节点的哪一个分支是「死胡同」分支。<br><img src="/assets/img/algorithm/332_fig1.png" alt="image"><br>不妨倒过来思考。我们注意到只有那个入度与出度差为 11、 的节点会导致死胡同。而该节点必然是最后一个遍历到的节点。<strong>我们可以改变入栈的规则，当我们遍历完一个节点所连的所有节点后，我们才将该节点入栈（即逆序入栈）。—— 这样就可以先将最后的路径进栈！得到的结果为逆序路径！可以发现了路径终点一定是入度比出度多1的节点！所以递归先入结果栈的肯定是终点。</strong><br><img src="/assets/img/algorithm/332_fig2.png" alt="image"><br>对于当前节点而言，从它的每一个非「死胡同」分支出发进行深度优先搜索，都将会搜回到当前节点。而从它的「死胡同」分支出发进行深度优先搜索将不会搜回到当前节点。也就是说当前节点的死胡同分支将会优先于其他非「死胡同」分支入栈。</li></ul><p>时间复杂度：$O(E\log{E})$，$E$为边数。<br>空间复杂度：$O(E)$，需要存储每条边</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, priority_queue&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;, greater&lt;<span class="built_in">string</span>&gt;&gt;&gt; Adj;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; stk;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; cur)</span></span>{</span><br><span class="line">        <span class="keyword">while</span>(Adj[cur].size()&gt;<span class="number">0</span>){</span><br><span class="line">            <span class="built_in">string</span> str=Adj[cur].top();</span><br><span class="line">            Adj[cur].pop();</span><br><span class="line">            backtracking(str);</span><br><span class="line">        }</span><br><span class="line">        stk.push_back(cur);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findItinerary(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; tickets) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; vec:tickets){</span><br><span class="line">            Adj[vec[<span class="number">0</span>]].push(vec[<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        backtracking(<span class="string">"JFK"</span>);</span><br><span class="line">        reverse(stk.begin(), stk.end());</span><br><span class="line">        <span class="keyword">return</span> stk;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="Morris中序遍历"><a href="#Morris中序遍历" class="headerlink" title="Morris中序遍历"></a>Morris中序遍历</h1></blockquote><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>Morris 中序遍历的一个重要步骤就是寻找当前节点的前驱节点，并且 Morris 中序遍历寻找下一个点始终是通过转移到right 指针指向的位置来完成的。</p><ul><li>如果当前节点没有左子树，则遍历这个点，然后跳转到当前节点的右子树。</li><li>如果当前节点有左子树，那么它的前驱节点一定在左子树上，我们可以在左子树上一直向右行走，找到当前点的前驱节点。</li><li>如果前驱节点没有右子树，就将前驱节点的 right 指针指向当前节点。这一步是为了在遍历完前驱节点后能找到前驱节点的后继，也就是当前节点。</li><li>如果前驱节点的右子树为当前节点，说明前驱节点已经被遍历过并被修改了 \rm rightright 指针，这个时候我们重新将前驱的右孩子设置为空，遍历当前的点，然后跳转到当前节点的右子树。<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* cur=root, *pre=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(cur!=<span class="literal">NULL</span>){</span><br><span class="line">  <span class="keyword">if</span>(cur-&gt;left==<span class="literal">NULL</span>){</span><br><span class="line">    <span class="comment">//print(cur-&gt;val); //已经达到左子树左端点</span></span><br><span class="line">    cur=cur-&gt;right;</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//寻找前驱节点</span></span><br><span class="line">  pre=cur-&gt;left;</span><br><span class="line">  <span class="keyword">while</span>(pre-&gt;right!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;right!=cur){ <span class="comment">//有两种可能，第一种是第一次遍历该节点pre-&gt;right==NULL, 第二种是第二次遍历该节点，pre-&gt;right=cur</span></span><br><span class="line">    pre=pre-&gt;right;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span>(pre-&gt;right==<span class="literal">NULL</span>){ <span class="comment">//第一次访问该节点</span></span><br><span class="line">    pre-&gt;right=cur;</span><br><span class="line">    cur=cur-&gt;left;</span><br><span class="line">  }<span class="keyword">else</span>{  <span class="comment">//第二次访问该节点</span></span><br><span class="line">    pre-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//print(cur-&gt;val); //cur的左子树全部遍历完成</span></span><br><span class="line">    cur=cur-&gt;right;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a>501. 二叉搜索树中的众数</h2></li></ul><p><strong>Description</strong><br>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p><p>假定 BST 有如下定义：<br>结点左子树中所含结点的值小于等于当前结点的值<br>结点右子树中所含结点的值大于等于当前结点的值<br>左子树和右子树都是二叉搜索树<br><strong>Example</strong><br>例如：<br>给定 BST [1,null,2,2],</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">2</span><br></pre></td></tr></tbody></table></figure><p>返回[2].</p><p>提示：如果众数超过1个，不需考虑输出顺序<br>进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base, count ,maxCount;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(x==base){</span><br><span class="line">            count++;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            base=x;</span><br><span class="line">            count=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(count==maxCount){</span><br><span class="line">            res.push_back(base);</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(count&gt;maxCount){</span><br><span class="line">            res.clear();</span><br><span class="line">            maxCount=count;</span><br><span class="line">            res.push_back(base);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findMode(TreeNode* root) {</span><br><span class="line">        TreeNode* cur=root, *pre=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>){ <span class="comment">//Morris中序遍历，构造树的前驱</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left==<span class="literal">NULL</span>){ <span class="comment">//左节点为空没有前驱</span></span><br><span class="line">                update(cur-&gt;val);</span><br><span class="line">                cur=cur-&gt;right;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//左子树为空，寻找前驱</span></span><br><span class="line">            pre=cur-&gt;left;</span><br><span class="line">            <span class="keyword">while</span>(pre-&gt;right!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;right!=cur){</span><br><span class="line">                pre=pre-&gt;right;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(pre-&gt;right==<span class="literal">NULL</span>){ <span class="comment">//前驱右节点指向cur</span></span><br><span class="line">                pre-&gt;right=cur;</span><br><span class="line">                cur=cur-&gt;left;</span><br><span class="line">            }<span class="keyword">else</span>{  <span class="comment">//恢复原树结构，前驱右指针置空</span></span><br><span class="line">                pre-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">                update(cur-&gt;val);</span><br><span class="line">                cur=cur-&gt;right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h1></blockquote><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>{</span></span><br><span class="line">  <span class="keyword">bool</span> isEnd;</span><br><span class="line">  <span class="keyword">int</span> cnt;</span><br><span class="line">  Trie* next[<span class="number">26</span>];</span><br><span class="line">  Trie* fail;</span><br><span class="line">  Trie(){</span><br><span class="line">    isEnd=<span class="literal">false</span>;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) next[i]=<span class="literal">NULL</span>;</span><br><span class="line">    fail=<span class="literal">NULL</span>;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line">Trie* root=<span class="keyword">new</span> Trie();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">  <span class="keyword">int</span> n=str.length();</span><br><span class="line">  <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">  Trie* cur=root;</span><br><span class="line">  <span class="keyword">while</span>(idx&lt;n){</span><br><span class="line">    <span class="keyword">int</span> pos=str[idx]-<span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">if</span>(cur-&gt;next[pos]==<span class="literal">NULL</span>) cur-&gt;next[pos]=<span class="keyword">new</span> Trie();</span><br><span class="line">    cur=cur-&gt;next[pos];</span><br><span class="line">    idx++;</span><br><span class="line">  }</span><br><span class="line">  cur-&gt;isEnd=<span class="literal">true</span>;</span><br><span class="line">  cur-&gt;cnt++;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createFailPointer</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="built_in">queue</span>&lt;Trie*&gt; q;</span><br><span class="line">  q.push(root);</span><br><span class="line">  <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">    Trie* cur=q.front();q.pop();</span><br><span class="line">    Trie* fail=cur-&gt;fail;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++){</span><br><span class="line">      Trie* son=cur-&gt;next[i];</span><br><span class="line">      <span class="keyword">if</span>(son==<span class="literal">NULL</span>) {cur-&gt;next[i]=(fail==<span class="literal">NULL</span>?cur:fail.next[i]); <span class="keyword">continue</span>;}</span><br><span class="line">      son-&gt;fail=fail==<span class="literal">NULL</span>?cur:fail-&gt;next[i];</span><br><span class="line">      q.push(son);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="built_in">string</span> str)</span></span>{</span><br><span class="line">  <span class="keyword">int</span> n=str.length();</span><br><span class="line">  Trie* cur=root;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    <span class="keyword">int</span> pos=str[i]-<span class="string">'s'</span>;</span><br><span class="line">    Trie* son=cur-&gt;next[pos];</span><br><span class="line">    <span class="keyword">while</span>(son!=root&amp;&amp;son-&gt;cnt!=<span class="number">-1</span>){</span><br><span class="line">      ans+=son-&gt;cnt; son-&gt;cnt=<span class="number">-1</span>;</span><br><span class="line">      son=son-&gt;fail; <span class="comment">//继续跳fail，因为fail是son的后缀</span></span><br><span class="line">    }</span><br><span class="line">    cur=cur-&gt;next[pos];</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="面试题-17-17-多次搜索"><a href="#面试题-17-17-多次搜索" class="headerlink" title="面试题 17.17. 多次搜索"></a>面试题 17.17. 多次搜索</h2><p><strong>Description</strong><br>给定一个较长字符串big和一个包含较短字符串的数组smalls，设计一个方法，根据smalls中的每一个较短字符串，对big进行搜索。输出smalls中的字符串在big里出现的所有位置positions，其中positions[i]为smalls[i]出现的所有位置。<br><strong>Example</strong><br>示例：<br>输入：<br>big = “mississippi”<br>smalls = [“is”,”ppi”,”hi”,”sis”,”i”,”ssippi”]<br>输出： [[1,4],[8],[],[3],[1,4,7,10],[5]]</p><p>提示：<br>0 &lt;= len(big) &lt;= 1000<br>0 &lt;= len(smalls[i]) &lt;= 1000<br>smalls的总字符数不会超过 100000。<br>你可以认为smalls中没有重复字符串。<br>所有出现的字符均为英文小写字母。<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">**<span class="number">1</span>、KMP**</span><br><span class="line">KMP多次匹配问题</span><br><span class="line">时间复杂度：$O(m*l+\sum_{i=<span class="number">1</span>}^{l}{(n_i)})$，其中$l$为smalls数组长度，$n_i$为smalls数组第i个元素的长度；</span><br><span class="line">空间复杂度：$O(\sum_{i=<span class="number">1</span>}^{l}{(n_i)})$</span><br><span class="line">```cpp</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getNext(<span class="built_in">string</span> pattern){</span><br><span class="line">        <span class="keyword">int</span> n=pattern.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(n, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;pattern[i]!=pattern[j+<span class="number">1</span>]){</span><br><span class="line">                j=next[j];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(pattern[i]==pattern[j+<span class="number">1</span>]) j++;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; multiMatch(<span class="built_in">string</span> text, <span class="built_in">string</span> pattern){</span><br><span class="line">        <span class="keyword">int</span> m=text.length(), n=pattern.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next=getNext(pattern);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;text[i]!=pattern[j+<span class="number">1</span>]){</span><br><span class="line">                j=next[j];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(text[i]==pattern[j+<span class="number">1</span>]) j++;</span><br><span class="line">            <span class="keyword">if</span>(j==n<span class="number">-1</span>){</span><br><span class="line">                res.push_back(i-n+<span class="number">1</span>);</span><br><span class="line">                j=next[j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; multiSearch(<span class="built_in">string</span> big, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; smalls) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n=smalls.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(smalls[i]==<span class="string">""</span>){</span><br><span class="line">                res.push_back({});</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            res.push_back(multiMatch(big, smalls[i]));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>2、AC自动机</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>{</span></span><br><span class="line">        <span class="keyword">int</span> cnt;</span><br><span class="line">        Trie* fail;</span><br><span class="line">        Trie* next[<span class="number">26</span>];</span><br><span class="line">        Trie(){</span><br><span class="line">            cnt=<span class="number">0</span>;</span><br><span class="line">            fail=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) next[i]=<span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    Trie* root=<span class="keyword">new</span> Trie();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> i)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> n=str.length();</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        Trie* cur=root;</span><br><span class="line">        <span class="keyword">while</span>(idx&lt;n){</span><br><span class="line">            <span class="keyword">int</span> pos=str[idx]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next[pos]==<span class="literal">NULL</span>) cur-&gt;next[pos]=<span class="keyword">new</span> Trie();</span><br><span class="line">            cur=cur-&gt;next[pos];</span><br><span class="line">            idx++;</span><br><span class="line">        }</span><br><span class="line">        cur-&gt;cnt=i+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createFailPointer</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="built_in">queue</span>&lt;Trie*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            Trie* cur=q.front();q.pop();</span><br><span class="line">            Trie* fail=cur-&gt;fail;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++){</span><br><span class="line">                Trie* son=cur-&gt;next[i];</span><br><span class="line">                <span class="keyword">if</span>(son==<span class="literal">NULL</span>) {cur-&gt;next[i]=(fail==<span class="literal">NULL</span>?cur:fail-&gt;next[i]);<span class="keyword">continue</span>;} <span class="comment">//孩子为空，调整指向</span></span><br><span class="line">                son-&gt;fail=(fail==<span class="literal">NULL</span>?cur:fail-&gt;next[i]);</span><br><span class="line">                q.push(son);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="built_in">string</span> text, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; smalls)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> n=text.length();</span><br><span class="line">        Trie* cur=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> pos=text[i]-<span class="string">'a'</span>;</span><br><span class="line">            Trie* son=cur-&gt;next[pos];</span><br><span class="line">            <span class="keyword">while</span>(son!=root){</span><br><span class="line">                <span class="keyword">if</span>(son-&gt;cnt&gt;<span class="number">0</span>){</span><br><span class="line">                    <span class="keyword">int</span> idx=son-&gt;cnt<span class="number">-1</span>;</span><br><span class="line">                    res[idx].push_back(i-smalls[idx].length()+<span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">                son=son-&gt;fail; <span class="comment">//继续跳，因为fail也是son的后缀</span></span><br><span class="line">            }</span><br><span class="line">            cur=cur-&gt;next[pos];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; multiSearch(<span class="built_in">string</span> big, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; smalls) {</span><br><span class="line">        <span class="keyword">int</span> n=smalls.size();</span><br><span class="line">        res.resize(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) insert(smalls[i], i);</span><br><span class="line">        createFailPointer();</span><br><span class="line">        query(big, smalls);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h1></blockquote><p>中心思想就是用二进制表示集合！</p><h2 id="1755-最接近目标值的子序列和"><a href="#1755-最接近目标值的子序列和" class="headerlink" title="1755. 最接近目标值的子序列和"></a>1755. 最接近目标值的子序列和</h2><p><strong>Description</strong><br>给你一个整数数组 nums 和一个目标值 goal 。<br>你需要从 nums 中选出一个子序列，使子序列元素总和最接近 goal 。也就是说，如果子序列元素和为 sum ，你需要 最小化绝对差 abs(sum - goal) 。<br>返回 abs(sum - goal) 可能的 最小值 。<br>注意，数组的子序列是通过移除原始数组中的某些元素（可能全部或无）而形成的数组。<br><strong>Example</strong><br>示例 1：<br>输入：nums = [5,-7,3,5], goal = 6<br>输出：0<br>解释：选择整个数组作为选出的子序列，元素和为 6 。<br>子序列和与目标值相等，所以绝对差为 0 。</p><p>示例 2：<br>输入：nums = [7,-9,15,-2], goal = -5<br>输出：1<br>解释：选出子序列 [7,-9,-2] ，元素和为 -4 。<br>绝对差为 abs(-4 - (-5)) = abs(1) = 1 ，是可能的最小值。</p><p>示例 3：<br>输入：nums = [1,2,3], goal = -7<br>输出：7</p><p>提示：<br>$1 &lt;= nums.length &lt;= 40$<br>$-10^7 &lt;= nums[i] &lt;= 10^7$<br>$-10^9 &lt;= goal &lt;= 10^9$<br><strong>Program</strong><br><strong>状压DP+二分</strong><br>（1）首先，需要计算所有子序列的和sum[i]=sum[i-(1&lt;&lt;j)]+nums[j]，其中(i&amp;(1&lt;&lt;j))!=0，状压DP！<br>（2）然后计算每个子序列和求abs(goal-s);<br>（3）然而，题目$n=40$，求子序列和时间复杂度：$O(n * 2^{n})$，超时，因为超过了$10^8$，但是$O(n * 2^{n/2})$可行；<br>（4）将数组分成前后各一半，分别求出前后的子序列和，最终答案只会出现在这三种情况：<br>① leftSum的某个;<br>② rightSum的某个;<br>③ leftSum与rightSum各一个的和！<br>（5）然而①②时间复杂度都是$O(\frac{n}{2})$，而③顺序遍历会是$O(n)$，还是超时；<br>（6）考虑二分，将leftSum,rightSum排序，那么：<br> i=0, j=rightSum.size()-1;<br> s=leftSum[i]+rightSum[j]<br> 如果s比goal大，j减少，否则i增加！因为如果s大，那么j后面的与i求和都会比s大！，反之，如果s小，那么i前面的与j求和只会比s小；<br> 时间复杂度:$(\log{\frac{n}{n}}+n * 2^{\frac{n}{2}})$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAbsDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> goal)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> half=n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> ls=half, rs=n-half;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; leftSum((<span class="number">1</span>&lt;&lt;ls), <span class="number">0</span>), rightSum((<span class="number">1</span>&lt;&lt;(rs)), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;ls);i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ls;j++){</span><br><span class="line">                <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;j))==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                leftSum[i]=leftSum[i-(<span class="number">1</span>&lt;&lt;j)]+nums[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;rs);i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;rs;j++){</span><br><span class="line">                <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;j))==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                rightSum[i]=rightSum[i-(<span class="number">1</span>&lt;&lt;j)]+nums[j+half];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        sort(leftSum.begin(), leftSum.end());</span><br><span class="line">        sort(rightSum.begin(), rightSum.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:leftSum) res=min(res, <span class="built_in">abs</span>(goal-x));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:rightSum) res=min(res, <span class="built_in">abs</span>(goal-x));</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=rightSum.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;leftSum.size()&amp;&amp;j&gt;=<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">int</span> s=leftSum[i]+rightSum[j];</span><br><span class="line">            res=min(res, <span class="built_in">abs</span>(goal-s));</span><br><span class="line">            <span class="keyword">if</span>(s&gt;goal) j--;</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="526-优美的排列"><a href="#526-优美的排列" class="headerlink" title="526. 优美的排列"></a>526. 优美的排列</h2><p><strong>Description</strong><br>假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 &lt;= i &lt;= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：</p><p>第 i 位的数字能被 i 整除<br>i 能被第 i 位上的数字整除<br>现在给定一个整数 N，请问可以构造多少个优美的排列？<br><strong>Example</strong><br>示例1:<br>输入: 2<br>输出: 2<br>解释:<br>第 1 个优美的排列是 [1, 2]:<br> 第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除<br> 第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除</p><p>第 2 个优美的排列是 [2, 1]:<br> 第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除<br> 第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除<br>说明:<br>N 是一个正整数，并且不会超过15。<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(s==n){</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="keyword">if</span>(!vis[i]){</span><br><span class="line">                <span class="keyword">if</span>(((s+<span class="number">1</span>)%i==<span class="number">0</span>)||(i%(s+<span class="number">1</span>)==<span class="number">0</span>)){</span><br><span class="line">                    vis[i]=<span class="literal">true</span>;</span><br><span class="line">                    dfs(s+<span class="number">1</span>);</span><br><span class="line">                    vis[i]=<span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countArrangement</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        n=N;</span><br><span class="line">        vis.resize(n+<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>状态压缩DP</strong><br>设DP[i]为排列i的个数，其中i用二进制表示，例如1011表示数1,2,4被使用:<br>令j为待排列的数字(1…N)，那么i中第j-1位必须为0表示未用，状态转移方程：<br>DP[i|(1&lt;&lt;(j-1))]+=DP[i]，当i的第j-1位未使用，且j与s成倍数关系（s为当前待排的第s个数）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countArrangement</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP(<span class="number">1</span>&lt;&lt;N, <span class="number">0</span>);</span><br><span class="line">        DP[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;N);i++){</span><br><span class="line">            <span class="keyword">int</span> s=<span class="number">0</span>; <span class="comment">//已经使用的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++){</span><br><span class="line">                s+=(i&gt;&gt;j)&amp;<span class="number">1</span>; <span class="comment">//第j位是否为1,1表示使用，0表示未使用</span></span><br><span class="line">            }</span><br><span class="line">            s++;<span class="comment">//正在使用的第s个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++){ <span class="comment">//遍历第s个数的可能值</span></span><br><span class="line">                <span class="keyword">if</span>(((i&gt;&gt;(j<span class="number">-1</span>))&amp;<span class="number">1</span>)==<span class="number">0</span>&amp;&amp;(j%s==<span class="number">0</span>||s%j==<span class="number">0</span>)){</span><br><span class="line">                    DP[i|(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))]+=DP[i];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[(<span class="number">1</span>&lt;&lt;N)<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="滑窗技巧"><a href="#滑窗技巧" class="headerlink" title="滑窗技巧"></a>滑窗技巧</h1></blockquote><p>[1,2,3,4,…, n]的和子数组和为$n * (n + 1) /2$<br>$ans=n+(n-1)+(n-2)+…+1$<br>可以通过滑窗移动的时候来求解：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">while</span>(end+<span class="number">1</span>&lt;n&amp;&amp;...){}</span><br><span class="line">  ans+=end-i+<span class="number">1</span>; <span class="comment">//[1,2,3,4]以此[1],[1,2],[1,2,3],[1,2,3,4]的四个，[2,3,4]依次[2],[2,3],[2,3,4]的三个！</span></span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h1></blockquote><p>对于普通中缀表达式的计算，我们可以将其转化为后缀表达式再进行计算。转换方法也十分简单。只要建立一个用于存放运算符的栈，扫描该中缀表达式：</p><p>（1）如果遇到数字，直接将该数字输出到后缀表达式（以下部分用「输出」表示输出到后缀表达式）；<br>（2）如果遇到左括号，入栈；<br>（3）如果遇到右括号，不断输出栈顶元素，直至遇到左括号（左括号出栈，但不输出）；<br>（4）如果遇到其他运算符，不断去除所有运算优先级大于等于当前运算符的运算符，输出。（5）最后，新的符号入栈；<br>（6）把栈中剩下的符号依次输出，表达式转换结束。</p><blockquote><h1 id="位运算技巧"><a href="#位运算技巧" class="headerlink" title="位运算技巧"></a>位运算技巧</h1></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>{  <span class="comment">//求x最低位的1</span></span><br><span class="line">  <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setLowbitZero</span><span class="params">(<span class="keyword">int</span> x)</span></span>{  <span class="comment">//将x最低位置0</span></span><br><span class="line">  <span class="keyword">return</span> x &amp; (x - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">powerOftwo</span><span class="params">(<span class="keyword">int</span> cap)</span></span>{ <span class="comment">//返回大于等于cap的最小2次幂，</span></span><br><span class="line">  <span class="keyword">int</span> n = cap - <span class="number">1</span>; <span class="comment">//如果cap就是2的幂次，cap - 1后，求得的是其右边所有置1 + 1，最终结果也是自己---cap！</span></span><br><span class="line">  <span class="comment">//将n的最高位1及其右边所有置1，最后结果+1就是所求</span></span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">return</span> n &lt; <span class="number">0</span> ? <span class="number">1</span> : (n &gt;= (<span class="number">1</span> &lt;&lt; <span class="number">31</span>))? <span class="number">1</span> : n + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">a ^ b = c, a ^ c = b;</span><br><span class="line"></span><br><span class="line">x = s, x = (x - <span class="number">1</span>) &amp; s; <span class="comment">//将s看作集合，1表示有，0表示没有，x求s的所有子集，例如1110，子集有1000,1100,1010,0110,...，0100,0010</span></span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="跳表SkipList"><a href="#跳表SkipList" class="headerlink" title="跳表SkipList"></a>跳表SkipList</h1></blockquote><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p>查找、插入、删除的时间复杂度都是$log{n}$，具体分析见参考文献<br><img src="/assets/img/algorithm/skiplist.png" alt="image"></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>nexts数组记录了该节点的层高对应的下一跳位置，nexts[i]表示第i层的下一跳；</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> cnt; <span class="comment">//重复元素个数</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Node*&gt; nexts; <span class="comment">//节点层高，nexts[level]指向同一层level的下一个节点</span></span><br><span class="line">    Node(<span class="keyword">int</span> _val, <span class="keyword">int</span> size){</span><br><span class="line">        val = _val;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        nexts.resize(size);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++ ) nexts[i] = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="随机层高"><a href="#随机层高" class="headerlink" title="随机层高"></a>随机层高</h2><p>对于插入的节点来说，其随机上升为索引，即随机层高，表明其作为第几层的索引。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randLevel</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(rand() % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; level &lt; MAXLEVEL) level ++ ;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="找每层插入位置的前驱"><a href="#找每层插入位置的前驱" class="headerlink" title="找每层插入位置的前驱"></a>找每层插入位置的前驱</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">helper</span><span class="params">(Node* node, <span class="keyword">int</span> level, <span class="keyword">int</span> val)</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(node -&gt; nexts[level] != <span class="literal">NULL</span> &amp;&amp; node -&gt; nexts[level] -&gt; val &lt; val) node = node -&gt; nexts[level];</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="查找-5"><a href="#查找-5" class="headerlink" title="查找"></a>查找</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> num)</span></span>{ <span class="comment">//查找元素，如果找到就增加数量</span></span><br><span class="line">    Node * node = head;</span><br><span class="line">    <span class="keyword">bool</span> isPass = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = curLevel - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ){</span><br><span class="line">        node = helper(node, i, target);</span><br><span class="line">        <span class="keyword">if</span>(node -&gt; nexts[i] != <span class="literal">NULL</span> &amp;&amp; node -&gt; nexts[i] -&gt; val == target){</span><br><span class="line">            isPass = <span class="literal">true</span>;</span><br><span class="line">            node -&gt; nexts[i] -&gt; cnt += num; ;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> isPass;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="插入-3"><a href="#插入-3" class="headerlink" title="插入"></a>插入</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(find(num, <span class="number">1</span>)) <span class="keyword">return</span>; <span class="comment">//已存在</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不存在，则需要插入</span></span><br><span class="line">    <span class="keyword">int</span> level = randLevel(); <span class="comment">// 新节点随机上升的层高</span></span><br><span class="line">    Node* node = head;</span><br><span class="line">    Node* newNode = <span class="keyword">new</span> Node(num, level);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = curLevel - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ){</span><br><span class="line">        node = helper(node, i, num);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; level){</span><br><span class="line">            Node* tmp = node -&gt; nexts[i];</span><br><span class="line">            node -&gt; nexts[i] = newNode;</span><br><span class="line">            newNode -&gt; nexts[i] = tmp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(level &gt; curLevel){ <span class="comment">//当前新增节点层高比跳表层数高</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = curLevel; i &lt; level; i ++ ){</span><br><span class="line">            head -&gt; nexts[i] = newNode;</span><br><span class="line">        }</span><br><span class="line">        curLevel = level;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> num)</span> </span>{</span><br><span class="line">    Node* node = head;</span><br><span class="line">    Node* delNode = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">bool</span> isDel = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = curLevel - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ){</span><br><span class="line">        node = helper(node, i, num);</span><br><span class="line">        <span class="keyword">if</span>(node -&gt; nexts[i] != <span class="literal">NULL</span> &amp;&amp; node -&gt; nexts[i] -&gt; val == num){</span><br><span class="line">            <span class="keyword">if</span>(!isDel){  <span class="comment">//只删除一次</span></span><br><span class="line">                node -&gt; nexts[i] -&gt; cnt --;</span><br><span class="line">                isDel = <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; nexts[i] -&gt; cnt == <span class="number">0</span>){</span><br><span class="line">                delNode = node -&gt; nexts[i];</span><br><span class="line">                node -&gt; nexts[i] = node -&gt; nexts[i] -&gt; nexts[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(delNode != <span class="literal">NULL</span>) <span class="keyword">delete</span> delNode;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = curLevel - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i -- ){ <span class="comment">//检查跳表层数是否降低</span></span><br><span class="line">        <span class="keyword">if</span>(head -&gt; nexts[i] == <span class="literal">NULL</span>){</span><br><span class="line">            curLevel -- ;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> isDel;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="http://zhangtielei.com/posts/blog-redis-skiplist.html" target="_blank" rel="noopener">参考文献1</a><br><a href="https://leetcode-cn.com/problems/design-skiplist/solution/javashou-xie-shi-xian-tiao-biao-by-feng-omdm0/" target="_blank" rel="noopener">参考文献2</a></p><h2 id="LeetCode-设计跳表"><a href="#LeetCode-设计跳表" class="headerlink" title="LeetCode 设计跳表"></a>LeetCode 设计跳表</h2><p><strong>Description</strong><br>不使用任何库函数，设计一个跳表。</p><p>跳表是在 O(log(n)) 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。</p><p>跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 O(n)。跳表的每一个操作的平均时间复杂度是 O(log(n))，空间复杂度是 O(n)。</p><p>在本题中，你的设计应该要包含这些函数：<br>bool search(int target) : 返回target是否存在于跳表中。<br>void add(int num): 插入一个元素到跳表。<br>bool erase(int num): 在跳表中删除一个值，如果 num 不存在，直接返回false. 如果存在多个 num ，删除其中任意一个即可。<br>了解更多 : <a href="https://en.wikipedia.org/wiki/Skip_list" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Skip_list</a></p><p>注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。<br><strong>Example</strong><br>样例:<br>Skiplist skiplist = new Skiplist();<br>skiplist.add(1);<br>skiplist.add(2);<br>skiplist.add(3);<br>skiplist.search(0); // 返回 false<br>skiplist.add(4);<br>skiplist.search(1); // 返回 true<br>skiplist.erase(0); // 返回 false，0 不在跳表中<br>skiplist.erase(1); // 返回 true<br>skiplist.search(1); // 返回 false，1 已被擦除<br>约束条件:<br>0 &lt;= num, target &lt;= 20000<br>最多调用 50000 次 search, add, 以及 erase操作。</p><p><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Skiplist</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> cnt; <span class="comment">//重复元素个数</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;Node*&gt; nexts; <span class="comment">//节点层高，nexts[level]指向同一层level的下一个节点</span></span><br><span class="line">        Node(<span class="keyword">int</span> _val, <span class="keyword">int</span> size){</span><br><span class="line">            val = _val;</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">            nexts.resize(size);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++ ) nexts[i] = <span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="comment">//const int P = RAND_MAX / 4;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXLEVEL = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">int</span> curLevel;</span><br><span class="line">    Node* head;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">randLevel</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(rand() % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; level &lt; MAXLEVEL) level ++ ;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">Node* <span class="title">helper</span><span class="params">(Node* node, <span class="keyword">int</span> level, <span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        <span class="keyword">while</span>(node -&gt; nexts[level] != <span class="literal">NULL</span> &amp;&amp; node -&gt; nexts[level] -&gt; val &lt; val) node = node -&gt; nexts[level];</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> num)</span></span>{ <span class="comment">//查找元素，如果找到就增加数量</span></span><br><span class="line">        Node * node = head;</span><br><span class="line">        <span class="keyword">bool</span> isPass = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = curLevel - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ){</span><br><span class="line">            node = helper(node, i, target);</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; nexts[i] != <span class="literal">NULL</span> &amp;&amp; node -&gt; nexts[i] -&gt; val == target){</span><br><span class="line">                isPass = <span class="literal">true</span>;</span><br><span class="line">                node -&gt; nexts[i] -&gt; cnt += num; ;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> isPass;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Skiplist() {</span><br><span class="line">        curLevel = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="number">-1</span>, MAXLEVEL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> find(target, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(find(num, <span class="number">1</span>)) <span class="keyword">return</span>; <span class="comment">//已存在</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//不存在，则需要插入</span></span><br><span class="line">        <span class="keyword">int</span> level = randLevel(); <span class="comment">// 新节点随机上升的层高</span></span><br><span class="line">        Node* node = head;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> Node(num, level);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = curLevel - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ){</span><br><span class="line">            node = helper(node, i, num);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; level){</span><br><span class="line">                Node* tmp = node -&gt; nexts[i];</span><br><span class="line">                node -&gt; nexts[i] = newNode;</span><br><span class="line">                newNode -&gt; nexts[i] = tmp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(level &gt; curLevel){ <span class="comment">//当前新增节点层高比跳表层数高</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = curLevel; i &lt; level; i ++ ){</span><br><span class="line">                head -&gt; nexts[i] = newNode;</span><br><span class="line">            }</span><br><span class="line">            curLevel = level;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> num)</span> </span>{</span><br><span class="line">        Node* node = head;</span><br><span class="line">        Node* delNode = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">bool</span> isDel = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = curLevel - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ){</span><br><span class="line">            node = helper(node, i, num);</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; nexts[i] != <span class="literal">NULL</span> &amp;&amp; node -&gt; nexts[i] -&gt; val == num){</span><br><span class="line">                <span class="keyword">if</span>(!isDel){  <span class="comment">//只删除一次</span></span><br><span class="line">                    node -&gt; nexts[i] -&gt; cnt --;</span><br><span class="line">                    isDel = <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(node -&gt; nexts[i] -&gt; cnt == <span class="number">0</span>){</span><br><span class="line">                    delNode = node -&gt; nexts[i];</span><br><span class="line">                    node -&gt; nexts[i] = node -&gt; nexts[i] -&gt; nexts[i];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(delNode != <span class="literal">NULL</span>) <span class="keyword">delete</span> delNode;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = curLevel - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i -- ){ <span class="comment">//检查跳表层数是否降低</span></span><br><span class="line">            <span class="keyword">if</span>(head -&gt; nexts[i] == <span class="literal">NULL</span>){</span><br><span class="line">                curLevel -- ;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> isDel;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有问题的插入</span></span><br><span class="line">    <span class="comment">// void add(int num) {</span></span><br><span class="line">    <span class="comment">//     int level = randLevel(); // 新节点随机上升的层高</span></span><br><span class="line">    <span class="comment">//     Node* node = head;</span></span><br><span class="line">    <span class="comment">//     Node* newNode = new Node(num, level);</span></span><br><span class="line">    <span class="comment">//     bool isInsert = false;</span></span><br><span class="line">    <span class="comment">//     bool isAdd = false;</span></span><br><span class="line">    <span class="comment">//     for(int i = curLevel - 1; i &gt;= 0; i -- ){</span></span><br><span class="line">    <span class="comment">//         node = helper(node, i, num);</span></span><br><span class="line">    <span class="comment">//         if(i &lt; level){ //有问题，比如3，刚开始存在，后面如果随机3的层高更高，指向会不同</span></span><br><span class="line">    <span class="comment">//             if(node -&gt; nexts[i] != NULL &amp;&amp; node -&gt; nexts[i] -&gt; val == num){ //已经重复</span></span><br><span class="line">    <span class="comment">//                 if(!isAdd){  //只加一次</span></span><br><span class="line">    <span class="comment">//                     node -&gt; nexts[i] -&gt; cnt ++ ;</span></span><br><span class="line">    <span class="comment">//                     isAdd = true;</span></span><br><span class="line">    <span class="comment">//                 }</span></span><br><span class="line">    <span class="comment">//             }else{</span></span><br><span class="line">    <span class="comment">//                 isInsert = true;</span></span><br><span class="line">    <span class="comment">//                 Node* tmp = node -&gt; nexts[i];</span></span><br><span class="line">    <span class="comment">//                 node -&gt; nexts[i] = newNode;</span></span><br><span class="line">    <span class="comment">//                 newNode -&gt; nexts[i] = tmp;</span></span><br><span class="line">    <span class="comment">//             }  </span></span><br><span class="line">    <span class="comment">//         }</span></span><br><span class="line">    <span class="comment">//     }</span></span><br><span class="line">    <span class="comment">//     if(!isInsert &amp;&amp; level == 0) isInsert = true;</span></span><br><span class="line">    <span class="comment">//     if(isInsert &amp;&amp; level &gt; curLevel){ //当前新增节点层高比跳表层数高</span></span><br><span class="line">    <span class="comment">//         for(int i = curLevel; i &lt; level; i ++ ){</span></span><br><span class="line">    <span class="comment">//             head -&gt; nexts[i] = newNode;</span></span><br><span class="line">    <span class="comment">//         }</span></span><br><span class="line">    <span class="comment">//         curLevel = level;</span></span><br><span class="line">    <span class="comment">//     }</span></span><br><span class="line">    <span class="comment">//     if(!isInsert) delete newNode;</span></span><br><span class="line">    <span class="comment">//     //cout &lt;&lt;"aaa";</span></span><br><span class="line">    <span class="comment">// }</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Skiplist object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Skiplist* obj = new Skiplist();</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;search(target);</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(num);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;erase(num);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><div class="page-reward"><a href="javascript:;" class="page-reward-btn tooltip-top"><div class="tooltip tooltip-east"> <span class="tooltip-item">赏</span><span class="tooltip-content"><span class="tooltip-text"><span class="tooltip-inner"><p class="reward-p"><i class="icon icon-quo-left"></i>Thank you for inviting me to have candy.<i class="icon icon-quo-right"></i></p><div class="reward-box"><div class="reward-box-item"> <img class="reward-img" src="/assets/img/blog/zhifubao.png"> <span class="reward-type">支付宝</span></div><div class="reward-box-item"> <img class="reward-img" src="/assets/img/blog/weixin.jpg"> <span class="reward-type">微信</span></div></div></span></span></span></div></a></div></div><div class="article-info article-info-index"><div class="article-tag tagcloud"><i class="icon-price-tags icon"></i><ul class="article-tag-list"><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag article-tag-list-link color5">Algorithm</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag article-tag-list-link color4">C++</a></li></ul></div><div class="share-btn share-icons tooltip-left"><div class="tooltip tooltip-east"><span class="tooltip-item"><a href="javascript:;" class="share-sns share-outer"><i class="icon icon-share"></i></a></span><span class="tooltip-content"><div class="share-wrap"><div class="share-icons"><a class="weibo share-sns" href="javascript:;" data-type="weibo"><i class="icon icon-weibo"></i></a><a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin"><i class="icon icon-weixin"></i></a><a class="qq share-sns" href="javascript:;" data-type="qq"><i class="icon icon-qq"></i></a><a class="douban share-sns" href="javascript:;" data-type="douban"><i class="icon icon-douban"></i></a><a class="qzone share-sns" href="javascript:;" data-type="qzone"><i class="icon icon-qzone"></i></a><a class="facebook share-sns" href="javascript:;" data-type="facebook"><i class="icon icon-facebook"></i></a><a class="twitter share-sns" href="javascript:;" data-type="twitter"><i class="icon icon-twitter"></i></a><a class="google share-sns" href="javascript:;" data-type="google"><i class="icon icon-google"></i></a></div></div></span></div></div><div class="page-modal wx-share js-wx-box"><a class="close js-modal-close" href="javascript:;"><i class="icon icon-close"></i></a><p>扫一扫，分享到微信</p><div class="wx-qrcode"> <img src="http://s.jiathis.com/qrcode.php?url=https://lourisxu.github.io/2019/02/17/algorithm-note.html/" alt="微信分享二维码"></div></div><div class="mask js-mask"></div><div class="clearfix"></div></div></div></article><nav id="article-nav"><a href="/2019/05/18/worksheet.html/" id="article-nav-newer" class="article-nav-link-wrap"><i class="icon-circle-left"></i><div class="article-nav-title"> WorkSheet</div></a><a href="/2018/10/05/wang-dao-data-structure-afterschool-algorithm.html/" id="article-nav-older" class="article-nav-link-wrap"><div class="article-nav-title">王道数据结构课后算法题</div><i class="icon-circle-right"></i></a></nav><aside class="wrap-side-operation"><div class="mod-side-operation"><div class="jump-container" id="js-jump-container" style="display:none"><a href="javascript:void(0)" class="mod-side-operation__jump-to-top"><i class="icon-font icon-back"></i></a><div id="js-jump-plan-container" class="jump-plan-container" style="top:-11px"><i class="icon-font icon-plane jump-plane"></i></div></div><div class="toc-container tooltip-left"><i class="icon-font icon-category"></i><div class="tooltip tooltip-east"><span class="tooltip-item"></span><span class="tooltip-content"><div class="toc-article"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#简单模拟"><span class="toc-number">1.</span> <span class="toc-text">简单模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#【PAT-B1001】害死人不偿命的（3n-1）猜想"><span class="toc-number">1.1.</span> <span class="toc-text">【PAT B1001】害死人不偿命的（3n+1）猜想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#【PAT-B1032】挖掘机技术哪家强"><span class="toc-number">1.2.</span> <span class="toc-text">【PAT B1032】挖掘机技术哪家强</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#剩下的树"><span class="toc-number">1.3.</span> <span class="toc-text">剩下的树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-B"><span class="toc-number">1.4.</span> <span class="toc-text">A+B</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特殊乘法"><span class="toc-number">1.5.</span> <span class="toc-text">特殊乘法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#比较奇偶数个数"><span class="toc-number">1.6.</span> <span class="toc-text">比较奇偶数个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shortest-Distance"><span class="toc-number">1.7.</span> <span class="toc-text">Shortest Distance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-B和C"><span class="toc-number">1.8.</span> <span class="toc-text">A+B和C</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数字分类"><span class="toc-number">1.9.</span> <span class="toc-text">数字分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#部分A-B"><span class="toc-number">1.10.</span> <span class="toc-text">部分A+B</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锤子剪刀布"><span class="toc-number">1.11.</span> <span class="toc-text">锤子剪刀布</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#查找元素"><span class="toc-number">2.</span> <span class="toc-text">查找元素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#统计同成绩学生人数"><span class="toc-number">2.1.</span> <span class="toc-text">统计同成绩学生人数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#找x"><span class="toc-number">2.2.</span> <span class="toc-text">找x</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#查找学生信息"><span class="toc-number">2.3.</span> <span class="toc-text">查找学生信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#查找"><span class="toc-number">2.4.</span> <span class="toc-text">查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#图形输出"><span class="toc-number">3.</span> <span class="toc-text">图形输出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#跟奥巴马一起编程"><span class="toc-number">3.1.</span> <span class="toc-text">跟奥巴马一起编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hello-World-for-U"><span class="toc-number">3.2.</span> <span class="toc-text">Hello World for U</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#等腰梯形"><span class="toc-number">3.3.</span> <span class="toc-text">等腰梯形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#沙漏图形"><span class="toc-number">3.4.</span> <span class="toc-text">沙漏图形</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#日期处理"><span class="toc-number">4.</span> <span class="toc-text">日期处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#日期差值"><span class="toc-number">4.1.</span> <span class="toc-text">日期差值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Day-of-week"><span class="toc-number">4.2.</span> <span class="toc-text">Day of week</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#打印日期"><span class="toc-number">4.3.</span> <span class="toc-text">打印日期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#日期类"><span class="toc-number">4.4.</span> <span class="toc-text">日期类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#日期累加"><span class="toc-number">4.5.</span> <span class="toc-text">日期累加</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进制转换"><span class="toc-number">5.</span> <span class="toc-text">进制转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#又一版A-B"><span class="toc-number">5.1.</span> <span class="toc-text">又一版A+B</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数制转换"><span class="toc-number">5.2.</span> <span class="toc-text">数制转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进制转换-1"><span class="toc-number">5.3.</span> <span class="toc-text">进制转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八进制"><span class="toc-number">5.4.</span> <span class="toc-text">八进制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串处理"><span class="toc-number">6.</span> <span class="toc-text">字符串处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串连接"><span class="toc-number">6.1.</span> <span class="toc-text">字符串连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#首字母大写"><span class="toc-number">6.2.</span> <span class="toc-text">首字母大写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串的查找删除"><span class="toc-number">6.3.</span> <span class="toc-text">字符串的查找删除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单词替换"><span class="toc-number">6.4.</span> <span class="toc-text">单词替换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串中去特定字符"><span class="toc-number">6.5.</span> <span class="toc-text">字符串中去特定字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组逆置"><span class="toc-number">6.6.</span> <span class="toc-text">数组逆置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#比较字符串"><span class="toc-number">6.7.</span> <span class="toc-text">比较字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编排字符串"><span class="toc-number">6.8.</span> <span class="toc-text">编排字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回文串"><span class="toc-number">6.9.</span> <span class="toc-text">回文串</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#排序"><span class="toc-number">7.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#排序-1"><span class="toc-number">7.1.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特殊排序"><span class="toc-number">7.2.</span> <span class="toc-text">特殊排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Excel排序"><span class="toc-number">7.3.</span> <span class="toc-text">Excel排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串内排序"><span class="toc-number">7.4.</span> <span class="toc-text">字符串内排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Problem-B"><span class="toc-number">7.5.</span> <span class="toc-text">Problem B</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小白鼠排队"><span class="toc-number">7.6.</span> <span class="toc-text">小白鼠排队</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中位数"><span class="toc-number">7.7.</span> <span class="toc-text">中位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#排名"><span class="toc-number">7.8.</span> <span class="toc-text">排名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#谁是你的潜在朋友"><span class="toc-number">7.9.</span> <span class="toc-text">谁是你的潜在朋友</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分组统计"><span class="toc-number">7.10.</span> <span class="toc-text">分组统计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Be-Unique"><span class="toc-number">7.11.</span> <span class="toc-text">Be Unique</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-Subtraction"><span class="toc-number">7.12.</span> <span class="toc-text">String Subtraction</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#递归"><span class="toc-number">8.</span> <span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#吃糖果"><span class="toc-number">8.1.</span> <span class="toc-text">吃糖果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数列"><span class="toc-number">8.2.</span> <span class="toc-text">数列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#神奇的口袋"><span class="toc-number">8.3.</span> <span class="toc-text">神奇的口袋</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八皇后"><span class="toc-number">8.4.</span> <span class="toc-text">八皇后</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#贪心"><span class="toc-number">9.</span> <span class="toc-text">贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#看电视"><span class="toc-number">9.1.</span> <span class="toc-text">看电视</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#出租车费"><span class="toc-number">9.2.</span> <span class="toc-text">出租车费</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#To-Fill-or-Not-to-Fill"><span class="toc-number">9.3.</span> <span class="toc-text">To Fill or Not to Fill</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Repair-the-Wall"><span class="toc-number">9.4.</span> <span class="toc-text">Repair the Wall</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FatMouse’s-Trade"><span class="toc-number">9.5.</span> <span class="toc-text">FatMouse’s Trade</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#迷瘴"><span class="toc-number">9.6.</span> <span class="toc-text">迷瘴</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#找零钱"><span class="toc-number">9.7.</span> <span class="toc-text">找零钱</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二分法"><span class="toc-number">10.</span> <span class="toc-text">二分法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#技巧："><span class="toc-number">10.1.</span> <span class="toc-text">技巧：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#找x-1"><span class="toc-number">10.2.</span> <span class="toc-text">找x</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#打印极值点坐标"><span class="toc-number">10.3.</span> <span class="toc-text">打印极值点坐标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#查找-1"><span class="toc-number">10.4.</span> <span class="toc-text">查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Two-Pointers"><span class="toc-number">11.</span> <span class="toc-text">Two Pointers</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#二路归并排序-mergesort-递归法-2"><span class="toc-number">11.1.</span> <span class="toc-text">二路归并排序(mergesort)递归法 [2*+]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基础排序III：归并排序"><span class="toc-number">11.2.</span> <span class="toc-text">基础排序III：归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#快速排序-qsort-2"><span class="toc-number">11.3.</span> <span class="toc-text">快速排序 qsort [2*]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二分递归快排（Qsort）-2"><span class="toc-number">11.4.</span> <span class="toc-text">二分递归快排（Qsort） [2*]</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其他高效技巧与算法"><span class="toc-number">12.</span> <span class="toc-text">其他高效技巧与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#求第k大的数"><span class="toc-number">12.1.</span> <span class="toc-text">求第k大的数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#简单数学"><span class="toc-number">13.</span> <span class="toc-text">简单数学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#守形数"><span class="toc-number">13.1.</span> <span class="toc-text">守形数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反序数"><span class="toc-number">13.2.</span> <span class="toc-text">反序数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#百鸡问题"><span class="toc-number">13.3.</span> <span class="toc-text">百鸡问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#abc"><span class="toc-number">13.4.</span> <span class="toc-text">abc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#众数"><span class="toc-number">13.5.</span> <span class="toc-text">众数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#整数和"><span class="toc-number">13.6.</span> <span class="toc-text">整数和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多项式的值"><span class="toc-number">13.7.</span> <span class="toc-text">多项式的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#迭代求立方根"><span class="toc-number">13.8.</span> <span class="toc-text">迭代求立方根</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#与7无关的数"><span class="toc-number">13.9.</span> <span class="toc-text">与7无关的数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#鸡兔同笼"><span class="toc-number">13.10.</span> <span class="toc-text">鸡兔同笼</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#最大公因数与最小公倍数"><span class="toc-number">14.</span> <span class="toc-text">最大公因数与最小公倍数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Least-Common-multiple"><span class="toc-number">14.1.</span> <span class="toc-text">Least Common multiple</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分数的四则运算"><span class="toc-number">15.</span> <span class="toc-text">分数的四则运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#模板"><span class="toc-number">15.1.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分数矩阵"><span class="toc-number">15.2.</span> <span class="toc-text">分数矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1062-最简分数-20"><span class="toc-number">15.3.</span> <span class="toc-text">1062. 最简分数(20)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#素数"><span class="toc-number">16.</span> <span class="toc-text">素数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#模板-1"><span class="toc-number">16.1.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#素数-1"><span class="toc-number">16.2.</span> <span class="toc-text">素数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Prime-Number"><span class="toc-number">16.3.</span> <span class="toc-text">Prime Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Goldbach’s-Conjecture"><span class="toc-number">16.4.</span> <span class="toc-text">Goldbach’s Conjecture</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#完数"><span class="toc-number">16.5.</span> <span class="toc-text">完数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#质因数的个数"><span class="toc-number">16.6.</span> <span class="toc-text">质因数的个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#约数的个数"><span class="toc-number">16.7.</span> <span class="toc-text">约数的个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#完数与盈数"><span class="toc-number">16.8.</span> <span class="toc-text">完数与盈数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#大整数"><span class="toc-number">17.</span> <span class="toc-text">大整数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#模板-2"><span class="toc-number">17.1.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a-b"><span class="toc-number">17.2.</span> <span class="toc-text">a+b</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#组合数"><span class="toc-number">18.</span> <span class="toc-text">组合数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#n！含质因子p的个数"><span class="toc-number">18.1.</span> <span class="toc-text">n！含质因子p的个数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#深度优先搜索"><span class="toc-number">19.</span> <span class="toc-text">深度优先搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#全排列"><span class="toc-number">19.1.</span> <span class="toc-text">全排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组合的输出"><span class="toc-number">19.2.</span> <span class="toc-text">组合的输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组合-判断素数"><span class="toc-number">19.3.</span> <span class="toc-text">组合+判断素数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#深度优先搜多"><span class="toc-number">20.</span> <span class="toc-text">深度优先搜多</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#n皇后问题"><span class="toc-number">20.1.</span> <span class="toc-text">n皇后问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#出栈序列统计"><span class="toc-number">20.2.</span> <span class="toc-text">出栈序列统计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#走迷宫"><span class="toc-number">20.3.</span> <span class="toc-text">走迷宫</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#广度优先搜索"><span class="toc-number">21.</span> <span class="toc-text">广度优先搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Jugs"><span class="toc-number">21.1.</span> <span class="toc-text">Jugs</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#并查集"><span class="toc-number">22.</span> <span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#通信系统"><span class="toc-number">22.1.</span> <span class="toc-text">通信系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#畅通工程"><span class="toc-number">22.2.</span> <span class="toc-text">畅通工程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#How-Many-Tables"><span class="toc-number">22.3.</span> <span class="toc-text">How Many Tables</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#More-is-better"><span class="toc-number">22.4.</span> <span class="toc-text">More is better</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PAT1034-Head-of-a-Gang"><span class="toc-number">22.5.</span> <span class="toc-text">PAT1034 Head of a Gang</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#动态规划"><span class="toc-number">23.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#最大连续子序列"><span class="toc-number">23.1.</span> <span class="toc-text">最大连续子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最长上升子序列"><span class="toc-number">23.2.</span> <span class="toc-text">最长上升子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最长公共子序列"><span class="toc-number">23.3.</span> <span class="toc-text">最长公共子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最长回文子串"><span class="toc-number">23.4.</span> <span class="toc-text">最长回文子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DAG最长路"><span class="toc-number">23.5.</span> <span class="toc-text">DAG最长路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#不固定起点与终点"><span class="toc-number">23.5.1.</span> <span class="toc-text">不固定起点与终点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#固定终点"><span class="toc-number">23.5.2.</span> <span class="toc-text">固定终点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#矩形嵌套"><span class="toc-number">23.5.3.</span> <span class="toc-text">矩形嵌套</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#背包问题"><span class="toc-number">23.6.</span> <span class="toc-text">背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01背包"><span class="toc-number">23.6.1.</span> <span class="toc-text">01背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#完全背包"><span class="toc-number">23.6.2.</span> <span class="toc-text">完全背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#装箱问题"><span class="toc-number">23.6.3.</span> <span class="toc-text">装箱问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#采药"><span class="toc-number">23.6.4.</span> <span class="toc-text">采药</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#货币系统"><span class="toc-number">23.6.5.</span> <span class="toc-text">货币系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#图的遍历"><span class="toc-number">24.</span> <span class="toc-text">图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#图的深度优先搜索DFS"><span class="toc-number">24.1.</span> <span class="toc-text">图的深度优先搜索DFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#邻接矩阵"><span class="toc-number">24.1.1.</span> <span class="toc-text">邻接矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#邻接表"><span class="toc-number">24.1.2.</span> <span class="toc-text">邻接表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT1034-Head-of-a-Gang-1"><span class="toc-number">24.1.3.</span> <span class="toc-text">PAT1034 Head of a Gang</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第一题"><span class="toc-number">24.1.4.</span> <span class="toc-text">第一题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#连通图"><span class="toc-number">24.1.5.</span> <span class="toc-text">连通图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图的广度优先搜索"><span class="toc-number">24.2.</span> <span class="toc-text">图的广度优先搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#邻接矩阵-1"><span class="toc-number">24.2.1.</span> <span class="toc-text">邻接矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#邻接表-1"><span class="toc-number">24.2.2.</span> <span class="toc-text">邻接表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-A1076-Forwards-on-Weibo"><span class="toc-number">24.2.3.</span> <span class="toc-text">PAT-A1076 Forwards on Weibo</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#最短路径"><span class="toc-number">25.</span> <span class="toc-text">最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Dijkstra算法"><span class="toc-number">25.1.</span> <span class="toc-text">Dijkstra算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#邻接矩阵-O-V-2"><span class="toc-number">25.1.1.</span> <span class="toc-text">邻接矩阵 O(V^{2})</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#邻接表-O-V-2-E"><span class="toc-number">25.1.2.</span> <span class="toc-text">邻接表 O(V^{2}+E)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆优化-O-VlogV-E"><span class="toc-number">25.1.3.</span> <span class="toc-text">堆优化 O(VlogV+E)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变形"><span class="toc-number">25.1.4.</span> <span class="toc-text">变形</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#新增边权（比如花费）求最短路径下的花费最小"><span class="toc-number">25.1.4.1.</span> <span class="toc-text">新增边权（比如花费）求最短路径下的花费最小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#新增点权（比如物资）求最短路径下的收集的物资最大"><span class="toc-number">25.1.4.2.</span> <span class="toc-text">新增点权（比如物资）求最短路径下的收集的物资最大</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#求最短路径条数"><span class="toc-number">25.1.4.3.</span> <span class="toc-text">求最短路径条数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#求路径"><span class="toc-number">25.1.4.4.</span> <span class="toc-text">求路径</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dijkstra-DFS"><span class="toc-number">25.1.5.</span> <span class="toc-text">Dijkstra+DFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-A1003-Emergency（25）"><span class="toc-number">25.1.6.</span> <span class="toc-text">PAT-A1003 Emergency（25）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1030-Travel-Plan-30"><span class="toc-number">25.1.7.</span> <span class="toc-text">1030 Travel Plan (30)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bellman-Ford算法-O-VE"><span class="toc-number">25.2.</span> <span class="toc-text">Bellman-Ford算法 O(VE)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-A1003-Emergency（25）-1"><span class="toc-number">25.2.1.</span> <span class="toc-text">PAT-A1003 Emergency（25）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPFA算法-O-kE"><span class="toc-number">25.3.</span> <span class="toc-text">SPFA算法 O(kE)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-A1003-Emergency（25）-2"><span class="toc-number">25.3.1.</span> <span class="toc-text">PAT-A1003 Emergency（25）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1030-Travel-Plan-30-1"><span class="toc-number">25.3.2.</span> <span class="toc-text">1030 Travel Plan (30)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Floyd算法-O-n-3"><span class="toc-number">25.4.</span> <span class="toc-text">Floyd算法 $O(n^{3})$</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#练习"><span class="toc-number">25.5.</span> <span class="toc-text">练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#算法7-15：迪杰斯特拉最短路径算法"><span class="toc-number">25.5.1.</span> <span class="toc-text">算法7-15：迪杰斯特拉最短路径算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法7-16：弗洛伊德最短路径算法"><span class="toc-number">25.5.2.</span> <span class="toc-text">算法7-16：弗洛伊德最短路径算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最短路径-1"><span class="toc-number">25.5.3.</span> <span class="toc-text">最短路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最短路径-2"><span class="toc-number">25.5.4.</span> <span class="toc-text">最短路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最短路径问题"><span class="toc-number">25.5.5.</span> <span class="toc-text">最短路径问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#最小生成树"><span class="toc-number">26.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Prim算法"><span class="toc-number">26.1.</span> <span class="toc-text">Prim算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#邻接矩阵-O-V-2-1"><span class="toc-number">26.1.1.</span> <span class="toc-text">邻接矩阵 $O(V^{2})$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#邻接表-O-V-2-E-1"><span class="toc-number">26.1.2.</span> <span class="toc-text">邻接表 $O(V^{2}+E)$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆优化-O-VlogV-E-1"><span class="toc-number">26.1.3.</span> <span class="toc-text">堆优化 $O(VlogV+E)$</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kruskal算法-O-ElogE"><span class="toc-number">26.2.</span> <span class="toc-text">Kruskal算法 $O(ElogE)$</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#还是畅通工程"><span class="toc-number">26.2.1.</span> <span class="toc-text">还是畅通工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Freckles"><span class="toc-number">26.2.2.</span> <span class="toc-text">Freckles</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#畅通工程-1"><span class="toc-number">26.2.3.</span> <span class="toc-text">畅通工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继续畅通工程"><span class="toc-number">26.2.4.</span> <span class="toc-text">继续畅通工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jungle-Roads"><span class="toc-number">26.2.5.</span> <span class="toc-text">Jungle Roads</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#拓扑排序"><span class="toc-number">27.</span> <span class="toc-text">拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#算法7-12：有向无环图的拓扑排序"><span class="toc-number">27.1.</span> <span class="toc-text">算法7-12：有向无环图的拓扑排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#确定比赛名次"><span class="toc-number">27.2.</span> <span class="toc-text">确定比赛名次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Legal-or-Not"><span class="toc-number">27.3.</span> <span class="toc-text">Legal or Not</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#剑指-Offer-II-114-外星文字典"><span class="toc-number">27.4.</span> <span class="toc-text">剑指 Offer II 114. 外星文字典</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#剑指-Offer-II-115-重建序列"><span class="toc-number">27.5.</span> <span class="toc-text">剑指 Offer II 115. 重建序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1632-矩阵转换后的秩"><span class="toc-number">27.6.</span> <span class="toc-text">1632. 矩阵转换后的秩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1591-奇怪的打印机-II"><span class="toc-number">27.7.</span> <span class="toc-text">1591. 奇怪的打印机 II</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#关键路径"><span class="toc-number">28.</span> <span class="toc-text">关键路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#关键路径-1"><span class="toc-number">28.1.</span> <span class="toc-text">关键路径</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二叉树"><span class="toc-number">29.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#动态实现"><span class="toc-number">29.1.</span> <span class="toc-text">动态实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的存储结构"><span class="toc-number">29.1.1.</span> <span class="toc-text">二叉树的存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树节点的查找、修改"><span class="toc-number">29.1.2.</span> <span class="toc-text">二叉树节点的查找、修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树节点的插入"><span class="toc-number">29.1.3.</span> <span class="toc-text">二叉树节点的插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的创建"><span class="toc-number">29.1.4.</span> <span class="toc-text">二叉树的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#先序遍历"><span class="toc-number">29.1.5.</span> <span class="toc-text">先序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中序遍历"><span class="toc-number">29.1.6.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#后序遍历"><span class="toc-number">29.1.7.</span> <span class="toc-text">后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#先、中、后续遍历非递归实现"><span class="toc-number">29.1.8.</span> <span class="toc-text">先、中、后续遍历非递归实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#层序遍历"><span class="toc-number">29.1.9.</span> <span class="toc-text">层序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#先序中序建树"><span class="toc-number">29.1.10.</span> <span class="toc-text">先序中序建树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中序后序建树"><span class="toc-number">29.1.11.</span> <span class="toc-text">中序后序建树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中序层序建树"><span class="toc-number">29.1.12.</span> <span class="toc-text">中序层序建树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态实现"><span class="toc-number">29.2.</span> <span class="toc-text">静态实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#存储结构"><span class="toc-number">29.2.1.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#新建节点"><span class="toc-number">29.2.2.</span> <span class="toc-text">新建节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查找-2"><span class="toc-number">29.2.3.</span> <span class="toc-text">查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插入"><span class="toc-number">29.2.4.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#建树"><span class="toc-number">29.2.5.</span> <span class="toc-text">建树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历"><span class="toc-number">29.2.6.</span> <span class="toc-text">遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PAT-A1020-Tree-Traversals"><span class="toc-number">29.3.</span> <span class="toc-text">PAT-A1020 Tree Traversals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复原二叉树"><span class="toc-number">29.4.</span> <span class="toc-text">复原二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树-1"><span class="toc-number">29.5.</span> <span class="toc-text">二叉树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#树的遍历"><span class="toc-number">30.</span> <span class="toc-text">树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#存储结构-1"><span class="toc-number">30.1.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#新建节点-1"><span class="toc-number">30.2.</span> <span class="toc-text">新建节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#先根遍历"><span class="toc-number">30.3.</span> <span class="toc-text">先根遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#层序遍历-1"><span class="toc-number">30.4.</span> <span class="toc-text">层序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#层序编号"><span class="toc-number">30.5.</span> <span class="toc-text">层序编号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pat-A1053-Path-of-Equal-Weight"><span class="toc-number">30.6.</span> <span class="toc-text">Pat-A1053 Path of Equal Weight</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树查找"><span class="toc-number">30.7.</span> <span class="toc-text">树查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树的高度"><span class="toc-number">30.8.</span> <span class="toc-text">树的高度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二叉查找树"><span class="toc-number">31.</span> <span class="toc-text">二叉查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#查找-3"><span class="toc-number">31.1.</span> <span class="toc-text">查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#插入操作"><span class="toc-number">31.2.</span> <span class="toc-text">插入操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建树-1"><span class="toc-number">31.3.</span> <span class="toc-text">建树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#删除"><span class="toc-number">31.4.</span> <span class="toc-text">删除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pat-A1043-Is-It-a-Binary-Search-Tree"><span class="toc-number">31.5.</span> <span class="toc-text">Pat-A1043 Is It a Binary Search Tree</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#平衡二叉树"><span class="toc-number">32.</span> <span class="toc-text">平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#存储结构-2"><span class="toc-number">32.1.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#新建节点-2"><span class="toc-number">32.2.</span> <span class="toc-text">新建节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取高度"><span class="toc-number">32.3.</span> <span class="toc-text">获取高度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计算平衡因子"><span class="toc-number">32.4.</span> <span class="toc-text">计算平衡因子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更新高度"><span class="toc-number">32.5.</span> <span class="toc-text">更新高度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#查找-4"><span class="toc-number">32.6.</span> <span class="toc-text">查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#左旋"><span class="toc-number">32.7.</span> <span class="toc-text">左旋</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#右旋"><span class="toc-number">32.8.</span> <span class="toc-text">右旋</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#插入-1"><span class="toc-number">32.9.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#删除-1"><span class="toc-number">32.10.</span> <span class="toc-text">删除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AVL树建立"><span class="toc-number">32.11.</span> <span class="toc-text">AVL树建立</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#平衡二叉树的基本操作"><span class="toc-number">32.12.</span> <span class="toc-text">平衡二叉树的基本操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#堆"><span class="toc-number">33.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#存储结构-3"><span class="toc-number">33.1.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#向下调整"><span class="toc-number">33.2.</span> <span class="toc-text">向下调整</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建堆"><span class="toc-number">33.3.</span> <span class="toc-text">建堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#删除堆顶元素"><span class="toc-number">33.4.</span> <span class="toc-text">删除堆顶元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#向上调整"><span class="toc-number">33.5.</span> <span class="toc-text">向上调整</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#插入-2"><span class="toc-number">33.6.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆排序"><span class="toc-number">33.7.</span> <span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法10-10-10-11：堆排序"><span class="toc-number">33.8.</span> <span class="toc-text">算法10-10,10-11：堆排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#序列合并"><span class="toc-number">33.9.</span> <span class="toc-text">序列合并</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#合并果子（堆）"><span class="toc-number">33.10.</span> <span class="toc-text">合并果子（堆）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#哈夫曼树"><span class="toc-number">34.</span> <span class="toc-text">哈夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#计算带权路径长度WPL"><span class="toc-number">34.1.</span> <span class="toc-text">计算带权路径长度WPL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#哈夫曼编码"><span class="toc-number">34.2.</span> <span class="toc-text">哈夫曼编码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串专题"><span class="toc-number">35.</span> <span class="toc-text">字符串专题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串Hash"><span class="toc-number">35.1.</span> <span class="toc-text">字符串Hash</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#只有大写或小写字母"><span class="toc-number">35.1.1.</span> <span class="toc-text">只有大写或小写字母</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#大小写字母混合"><span class="toc-number">35.1.2.</span> <span class="toc-text">大小写字母混合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#大小写字母以及数字"><span class="toc-number">35.1.3.</span> <span class="toc-text">大小写字母以及数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如果数字只出现在末尾"><span class="toc-number">35.1.4.</span> <span class="toc-text">如果数字只出现在末尾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#超长字符串Hash（只有小写字母）"><span class="toc-number">35.1.5.</span> <span class="toc-text">超长字符串Hash（只有小写字母）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#求解子串Hash值H-i…j"><span class="toc-number">35.1.6.</span> <span class="toc-text">求解子串Hash值H[i…j]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输入两个长度均不超过1000的字符串，求它们的最长公共子串的长度"><span class="toc-number">35.1.7.</span> <span class="toc-text">输入两个长度均不超过1000的字符串，求它们的最长公共子串的长度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP算法"><span class="toc-number">35.2.</span> <span class="toc-text">KMP算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Next数组-O-left-N-right"><span class="toc-number">35.2.1.</span> <span class="toc-text">Next数组 $O\left(N\right)$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KMP算法-O-left-N-M-right"><span class="toc-number">35.2.2.</span> <span class="toc-text">KMP算法 $O\left(N+M\right)$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匹配次数"><span class="toc-number">35.2.3.</span> <span class="toc-text">匹配次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nextval数组"><span class="toc-number">35.2.4.</span> <span class="toc-text">Nextval数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#问题-A-动物简介-animal"><span class="toc-number">35.2.5.</span> <span class="toc-text">问题 A: 动物简介(animal)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#问题-B-P2-统计单词数"><span class="toc-number">35.2.6.</span> <span class="toc-text">问题 B: P2 统计单词数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#问题-C-剪花布条"><span class="toc-number">35.2.7.</span> <span class="toc-text">问题 C: 剪花布条</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最长回文串"><span class="toc-number">35.3.</span> <span class="toc-text">最长回文串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#动态规划-1"><span class="toc-number">35.3.1.</span> <span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中心扩展法"><span class="toc-number">35.3.2.</span> <span class="toc-text">中心扩展法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#马拉车算法（Manacher’s-Algorithm）"><span class="toc-number">35.3.3.</span> <span class="toc-text">马拉车算法（Manacher’s Algorithm）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#专题扩展"><span class="toc-number">36.</span> <span class="toc-text">专题扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#分块思想"><span class="toc-number">36.1.</span> <span class="toc-text">分块思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A1057-Stack-30"><span class="toc-number">36.1.1.</span> <span class="toc-text">A1057 Stack(30)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树状数组"><span class="toc-number">36.2.</span> <span class="toc-text">树状数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#经典应用①"><span class="toc-number">36.2.1.</span> <span class="toc-text">经典应用①</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#经典应用②"><span class="toc-number">36.2.2.</span> <span class="toc-text">经典应用②</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#经典应用③"><span class="toc-number">36.2.3.</span> <span class="toc-text">经典应用③</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二维树状数组"><span class="toc-number">36.2.4.</span> <span class="toc-text">二维树状数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#区间更新，单点查询"><span class="toc-number">36.2.5.</span> <span class="toc-text">区间更新，单点查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#区间查询"><span class="toc-number">36.2.6.</span> <span class="toc-text">区间查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最少的交换"><span class="toc-number">36.2.7.</span> <span class="toc-text">最少的交换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字典树"><span class="toc-number">37.</span> <span class="toc-text">字典树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理"><span class="toc-number">37.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#作用"><span class="toc-number">37.2.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码"><span class="toc-number">37.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#单调栈"><span class="toc-number">38.</span> <span class="toc-text">单调栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概念"><span class="toc-number">38.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Next-Greater-Element"><span class="toc-number">38.2.</span> <span class="toc-text">Next Greater Element</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#每日温度"><span class="toc-number">38.3.</span> <span class="toc-text">每日温度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#欧拉图"><span class="toc-number">39.</span> <span class="toc-text">欧拉图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode-332-重新安排行程"><span class="toc-number">39.1.</span> <span class="toc-text">LeetCode 332. 重新安排行程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Morris中序遍历"><span class="toc-number">40.</span> <span class="toc-text">Morris中序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概念-1"><span class="toc-number">40.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#501-二叉搜索树中的众数"><span class="toc-number">40.2.</span> <span class="toc-text">501. 二叉搜索树中的众数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AC自动机"><span class="toc-number">41.</span> <span class="toc-text">AC自动机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概念-2"><span class="toc-number">41.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题-17-17-多次搜索"><span class="toc-number">41.2.</span> <span class="toc-text">面试题 17.17. 多次搜索</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#状态压缩DP"><span class="toc-number">42.</span> <span class="toc-text">状态压缩DP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1755-最接近目标值的子序列和"><span class="toc-number">42.1.</span> <span class="toc-text">1755. 最接近目标值的子序列和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#526-优美的排列"><span class="toc-number">42.2.</span> <span class="toc-text">526. 优美的排列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#滑窗技巧"><span class="toc-number">43.</span> <span class="toc-text">滑窗技巧</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#中缀表达式转后缀表达式"><span class="toc-number">44.</span> <span class="toc-text">中缀表达式转后缀表达式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#位运算技巧"><span class="toc-number">45.</span> <span class="toc-text">位运算技巧</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#跳表SkipList"><span class="toc-number">46.</span> <span class="toc-text">跳表SkipList</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#图示"><span class="toc-number">46.1.</span> <span class="toc-text">图示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构"><span class="toc-number">46.2.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#随机层高"><span class="toc-number">46.3.</span> <span class="toc-text">随机层高</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#找每层插入位置的前驱"><span class="toc-number">46.4.</span> <span class="toc-text">找每层插入位置的前驱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#查找-5"><span class="toc-number">46.5.</span> <span class="toc-text">查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#插入-3"><span class="toc-number">46.6.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#删除-2"><span class="toc-number">46.7.</span> <span class="toc-text">删除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode-设计跳表"><span class="toc-number">46.8.</span> <span class="toc-text">LeetCode 设计跳表</span></a></li></ol></li></ol></div></span></div></div></div></aside></div></div></div><footer id="footer"><div class="outer"><div id="footer-info"><div class="footer-left"> &copy; 2025 Louris <span style="font-size:smaller">Hosted by <a href="https://coding.net/" target="_blank" rel="noopener" style="font-weight:700">Coding Pages</a>/ <a href="https://gitee.com/" target="_blank" rel="noopener" style="font-weight:700">Gitee Pages</a>/ <a href="https://github.com/" target="_blank" rel="noopener" style="font-weight:700">Github Pages</a></span></div><div class="footer-right"> <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten</div></div></div></footer></div><script>var yiliaConfig={mathjax:!0,isHome:!1,isPost:!0,isArchive:!1,isTag:!1,isCategory:!1,open_in_new:!1,toc_hide_index:!1,root:"/",innerArchive:!0,showTags:!1}</script><script>!function(r){function e(t){if(i[t])return i[t].exports;var n=i[t]={exports:{},id:t,loaded:!1};return r[t].call(n.exports,n,n.exports,e),n.loaded=!0,n.exports}var i={};e.m=r,e.c=i,e.p="./",e(0)}([function(t,n,r){r(203),t.exports=r(199)},function(t,n,r){var d=r(3),y=r(49),g=r(26),m=r(27),b=r(46),x="prototype",S=function(t,n,r){var e,i,o,u,c=t&S.F,f=t&S.G,a=t&S.S,s=t&S.P,l=t&S.B,h=f?d:a?d[n]||(d[n]={}):(d[n]||{})[x],v=f?y:y[n]||(y[n]={}),p=v[x]||(v[x]={});for(e in f&&(r=n),r)o=((i=!c&&h&&void 0!==h[e])?h:r)[e],u=l&&i?b(o,d):s&&"function"==typeof o?b(Function.call,o):o,h&&m(h,e,o,t&S.U),v[e]!=o&&g(v,e,u),s&&p[e]!=o&&(p[e]=o)};d.core=y,S.F=1,S.G=2,S.S=4,S.P=8,S.B=16,S.W=32,S.U=64,S.R=128,t.exports=S},function(t,n,r){var e=r(5);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n,r){var e=r(128)("wks"),i=r(78),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(170),o=r(53),u=Object.defineProperty;n.f=r(9)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(52),i=Math.min;t.exports=function(t){return 0<t?i(e(t),9007199254740991):0}},function(t,n,r){t.exports=!r(18)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(22);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(20),i=r(59),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(95),i=r(33);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(40)("wks"),i=r(23),o=r(6).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(50);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(21);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n){var r=t.exports={version:"2.5.1"};"number"==typeof __e&&(__e=r)},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(10),i=r(74);t.exports=r(9)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var o=r(3),u=r(26),c=r(25),f=r(78)("src"),e="toString",i=Function[e],a=(""+i).split(e);r(49).inspectSource=function(t){return i.call(t)},(t.exports=function(t,n,r,e){var i="function"==typeof r;i&&(c(r,"name")||u(r,"name",n)),t[n]!==r&&(i&&(c(r,f)||u(r,f,t[n]?""+t[n]:a.join(String(n)))),t===o?t[n]=r:e?t[n]?t[n]=r:u(t,n,r):(delete t[n],u(t,n,r)))})(Function.prototype,e,function(){return"function"==typeof this&&this[f]||i.call(this)})},function(t,n,r){var e=r(1),i=r(4),u=r(50),c=/"/g,o=function(t,n,r,e){var i=String(u(t)),o="<"+n;return""!==r&&(o+=" "+r+'="'+String(e).replace(c,"&quot;")+'"'),o+">"+i+"</"+n+">"};t.exports=function(n,t){var r={};r[n]=t(o),e(e.P+e.F*i(function(){var t=""[n]('"');return t!==t.toLowerCase()||3<t.split('"').length}),"String",r)}},function(t,n,r){var e=r(64),i=r(34);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(116),i=r(74),o=r(32),u=r(53),c=r(25),f=r(170),a=Object.getOwnPropertyDescriptor;n.f=r(9)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(25),i=r(17),o=r(149)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(115),i=r(50);t.exports=function(t){return e(i(t))}},function(t,n){t.exports=function(t){if(null==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(8),o=r(16)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(23);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(6),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(0<t?e:r)(t)}},function(t,n,r){var i=r(21);t.exports=function(t,n){if(!i(t))return t;var r,e;if(n&&"function"==typeof(r=t.toString)&&!i(e=r.call(t)))return e;if("function"==typeof(r=t.valueOf)&&!i(e=r.call(t)))return e;if(!n&&"function"==typeof(r=t.toString)&&!i(e=r.call(t)))return e;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(6),i=r(24),o=r(36),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(16)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var o=r(19);t.exports=function(e,i,t){if(o(e),void 0===i)return e;switch(t){case 1:return function(t){return e.call(i,t)};case 2:return function(t,n){return e.call(i,t,n)};case 3:return function(t,n,r){return e.call(i,t,n,r)}}return function(){return e.apply(i,arguments)}}},function(t,n,r){"use strict";var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n,r){var b=r(46),x=r(115),S=r(17),w=r(11),e=r(134);t.exports=function(l,t){var h=1==l,v=2==l,p=3==l,d=4==l,y=6==l,g=5==l||y,m=t||e;return function(t,n,r){for(var e,i,o=S(t),u=x(o),c=b(n,r,3),f=w(u.length),a=0,s=h?m(t,f):v?m(t,0):void 0;a<f;a++)if((g||a in u)&&(i=c(e=u[a],a,o),l))if(h)s[a]=i;else if(i)switch(l){case 3:return!0;case 5:return e;case 6:return a;case 2:s.push(e)}else if(d)return!1;return y?-1:p||d?d:s}}},function(t,n){var r=t.exports={version:"2.5.1"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){if(null==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var i=r(1),o=r(49),u=r(4);t.exports=function(t,n){var r=(o.Object||{})[t]||Object[t],e={};e[t]=n(r),i(i.S+i.F*u(function(){r(1)}),"Object",e)}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(0<t?e:r)(t)}},function(t,n,r){var i=r(5);t.exports=function(t,n){if(!i(t))return t;var r,e;if(n&&"function"==typeof(r=t.toString)&&!i(e=r.call(t)))return e;if("function"==typeof(r=t.valueOf)&&!i(e=r.call(t)))return e;if(!n&&"function"==typeof(r=t.toString)&&!i(e=r.call(t)))return e;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var d=r(6),y=r(24),g=r(92),m=r(13),b="prototype",x=function(t,n,r){var e,i,o,u=t&x.F,c=t&x.G,f=t&x.S,a=t&x.P,s=t&x.B,l=t&x.W,h=c?y:y[n]||(y[n]={}),v=h[b],p=c?d:f?d[n]:(d[n]||{})[b];for(e in c&&(r=n),r)(i=!u&&p&&void 0!==p[e])&&e in h||(o=i?p[e]:r[e],h[e]=c&&"function"!=typeof p[e]?r[e]:s&&i?g(o,d):l&&p[e]==o?function(e){var t=function(t,n,r){if(this instanceof e){switch(arguments.length){case 0:return new e;case 1:return new e(t);case 2:return new e(t,n)}return new e(t,n,r)}return e.apply(this,arguments)};return t[b]=e[b],t}(o):a&&"function"==typeof o?g(Function.call,o):o,a&&((h.virtual||(h.virtual={}))[e]=o,t&x.R&&v&&!v[e]&&m(v,e,o)))};x.F=1,x.G=2,x.S=4,x.P=8,x.B=16,x.W=32,x.U=64,x.R=128,t.exports=x},function(t,n,r){var o=r(191),e=r(1),i=r(128)("metadata"),u=i.store||(i.store=new(r(194))),c=function(t,n,r){var e=u.get(t);if(!e){if(!r)return;u.set(t,e=new o)}var i=e.get(n);if(!i){if(!r)return;e.set(n,i=new o)}return i};t.exports={store:u,map:c,has:function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},get:function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},set:function(t,n,r,e){c(r,e,!0).set(t,n)},keys:function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},key:function(t){return void 0===t||"symbol"==typeof t?t:String(t)},exp:function(t){e(e.S,"Reflect",t)}}},function(t,n,r){"use strict";if(r(9)){var g=r(70),m=r(3),b=r(4),x=r(1),S=r(130),e=r(155),h=r(46),w=r(68),i=r(74),_=r(26),o=r(75),u=r(52),O=r(11),E=r(189),c=r(77),f=r(53),a=r(25),M=r(114),P=r(5),v=r(17),p=r(141),j=r(71),F=r(31),A=r(72).f,d=r(157),s=r(78),l=r(7),y=r(48),L=r(117),N=r(129),T=r(158),I=r(80),k=r(123),R=r(76),C=r(133),D=r(162),G=r(10),W=r(30),U=G.f,V=W.f,B=m.RangeError,q=m.TypeError,z=m.Uint8Array,H="ArrayBuffer",K="Shared"+H,J="BYTES_PER_ELEMENT",Y="prototype",$=Array[Y],X=e.ArrayBuffer,Q=e.DataView,Z=y(0),tt=y(2),nt=y(3),rt=y(4),et=y(5),it=y(6),ot=L(!0),ut=L(!1),ct=T.values,ft=T.keys,at=T.entries,st=$.lastIndexOf,lt=$.reduce,ht=$.reduceRight,vt=$.join,pt=$.sort,dt=$.slice,yt=$.toString,gt=$.toLocaleString,mt=l("iterator"),bt=l("toStringTag"),xt=s("typed_constructor"),St=s("def_constructor"),wt=S.CONSTR,_t=S.TYPED,Ot=S.VIEW,Et="Wrong length!",Mt=y(1,function(t,n){return Lt(N(t,t[St]),n)}),Pt=b(function(){return 1===new z(new Uint16Array([1]).buffer)[0]}),jt=!!z&&!!z[Y].set&&b(function(){new z(1).set({})}),Ft=function(t,n){var r=u(t);if(r<0||r%n)throw B("Wrong offset!");return r},At=function(t){if(P(t)&&_t in t)return t;throw q(t+" is not a typed array!")},Lt=function(t,n){if(!(P(t)&&xt in t))throw q("It is not a typed array constructor!");return new t(n)},Nt=function(t,n){return Tt(N(t,t[St]),n)},Tt=function(t,n){for(var r=0,e=n.length,i=Lt(t,e);r<e;)i[r]=n[r++];return i},It=function(t,n,r){U(t,n,{get:function(){return this._d[r]}})},kt=function(t){var n,r,e,i,o,u,c=v(t),f=arguments.length,a=1<f?arguments[1]:void 0,s=void 0!==a,l=d(c);if(null!=l&&!p(l)){for(u=l.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(s&&2<f&&(a=h(a,arguments[2],2)),n=0,r=O(c.length),i=Lt(this,r);n<r;n++)i[n]=s?a(c[n],n):c[n];return i},Rt=function(){for(var t=0,n=arguments.length,r=Lt(this,n);t<n;)r[t]=arguments[t++];return r},Ct=!!z&&b(function(){gt.call(new z(1))}),Dt=function(){return gt.apply(Ct?dt.call(At(this)):At(this),arguments)},Gt={copyWithin:function(t,n){return D.call(At(this),t,n,2<arguments.length?arguments[2]:void 0)},every:function(t){return rt(At(this),t,1<arguments.length?arguments[1]:void 0)},fill:function(t){return C.apply(At(this),arguments)},filter:function(t){return Nt(this,tt(At(this),t,1<arguments.length?arguments[1]:void 0))},find:function(t){return et(At(this),t,1<arguments.length?arguments[1]:void 0)},findIndex:function(t){return it(At(this),t,1<arguments.length?arguments[1]:void 0)},forEach:function(t){Z(At(this),t,1<arguments.length?arguments[1]:void 0)},indexOf:function(t){return ut(At(this),t,1<arguments.length?arguments[1]:void 0)},includes:function(t){return ot(At(this),t,1<arguments.length?arguments[1]:void 0)},join:function(t){return vt.apply(At(this),arguments)},lastIndexOf:function(t){return st.apply(At(this),arguments)},map:function(t){return Mt(At(this),t,1<arguments.length?arguments[1]:void 0)},reduce:function(t){return lt.apply(At(this),arguments)},reduceRight:function(t){return ht.apply(At(this),arguments)},reverse:function(){for(var t,n=this,r=At(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(At(this),t,1<arguments.length?arguments[1]:void 0)},sort:function(t){return pt.call(At(this),t)},subarray:function(t,n){var r=At(this),e=r.length,i=c(t,e);return new(N(r,r[St]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,O((void 0===n?e:c(n,e))-i))}},Wt=function(t,n){return Nt(this,dt.call(At(this),t,n))},Ut=function(t){At(this);var n=Ft(arguments[1],1),r=this.length,e=v(t),i=O(e.length),o=0;if(r<i+n)throw B(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(At(this))},keys:function(){return ft.call(At(this))},values:function(){return ct.call(At(this))}},Bt=function(t,n){return P(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return Bt(t,n=f(n,!0))?i(2,t[n]):V(t,n)},zt=function(t,n,r){return!(Bt(t,n=f(n,!0))&&P(r)&&a(r,"value"))||a(r,"get")||a(r,"set")||r.configurable||a(r,"writable")&&!r.writable||a(r,"enumerable")&&!r.enumerable?U(t,n,r):(t[n]=r.value,t)};wt||(W.f=qt,G.f=zt),x(x.S+x.F*!wt,"Object",{getOwnPropertyDescriptor:qt,defineProperty:zt}),b(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Ht=o({},Gt);o(Ht,Vt),_(Ht,mt,Vt.values),o(Ht,{slice:Wt,set:Ut,constructor:function(){},toString:yt,toLocaleString:Dt}),It(Ht,"buffer","b"),It(Ht,"byteOffset","o"),It(Ht,"byteLength","l"),It(Ht,"length","e"),U(Ht,bt,{get:function(){return this[_t]}}),t.exports=function(t,l,n,o){var h=t+((o=!!o)?"Clamped":"")+"Array",r="get"+t,u="set"+t,v=m[h],c=v||{},e=v&&F(v),i=!v||!S.ABV,f={},a=v&&v[Y],p=function(t,i){U(t,i,{get:function(){return t=i,(n=this._d).v[r](t*l+n.o,Pt);var t,n},set:function(t){return n=i,r=t,e=this._d,o&&(r=(r=Math.round(r))<0?0:255<r?255:255&r),void e.v[u](n*l+e.o,r,Pt);var n,r,e},enumerable:!0})};i?(v=n(function(t,n,r,e){w(t,v,h,"_d");var i,o,u,c,f=0,a=0;if(P(n)){if(!(n instanceof X||(c=M(n))==H||c==K))return _t in n?Tt(v,n):kt.call(v,n);i=n,a=Ft(r,l);var s=n.byteLength;if(void 0===e){if(s%l)throw B(Et);if((o=s-a)<0)throw B(Et)}else if((o=O(e)*l)+a>s)throw B(Et);u=o/l}else u=E(n),i=new X(o=u*l);for(_(t,"_d",{b:i,o:a,l:o,e:u,v:new Q(i)});f<u;)p(t,f++)}),a=v[Y]=j(Ht),_(a,"constructor",v)):b(function(){v(1)})&&b(function(){new v(-1)})&&k(function(t){new v,new v(null),new v(1.5),new v(t)},!0)||(v=n(function(t,n,r,e){var i;return w(t,v,h),P(n)?n instanceof X||(i=M(n))==H||i==K?void 0!==e?new c(n,Ft(r,l),e):void 0!==r?new c(n,Ft(r,l)):new c(n):_t in n?Tt(v,n):kt.call(v,n):new c(E(n))}),Z(e!==Function.prototype?A(c).concat(A(e)):A(c),function(t){t in v||_(v,t,c[t])}),v[Y]=a,g||(a.constructor=v));var s=a[mt],d=!!s&&("values"==s.name||null==s.name),y=Vt.values;_(v,xt,!0),_(a,_t,h),_(a,Ot,!0),_(a,St,v),(o?new v(1)[bt]==h:bt in a)||U(a,bt,{get:function(){return h}}),f[h]=v,x(x.G+x.W+x.F*(v!=c),f),x(x.S,h,{BYTES_PER_ELEMENT:l}),x(x.S+x.F*b(function(){c.of.call(v,1)}),h,{from:kt,of:Rt}),J in a||_(a,J,l),x(x.P,h,Gt),R(h),x(x.P+x.F*jt,h,{set:Ut}),x(x.P+x.F*!d,h,Vt),g||a.toString==yt||(a.toString=yt),x(x.P+x.F*b(function(){new v(1).slice()}),h,{slice:Wt}),x(x.P+x.F*(b(function(){return[1,2].toLocaleString()!=new v([1,2]).toLocaleString()})||!b(function(){a.toLocaleString.call([1,2])})),h,{toLocaleString:Dt}),I[h]=d?s:y,g||d||_(a,mt,y)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(21),i=r(6).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(18)(function(){return 7!=Object.defineProperty(r(58)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var b=r(36),x=r(54),S=r(65),w=r(13),_=r(8),O=r(35),E=r(97),M=r(38),P=r(103),j=r(16)("iterator"),F=!([].keys&&"next"in[].keys()),A="values",L=function(){return this};t.exports=function(t,n,r,e,i,o,u){E(r,n,e);var c,f,a,s=function(t){if(!F&&t in p)return p[t];switch(t){case"keys":case A:return function(){return new r(this,t)}}return function(){return new r(this,t)}},l=n+" Iterator",h=i==A,v=!1,p=t.prototype,d=p[j]||p["@@iterator"]||i&&p[i],y=d||s(i),g=i?h?s("entries"):y:void 0,m="Array"==n&&p.entries||d;if(m&&(a=P(m.call(new t)))!==Object.prototype&&a.next&&(M(a,l,!0),b||_(a,j)||w(a,j,L)),h&&d&&d.name!==A&&(v=!0,y=function(){return d.call(this)}),b&&!u||!F&&!v&&p[j]||w(p,j,y),O[n]=y,O[l]=L,i)if(c={values:h?y:s(A),keys:o?y:s("keys"),entries:g},u)for(f in c)f in p||S(p,f,c[f]);else x(x.P+x.F*(F||v),n,c);return c}},function(t,n,e){var i=e(20),o=e(100),u=e(34),c=e(39)("IE_PROTO"),f=function(){},a="prototype",s=function(){var t,n=e(58)("iframe"),r=u.length;for(n.style.display="none",e(94).appendChild(n),n.src="javascript:",(t=n.contentWindow.document).open(),t.write("<script>document.F=Object<\/script>"),t.close(),s=t.F;r--;)delete s[a][u[r]];return s()};t.exports=Object.create||function(t,n){var r;return null!==t?(f[a]=i(t),r=new f,f[a]=null,r[c]=t):r=s(),void 0===n?r:o(r,n)}},function(t,n,r){var e=r(64),i=r(34).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var u=r(8),c=r(15),f=r(91)(!1),a=r(39)("IE_PROTO");t.exports=function(t,n){var r,e=c(t),i=0,o=[];for(r in e)r!=a&&u(e,r)&&o.push(r);for(;n.length>i;)u(e,r=n[i++])&&(~f(o,r)||o.push(r));return o}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;null==i[e]&&r(26)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n,r){var e=r(78)("meta"),i=r(5),o=r(25),u=r(10).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=t.exports={KEY:e,NEED:!1,fastKey:function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},getWeak:function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},onFreeze:function(t){return a&&l.NEED&&f(t)&&!o(t,e)&&s(t),t}}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n,r){var h=r(46),v=r(173),p=r(141),d=r(2),y=r(11),g=r(157),m={},b={};(n=t.exports=function(t,n,r,e,i){var o,u,c,f,a=i?function(){return t}:g(t),s=h(r,e,n?2:1),l=0;if("function"!=typeof a)throw TypeError(t+" is not iterable!");if(p(a)){for(o=y(t.length);l<o;l++)if((f=n?s(d(u=t[l])[0],u[1]):s(t[l]))===m||f===b)return f}else for(c=a.call(t);!(u=c.next()).done;)if((f=v(c,s,u.value,n))===m||f===b)return f}).BREAK=m,n.RETURN=b},function(t,n){t.exports=!1},function(t,n,e){var i=e(2),o=e(179),u=e(137),c=e(149)("IE_PROTO"),f=function(){},a="prototype",s=function(){var t,n=e(136)("iframe"),r=u.length;for(n.style.display="none",e(139).appendChild(n),n.src="javascript:",(t=n.contentWindow.document).open(),t.write("<script>document.F=Object<\/script>"),t.close(),s=t.F;r--;)delete s[a][u[r]];return s()};t.exports=Object.create||function(t,n){var r;return null!==t?(f[a]=i(t),r=new f,f[a]=null,r[c]=t):r=s(),void 0===n?r:o(r,n)}},function(t,n,r){var e=r(181),i=r(137).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(181),i=r(137);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n,r){var i=r(27);t.exports=function(t,n,r){for(var e in n)i(t,e,n[e],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(10),o=r(9),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(52),i=Math.max,o=Math.min;t.exports=function(t,n){return(t=e(t))<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(33);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports={}},function(t,n,r){var e=r(10).f,i=r(25),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var u=r(1),e=r(50),c=r(4),f=r(153),i="["+f+"]",o=RegExp("^"+i+i+"*"),a=RegExp(i+i+"*$"),s=function(t,n,r){var e={},i=c(function(){return!!f[t]()||"​"!="​"[t]()}),o=e[t]=i?n(l):f[t];r&&(e[r]=o),u(u.P+u.F*i,"String",e)},l=s.trim=function(t,n){return t=String(e(t)),1&n&&(t=t.replace(o,"")),2&n&&(t=t.replace(a,"")),t};t.exports=s},function(t,n,r){var e=r(5);t.exports=function(t,n){if(!e(t)||t._t!==n)throw TypeError("Incompatible receiver, "+n+" required!");return t}},function(t,n,r){t.exports={default:r(87),__esModule:!0}},function(t,n,r){t.exports={default:r(88),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=e(r(85)),o=e(r(84)),u="function"==typeof o.default&&"symbol"==typeof i.default?function(t){return typeof t}:function(t){return t&&"function"==typeof o.default&&t.constructor===o.default&&t!==o.default.prototype?"symbol":typeof t};n.default="function"==typeof o.default&&"symbol"===u(i.default)?function(t){return void 0===t?"undefined":u(t)}:function(t){return t&&"function"==typeof o.default&&t.constructor===o.default&&t!==o.default.prototype?"symbol":void 0===t?"undefined":u(t)}},function(t,n,r){r(110),r(108),r(111),r(112),t.exports=r(24).Symbol},function(t,n,r){r(109),r(113),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var f=r(15),a=r(106),s=r(105);t.exports=function(c){return function(t,n,r){var e,i=f(t),o=a(i.length),u=s(r,o);if(c&&n!=n){for(;u<o;)if((e=i[u++])!=e)return!0}else for(;u<o;u++)if((c||u in i)&&i[u]===n)return c||u||0;return!c&&-1}}},function(t,n,r){var o=r(89);t.exports=function(e,i,t){if(o(e),void 0===i)return e;switch(t){case 1:return function(t){return e.call(i,t)};case 2:return function(t,n){return e.call(i,t,n)};case 3:return function(t,n,r){return e.call(i,t,n,r)}}return function(){return e.apply(i,arguments)}}},function(t,n,r){var c=r(29),f=r(63),a=r(37);t.exports=function(t){var n=c(t),r=f.f;if(r)for(var e,i=r(t),o=a.f,u=0;i.length>u;)o.call(t,e=i[u++])&&n.push(e);return n}},function(t,n,r){var e=r(6).document;t.exports=e&&e.documentElement},function(t,n,r){var e=r(57);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(57);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(61),i=r(22),o=r(38),u={};r(13)(u,r(16)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(23)("meta"),i=r(21),o=r(8),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(18)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=t.exports={KEY:e,NEED:!1,fastKey:function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},getWeak:function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},onFreeze:function(t){return a&&l.NEED&&f(t)&&!o(t,e)&&s(t),t}}},function(t,n,r){var u=r(14),c=r(20),f=r(29);t.exports=r(12)?Object.defineProperties:function(t,n){c(t);for(var r,e=f(n),i=e.length,o=0;o<i;)u.f(t,r=e[o++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(22),o=r(15),u=r(42),c=r(8),f=r(59),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(15),i=r(62).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?function(t){try{return i(t)}catch(t){return u.slice()}}(t):i(e(t))}},function(t,n,r){var e=r(8),i=r(79),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var f=r(41),a=r(33);t.exports=function(c){return function(t,n){var r,e,i=String(a(t)),o=f(n),u=i.length;return o<0||u<=o?c?"":void 0:(r=i.charCodeAt(o))<55296||56319<r||o+1===u||(e=i.charCodeAt(o+1))<56320||57343<e?c?i.charAt(o):r:c?i.slice(o,o+2):e-56320+(r-55296<<10)+65536}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return(t=e(t))<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return 0<t?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(90),i=r(98),o=r(35),u=r(15);t.exports=r(60)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):i(0,"keys"==n?r:"values"==n?t[r]:[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(104)(!0);r(60)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(6),u=r(8),i=r(12),o=r(54),c=r(65),f=r(99).KEY,a=r(18),s=r(40),l=r(38),h=r(23),v=r(16),p=r(44),d=r(43),y=r(93),g=r(96),m=r(20),b=r(15),x=r(42),S=r(22),w=r(61),_=r(102),O=r(101),E=r(14),M=r(29),P=O.f,j=E.f,F=_.f,A=e.Symbol,L=e.JSON,N=L&&L.stringify,T="prototype",I=v("_hidden"),k=v("toPrimitive"),R={}.propertyIsEnumerable,C=s("symbol-registry"),D=s("symbols"),G=s("op-symbols"),W=Object[T],U="function"==typeof A,V=e.QObject,B=!V||!V[T]||!V[T].findChild,q=i&&a(function(){return 7!=w(j({},"a",{get:function(){return j(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=P(W,n);e&&delete W[n],j(t,n,r),e&&t!==W&&j(W,n,e)}:j,z=function(t){var n=D[t]=w(A[T]);return n._k=t,n},H=U&&"symbol"==typeof A.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof A},K=function(t,n,r){return t===W&&K(G,n,r),m(t),n=x(n,!0),m(r),u(D,n)?(r.enumerable?(u(t,I)&&t[I][n]&&(t[I][n]=!1),r=w(r,{enumerable:S(0,!1)})):(u(t,I)||j(t,I,S(1,{})),t[I][n]=!0),q(t,n,r)):j(t,n,r)},J=function(t,n){m(t);for(var r,e=y(n=b(n)),i=0,o=e.length;i<o;)K(t,r=e[i++],n[r]);return t},Y=function(t){var n=R.call(this,t=x(t,!0));return!(this===W&&u(D,t)&&!u(G,t))&&(!(n||!u(this,t)||!u(D,t)||u(this,I)&&this[I][t])||n)},$=function(t,n){if(t=b(t),n=x(n,!0),t!==W||!u(D,n)||u(G,n)){var r=P(t,n);return!r||!u(D,n)||u(t,I)&&t[I][n]||(r.enumerable=!0),r}},X=function(t){for(var n,r=F(b(t)),e=[],i=0;r.length>i;)u(D,n=r[i++])||n==I||n==f||e.push(n);return e},Q=function(t){for(var n,r=t===W,e=F(r?G:b(t)),i=[],o=0;e.length>o;)!u(D,n=e[o++])||r&&!u(W,n)||i.push(D[n]);return i};U||(c((A=function(){if(this instanceof A)throw TypeError("Symbol is not a constructor!");var n=h(0<arguments.length?arguments[0]:void 0),r=function(t){this===W&&r.call(G,t),u(this,I)&&u(this[I],n)&&(this[I][n]=!1),q(this,n,S(1,t))};return i&&B&&q(W,n,{configurable:!0,set:r}),z(n)})[T],"toString",function(){return this._k}),O.f=$,E.f=K,r(62).f=_.f=X,r(37).f=Y,r(63).f=Q,i&&!r(36)&&c(W,"propertyIsEnumerable",Y,!0),p.f=function(t){return z(v(t))}),o(o.G+o.W+o.F*!U,{Symbol:A});for(var Z="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),tt=0;Z.length>tt;)v(Z[tt++]);for(var nt=M(v.store),rt=0;nt.length>rt;)d(nt[rt++]);o(o.S+o.F*!U,"Symbol",{for:function(t){return u(C,t+="")?C[t]:C[t]=A(t)},keyFor:function(t){if(!H(t))throw TypeError(t+" is not a symbol!");for(var n in C)if(C[n]===t)return n},useSetter:function(){B=!0},useSimple:function(){B=!1}}),o(o.S+o.F*!U,"Object",{create:function(t,n){return void 0===n?w(t):J(w(t),n)},defineProperty:K,defineProperties:J,getOwnPropertyDescriptor:$,getOwnPropertyNames:X,getOwnPropertySymbols:Q}),L&&o(o.S+o.F*(!U||a(function(){var t=A();return"[null]"!=N([t])||"{}"!=N({a:t})||"{}"!=N(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!H(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return"function"==typeof(n=e[1])&&(r=n),!r&&g(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!H(n))return n}),e[1]=n,N.apply(L,e)}}}),A[T][k]||r(13)(A[T],k,A[T].valueOf),l(A,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(107);for(var e=r(6),i=r(13),o=r(35),u=r(16)("toStringTag"),c="CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","),f=0;f<c.length;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){var i=r(45),o=r(7)("toStringTag"),u="Arguments"==i(function(){return arguments}());t.exports=function(t){var n,r,e;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=function(t,n){try{return t[n]}catch(t){}}(n=Object(t),o))?r:u?i(n):"Object"==(e=i(n))&&"function"==typeof n.callee?"Arguments":e}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var f=r(32),a=r(11),s=r(77);t.exports=function(c){return function(t,n,r){var e,i=f(t),o=a(i.length),u=s(r,o);if(c&&n!=n){for(;u<o;)if((e=i[u++])!=e)return!0}else for(;u<o;u++)if((c||u in i)&&i[u]===n)return c||u||0;return!c&&-1}}},function(t,n,r){"use strict";var g=r(3),m=r(1),b=r(27),x=r(75),S=r(67),w=r(69),_=r(68),O=r(5),E=r(4),M=r(123),P=r(81),j=r(140);t.exports=function(e,t,n,r,i,o){var u=g[e],c=u,f=i?"set":"add",a=c&&c.prototype,s={},l=function(t){var r=a[t];b(a,t,"delete"==t?function(t){return!(o&&!O(t))&&r.call(this,0===t?0:t)}:"has"==t?function(t){return!(o&&!O(t))&&r.call(this,0===t?0:t)}:"get"==t?function(t){return o&&!O(t)?void 0:r.call(this,0===t?0:t)}:"add"==t?function(t){return r.call(this,0===t?0:t),this}:function(t,n){return r.call(this,0===t?0:t,n),this})};if("function"==typeof c&&(o||a.forEach&&!E(function(){(new c).entries().next()}))){var h=new c,v=h[f](o?{}:-0,1)!=h,p=E(function(){h.has(1)}),d=M(function(t){new c(t)}),y=!o&&E(function(){for(var t=new c,n=5;n--;)t[f](n,n);return!t.has(-0)});d||(((c=t(function(t,n){_(t,c,e);var r=j(new u,t,c);return null!=n&&w(n,i,r[f],r),r})).prototype=a).constructor=c),(p||y)&&(l("delete"),l("has"),i&&l("get")),(y||v)&&l(f),o&&a.clear&&delete a.clear}else c=r.getConstructor(t,e,i,f),x(c.prototype,n),S.NEED=!0;return P(c,e),s[e]=c,m(m.G+m.W+m.F*(c!=u),s),o||r.setStrong(c,e,i),c}},function(t,n,r){"use strict";var c=r(26),f=r(27),a=r(4),s=r(50),l=r(7);t.exports=function(n,t,r){var e=l(n),i=r(s,e,""[n]),o=i[0],u=i[1];a(function(){var t={};return t[e]=function(){return 7},7!=""[n](t)})&&(f(String.prototype,n,o),c(RegExp.prototype,e,2==t?function(t,n){return u.call(t,this,n)}:function(t){return u.call(t,this)}))}},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){var e=r(5),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var o=r(7)("iterator"),u=!1;try{var e=[7][o]();e.return=function(){u=!0},Array.from(e,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!u)return!1;var r=!1;try{var e=[7],i=e[o]();i.next=function(){return{done:r=!0}},e[o]=function(){return i},t(e)}catch(t){}return r}},function(t,n,r){"use strict";t.exports=r(70)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){"use strict";var e=r(1),u=r(19),c=r(46),f=r(69);t.exports=function(t){e(e.S,t,{from:function(t){var n,r,e,i,o=arguments[1];return u(this),(n=void 0!==o)&&u(o),null==t?new this:(r=[],n?(e=0,i=c(o,arguments[2],2),f(t,!1,function(t){r.push(i(t,e++))})):f(t,!1,r.push,r),new this(r))}})}},function(t,n,r){"use strict";var e=r(1);t.exports=function(t){e(e.S,t,{of:function(){for(var t=arguments.length,n=Array(t);t--;)n[t]=arguments[t];return new this(n)}})}},function(t,n,r){var e=r(3),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n,r){var i=r(2),o=r(19),u=r(7)("species");t.exports=function(t,n){var r,e=i(t).constructor;return void 0===e||null==(r=i(e)[u])?n:o(r)}},function(t,n,r){for(var e,i=r(3),o=r(26),u=r(78),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n){"use strict";var r,e={versions:(r=window.navigator.userAgent,{trident:-1<r.indexOf("Trident"),presto:-1<r.indexOf("Presto"),webKit:-1<r.indexOf("AppleWebKit"),gecko:-1<r.indexOf("Gecko")&&-1==r.indexOf("KHTML"),mobile:!!r.match(/AppleWebKit.*Mobile.*/),ios:!!r.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:-1<r.indexOf("Android")||-1<r.indexOf("Linux"),iPhone:-1<r.indexOf("iPhone")||-1<r.indexOf("Mac"),iPad:-1<r.indexOf("iPad"),webApp:-1==r.indexOf("Safari"),weixin:-1==r.indexOf("MicroMessenger")})};t.exports=e},function(t,n,r){"use strict";var e,l=(e=r(86))&&e.__esModule?e:{default:e},h=function(){function n(t,n,r){return n||r?String.fromCharCode(n||r):o[t]||t}function r(t){return s[t]}var e=/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,i=/['<> "&]/g,o={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},u=/\u00a0/g,c=/<br\s*\/?>/gi,f=/\r?\n/g,a=/\s/g,s={};for(var t in o)s[o[t]]=t;return o["&apos;"]="'",s["'"]="&#39;",{encode:function(t){return t?(""+t).replace(i,r).replace(f,"<br/>").replace(a,"&nbsp;"):""},decode:function(t){return t?(""+t).replace(c,"\n").replace(e,n).replace(u," "):""},encodeBase16:function(t){if(!t)return t;for(var n=[],r=0,e=(t+="").length;r<e;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;for(var n=[],r=0,e=(t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")})).length;r<e;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;for(var n=[],r=0,e=(t+="").length;r<e;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;n<r;n++)t[n]=h.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,l.default)(t)))for(var e in t)t[e]=h.encodeObject(t[e]);else if("string"==typeof t)return h.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=h},function(t,n,r){"use strict";var c=r(17),f=r(77),a=r(11);t.exports=function(t){for(var n=c(this),r=a(n.length),e=arguments.length,i=f(1<e?arguments[1]:void 0,r),o=2<e?arguments[2]:void 0,u=void 0===o?r:f(o,r);i<u;)n[i++]=t;return n}},function(t,n,r){var e=r(211);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(10),i=r(74);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(5),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(n){var r=/./;try{"/./"[n](r)}catch(t){try{return r[e]=!1,!"/./"[n](r)}catch(n){}}return!0}},function(t,n,r){var e=r(3).document;t.exports=e&&e.documentElement},function(t,n,r){var o=r(5),u=r(148).set;t.exports=function(t,n,r){var e,i=n.constructor;return i!==r&&"function"==typeof i&&(e=i.prototype)!==r.prototype&&o(e)&&u&&u(t,e),t}},function(t,n,r){var e=r(80),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){"use strict";var e=r(71),i=r(74),o=r(81),u={};r(26)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var b=r(70),x=r(1),S=r(27),w=r(26),_=r(25),O=r(80),E=r(142),M=r(81),P=r(31),j=r(7)("iterator"),F=!([].keys&&"next"in[].keys()),A="values",L=function(){return this};t.exports=function(t,n,r,e,i,o,u){E(r,n,e);var c,f,a,s=function(t){if(!F&&t in p)return p[t];switch(t){case"keys":case A:return function(){return new r(this,t)}}return function(){return new r(this,t)}},l=n+" Iterator",h=i==A,v=!1,p=t.prototype,d=p[j]||p["@@iterator"]||i&&p[i],y=d||s(i),g=i?h?s("entries"):y:void 0,m="Array"==n&&p.entries||d;if(m&&(a=P(m.call(new t)))!==Object.prototype&&a.next&&(M(a,l,!0),b||_(a,j)||w(a,j,L)),h&&d&&d.name!==A&&(v=!0,y=function(){return d.call(this)}),b&&!u||!F&&!v&&p[j]||w(p,j,y),O[n]=y,O[l]=L,i)if(c={values:h?y:s(A),keys:o?y:s("keys"),entries:g},u)for(f in c)f in p||S(p,f,c[f]);else x(x.P+x.F*(F||v),n,c);return c}},function(t,n){var r=Math.expm1;t.exports=!r||22025.465794806718<r(10)||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:-1e-6<t&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var c=r(3),f=r(154).set,a=c.MutationObserver||c.WebKitMutationObserver,s=c.process,l=c.Promise,h="process"==r(45)(s);t.exports=function(){var r,e,i,t=function(){var t,n;for(h&&(t=s.domain)&&t.exit();r;){n=r.fn,r=r.next;try{n()}catch(t){throw r?i():e=void 0,t}}e=void 0,t&&t.enter()};if(h)i=function(){s.nextTick(t)};else if(a){var n=!0,o=document.createTextNode("");new a(t).observe(o,{characterData:!0}),i=function(){o.data=n=!n}}else if(l&&l.resolve){var u=l.resolve();i=function(){u.then(t)}}else i=function(){f.call(c,t)};return function(t){var n={fn:t,next:void 0};e&&(e.next=n),r||(r=n,i()),e=n}}},function(t,n,r){"use strict";function e(t){var r,e;this.promise=new t(function(t,n){if(void 0!==r||void 0!==e)throw TypeError("Bad Promise constructor");r=t,e=n}),this.resolve=i(r),this.reject=i(e)}var i=r(19);t.exports.f=function(t){return new e(t)}},function(t,n,i){var r=i(5),e=i(2),o=function(t,n){if(e(t),!r(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,r,e){try{(e=i(46)(Function.call,i(30).f(Object.prototype,"__proto__").set,2))(t,[]),r=!(t instanceof Array)}catch(t){r=!0}return function(t,n){return o(t,n),r?t.__proto__=n:e(t,n),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(128)("keys"),i=r(78);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var f=r(52),a=r(50);t.exports=function(c){return function(t,n){var r,e,i=String(a(t)),o=f(n),u=i.length;return o<0||u<=o?c?"":void 0:(r=i.charCodeAt(o))<55296||56319<r||o+1===u||(e=i.charCodeAt(o+1))<56320||57343<e?c?i.charAt(o):r:c?i.slice(o,o+2):e-56320+(r-55296<<10)+65536}}},function(t,n,r){var e=r(122),i=r(50);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var i=r(52),o=r(50);t.exports=function(t){var n=String(o(this)),r="",e=i(t);if(e<0||e==1/0)throw RangeError("Count can't be negative");for(;0<e;(e>>>=1)&&(n+=n))1&e&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(46),c=r(171),f=r(139),a=r(136),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=s.Dispatch,y=0,g={},m="onreadystatechange",b=function(){var t=+this;if(g.hasOwnProperty(t)){var n=g[t];delete g[t],n()}},x=function(t){b.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return g[++y]=function(){c("function"==typeof t?t:Function(t),n)},e(y),y},v=function(t){delete g[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(b,t,1))}:d&&d.now?e=function(t){d.now(u(b,t,1))}:p?(o=(i=new p).port2,i.port1.onmessage=x,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",x,!1)):e=m in a("script")?function(t){f.appendChild(a("script"))[m]=function(){f.removeChild(this),b.call(t)}}:function(t){setTimeout(u(b,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";function e(t,n,r){var e,i,o,u=Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?W(2,-24)-W(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for((t=G(t))!=t||t===C?(i=t!=t?1:0,e=f):(e=U(V(t)/B),t*(o=W(2,-e))<1&&(e--,o*=2),2<=(t+=1<=e+a?s/o:s*W(2,1-a))*o&&(e++,o/=2),f<=e+a?(i=0,e=f):1<=e+a?(i=(t*o-1)*W(2,n),e+=a):(i=t*W(2,a-1)*W(2,n),e=0));8<=n;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;0<c;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u}function i(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;0<c;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;0<c;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-C:C;e+=W(2,n),s-=u}return(a?-1:1)*e*W(2,s-n)}function o(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]}function u(t){return[255&t]}function c(t){return[255&t,t>>8&255]}function f(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]}function a(t){return e(t,52,8)}function s(t){return e(t,23,4)}function l(t,n,r){M(t[L],n,{get:function(){return this[r]}})}function h(t,n,r,e){var i=O(+r);if(i+n>t[K])throw R(N);var o=t[H]._b,u=i+t[J],c=o.slice(u,u+n);return e?c:c.reverse()}function v(t,n,r,e,i,o){var u=O(+r);if(u+n>t[K])throw R(N);for(var c=t[H]._b,f=u+t[J],a=e(+i),s=0;s<n;s++)c[f+s]=a[o?s:n-s-1]}var p=r(3),d=r(9),y=r(70),g=r(130),m=r(26),b=r(75),x=r(4),S=r(68),w=r(52),_=r(11),O=r(189),E=r(72).f,M=r(10).f,P=r(133),j=r(81),F="ArrayBuffer",A="DataView",L="prototype",N="Wrong index!",T=p[F],I=p[A],k=p.Math,R=p.RangeError,C=p.Infinity,D=T,G=k.abs,W=k.pow,U=k.floor,V=k.log,B=k.LN2,q="byteLength",z="byteOffset",H=d?"_b":"buffer",K=d?"_l":q,J=d?"_o":z;if(g.ABV){if(!x(function(){T(1)})||!x(function(){new T(-1)})||x(function(){return new T,new T(1.5),new T(NaN),T.name!=F})){for(var Y,$=(T=function(t){return S(this,T),new D(O(t))})[L]=D[L],X=E(D),Q=0;X.length>Q;)(Y=X[Q++])in T||m(T,Y,D[Y]);y||($.constructor=T)}var Z=new I(new T(2)),tt=I[L].setInt8;Z.setInt8(0,2147483648),Z.setInt8(1,2147483649),!Z.getInt8(0)&&Z.getInt8(1)||b(I[L],{setInt8:function(t,n){tt.call(this,t,n<<24>>24)},setUint8:function(t,n){tt.call(this,t,n<<24>>24)}},!0)}else T=function(t){S(this,T,F);var n=O(t);this._b=P.call(Array(n),0),this[K]=n},I=function(t,n,r){S(this,I,A),S(t,T,A);var e=t[K],i=w(n);if(i<0||e<i)throw R("Wrong offset!");if(e<i+(r=void 0===r?e-i:_(r)))throw R("Wrong length!");this[H]=t,this[J]=i,this[K]=r},d&&(l(T,q,"_l"),l(I,"buffer","_b"),l(I,q,"_l"),l(I,z,"_o")),b(I[L],{getInt8:function(t){return h(this,1,t)[0]<<24>>24},getUint8:function(t){return h(this,1,t)[0]},getInt16:function(t){var n=h(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=h(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return o(h(this,4,t,arguments[1]))},getUint32:function(t){return o(h(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return i(h(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return i(h(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){v(this,1,t,u,n)},setUint8:function(t,n){v(this,1,t,u,n)},setInt16:function(t,n){v(this,2,t,c,n,arguments[2])},setUint16:function(t,n){v(this,2,t,c,n,arguments[2])},setInt32:function(t,n){v(this,4,t,f,n,arguments[2])},setUint32:function(t,n){v(this,4,t,f,n,arguments[2])},setFloat32:function(t,n){v(this,4,t,s,n,arguments[2])},setFloat64:function(t,n){v(this,8,t,a,n,arguments[2])}});j(T,F),j(I,A),m(I[L],g.VIEW,!0),n[F]=T,n[A]=I},function(t,n,r){var e=r(3),i=r(49),o=r(70),u=r(190),c=r(10).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(114),i=r(7)("iterator"),o=r(80);t.exports=r(49).getIteratorMethod=function(t){if(null!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(66),i=r(174),o=r(80),u=r(32);t.exports=r(143)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):i(0,"keys"==n?r:"values"==n?t[r]:[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){t.exports=function(t,n){t.classList?t.classList.add(n):t.className+=" "+n}},function(t,n){t.exports=function(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var a=r(17),s=r(77),l=r(11);t.exports=[].copyWithin||function(t,n){var r=a(this),e=l(r.length),i=s(t,e),o=s(n,e),u=2<arguments.length?arguments[2]:void 0,c=Math.min((void 0===u?e:s(u,e))-o,e-i),f=1;for(o<i&&i<o+c&&(f=-1,o+=c-1,i+=c-1);0<c--;)o in r?r[i]=r[o]:delete r[i],i+=f,o+=f;return r}},function(t,n,r){var e=r(69);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var s=r(19),l=r(17),h=r(115),v=r(11);t.exports=function(t,n,r,e,i){s(n);var o=l(t),u=h(o),c=v(o.length),f=i?c-1:0,a=i?-1:1;if(r<2)for(;;){if(f in u){e=u[f],f+=a;break}if(f+=a,i?f<0:c<=f)throw TypeError("Reduce of empty array with no initial value")}for(;i?0<=f:f<c;f+=a)f in u&&(e=n(e,u[f],f,o));return e}},function(t,n,r){"use strict";var o=r(19),u=r(5),c=r(171),f=[].slice,a={};t.exports=Function.bind||function(n){var r=o(this),e=f.call(arguments,1),i=function(){var t=e.concat(f.call(arguments));return this instanceof i?function(t,n,r){if(!(n in a)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";a[n]=Function("F,a","return new F("+e.join(",")+")")}return a[n](t,r)}(r,t.length,t):c(r,t,n)};return u(r.prototype)&&(i.prototype=r.prototype),i}},function(t,n,r){"use strict";var u=r(10).f,c=r(71),f=r(75),a=r(46),s=r(68),l=r(69),e=r(143),i=r(174),o=r(76),h=r(9),v=r(67).fastKey,p=r(83),d=h?"_s":"size",y=function(t,n){var r,e=v(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,o,r,e){var i=t(function(t,n){s(t,i,o,"_i"),t._t=o,t._i=c(null),t._f=void 0,t._l=void 0,t[d]=0,null!=n&&l(n,r,t[e],t)});return f(i.prototype,{clear:function(){for(var t=p(this,o),n=t._i,r=t._f;r;r=r.n)r.r=!0,r.p&&(r.p=r.p.n=void 0),delete n[r.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var n=p(this,o),r=y(n,t);if(r){var e=r.n,i=r.p;delete n._i[r.i],r.r=!0,i&&(i.n=e),e&&(e.p=i),n._f==r&&(n._f=e),n._l==r&&(n._l=i),n[d]--}return!!r},forEach:function(t){p(this,o);for(var n,r=a(t,1<arguments.length?arguments[1]:void 0,3);n=n?n.n:this._f;)for(r(n.v,n.k,this);n&&n.r;)n=n.p},has:function(t){return!!y(p(this,o),t)}}),h&&u(i.prototype,"size",{get:function(){return p(this,o)[d]}}),i},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=v(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,r,n){e(t,r,function(t,n){this._t=p(t,r),this._k=n,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?i(0,"keys"==n?r.k:"values"==n?r.v:[r.k,r.v]):(t._t=void 0,i(1))},n?"entries":"values",!n,!0),o(r)}}},function(t,n,r){var e=r(114),i=r(163);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var u=r(75),c=r(67).getWeak,i=r(2),f=r(5),a=r(68),s=r(69),e=r(48),l=r(25),h=r(83),o=e(5),v=e(6),p=0,d=function(t){return t._l||(t._l=new y)},y=function(){this.a=[]},g=function(t,n){return o(t.a,function(t){return t[0]===n})};y.prototype={get:function(t){var n=g(this,t);if(n)return n[1]},has:function(t){return!!g(this,t)},set:function(t,n){var r=g(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(n){var t=v(this.a,function(t){return t[0]===n});return~t&&this.a.splice(t,1),!!~t}},t.exports={getConstructor:function(t,r,e,i){var o=t(function(t,n){a(t,o,r,"_i"),t._t=r,t._i=p++,t._l=void 0,null!=n&&s(n,e,t[i],t)});return u(o.prototype,{delete:function(t){if(!f(t))return!1;var n=c(t);return!0===n?d(h(this,r)).delete(t):n&&l(n,this._i)&&delete n[this._i]},has:function(t){if(!f(t))return!1;var n=c(t);return!0===n?d(h(this,r)).has(t):n&&l(n,this._i)}}),o},def:function(t,n,r){var e=c(i(n),!0);return!0===e?d(t).set(n,r):e[t._i]=r,t},ufstore:d}},function(t,n,r){"use strict";var p=r(121),d=r(5),y=r(11),g=r(46),m=r(7)("isConcatSpreadable");t.exports=function t(n,r,e,i,o,u,c,f){for(var a,s,l=o,h=0,v=!!c&&g(c,f,3);h<i;){if(h in e){if(a=v?v(e[h],h,r):e[h],s=!1,d(a)&&(s=void 0!==(s=a[m])?!!s:p(a)),s&&0<u)l=t(n,r,a,y(a.length),l,u-1)-1;else{if(9007199254740991<=l)throw TypeError();n[l]=a}l++}h++}return l}},function(t,n,r){t.exports=!r(9)&&!r(4)(function(){return 7!=Object.defineProperty(r(136)("div"),"a",{get:function(){return 7}}).a})},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(5),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var o=r(2);t.exports=function(t,n,r,e){try{return e?n(o(r)[0],r[1]):n(r)}catch(n){var i=t.return;throw void 0!==i&&o(i.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var o=r(145),e=Math.pow,u=e(2,-52),c=e(2,-23),f=e(2,127)*(2-c),a=e(2,-126);t.exports=Math.fround||function(t){var n,r,e=Math.abs(t),i=o(t);return e<a?i*(e/a/c+1/u-1/u)*a*c:(r=(n=(1+c/u)*e)-(n-e))>f||r!=r?i*(1/0):i*r}},function(t,n){t.exports=Math.log1p||function(t){return-1e-8<(t=+t)&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n){t.exports=Math.scale||function(t,n,r,e,i){return 0===arguments.length||t!=t||n!=n||r!=r||e!=e||i!=i?NaN:t===1/0||t===-1/0?t:(t-n)*(i-e)/(r-n)+e}},function(t,n,r){"use strict";var h=r(73),v=r(125),p=r(116),d=r(17),y=r(115),i=Object.assign;t.exports=!i||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=i({},t)[r]||Object.keys(i({},n)).join("")!=e})?function(t,n){for(var r=d(t),e=arguments.length,i=1,o=v.f,u=p.f;i<e;)for(var c,f=y(arguments[i++]),a=o?h(f).concat(o(f)):h(f),s=a.length,l=0;l<s;)u.call(f,c=a[l++])&&(r[c]=f[c]);return r}:i},function(t,n,r){var u=r(10),c=r(2),f=r(73);t.exports=r(9)?Object.defineProperties:function(t,n){c(t);for(var r,e=f(n),i=e.length,o=0;o<i;)u.f(t,r=e[o++],n[r]);return t}},function(t,n,r){var e=r(32),i=r(72).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?function(t){try{return i(t)}catch(t){return u.slice()}}(t):i(e(t))}},function(t,n,r){var u=r(25),c=r(32),f=r(117)(!1),a=r(149)("IE_PROTO");t.exports=function(t,n){var r,e=c(t),i=0,o=[];for(r in e)r!=a&&u(e,r)&&o.push(r);for(;n.length>i;)u(e,r=n[i++])&&(~f(o,r)||o.push(r));return o}},function(t,n,r){var f=r(73),a=r(32),s=r(116).f;t.exports=function(c){return function(t){for(var n,r=a(t),e=f(r),i=e.length,o=0,u=[];o<i;)s.call(r,n=e[o++])&&u.push(c?[n,r[n]]:r[n]);return u}}},function(t,n,r){var e=r(72),i=r(125),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(82).trim;t.exports=1/e(r(153)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(82).trim,o=r(153),u=/^[-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=function(t){try{return{e:!1,v:t()}}catch(t){return{e:!0,v:t}}}},function(t,n,r){var e=r(2),i=r(5),o=r(147);t.exports=function(t,n){if(e(t),i(n)&&n.constructor===t)return n;var r=o.f(t);return(0,r.resolve)(n),r.promise}},function(t,n,r){var s=r(11),l=r(152),h=r(50);t.exports=function(t,n,r,e){var i=String(h(t)),o=i.length,u=void 0===r?" ":String(r),c=s(n);if(c<=o||""==u)return i;var f=c-o,a=l.call(u,Math.ceil(f/u.length));return a.length>f&&(a=a.slice(0,f)),e?a+i:i+a}},function(t,n,r){var e=r(52),i=r(11);t.exports=function(t){if(void 0===t)return 0;var n=e(t),r=i(n);if(n!==r)throw RangeError("Wrong length!");return r}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(166),i=r(83);t.exports=r(118)("Map",function(t){return function(){return t(this,0<arguments.length?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(i(this,"Map"),t);return n&&n.v},set:function(t,n){return e.def(i(this,"Map"),0===t?0:t,n)}},e,!0)},function(t,n,r){r(9)&&"g"!=/./g.flags&&r(10).f(RegExp.prototype,"flags",{configurable:!0,get:r(120)})},function(t,n,r){"use strict";var e=r(166),i=r(83);t.exports=r(118)("Set",function(t){return function(){return t(this,0<arguments.length?arguments[0]:void 0)}},{add:function(t){return e.def(i(this,"Set"),t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var o,e=r(48)(0),u=r(27),i=r(67),c=r(178),f=r(168),a=r(5),s=r(4),l=r(83),h="WeakMap",v=i.getWeak,p=Object.isExtensible,d=f.ufstore,y={},g=function(t){return function(){return t(this,0<arguments.length?arguments[0]:void 0)}},m={get:function(t){if(a(t)){var n=v(t);return!0===n?d(l(this,h)).get(t):n?n[this._i]:void 0}},set:function(t,n){return f.def(l(this,h),t,n)}},b=t.exports=r(118)(h,g,m,f,!0,!0);s(function(){return 7!=(new b).set((Object.freeze||Object)(y),7).get(y)})&&(c((o=f.getConstructor(g,h)).prototype,m),i.NEED=!0,e(["delete","has","get","set"],function(e){var t=b.prototype,i=t[e];u(t,e,function(t,n){if(!a(t)||p(t))return i.call(this,t,n);this._f||(this._f=new o);var r=this._f[e](t,n);return"set"==e?this:r})}))},,,,function(t,n){"use strict";t.exports={init:function(){var t=document.querySelector("#page-nav");t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&lt; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &gt;</a>'),yiliaConfig&&yiliaConfig.open_in_new&&document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")}),yiliaConfig&&yiliaConfig.toc_hide_index&&document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"});var n=document.querySelector("#js-aboutme");n&&0!==n.length&&(n.innerHTML=n.innerText)}}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n,r,e,i){var o=function(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}(t),u=function(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}(t)-n;if(u-r<=i){var c=t.$newDom;c||(c=t.cloneNode(!0),(0,a.default)(t,c),(t.$newDom=c).style.position="fixed",c.style.top=(r||u)+"px",c.style.left=o+"px",c.style.zIndex=e||2,c.style.width="100%",c.style.color="#fff"),c.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var f=t.$newDom;f&&(f.style.visibility="hidden")}}function o(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");i(t,document.body.scrollTop,-63,2,0),i(n,document.body.scrollTop,1,3,0)}var f=e(r(159)),a=e((e(r(160)),r(410))),u=e(r(131)),c=e(r(198)),s=r(132);u.default.versions.mobile&&window.screen.width<800&&(function(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var i=t[r];o=n,u=i.getAttribute("href"),c=/\/|index.html/g,o.replace(c,"")===u.replace(c,"")&&(0,f.default)(i,"active")}var o,u,c}(),document.querySelector("#container").addEventListener("scroll",function(t){o()}),window.addEventListener("scroll",function(t){o()}),o()),(0,s.addLoadEvent)(function(){c.default.init()}),t.exports={}},,,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object.defineProperty(t,n,{writable:!0,configurable:!0,value:r})}if(r(409),r(204),r(207),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},function(N,t){(function(t){!function(t){"use strict";function o(t,n,r,e){var o,u,c,f,i=n&&n.prototype instanceof h?n:h,a=Object.create(i.prototype),s=new p(e||[]);return a._invoke=(o=t,u=r,c=s,f=_,function(t,n){if(f===E)throw new Error("Generator is already running");if(f===M){if("throw"===t)throw n;return d()}for(c.method=t,c.arg=n;;){var r=c.delegate;if(r){var e=v(r,c);if(e){if(e===P)continue;return e}}if("next"===c.method)c.sent=c._sent=c.arg;else if("throw"===c.method){if(f===_)throw f=M,c.arg;c.dispatchException(c.arg)}else"return"===c.method&&c.abrupt("return",c.arg);f=E;var i=l(o,u,c);if("normal"===i.type){if(f=c.done?M:O,i.arg===P)continue;return{value:i.arg,done:c.done}}"throw"===i.type&&(f=M,c.method="throw",c.arg=i.arg)}}),a}function l(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function h(){}function r(){}function n(){}function e(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function u(c){function f(t,n,r,e){var i=l(c[t],c,n);if("throw"!==i.type){var o=i.arg,u=o.value;return u&&"object"==typeof u&&y.call(u,"__await")?Promise.resolve(u.__await).then(function(t){f("next",t,r,e)},function(t){f("throw",t,r,e)}):Promise.resolve(u).then(function(t){o.value=t,r(o)},e)}e(i.arg)}var n;"object"==typeof t.process&&t.process.domain&&(f=t.process.domain.bind(f)),this._invoke=function(r,e){function t(){return new Promise(function(t,n){f(r,e,t,n)})}return n=n?n.then(t,t):t()}}function v(t,n){var r=t.iterator[n.method];if(r===a){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=a,v(t,n),"throw"===n.method))return P;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return P}var e=l(r,t.iterator,n.arg);if("throw"===e.type)return n.method="throw",n.arg=e.arg,n.delegate=null,P;var i=e.arg;return i?i.done?(n[t.resultName]=i.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=a),n.delegate=null,P):i:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,P)}function i(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function c(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function p(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(i,this),this.reset(!0)}function f(n){if(n){var t=n[m];if(t)return t.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var r=-1,e=function t(){for(;++r<n.length;)if(y.call(n,r))return t.value=n[r],t.done=!1,t;return t.value=a,t.done=!0,t};return e.next=e}}return{next:d}}function d(){return{value:a,done:!0}}var a,s=Object.prototype,y=s.hasOwnProperty,g="function"==typeof Symbol?Symbol:{},m=g.iterator||"@@iterator",b=g.asyncIterator||"@@asyncIterator",x=g.toStringTag||"@@toStringTag",S="object"==typeof N,w=t.regeneratorRuntime;if(w)S&&(N.exports=w);else{(w=t.regeneratorRuntime=S?N.exports:{}).wrap=o;var _="suspendedStart",O="suspendedYield",E="executing",M="completed",P={},j={};j[m]=function(){return this};var F=Object.getPrototypeOf,A=F&&F(F(f([])));A&&A!==s&&y.call(A,m)&&(j=A);var L=n.prototype=h.prototype=Object.create(j);r.prototype=L.constructor=n,n.constructor=r,n[x]=r.displayName="GeneratorFunction",w.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===r||"GeneratorFunction"===(n.displayName||n.name))},w.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,n):(t.__proto__=n,x in t||(t[x]="GeneratorFunction")),t.prototype=Object.create(L),t},w.awrap=function(t){return{__await:t}},e(u.prototype),u.prototype[b]=function(){return this},w.AsyncIterator=u,w.async=function(t,n,r,e){var i=new u(o(t,n,r,e));return w.isGeneratorFunction(n)?i:i.next().then(function(t){return t.done?t.value:i.next()})},e(L),L[x]="Generator",L[m]=function(){return this},L.toString=function(){return"[object Generator]"},w.keys=function(r){var e=[];for(var t in r)e.push(t);return e.reverse(),function t(){for(;e.length;){var n=e.pop();if(n in r)return t.value=n,t.done=!1,t}return t.done=!0,t}},w.values=f,p.prototype={constructor:p,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=a,this.done=!1,this.delegate=null,this.method="next",this.arg=a,this.tryEntries.forEach(c),!t)for(var n in this)"t"===n.charAt(0)&&y.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=a)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(r){function t(t,n){return o.type="throw",o.arg=r,e.next=t,n&&(e.method="next",e.arg=a),!!n}if(this.done)throw r;for(var e=this,n=this.tryEntries.length-1;0<=n;--n){var i=this.tryEntries[n],o=i.completion;if("root"===i.tryLoc)return t("end");if(i.tryLoc<=this.prev){var u=y.call(i,"catchLoc"),c=y.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return t(i.catchLoc,!0);if(this.prev<i.finallyLoc)return t(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return t(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return t(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;0<=r;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&y.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,P):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),P},finish:function(t){for(var n=this.tryEntries.length-1;0<=n;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),c(r),P}},catch:function(t){for(var n=this.tryEntries.length-1;0<=n;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;c(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:f(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=a),P}}}}("object"==typeof t?t:"object"==typeof window?window:"object"==typeof self?self:this)}).call(t,function(){return this}())},,,function(t,n,r){r(217),t.exports=r(49).RegExp.escape},,,,function(t,n,r){var e=r(5),i=r(121),o=r(7)("species");t.exports=function(t){var n;return i(t)&&("function"!=typeof(n=t.constructor)||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&null===(n=n[o])&&(n=void 0)),void 0===n?Array:n}},function(t,n,r){"use strict";var e=r(4),i=Date.prototype.getTime,o=Date.prototype.toISOString,u=function(t){return 9<t?t:"0"+t};t.exports=e(function(){return"0385-07-25T07:06:39.999Z"!=o.call(new Date(-5e13-1))})||!e(function(){o.call(new Date(NaN))})?function(){if(!isFinite(i.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":9999<n?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(99<r?r:"0"+u(r))+"Z"}:o},function(t,n,r){"use strict";var e=r(2),i=r(53);t.exports=function(t){if("string"!==t&&"number"!==t&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),"number"!=t)}},function(t,n,r){var c=r(73),f=r(125),a=r(116);t.exports=function(t){var n=c(t),r=f.f;if(r)for(var e,i=r(t),o=a.f,u=0;i.length>u;)o.call(t,e=i[u++])&&n.push(e);return n}},function(t,n){t.exports=function(n,r){var e=r===Object(r)?function(t){return r[t]}:r;return function(t){return String(t).replace(n,e)}}},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var e=r(1),i=r(215)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(162)}),r(66)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(48)(4);e(e.P+e.F*!r(47)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(133)}),r(66)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(48)(2);e(e.P+e.F*!r(47)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,1<arguments.length?arguments[1]:void 0)}}),r(66)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,1<arguments.length?arguments[1]:void 0)}}),r(66)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(0),o=r(47)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var h=r(46),e=r(1),v=r(17),p=r(173),d=r(141),y=r(11),g=r(135),m=r(157);e(e.S+e.F*!r(123)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,e,i,o=v(t),u="function"==typeof this?this:Array,c=arguments.length,f=1<c?arguments[1]:void 0,a=void 0!==f,s=0,l=m(o);if(a&&(f=h(f,2<c?arguments[2]:void 0,2)),null==l||u==Array&&d(l))for(r=new u(n=y(o.length));s<n;s++)g(r,s,a?f(o[s],s):o[s]);else for(i=l.call(o),r=new u;!(e=i.next()).done;s++)g(r,s,a?p(i,f,[e.value,s],!0):e.value);return r.length=s,r}})},function(t,n,r){"use strict";var e=r(1),i=r(117)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(47)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(121)})},function(t,n,r){"use strict";var e=r(1),i=r(32),o=[].join;e(e.P+e.F*(r(115)!=Object||!r(47)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(32),o=r(52),u=r(11),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(47)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(1<arguments.length&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);0<=e;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(1);e(e.P+e.F*!r(47)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(135);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);t<n;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(164);e(e.P+e.F*!r(47)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(164);e(e.P+e.F*!r(47)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(139),a=r(45),s=r(77),l=r(11),h=[].slice;e(e.P+e.F*r(4)(function(){i&&h.call(i)}),"Array",{slice:function(t,n){var r=l(this.length),e=a(this);if(n=void 0===n?r:n,"Array"==e)return h.call(this,t,n);for(var i=s(t,r),o=s(n,r),u=l(o-i),c=Array(u),f=0;f<u;f++)c[f]="String"==e?this.charAt(i+f):this[i+f];return c}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(3);e(e.P+e.F*!r(47)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(19),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(47)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(76)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){var e=r(1),i=r(212);e(e.P+e.F*(Date.prototype.toISOString!==i),"Date",{toISOString:i})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(53);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(26)(i,e,r(213))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(27)(e,o,function(){var t=c.call(this);return t==t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(165)})},function(t,n,r){"use strict";var e=r(5),i=r(31),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(10).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(10).f,i=Function.prototype,o=/^\s*function ([^ (]*)/;"name"in i||r(9)&&e(i,"name",{configurable:!0,get:function(){try{return(""+this).match(o)[1]}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(176),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:94906265.62425156<t?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){var e=r(1),i=Math.asinh;e(e.S+e.F*!(i&&0<1/i(0)),"Math",{asinh:function t(n){return isFinite(n=+n)&&0!=n?n<0?-t(-n):Math.log(n+Math.sqrt(n*n+1)):n}})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(145);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(144);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1);e(e.S,"Math",{fround:r(175)})},function(t,n,r){var e=r(1),f=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,i=0,o=0,u=arguments.length,c=0;o<u;)c<(r=f(arguments[o++]))?(i=i*(e=c/r)*e+1,c=r):0<r?i+=(e=r/c)*e:i+=r;return c===1/0?1/0:c*Math.sqrt(i)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)*Math.LOG10E}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(176)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(145)})},function(t,n,r){var e=r(1),i=r(144),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(144),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(0<t?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(25),o=r(45),u=r(140),s=r(53),c=r(4),f=r(72).f,a=r(30).f,l=r(10).f,h=r(82).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(71)(y))==v,m="trim"in String.prototype,b=function(t){var n=s(t,!1);if("string"==typeof n&&2<n.length){var r,e,i,o=(n=m?n.trim():h(n,3)).charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,c=n.slice(2),f=0,a=c.length;f<a;f++)if((u=c.charCodeAt(f))<48||i<u)return NaN;return parseInt(c,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?c(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(b(n)),r,p):b(n)};for(var x,S=r(9)?f(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),w=0;S.length>w;w++)i(d,x=S[w])&&!i(p,x)&&l(p,x,a(d,x));(p.prototype=y).constructor=p,r(27)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(172)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(172),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(184);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(185);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),a=r(52),s=r(161),l=r(152),i=1..toFixed,o=Math.floor,u=[0,0,0,0,0,0],h="Number.toFixed: incorrect invocation!",v=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*u[r],u[r]=e%1e7,e=o(e/1e7)},p=function(t){for(var n=6,r=0;0<=--n;)r+=u[n],u[n]=o(r/t),r=r%t*1e7},d=function(){for(var t=6,n="";0<=--t;)if(""!==n||0===t||0!==u[t]){var r=String(u[t]);n=""===n?r:n+l.call("0",7-r.length)+r}return n},y=function(t,n,r){return 0===n?r:n%2==1?y(t,n-1,r*t):y(t*t,n/2,r)};e(e.P+e.F*(!!i&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){i.call({})})),"Number",{toFixed:function(t){var n,r,e,i,o=s(this,h),u=a(t),c="",f="0";if(u<0||20<u)throw RangeError(h);if(o!=o)return"NaN";if(o<=-1e21||1e21<=o)return String(o);if(o<0&&(c="-",o=-o),1e-21<o)if(r=(n=function(t){for(var n=0,r=t;4096<=r;)n+=12,r/=4096;for(;2<=r;)n+=1,r/=2;return n}(o*y(2,69,1))-69)<0?o*y(2,-n,1):o/y(2,n,1),r*=4503599627370496,0<(n=52-n)){for(v(0,r),e=u;7<=e;)v(1e7,0),e-=7;for(v(y(10,e,1),0),e=n-1;23<=e;)p(1<<23),e-=23;p(1<<e),v(1,1),p(2),f=d()}else v(0,r),v(1<<-n,0),f=d()+l.call("0",u);return f=0<u?c+((i=f.length)<=u?"0."+l.call("0",u-i)+f:f.slice(0,i-u)+"."+f.slice(i-u)):c+f}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(161),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(178)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(71)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(9),"Object",{defineProperties:r(179)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(9),"Object",{defineProperty:r(10).f})},function(t,n,r){var e=r(5),i=r(67).onFreeze;r(51)("freeze",function(n){return function(t){return n&&e(t)?n(i(t)):t}})},function(t,n,r){var e=r(32),i=r(30).f;r(51)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(51)("getOwnPropertyNames",function(){return r(180).f})},function(t,n,r){var e=r(17),i=r(31);r(51)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(5);r(51)("isExtensible",function(n){return function(t){return!!e(t)&&(!n||n(t))}})},function(t,n,r){var e=r(5);r(51)("isFrozen",function(n){return function(t){return!e(t)||!!n&&n(t)}})},function(t,n,r){var e=r(5);r(51)("isSealed",function(n){return function(t){return!e(t)||!!n&&n(t)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(216)})},function(t,n,r){var e=r(17),i=r(73);r(51)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(5),i=r(67).onFreeze;r(51)("preventExtensions",function(n){return function(t){return n&&e(t)?n(i(t)):t}})},function(t,n,r){var e=r(5),i=r(67).onFreeze;r(51)("seal",function(n){return function(t){return n&&e(t)?n(i(t)):t}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(148).set})},function(t,n,r){"use strict";var e=r(114),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(27)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(184);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(185);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u,c=r(70),f=r(3),a=r(46),s=r(114),l=r(1),h=r(5),v=r(19),p=r(68),d=r(69),y=r(129),g=r(154).set,m=r(146)(),b=r(147),x=r(186),S=r(187),w="Promise",_=f.TypeError,O=f.process,E=f[w],M="process"==s(O),P=function(){},j=i=b.f,F=!!function(){try{var t=E.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(P,P)};return(M||"function"==typeof PromiseRejectionEvent)&&t.then(P)instanceof n}catch(t){}}(),A=function(t){var n;return!(!h(t)||"function"!=typeof(n=t.then))&&n},L=function(a,n){if(!a._n){a._n=!0;var r=a._c;m(function(){for(var c=a._v,f=1==a._s,t=0;r.length>t;)!function(t){var n,r,e=f?t.ok:t.fail,i=t.resolve,o=t.reject,u=t.domain;try{e?(f||(2==a._h&&I(a),a._h=1),!0===e?n=c:(u&&u.enter(),n=e(c),u&&u.exit()),n===t.promise?o(_("Promise-chain cycle")):(r=A(n))?r.call(n,i,o):i(n)):o(c)}catch(t){o(t)}}(r[t++]);a._c=[],a._n=!1,n&&!a._h&&N(a)})}},N=function(o){g.call(f,function(){var t,n,r,e=o._v,i=T(o);if(i&&(t=x(function(){M?O.emit("unhandledRejection",e,o):(n=f.onunhandledrejection)?n({promise:o,reason:e}):(r=f.console)&&r.error&&r.error("Unhandled promise rejection",e)}),o._h=M||T(o)?2:1),o._a=void 0,i&&t.e)throw t.v})},T=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if((n=r[e++]).fail||!T(n.promise))return!1;return!0},I=function(n){g.call(f,function(){var t;M?O.emit("rejectionHandled",n):(t=f.onrejectionhandled)&&t({promise:n,reason:n._v})})},k=function(t){var n=this;n._d||(n._d=!0,(n=n._w||n)._v=t,n._s=2,n._a||(n._a=n._c.slice()),L(n,!0))},R=function(t){var r,e=this;if(!e._d){e._d=!0,e=e._w||e;try{if(e===t)throw _("Promise can't be resolved itself");(r=A(t))?m(function(){var n={_w:e,_d:!1};try{r.call(t,a(R,n,1),a(k,n,1))}catch(t){k.call(n,t)}}):(e._v=t,e._s=1,L(e,!1))}catch(t){k.call({_w:e,_d:!1},t)}}};F||(E=function(t){p(this,E,w,"_h"),v(t),e.call(this);try{t(a(R,this,1),a(k,this,1))}catch(t){k.call(this,t)}},(e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1}).prototype=r(75)(E.prototype,{then:function(t,n){var r=j(y(this,E));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=M?O.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&L(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),o=function(){var t=new e;this.promise=t,this.resolve=a(R,t,1),this.reject=a(k,t,1)},b.f=j=function(t){return t===E||t===u?new o(t):i(t)}),l(l.G+l.W+l.F*!F,{Promise:E}),r(81)(E,w),r(76)(w),u=r(49)[w],l(l.S+l.F*!F,w,{reject:function(t){var n=j(this);return(0,n.reject)(t),n.promise}}),l(l.S+l.F*(c||!F),w,{resolve:function(t){return S(c&&this===u?E:this,t)}}),l(l.S+l.F*!(F&&r(123)(function(t){E.all(t).catch(P)})),w,{all:function(t){var u=this,n=j(u),c=n.resolve,f=n.reject,r=x(function(){var e=[],i=0,o=1;d(t,!1,function(t){var n=i++,r=!1;e.push(void 0),o++,u.resolve(t).then(function(t){r||(r=!0,e[n]=t,--o||c(e))},f)}),--o||c(e)});return r.e&&f(r.v),n.promise},race:function(t){var n=this,r=j(n),e=r.reject,i=x(function(){d(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i.e&&e(i.v),r.promise}})},function(t,n,r){var e=r(1),o=r(19),u=r(2),c=(r(3).Reflect||{}).apply,f=Function.apply;e(e.S+e.F*!r(4)(function(){c(function(){})}),"Reflect",{apply:function(t,n,r){var e=o(t),i=u(r);return c?c(e,n,i):f.call(e,n,i)}})},function(t,n,r){var e=r(1),c=r(71),f=r(19),a=r(2),s=r(5),i=r(4),l=r(165),h=(r(3).Reflect||{}).construct,v=i(function(){function t(){}return!(h(function(){},[],t)instanceof t)}),p=!i(function(){h(function(){})});e(e.S+e.F*(v||p),"Reflect",{construct:function(t,n){f(t),a(n);var r=arguments.length<3?t:f(arguments[2]);if(p&&!v)return h(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(l.apply(t,e))}var i=r.prototype,o=c(s(i)?i:Object.prototype),u=Function.apply.call(t,o,n);return s(u)?u:o}})},function(t,n,r){var e=r(10),i=r(1),o=r(2),u=r(53);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(30).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(142)(o,"Object",function(){var t,n=this._k;do{if(this._i>=n.length)return{value:void 0,done:!0}}while(!((t=n[this._i++])in this._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(30),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(31),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){var u=r(30),c=r(31),f=r(25),e=r(1),a=r(5),s=r(2);e(e.S,"Reflect",{get:function t(n,r){var e,i,o=arguments.length<3?n:arguments[2];return s(n)===o?n[r]:(e=u.f(n,r))?f(e,"value")?e.value:void 0!==e.get?e.get.call(o):void 0:a(i=c(n))?t(i,r,o):void 0}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(183)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(148);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){var f=r(10),a=r(30),s=r(31),l=r(25),e=r(1),h=r(74),v=r(2),p=r(5);e(e.S,"Reflect",{set:function t(n,r,e){var i,o,u=arguments.length<4?n:arguments[3],c=a.f(v(n),r);if(!c){if(p(o=s(n)))return t(o,r,e,u);c=h(0)}return l(c,"value")?!(!1===c.writable||!p(u)||((i=a.f(u,r)||h(0)).value=e,f.f(u,r,i),0)):void 0!==c.set&&(c.set.call(u,e),!0)}})},function(t,n,r){var e=r(3),o=r(140),i=r(10).f,u=r(72).f,c=r(122),f=r(120),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(9)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),i=void 0===n;return!r&&e&&t.constructor===a&&i?t:o(p?new s(e&&!i?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&i?f.call(t):n),r?this:l,a)};for(var d=u(s),y=0;d.length>y;)!function(n){n in a||i(a,n,{configurable:!0,get:function(){return s[n]},set:function(t){s[n]=t}})}(d[y++]);(l.constructor=a).prototype=l,r(27)(e,"RegExp",a)}r(76)("RegExp")},function(t,n,r){r(119)("match",1,function(e,i,t){return[function(t){"use strict";var n=e(this),r=null==t?void 0:t[i];return void 0!==r?r.call(t,n):new RegExp(t)[i](String(n))},t]})},function(t,n,r){r(119)("replace",2,function(i,o,u){return[function(t,n){"use strict";var r=i(this),e=null==t?void 0:t[o];return void 0!==e?e.call(t,r,n):u.call(String(r),t,n)},u]})},function(t,n,r){r(119)("search",1,function(e,i,t){return[function(t){"use strict";var n=e(this),r=null==t?void 0:t[i];return void 0!==r?r.call(t,n):new RegExp(t)[i](String(n))},t]})},function(t,n,r){r(119)("split",2,function(i,o,u){"use strict";var v=r(122),p=u,d=[].push,t="split",y="length",g="lastIndex";if("c"=="abbc"[t](/(b)*/)[1]||4!="test"[t](/(?:)/,-1)[y]||2!="ab"[t](/(?:ab)*/)[y]||4!="."[t](/(.?)(.?)/)[y]||1<"."[t](/()()/)[y]||""[t](/.?/)[y]){var m=void 0===/()??/.exec("")[1];u=function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!v(t))return p.call(r,t,n);var e,i,o,u,c,f=[],a=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),s=0,l=void 0===n?4294967295:n>>>0,h=new RegExp(t.source,a+"g");for(m||(e=new RegExp("^"+h.source+"$(?!\\s)",a));(i=h.exec(r))&&!((o=i.index+i[0][y])>s&&(f.push(r.slice(s,i.index)),!m&&1<i[y]&&i[0].replace(e,function(){for(c=1;c<arguments[y]-2;c++)void 0===arguments[c]&&(i[c]=void 0)}),1<i[y]&&i.index<r[y]&&d.apply(f,i.slice(1)),u=i[0][y],s=o,f[y]>=l));)h[g]===i.index&&h[g]++;return s===r[y]?!u&&h.test("")||f.push(""):f.push(r.slice(s)),f[y]>l?f.slice(0,l):f}}else"0"[t](void 0,0)[y]&&(u=function(t,n){return void 0===t&&0===n?[]:p.call(this,t,n)});return[function(t,n){var r=i(this),e=null==t?void 0:t[o];return void 0!==e?e.call(t,r,n):u.call(String(r),t,n)},u]})},function(t,n,r){"use strict";r(192);var e=r(2),i=r(120),o=r(9),u="toString",c=/./[u],f=function(t){r(27)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(28)("anchor",function(n){return function(t){return n(this,"a","name",t)}})},function(t,n,r){"use strict";r(28)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(28)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(28)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(150)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),u=r(11),c=r(151),f="endsWith",a=""[f];e(e.P+e.F*r(138)(f),"String",{endsWith:function(t){var n=c(this,t,f),r=1<arguments.length?arguments[1]:void 0,e=u(n.length),i=void 0===r?e:Math.min(u(r),e),o=String(t);return a?a.call(n,o,i):n.slice(i-o.length,i)===o}})},function(t,n,r){"use strict";r(28)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(28)("fontcolor",function(n){return function(t){return n(this,"font","color",t)}})},function(t,n,r){"use strict";r(28)("fontsize",function(n){return function(t){return n(this,"font","size",t)}})},function(t,n,r){var e=r(1),o=r(77),u=String.fromCharCode,i=String.fromCodePoint;e(e.S+e.F*(!!i&&1!=i.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,i=0;i<e;){if(n=+arguments[i++],o(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?u(n):u(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(151);e(e.P+e.F*r(138)("includes"),"String",{includes:function(t){return!!~i(this,t,"includes").indexOf(t,1<arguments.length?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(28)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(150)(!0);r(143)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(28)("link",function(n){return function(t){return n(this,"a","href",t)}})},function(t,n,r){var e=r(1),u=r(32),c=r(11);e(e.S,"String",{raw:function(t){for(var n=u(t.raw),r=c(n.length),e=arguments.length,i=[],o=0;o<r;)i.push(String(n[o++])),o<e&&i.push(String(arguments[o]));return i.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(152)})},function(t,n,r){"use strict";r(28)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(11),o=r(151),u="startsWith",c=""[u];e(e.P+e.F*r(138)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(1<arguments.length?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(28)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(28)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(28)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(82)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),u=r(25),i=r(9),o=r(1),c=r(27),f=r(67).KEY,a=r(4),s=r(128),l=r(81),h=r(78),v=r(7),p=r(190),d=r(156),y=r(214),g=r(121),m=r(2),b=r(32),x=r(53),S=r(74),w=r(71),_=r(180),O=r(30),E=r(10),M=r(73),P=O.f,j=E.f,F=_.f,A=e.Symbol,L=e.JSON,N=L&&L.stringify,T="prototype",I=v("_hidden"),k=v("toPrimitive"),R={}.propertyIsEnumerable,C=s("symbol-registry"),D=s("symbols"),G=s("op-symbols"),W=Object[T],U="function"==typeof A,V=e.QObject,B=!V||!V[T]||!V[T].findChild,q=i&&a(function(){return 7!=w(j({},"a",{get:function(){return j(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=P(W,n);e&&delete W[n],j(t,n,r),e&&t!==W&&j(W,n,e)}:j,z=function(t){var n=D[t]=w(A[T]);return n._k=t,n},H=U&&"symbol"==typeof A.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof A},K=function(t,n,r){return t===W&&K(G,n,r),m(t),n=x(n,!0),m(r),u(D,n)?(r.enumerable?(u(t,I)&&t[I][n]&&(t[I][n]=!1),r=w(r,{enumerable:S(0,!1)})):(u(t,I)||j(t,I,S(1,{})),t[I][n]=!0),q(t,n,r)):j(t,n,r)},J=function(t,n){m(t);for(var r,e=y(n=b(n)),i=0,o=e.length;i<o;)K(t,r=e[i++],n[r]);return t},Y=function(t){var n=R.call(this,t=x(t,!0));return!(this===W&&u(D,t)&&!u(G,t))&&(!(n||!u(this,t)||!u(D,t)||u(this,I)&&this[I][t])||n)},$=function(t,n){if(t=b(t),n=x(n,!0),t!==W||!u(D,n)||u(G,n)){var r=P(t,n);return!r||!u(D,n)||u(t,I)&&t[I][n]||(r.enumerable=!0),r}},X=function(t){for(var n,r=F(b(t)),e=[],i=0;r.length>i;)u(D,n=r[i++])||n==I||n==f||e.push(n);return e},Q=function(t){for(var n,r=t===W,e=F(r?G:b(t)),i=[],o=0;e.length>o;)!u(D,n=e[o++])||r&&!u(W,n)||i.push(D[n]);return i};U||(c((A=function(){if(this instanceof A)throw TypeError("Symbol is not a constructor!");var n=h(0<arguments.length?arguments[0]:void 0),r=function(t){this===W&&r.call(G,t),u(this,I)&&u(this[I],n)&&(this[I][n]=!1),q(this,n,S(1,t))};return i&&B&&q(W,n,{configurable:!0,set:r}),z(n)})[T],"toString",function(){return this._k}),O.f=$,E.f=K,r(72).f=_.f=X,r(116).f=Y,r(125).f=Q,i&&!r(70)&&c(W,"propertyIsEnumerable",Y,!0),p.f=function(t){return z(v(t))}),o(o.G+o.W+o.F*!U,{Symbol:A});for(var Z="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),tt=0;Z.length>tt;)v(Z[tt++]);for(var nt=M(v.store),rt=0;nt.length>rt;)d(nt[rt++]);o(o.S+o.F*!U,"Symbol",{for:function(t){return u(C,t+="")?C[t]:C[t]=A(t)},keyFor:function(t){if(!H(t))throw TypeError(t+" is not a symbol!");for(var n in C)if(C[n]===t)return n},useSetter:function(){B=!0},useSimple:function(){B=!1}}),o(o.S+o.F*!U,"Object",{create:function(t,n){return void 0===n?w(t):J(w(t),n)},defineProperty:K,defineProperties:J,getOwnPropertyDescriptor:$,getOwnPropertyNames:X,getOwnPropertySymbols:Q}),L&&o(o.S+o.F*(!U||a(function(){var t=A();return"[null]"!=N([t])||"{}"!=N({a:t})||"{}"!=N(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!H(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return"function"==typeof(n=e[1])&&(r=n),!r&&g(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!H(n))return n}),e[1]=n,N.apply(L,e)}}}),A[T][k]||r(26)(A[T],k,A[T].valueOf),l(A,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(130),o=r(155),a=r(2),s=r(77),l=r(11),u=r(5),c=r(3).ArrayBuffer,h=r(129),v=o.ArrayBuffer,p=o.DataView,f=i.ABV&&c.isView,d=v.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(c!==v),{ArrayBuffer:v}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return f&&f(t)||u(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new v(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(a(this),t);for(var r=a(this).byteLength,e=s(t,r),i=s(void 0===n?r:n,r),o=new(h(this,v))(l(i-e)),u=new p(this),c=new p(o),f=0;e<i;)c.setUint8(f++,u.getUint8(e++));return o}}),r(76)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(130).ABV,{DataView:r(155).DataView})},function(t,n,r){r(56)("Float32",4,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(56)("Float64",8,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(56)("Int16",2,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(56)("Int32",4,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(56)("Int8",1,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(56)("Uint16",2,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(56)("Uint32",4,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(56)("Uint8",1,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(56)("Uint8",1,function(e){return function(t,n,r){return e(this,t,n,r)}},!0)},function(t,n,r){"use strict";var e=r(168),i=r(83);r(118)("WeakSet",function(t){return function(){return t(this,0<arguments.length?arguments[0]:void 0)}},{add:function(t){return e.def(i(this,"WeakSet"),t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(169),o=r(17),u=r(11),c=r(19),f=r(134);e(e.P,"Array",{flatMap:function(t){var n,r,e=o(this);return c(t),n=u(e.length),r=f(e,0),i(r,e,e,n,0,1,t,arguments[1]),r}}),r(66)("flatMap")},function(t,n,r){"use strict";var e=r(1),i=r(169),o=r(17),u=r(11),c=r(52),f=r(134);e(e.P,"Array",{flatten:function(){var t=arguments[0],n=o(this),r=u(n.length),e=f(n,0);return i(e,n,n,r,0,void 0===t?1:c(t)),e}}),r(66)("flatten")},function(t,n,r){"use strict";var e=r(1),i=r(117)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,1<arguments.length?arguments[1]:void 0)}}),r(66)("includes")},function(t,n,r){var e=r(1),i=r(146)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.G,{global:r(3)})},function(t,n,r){r(126)("Map")},function(t,n,r){r(127)("Map")},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(167)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{clamp:function(t,n,r){return Math.min(r,Math.max(n,t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{DEG_PER_RAD:Math.PI/180})},function(t,n,r){var e=r(1),i=180/Math.PI;e(e.S,"Math",{degrees:function(t){return t*i}})},function(t,n,r){var e=r(1),o=r(177),u=r(175);e(e.S,"Math",{fscale:function(t,n,r,e,i){return u(o(t,n,r,e,i))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=r>>>0;return(n>>>0)+(e>>>0)+((i&o|(i|o)&~(i+o>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=+t,e=+n,i=65535&r,o=65535&e,u=r>>16,c=e>>16,f=(u*o>>>0)+(i*o>>>16);return u*c+(f>>16)+((i*c>>>0)+(65535&f)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=r>>>0;return(n>>>0)-(e>>>0)-((~i&o|~(i^o)&i-o>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{RAD_PER_DEG:180/Math.PI})},function(t,n,r){var e=r(1),i=Math.PI/180;e(e.S,"Math",{radians:function(t){return t*i}})},function(t,n,r){var e=r(1);e(e.S,"Math",{scale:r(177)})},function(t,n,r){var e=r(1);e(e.S,"Math",{signbit:function(t){return(t=+t)!=t?t:0==t?1/t==1/0:0<t}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=+t,e=+n,i=65535&r,o=65535&e,u=r>>>16,c=e>>>16,f=(u*o>>>0)+(i*o>>>16);return u*c+(f>>>16)+((i*c>>>0)+(65535&f)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(19),u=r(10);r(9)&&e(e.P+r(124),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(19),u=r(10);r(9)&&e(e.P+r(124),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(182)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),f=r(183),a=r(32),s=r(30),l=r(135);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r,e=a(t),i=s.f,o=f(e),u={},c=0;o.length>c;)void 0!==(r=i(e,n=o[c++]))&&l(u,n,r);return u}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(53),u=r(31),c=r(30).f;r(9)&&e(e.P+r(124),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(53),u=r(31),c=r(30).f;r(9)&&e(e.P+r(124),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(182)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),o=r(3),u=r(49),i=r(146)(),c=r(7)("observable"),f=r(19),a=r(2),s=r(68),l=r(75),h=r(26),v=r(69),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},m=function(t){g(t)||(t._o=void 0,y(t))},b=function(t,n){a(t),this._c=void 0,this._o=t,t=new x(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};b.prototype=l({},{unsubscribe:function(){m(this)}});var x=function(t){this._s=t};x.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{m(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var S=function(t){s(this,S,"Observable","_f")._f=f(t)};l(S.prototype,{subscribe:function(t){return new b(t,this._f)},forEach:function(e){var i=this;return new(u.Promise||o.Promise)(function(t,n){f(e);var r=i.subscribe({next:function(t){try{return e(t)}catch(t){n(t),r.unsubscribe()}},error:n,complete:t})})}}),l(S,{from:function(t){var n="function"==typeof this?this:S,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return i(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,e=Array(n);t<n;)e[t]=arguments[t++];return new("function"==typeof this?this:S)(function(n){var r=!1;return i(function(){if(!r){for(var t=0;t<e.length;++t)if(n.next(e[t]),r)return;n.complete()}}),function(){r=!0}})}}),h(S.prototype,c,function(){return this}),e(e.G,{Observable:S}),r(76)("Observable")},function(t,n,r){"use strict";var e=r(1),i=r(49),o=r(3),u=r(129),c=r(187);e(e.P+e.R,"Promise",{finally:function(n){var r=u(this,i.Promise||o.Promise),t="function"==typeof n;return this.then(t?function(t){return c(r,n()).then(function(){return t})}:n,t?function(t){return c(r,n()).then(function(){throw t})}:n)}})},function(t,n,r){"use strict";var e=r(1),i=r(147),o=r(186);e(e.S,"Promise",{try:function(t){var n=i.f(this),r=o(t);return(r.e?n.reject:n.resolve)(r.v),n.promise}})},function(t,n,r){var e=r(55),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(55),o=r(2),u=e.key,c=e.map,f=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:u(arguments[2]),e=c(o(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var i=f.get(n);return i.delete(r),!!i.size||f.delete(n)}})},function(t,n,r){var o=r(193),u=r(163),e=r(55),i=r(2),c=r(31),f=e.keys,a=e.key,s=function(t,n){var r=f(t,n),e=c(t);if(null===e)return r;var i=s(e,n);return i.length?r.length?u(new o(r.concat(i))):i:r};e.exp({getMetadataKeys:function(t){return s(i(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(55),i=r(2),o=r(31),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(55),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(55),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(55),i=r(2),o=r(31),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(55),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(55),i=r(2),o=r(19),u=e.key,c=e.set;e.exp({metadata:function(r,e){return function(t,n){c(r,e,(void 0!==n?i:o)(t),u(n))}}})},function(t,n,r){r(126)("Set")},function(t,n,r){r(127)("Set")},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(167)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(150)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(50),o=r(11),u=r(122),c=r(120),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(142)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(188);e(e.P,"String",{padEnd:function(t){return i(this,t,1<arguments.length?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(188);e(e.P,"String",{padStart:function(t){return i(this,t,1<arguments.length?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(82)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(82)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(156)("asyncIterator")},function(t,n,r){r(156)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){r(126)("WeakMap")},function(t,n,r){r(127)("WeakMap")},function(t,n,r){r(126)("WeakSet")},function(t,n,r){r(127)("WeakSet")},function(t,n,r){for(var e=r(158),i=r(73),o=r(27),u=r(3),c=r(26),f=r(80),a=r(7),s=a("iterator"),l=a("toStringTag"),h=f.Array,v={CSSRuleList:!0,CSSStyleDeclaration:!1,CSSValueList:!1,ClientRectList:!1,DOMRectList:!1,DOMStringList:!1,DOMTokenList:!0,DataTransferItemList:!1,FileList:!1,HTMLAllCollection:!1,HTMLCollection:!1,HTMLFormElement:!1,HTMLSelectElement:!1,MediaList:!0,MimeTypeArray:!1,NamedNodeMap:!1,NodeList:!0,PaintRequestList:!1,Plugin:!1,PluginArray:!1,SVGLengthList:!1,SVGNumberList:!1,SVGPathSegList:!1,SVGPointList:!1,SVGStringList:!1,SVGTransformList:!1,SourceBufferList:!1,StyleSheetList:!0,TextTrackCueList:!1,TextTrackList:!1,TouchList:!1},p=i(v),d=0;d<p.length;d++){var y,g=p[d],m=v[g],b=u[g],x=b&&b.prototype;if(x&&(x[s]||c(x,s,h),x[l]||c(x,l,g),f[g]=h,m))for(y in e)x[y]||o(x,y,e[y],!0)}},function(t,n,r){var e=r(1),i=r(154);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=e.navigator,u=[].slice,c=!!o&&/MSIE .\./.test(o.userAgent),f=function(i){return function(t,n){var r=2<arguments.length,e=!!r&&u.call(arguments,2);return i(r?function(){("function"==typeof t?t:Function(t)).apply(this,e)}:t,n)}};i(i.G+i.B+i.F*c,{setTimeout:f(e.setTimeout),setInterval:f(e.setInterval)})},function(t,n,r){r(337),r(276),r(278),r(277),r(280),r(282),r(287),r(281),r(279),r(289),r(288),r(284),r(285),r(283),r(275),r(286),r(290),r(291),r(243),r(245),r(244),r(293),r(292),r(263),r(273),r(274),r(264),r(265),r(266),r(267),r(268),r(269),r(270),r(271),r(272),r(246),r(247),r(248),r(249),r(250),r(251),r(252),r(253),r(254),r(255),r(256),r(257),r(258),r(259),r(260),r(261),r(262),r(324),r(329),r(336),r(327),r(319),r(320),r(325),r(330),r(332),r(315),r(316),r(317),r(318),r(321),r(322),r(323),r(326),r(328),r(331),r(333),r(334),r(335),r(238),r(240),r(239),r(242),r(241),r(227),r(225),r(231),r(228),r(234),r(236),r(224),r(230),r(221),r(235),r(219),r(233),r(232),r(226),r(229),r(218),r(220),r(223),r(222),r(237),r(158),r(309),r(314),r(192),r(310),r(311),r(312),r(313),r(294),r(191),r(193),r(194),r(349),r(338),r(339),r(344),r(347),r(348),r(342),r(345),r(343),r(346),r(340),r(341),r(295),r(296),r(297),r(298),r(299),r(302),r(300),r(301),r(303),r(304),r(305),r(306),r(308),r(307),r(352),r(350),r(351),r(393),r(396),r(395),r(397),r(398),r(394),r(399),r(400),r(374),r(377),r(373),r(371),r(372),r(375),r(376),r(358),r(392),r(357),r(391),r(403),r(405),r(356),r(390),r(402),r(404),r(355),r(401),r(354),r(359),r(360),r(361),r(362),r(363),r(365),r(364),r(366),r(367),r(368),r(370),r(369),r(379),r(380),r(381),r(382),r(384),r(383),r(386),r(385),r(387),r(388),r(389),r(353),r(378),r(408),r(407),r(406),t.exports=r(49)},function(t,n){t.exports=function(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}}])</script><script src="/./main.e8862b.js"></script><script>!function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src","/slider.5b7e29.js")}()</script><script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script><script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)"><div class="tools-nav header-menu"><ul style="width:70%"><li style="width:33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">All articles</a></li><li style="width:33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">Friends</a></li><li style="width:33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">About me</a></li></ul></div><div class="tools-wrap"><section class="tools-section tools-section-all" q-show="innerArchive"><div class="search-wrap"> <input class="search-ipt" q-model="search" type="text" placeholder="find something…"><i class="icon-search icon" q-show="search|isEmptyStr"></i><i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i></div><div class="widget tagcloud search-tag"><p class="search-tag-wording">tag:</p> <label class="search-switch"><input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags"></label><ul class="article-tag-list" q-show="showTags"><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color5">Algorithm</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color4">C++</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color3">DS</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color3">Android</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color5">Tech</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color3">ML</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color3">DL</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color1">Essay</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color4">git</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color5">hexo</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color2">golang</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color5">HTML</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color1">Javascript</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color4">CSS</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color3">js</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color5">html</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color5">Java</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color1">Redis</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color1">MYSQL</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color2">Spring</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color1">linux</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color2">papers</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color3">RL</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color4">k8s</a></li><div class="clearfix"></div></ul></div><ul class="search-ul"><p q-show="jsonFail" style="padding:20px;font-size:12px"> 缺失模块。<br>1、请确保node版本大于6.2<br>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br> npm i hexo-generator-json-content --save<br><br> 3、在根目录_config.yml里添加配置：<pre style="font-size:12px" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre></p><li class="search-li" q-repeat="items" q-show="isShow"><a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a><p class="search-time"><i class="icon-calendar icon"></i><span q-text="date|dateformat"></span></p><p class="search-tag"><i class="icon-price-tags icon"></i><span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span></p></li></ul></section><section class="tools-section tools-section-friends" q-show="friends"><ul class="search-ul"><li class="search-li"><a href="https://leetcode-cn.com/u/louris/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i> 我的力扣</a></li><li class="search-li"><a href="https://www.six1110.top/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i> 饭勺</a></li><li class="search-li"><a href="https://www.zjcheng.site/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i> 中建</a></li></ul></section><section class="tools-section tools-section-me" q-show="aboutme"><div class="aboutme-wrap" id="js-aboutme">做一个安静细微的人，&lt;br&gt; 于角落里自在开放，&lt;br&gt; 默默悦人，&lt;br&gt; 却始终不引起过分热闹的关注，&lt;br&gt; 保有独立而随意的品格，&lt;br&gt; 这就很好。&lt;br&gt;&lt;br&gt; Stick to what you insist on,&lt;br&gt; believe what you believe!&lt;br&gt; Life hastily for decades,&lt;br&gt; do what I can!</div></section></div></div><div class="pswp" tabindex="-1" role="dialog" aria-hidden="true"><div class="pswp__bg"></div><div class="pswp__scroll-wrap"><div class="pswp__container"><div class="pswp__item"></div><div class="pswp__item"></div><div class="pswp__item"></div></div><div class="pswp__ui pswp__ui--hidden"><div class="pswp__top-bar"><div class="pswp__counter"></div> <button class="pswp__button pswp__button--close" title="Close (Esc)"></button> <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button> <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button> <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class="pswp__preloader"><div class="pswp__preloader__icn"><div class="pswp__preloader__cut"><div class="pswp__preloader__donut"></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class="pswp__share-tooltip"></div></div> <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button> <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class="pswp__caption"><div class="pswp__caption__center"></div></div></div></div></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!1},react:{opacity:1},log:!1})</script></body></html>