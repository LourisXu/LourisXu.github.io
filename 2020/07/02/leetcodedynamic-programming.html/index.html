<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="renderer" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link rel="dns-prefetch" href="https://lourisxu.github.io"><title>Leetcode-动态规划 | Louris&#39; Blog</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="动态规划 线性DP经典DP53. 最大子序和Description给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。Example示例:输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。Program 12345678910111213141516class Solut"><meta property="og:type" content="article"><meta property="og:title" content="Leetcode-动态规划"><meta property="og:url" content="https://lourisxu.github.io/2020/07/02/leetcodedynamic-programming.html/index.html"><meta property="og:site_name" content="Louris&#39; Blog"><meta property="og:description" content="动态规划 线性DP经典DP53. 最大子序和Description给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。Example示例:输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。Program 12345678910111213141516class Solut"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/stock_309.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/14_I_01.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/14_I_02.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/14_I_03.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/790.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/935_example_01.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/935_example_02.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/1191.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/robot_maze_1.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/Palindrome_01.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/304.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/minimum-score-triangulation-of-polygon-1.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/shelves.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/sample_11_1592.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/sample_22_1592.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/sample_33_1592.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/1240_exampler_01.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/robot_maze.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/robot_maze.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/out_of_boundary_paths_1.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/out_of_boundary_paths_2.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/1025_example_01.jpg"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/1367_example_01.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/1367_example_02.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/knight.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/1372_example_01.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/1372_example_02.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/ring.jpg"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/ex1.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/ex2.png"><meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/ex3.png"><meta property="article:published_time" content="2020-07-02T10:46:15.000Z"><meta property="article:modified_time" content="2024-01-19T02:20:51.957Z"><meta property="article:author" content="Louris"><meta property="article:tag" content="Algorithm"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://lourisxu.github.io/assets/img/algorithm/stock_309.png"><link rel="alternative" href="/atom.xml" title="Louris&#39; Blog" type="application/atom+xml"><link rel="icon" href="/assets/img/blog/favicon.png"><link rel="stylesheet" href="/./main.e8862b.css"><style>#container.show{background:linear-gradient(200deg,#a0cfe4,#e8c37e)}</style><meta name="generator" content="Hexo 4.2.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><body><div id="container" q-class="show:isCtnShow"><canvas id="anm-canvas" class="anm-canvas"></canvas><div class="left-col" q-class="show:isShow"><div class="overlay" style="background:#00bfff"></div><div class="intrude-less"><header id="header" class="inner"> <a href="/" class="profilepic"><img src="/assets/img/blog/userpic.jpg" class="js-avatar"></a><hgroup><h1 class="header-author"><a href="/">Louris</a></h1></hgroup><p class="header-subtitle">Do what I can</p><nav class="header-menu"><ul><li><a href="/">Home</a></li><li><a href="/categories/DS/">DS</a></li><li><a href="/tags/ML/">ML&amp;DL</a></li><li><a href="/tags/Tech/">Tech</a></li><li><a href="/tags/Algorithm/">Algorithm</a></li></ul></nav><nav class="header-smart-menu"> <a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">All articles</a> <a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">Friends</a> <a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">About me</a></nav><nav><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="230" height="86" src="//music.163.com/outchain/player?type=2&id=2080322&auto=1&height=66"></iframe></nav><nav class="header-nav"><div class="social"><a class="github" target="_blank" href="https://github.com/LourisXu" title="github"><i class="icon-github"></i></a><a class="weibo" target="_blank" href="http://weibo.com/5634881238/profile?rightmod=1&wvr=6&mod=personinfo" title="weibo"><i class="icon-weibo"></i></a><a class="mail" target="_blank" href="mailto:louris@csu.edu.cn" title="mail"><i class="icon-mail"></i></a></div></nav></header></div></div><div class="mid-col" q-class="show:isShow,hide:isShow|isFalse"><nav id="mobile-nav"><div class="overlay js-overlay" style="background:#00bfff"></div><div class="btnctn js-mobile-btnctn"><div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div></div><div class="intrude-less"><header id="header" class="inner"><div class="profilepic"> <img src="/assets/img/blog/userpic.jpg" class="js-avatar"></div><hgroup><h1 class="header-author js-header-author">Louris</h1></hgroup><p class="header-subtitle"><i class="icon icon-quo-left"></i>Do what I can<i class="icon icon-quo-right"></i></p><nav class="header-nav"><div class="social"><a class="github" target="_blank" href="https://github.com/LourisXu" title="github"><i class="icon-github"></i></a><a class="weibo" target="_blank" href="http://weibo.com/5634881238/profile?rightmod=1&wvr=6&mod=personinfo" title="weibo"><i class="icon-weibo"></i></a><a class="mail" target="_blank" href="mailto:louris@csu.edu.cn" title="mail"><i class="icon-mail"></i></a></div></nav><nav class="header-menu js-header-menu"><ul style="width:70%"><li style="width:20%"><a href="/">Home</a></li><li style="width:20%"><a href="/categories/DS/">DS</a></li><li style="width:20%"><a href="/tags/ML/">ML&amp;DL</a></li><li style="width:20%"><a href="/tags/Tech/">Tech</a></li><li style="width:20%"><a href="/tags/Algorithm/">Algorithm</a></li></ul></nav></header></div><div class="mobile-mask" style="display:none" q-show="isShow"></div></nav><div id="wrapper" class="body-wrap"><div class="menu-l"><div class="canvas-wrap"><canvas data-colors="#eaeaea" data-sectionheight="100" data-contentid="js-content" id="myCanvas1" class="anm-canvas"></canvas></div><div id="js-content" class="content-ll"><article id="post-Algorithm/leetcode/Leetcode-动态规划" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner"><header class="article-header"><h1 class="article-title" itemprop="name"> Leetcode-动态规划</h1><a href="/2020/07/02/leetcodedynamic-programming.html/" class="archive-article-date"><time datetime="2020-07-02T10:46:15.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i> 2020-07-02</time></a></header><div class="article-entry" itemprop="articleBody"><link rel="stylesheet" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1></blockquote><h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h2><h3 id="经典DP"><a href="#经典DP" class="headerlink" title="经典DP"></a>经典DP</h3><h4 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h4><p><strong>Description</strong><br>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br><strong>Example</strong><br>示例:<br>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>* DP=<span class="keyword">new</span> <span class="keyword">int</span>[nums.size()];</span><br><span class="line">        fill(DP,DP+nums.size(), INT_MIN);</span><br><span class="line">        DP[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++){</span><br><span class="line">            DP[i]=max(nums[i],DP[i<span class="number">-1</span>]+nums[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> MAX=INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(DP[i]&gt;MAX) MAX=DP[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> MAX;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a>120. 三角形最小路径和</h4><p><strong>Description</strong><br>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。<br><strong>Example</strong><br>例如，给定三角形：<br>[<br> [2],<br> [3,4],<br> [6,5,7],<br> [4,1,8,3]<br>]<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p><p>说明：<br>如果你可以只使用$O(n)$的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=triangle.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;DP=triangle[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i+<span class="number">1</span>;j++){</span><br><span class="line">                DP[j]=min(DP[j], DP[j+<span class="number">1</span>])+triangle[i][j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="132-分割回文串-II"><a href="#132-分割回文串-II" class="headerlink" title="132. 分割回文串 II"></a>132. 分割回文串 II</h4><p><strong>Description</strong><br>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。<br>返回符合要求的最少分割次数。<br><strong>Example</strong><br>示例:<br>输入: “aab”<br>输出: 1<br>解释: 进行一次分割就可将 s 分割成 [“aa”,”b”] 这样两个回文子串。<br><strong>Program</strong><br><strong>思路</strong><br>思路比较直观<br>（1）先isPal[i][j]的动规计算计算是否为回文串；<br>（2）设dp[i]为分割s为回文串的最小次数，状态转移方程为：<br>dp[i]=min(dp[j]+1)，当isPal[j+1][i]为true时；<br>这里有个关键点，整个串也算是自身的一个子串，纠结半天，觉得至少需要分割一次，即子串长度必须为[1,n-1]，想多了。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">bool</span> isPal[n][n];</span><br><span class="line">        <span class="built_in">memset</span>(isPal, <span class="literal">false</span>, <span class="keyword">sizeof</span>(isPal));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            isPal[i][i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;s[i<span class="number">-1</span>]==s[i]) isPal[i<span class="number">-1</span>][i]=<span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">3</span>;len&lt;=n;len++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+len<span class="number">-1</span>&lt;n;i++){</span><br><span class="line">                <span class="keyword">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j]) isPal[i][j]=isPal[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> dp[n];</span><br><span class="line">        <span class="built_in">memset</span>(dp, inf, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(isPal[<span class="number">0</span>][i]){ <span class="comment">//整个串就是回文串了</span></span><br><span class="line">                dp[i]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--){</span><br><span class="line">                <span class="keyword">if</span>(isPal[j+<span class="number">1</span>][i]) dp[i]=min(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="152-乘积最大子序列"><a href="#152-乘积最大子序列" class="headerlink" title="152. 乘积最大子序列"></a>152. 乘积最大子序列</h4><p><strong>Description</strong><br>给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。<br><strong>Example</strong><br>示例 1:<br>输入: [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。</p><p>示例 2:<br>输入: [-2,0,-1]<br>输出: 0<br>解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。<br><strong>Program</strong><br>很自然地想到$DP[i]=max(DP[i-1]<em>nums[i], nums[i])$，但是数组存在负数，必须维护两个值，当前最小值和当前最大值，即<br>$imax=max(imax</em>nums[i], nums[i]),imin=min(imin*nums[i], nums[i])$，当出现负数交换两值！！！因为负数出现必然要用最小值（负数）才得到更大的数！</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans=INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> imax=<span class="number">1</span>, imin=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;<span class="number">0</span>) swap(imax, imin);</span><br><span class="line">            imax=max(imax*nums[i], nums[i]);</span><br><span class="line">            imin=min(imin*nums[i], nums[i]);</span><br><span class="line">            ans=max(imax, ans);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="174-地下城游戏"><a href="#174-地下城游戏" class="headerlink" title="174. 地下城游戏"></a>174. 地下城游戏</h4><p><strong>Description</strong><br>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p><p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。<br>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p><p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p><p><strong>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</strong><br>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-2 (K)	-3	3</span><br><span class="line">-5	-10	1</span><br><span class="line">10	30	-5 (P)</span><br></pre></td></tr></tbody></table></figure><p>说明:<br>骑士的健康点数没有上限。<br>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。<br><strong>Program</strong><br><strong>思路</strong><br>与经典动规类似，从右下往左上DP，设DP[i][j]为从i，j出发，到达右下角的最低健康数：<br>$DP[i][j]=max(min(DP[i+1][j],DP[i][j+1])-dungeon[i][j], 1)$<br>即DP[i][j]与右侧与下方DP值有关，取最小minx，而[i,j]位置需要minx-dungeon[i][j],其值为非正，表示恰好够或者有多余健康值，当为0值时，只要需要1点健康值。<br>注意边界</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dungeon)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m=dungeon.size(),n=dungeon[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> DP[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--){</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;m&amp;&amp;j+<span class="number">1</span>&lt;n) DP[i][j]=max(min(DP[i+<span class="number">1</span>][j], DP[i][j+<span class="number">1</span>])-dungeon[i][j],<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i+<span class="number">1</span>&lt;m) DP[i][j]=max(DP[i+<span class="number">1</span>][j]-dungeon[i][j], <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j+<span class="number">1</span>&lt;n) DP[i][j]=max(DP[i][j+<span class="number">1</span>]-dungeon[i][j], <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> DP[i][j]=max(<span class="number">1</span>-dungeon[i][j], <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h4><p><strong>Description</strong><br>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。<br><strong>Example</strong><br>示例 1:<br>输入: [1,2,3,1]<br>输出: 4<br>解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br> 偷窃到的最高金额 = 1 + 3 = 4 。</p><p>示例 2:<br>输入: [2,7,9,3,1]<br>输出: 12<br>解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br> 偷窃到的最高金额 = 2 + 9 + 1 = 12 。<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP;</span><br><span class="line">        DP.resize(nums.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++) DP[i]=nums[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;nums.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(i<span class="number">-3</span>&lt;<span class="number">0</span>){</span><br><span class="line">                DP[i]+=DP[i<span class="number">-2</span>];</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                DP[i] += max(DP[i<span class="number">-2</span>], DP[i<span class="number">-3</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxN=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(maxN&lt;DP[i]) maxN=DP[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> maxN;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a>213. 打家劫舍 II</h4><p><strong>Description</strong><br>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。<br><strong>Example</strong><br>示例 1:<br>输入: [2,3,2]<br>输出: 3<br>解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</p><p>示例 2:<br>输入: [1,2,3,1]<br>输出: 4<br>解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。<br> 偷窃到的最高金额 = 1 + 3 = 4 。<br><strong>Program</strong><br>由于成环，所以首尾两个数必须不能同时取，则划分成两个子问题：<br>①不包含第一个数<br>②不包含最后一个数<br>两个子问题下求解的不成环单列最大值中取最值就是最终答案！</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP;</span><br><span class="line">        DP.resize(nums.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++) DP[i]=nums[i];</span><br><span class="line">        <span class="keyword">int</span> ans=max(DP[<span class="number">0</span>], DP[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;nums.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(i<span class="number">-3</span>&lt;<span class="number">0</span>){</span><br><span class="line">                DP[i]+=DP[i<span class="number">-2</span>];</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                DP[i] += max(DP[i<span class="number">-2</span>], DP[i<span class="number">-3</span>]);</span><br><span class="line">            }</span><br><span class="line">            ans=max(ans, DP[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x1(nums.begin(), nums.end()<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x2(nums.begin()+<span class="number">1</span>, nums.end());</span><br><span class="line">        <span class="keyword">int</span> ans1=cal(x1);</span><br><span class="line">        <span class="keyword">int</span> ans2=cal(x2);</span><br><span class="line">        <span class="keyword">return</span> max(ans1, ans2);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="256-粉刷房子"><a href="#256-粉刷房子" class="headerlink" title="256. 粉刷房子"></a>256. 粉刷房子</h4><p><strong>Description</strong><br>假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。<br>当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的矩阵来表示的。<br>例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。<br>注意：<br>所有花费均为正整数。<br><strong>Example</strong><br>示例：<br>输入: [[17,2,17],[16,16,5],[14,3,19]]<br>输出: 10<br>解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。<br> 最少花费: 2 + 5 + 3 = 10。<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; costs)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(costs.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=costs.size();</span><br><span class="line">        <span class="keyword">int</span> DP[n][<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) DP[<span class="number">0</span>][i]=costs[<span class="number">0</span>][i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++){</span><br><span class="line">                DP[i][j]=costs[i][j];</span><br><span class="line">                DP[i][j]+=min(DP[i<span class="number">-1</span>][j<span class="number">-1</span>&lt;<span class="number">0</span>?<span class="number">2</span>:j<span class="number">-1</span>], DP[i<span class="number">-1</span>][j+<span class="number">1</span>&gt;<span class="number">2</span>?<span class="number">0</span>:j+<span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) ans=min(ans, DP[n<span class="number">-1</span>][i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="276-栅栏涂色"><a href="#276-栅栏涂色" class="headerlink" title="276. 栅栏涂色"></a>276. 栅栏涂色</h4><p><strong>Description</strong><br>有 k 种颜色的涂料和一个包含 n 个栅栏柱的栅栏，每个栅栏柱可以用其中一种颜色进行上色。</p><p>你需要给所有栅栏柱上色，并且保证其中相邻的栅栏柱 最多连续两个 颜色相同。然后，返回所有有效涂色的方案数。</p><p>注意:<br>n 和 k 均为非负的整数。<br><strong>Example</strong><br>示例:<br>输入: n = 3，k = 2<br>输出: 6<br>解析: 用 c1 表示颜色 1，c2 表示颜色 2，所有可能的涂色方案有:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&nbsp;           柱 1    柱 2   柱 3     </span><br><span class="line">-----      -----  -----  -----       </span><br><span class="line">  1         c1     c1     c2</span><br><span class="line">&nbsp;  2         c1     c2     c1</span><br><span class="line">&nbsp;  3         c1     c2     c2</span><br><span class="line">&nbsp;  4         c2     c1     c1&nbsp;</span><br><span class="line">  5         c2     c1     c2</span><br><span class="line">&nbsp;  6         c2     c2     c1</span><br></pre></td></tr></tbody></table></figure><p><strong>Program</strong><br><strong>一般思路</strong><br>设DP[i][j][c]为第i个栅栏连续j个颜色为c的个数，状态转移方程：</p><ul><li>DP[i][2][c]=DP[i-1][1][c];</li><li>DP[i][1][c]=DP[i-1][1][cc!=c]+DP[i-1][2][cc!=c];<br>无奈超时<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>||n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> DP[n][<span class="number">3</span>][k];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;k;c++) DP[<span class="number">0</span>][<span class="number">1</span>][c]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;<span class="number">3</span>;j++){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;k;c++){</span><br><span class="line">                    <span class="keyword">if</span>(j==<span class="number">2</span>) DP[i][j][c]=DP[i<span class="number">-1</span>][<span class="number">1</span>][c];</span><br><span class="line">                    <span class="keyword">if</span>(j==<span class="number">1</span>){</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> cc=<span class="number">0</span>;cc&lt;k;cc++){</span><br><span class="line">                            <span class="keyword">if</span>(cc!=c) {</span><br><span class="line">                                DP[i][j][c]+=DP[i<span class="number">-1</span>][<span class="number">1</span>][cc];</span><br><span class="line">                                DP[i][j][c]+=DP[i<span class="number">-1</span>][<span class="number">2</span>][cc];</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;<span class="number">3</span>;j++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;k;c++){</span><br><span class="line">                ans+=DP[n<span class="number">-1</span>][j][c];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li></ul><p><strong>DP</strong><br>设DP[i][0]为第i个栅栏与前一个不同的数量，DP[i][1]为第i个栅栏与前一个相同的数量：<br>DP[i][0]=(DP[i-1][0]+DP[i-1][1]) * (k-1);<br>DP[i][1]=DP[i-1][0];</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>||n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> DP[n][<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        DP[<span class="number">0</span>][<span class="number">0</span>]=k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            DP[i][<span class="number">0</span>]=(DP[i<span class="number">-1</span>][<span class="number">1</span>]+DP[i<span class="number">-1</span>][<span class="number">0</span>])*(k<span class="number">-1</span>);</span><br><span class="line">            DP[i][<span class="number">1</span>]=DP[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n<span class="number">-1</span>][<span class="number">0</span>]+DP[n<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>状态压缩</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>||n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> DP[<span class="number">2</span>]={k, <span class="number">0</span>};</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> tmp=DP[<span class="number">0</span>];</span><br><span class="line">            DP[<span class="number">0</span>]=(DP[<span class="number">1</span>]+DP[<span class="number">0</span>])*(k<span class="number">-1</span>);</span><br><span class="line">            DP[<span class="number">1</span>]=tmp;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[<span class="number">0</span>]+DP[<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a>300. 最长上升子序列</h4><p><strong>Description</strong><br>给定一个无序的整数数组，找到其中最长上升子序列的长度。<br><strong>Example</strong><br>示例:<br>输入: [10,9,2,5,3,7,101,18]<br>输出: 4<br>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。<br>说明:</p><p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为 $O(n^2)$ 。<br>进阶: 你能将算法的时间复杂度降低到 $O(n\log{n})$ 吗?<br><strong>Program</strong><br><strong>DP</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++){</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[j]) DP[i]=max(DP[i], DP[j]+<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            ans=max(ans, DP[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>贪心+二分</strong><br>维护一个递增序列，维持其尾部尽可能小，因为这样可以使得序列尽可能长。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tail(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums){</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>, j=res;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j){ <span class="comment">//找比x大的最小元素的位置</span></span><br><span class="line">                <span class="keyword">int</span> mid=(i+j)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(tail[mid]&lt;x) i=mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> j=mid;</span><br><span class="line">            }</span><br><span class="line">            tail[i]=x;</span><br><span class="line">            <span class="keyword">if</span>(j==res) res++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="354-俄罗斯套娃信封问题"><a href="#354-俄罗斯套娃信封问题" class="headerlink" title="354. 俄罗斯套娃信封问题"></a>354. 俄罗斯套娃信封问题</h4><p><strong>Description</strong><br>给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。<br>请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。<br>说明:<br>不允许旋转信封。<br><strong>Example</strong><br>示例:<br>输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]<br>输出: 3<br>解释: 最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。<br><strong>Program</strong><br><strong>常规DP</strong><br>（1）先对信封按照w，h升序排列，然后DP；<br>（2）设DP[i]表示以i为结尾的最大嵌套次数，则状态转移方程：<br>DP[i]=max(DP[j])+1;<br>时间复杂度：$O(n^2)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; envelopes)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(envelopes.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=envelopes.size();</span><br><span class="line">        sort(envelopes.begin(), envelopes.end(), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b){</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>]&lt;b[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">int</span> dp[n];</span><br><span class="line">        fill(dp, dp + n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++){</span><br><span class="line">                <span class="keyword">if</span>(envelopes[j][<span class="number">0</span>]&lt;envelopes[i][<span class="number">0</span>]&amp;&amp;envelopes[j][<span class="number">1</span>]&lt;envelopes[i][<span class="number">1</span>]) dp[i]=max(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            ans=max(ans, dp[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>二分</strong><br>与最长上升子序列的二分法思路类似；<br>（1）先对w升序，h降序，关键在h降序，保证相同的w下，tail只保留较大的h，防止相同的w下，更大的h的信封套上相同w而h更小的信封；<br>（2）tail[i]表示长度i的上升子序列尾部元素，贪心地希望尾部元素更小，那么就能够使得整个上升子序列越大；<br>（3）二分找比当前元素x更大的最小元素进行替换，没找到那么就增加长度；<br>时间复杂度：$O(n\log{n})$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; envelopes)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(envelopes.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=envelopes.size();</span><br><span class="line">        sort(envelopes.begin(), envelopes.end(), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b){ <span class="comment">//按w升序，h降序</span></span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>]&gt;b[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">int</span> height[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) height[i]=envelopes[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> tail[n];</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:height){</span><br><span class="line">            <span class="keyword">int</span> left=<span class="number">0</span>, right=len;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">                <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(tail[mid]&gt;=x) right=mid;</span><br><span class="line">                <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            tail[left]=x;</span><br><span class="line">            <span class="keyword">if</span>(left==len) len++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="面试题-17-08-马戏团人塔"><a href="#面试题-17-08-马戏团人塔" class="headerlink" title="面试题 17.08. 马戏团人塔"></a>面试题 17.08. 马戏团人塔</h4><p><strong>Description</strong><br>有个马戏团正在设计叠罗汉的表演节目，一个人要站在另一人的肩膀上。出于实际和美观的考虑，在上面的人要比下面的人矮一点且轻一点。已知马戏团每个人的身高和体重，请编写代码计算叠罗汉最多能叠几个人。<br><strong>Example</strong><br>示例：<br>输入：height = [65,70,56,75,60,68] weight = [100,150,90,190,95,110]<br>输出：6<br>解释：从上往下数，叠罗汉最多能叠 6 层：(56,90), (60,95), (65,100), (68,110), (70,150), (75,190)<br>提示：<br>height.length == weight.length &lt;= 10000<br><strong>Program</strong><br><strong>常规DP</strong><br>时间复杂度:$O(n^2)$<br>超时</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> h, w;</span><br><span class="line">        Node(<span class="keyword">int</span> _h, <span class="keyword">int</span> _w):h(_h),w(_w){}</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; tmp) <span class="keyword">const</span>{</span><br><span class="line">            <span class="keyword">if</span>(h!=tmp.h) <span class="keyword">return</span> h&lt;tmp.h;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> w&lt;tmp.w;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bestSeqAtIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; weight)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(height.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; vec;</span><br><span class="line">        <span class="keyword">int</span> n=height.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            vec.push_back(Node(height[i], weight[i]));</span><br><span class="line">        }</span><br><span class="line">        sort(vec.begin(), vec.end());</span><br><span class="line">        <span class="keyword">int</span> DP[n];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            DP[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++){</span><br><span class="line">                <span class="keyword">if</span>(vec[j].h&lt;vec[i].h&amp;&amp;vec[j].w&lt;vec[i].w){</span><br><span class="line">                    DP[i]=max(DP[i], DP[j]+<span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            ans=max(DP[i], ans);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>贪心+二分</strong><br>根据上一题的思路，设tails[i]为以tails[i]为结尾长度为i+1的满足题目要求的序列</p><ul><li><strong>这里先对h升序，再对w降序：</strong><br>升序保证不受h影响，只需要对w进行最长上升子序列求法，而对w降序则是在上述算法中避免h相同但较小的w更早出现的情况下不方便进行二分。—— 若h相同，较小的w先出现，那么较大的w出现时二分如何进行？找第一个大于等于w的位置？错误，明显不进行任何操作，但在进行二分的时候不方便体现，在h升序的基础上对w进行降序，则可以有效避免该情况的发生，因为h相同情况下，较大的w更早出现占据tails的某个位置，而较小的w则刚好在算法的执行当中替换掉较大的w的位置。</li><li><strong>二分找第一个比x大的元素位置进行替换</strong><br>因为tails[i]记录了长度为i+1结尾为tails[i]的满足题意的序列，那么贪心的希望tails[i]更小，那么后面得到的序列就会更长。<br>时间复杂度：$O(n\log{n})$<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> h, w;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> _h, <span class="keyword">int</span> _w):h(_h),w(_w){}</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; tmp) <span class="keyword">const</span>{</span><br><span class="line">            <span class="keyword">if</span>(h!=tmp.h) <span class="keyword">return</span> h&lt;tmp.h;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> w&gt;tmp.w;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bestSeqAtIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; weight)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(height.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; vec;</span><br><span class="line">        <span class="keyword">int</span> n=height.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            vec.push_back(Node(height[i], weight[i]));</span><br><span class="line">        }</span><br><span class="line">        sort(vec.begin(), vec.end());</span><br><span class="line">        <span class="keyword">int</span> tails[n]; <span class="comment">//长度为i+1的以tails[i]为结尾的子序列</span></span><br><span class="line">        <span class="comment">// memset(tails, 0, sizeof(tails));</span></span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> w=vec[i].w;</span><br><span class="line">            <span class="keyword">int</span> left=<span class="number">0</span>, right=len;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right){ <span class="comment">//找比x大的最小元素位置</span></span><br><span class="line">                <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(tails[mid]&gt;=w) right=mid;</span><br><span class="line">                <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            tails[left]=w;</span><br><span class="line">            <span class="keyword">if</span>(left==len) len++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="712-两个字符串的最小ASCII删除和"><a href="#712-两个字符串的最小ASCII删除和" class="headerlink" title="712. 两个字符串的最小ASCII删除和"></a>712. 两个字符串的最小ASCII删除和</h4></li></ul><p><strong>Description</strong><br>给定两个字符串s1, s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。<br><strong>Example</strong><br>示例 1:<br>输入: s1 = “sea”, s2 = “eat”<br>输出: 231<br>解释: 在 “sea” 中删除 “s” 并将 “s” 的值(115)加入总和。<br>在 “eat” 中删除 “t” 并将 116 加入总和。<br>结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。</p><p>示例 2:<br>输入: s1 = “delete”, s2 = “leet”<br>输出: 403<br>解释: 在 “delete” 中删除 “dee” 字符串变成 “let”，<br>将 100[d]+101[e]+101[e] 加入总和。在 “leet” 中删除 “e” 将 101[e] 加入总和。<br>结束时，两个字符串都等于 “let”，结果即为 100+101+101+101 = 403 。<br>如果改为将两个字符串转换为 “lee” 或 “eet”，我们会得到 433 或 417 的结果，比答案更大。<br>注意:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 &lt; s1.length, s2.length &lt;= 1000。</span><br><span class="line">所有字符串中的字符ASCII值在[97, 122]之间。</span><br></pre></td></tr></tbody></table></figure><p><strong>Program</strong><br>就是要找最长公共子序列，同时满足最长子序列的和最大。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m=s1.length();</span><br><span class="line">        <span class="keyword">int</span> n=s2.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; S(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line">                <span class="keyword">if</span>(s1[i<span class="number">-1</span>]==s2[j<span class="number">-1</span>]){</span><br><span class="line">                    S[i][j]=S[i<span class="number">-1</span>][j<span class="number">-1</span>]+(<span class="keyword">int</span>)s1[i<span class="number">-1</span>];</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    S[i][j]=max(S[i][j<span class="number">-1</span>],S[i<span class="number">-1</span>][j]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) sum+=(<span class="keyword">int</span>)s1[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) sum+=(<span class="keyword">int</span>)s2[j];</span><br><span class="line">        <span class="keyword">return</span> sum<span class="number">-2</span>*S[m][n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h4><p><strong>Description</strong><br>数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost<a href="索引从0开始">i</a>。<br>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。<br>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。<br><strong>Example</strong><br>示例 1:<br>输入: cost = [10, 15, 20]<br>输出: 15<br>解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。</p><p>示例 2:<br>输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br>输出: 6<br>解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。</p><p>注意：<br>cost 的长度将会在 [2, 1000]。<br>每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。<br><strong>Program</strong><br>注意顶层不是最后n-1，而是n。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=cost.size();</span><br><span class="line">        <span class="keyword">int</span> DP[n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP,inf,<span class="keyword">sizeof</span>(DP));</span><br><span class="line">        DP[<span class="number">0</span>]=cost[<span class="number">0</span>];</span><br><span class="line">        DP[<span class="number">1</span>]=cost[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++){</span><br><span class="line">            DP[i]=min(DP[i<span class="number">-1</span>], DP[i<span class="number">-2</span>]);</span><br><span class="line">            <span class="keyword">if</span>(i&lt;n) DP[i]+=cost[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="799-香槟塔"><a href="#799-香槟塔" class="headerlink" title="799. 香槟塔"></a>799. 香槟塔</h4><p><strong>Description</strong><br>我们把玻璃杯摆成金字塔的形状，其中第一层有1个玻璃杯，第二层有2个，依次类推到第100层，每个玻璃杯(250ml)将盛有香槟。</p><p>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）</p><p>例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，如下图所示。</p><p>现在当倾倒了非负整数杯香槟后，返回第 i 行 j 个玻璃杯所盛放的香槟占玻璃杯容积的比例（i 和 j都从0开始）。<br><strong>Example</strong><br>示例 1:<br>输入: poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1<br>输出: 0.0<br>解释: 我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。</p><p>示例 2:<br>输入: poured(倾倒香槟总杯数) = 2, query_glass(杯子的位置数) = 1, query_row(行数) = 1<br>输出: 0.5<br>解释: 我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。</p><p>注意:<br>poured 的范围$[0, 10 ^ 9]$。<br>query_glass 和query_row 的范围 $[0, 99]$。<br><strong>Program</strong><br><strong>DP</strong><br>设DP[i][j]为[i,j]的香槟容量，rest[i][j]为[i,j]的剩余容量。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">champagneTower</span><span class="params">(<span class="keyword">int</span> poured, <span class="keyword">int</span> query_row, <span class="keyword">int</span> query_glass)</span> </span>{</span><br><span class="line">        <span class="keyword">double</span> DP[<span class="number">100</span>][<span class="number">100</span>], rest[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="built_in">memset</span>(rest, <span class="number">0</span>, <span class="keyword">sizeof</span>(rest));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++){</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>){</span><br><span class="line">                    <span class="keyword">if</span>(poured&gt;=<span class="number">1</span>) {DP[i][j]=<span class="number">1.0</span>;rest[i][j]=(<span class="keyword">double</span>)poured<span class="number">-1.0</span>;}</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                DP[i][j]=(j<span class="number">-1</span>&gt;=<span class="number">0</span>?rest[i<span class="number">-1</span>][j<span class="number">-1</span>]/<span class="number">2</span>:<span class="number">0</span>)+(j&lt;=i<span class="number">-1</span>?rest[i<span class="number">-1</span>][j]/<span class="number">2</span>:<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(DP[i][j]&gt;<span class="number">1.0</span>){rest[i][j]=DP[i][j]<span class="number">-1.0</span>; DP[i][j]=<span class="number">1.0</span>;}</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[query_row][query_glass];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="931-下降路径最小和"><a href="#931-下降路径最小和" class="headerlink" title="931. 下降路径最小和"></a>931. 下降路径最小和</h4><p><strong>Description</strong><br>给定一个方形整数数组 A，我们想要得到通过 A 的下降路径的最小和。<br>下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。<br><strong>Example</strong><br>示例：<br>输入：[[1,2,3],[4,5,6],[7,8,9]]<br>输出：12<br>解释：<br>可能的下降路径有：<br>[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]<br>[2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]<br>[3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]<br>和最小的下降路径是 [1,4,7]，所以答案是 12。</p><p>提示：<br>1 &lt;= A.length == A[0].length &lt;= 100<br>-100 &lt;= A[i][j] &lt;= 100<br><strong>Program</strong><br><strong>思路</strong><br>常规动规题：设DP[i][j]为从第i行j列出发，到达最底层的最小值：<br>递推公式：$DP[i][j]=\min \lbrace DP[i+1][j-1], DP[i+1][j], DP[i+1][j+1]\rbrace$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minFallingPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="keyword">int</span> DP[n][n];</span><br><span class="line">        <span class="built_in">memset</span>(DP, inf, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">if</span>(i==n<span class="number">-1</span>){</span><br><span class="line">                    DP[i][j]=A[i][j];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(j<span class="number">-1</span>&gt;=<span class="number">0</span>) DP[i][j]=min(DP[i][j], DP[i+<span class="number">1</span>][j<span class="number">-1</span>]);</span><br><span class="line">                DP[i][j]=min(DP[i][j], DP[i+<span class="number">1</span>][j]);</span><br><span class="line">                <span class="keyword">if</span>(j+<span class="number">1</span>&lt;n) DP[i][j]=min(DP[i][j], DP[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">                DP[i][j]+=A[i][j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) ans=min(ans, DP[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="1043-分隔数组以得到最大和"><a href="#1043-分隔数组以得到最大和" class="headerlink" title="1043. 分隔数组以得到最大和"></a>1043. 分隔数组以得到最大和</h4><p><strong>Description</strong><br>给你一个整数数组 arr，请你将该数组分隔为长度最多为 k 的一些（连续）子数组。分隔完成后，每个子数组的中的所有值都会变为该子数组中的最大值。<br>返回将数组分隔变换后能够得到的元素最大和。<br>注意，原数组和分隔后的数组对应顺序应当一致，也就是说，你只能选择分隔数组的位置而不能调整数组中的顺序。<br><strong>Example</strong><br>示例 1：<br>输入：arr = [1,15,7,9,2,5,10], k = 3<br>输出：84<br>解释：<br>因为 k=3 可以分隔成 [1,15,7] [9] [2,5,10]，结果为 [15,15,15,9,10,10,10]，和为 84，是该数组所有分隔变换后元素总和最大的。<br>若是分隔成 [1] [15,7,9] [2,5,10]，结果就是 [1, 15, 15, 15, 10, 10, 10] 但这种分隔方式的元素总和（76）小于上一种。</p><p>示例 2：<br>输入：arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4<br>输出：83</p><p>示例 3：<br>输入：arr = [1], k = 1<br>输出：1</p><p>提示：<br>1 &lt;= arr.length &lt;= 500<br>0 &lt;= arr[i] &lt;= 109<br>1 &lt;= k &lt;= arr.length<br><strong>Program</strong><br><strong>思路</strong><br>$DP[i]=max(DP[i], DP[j]+max(A[j+1], … , A[i]))$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumAfterPartitioning</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; mx(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++){</span><br><span class="line">                tmp=max(tmp, arr[j]);</span><br><span class="line">                mx[i][j]=tmp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=max(<span class="number">0</span>, i-k);j&lt;i;j++){</span><br><span class="line">                DP[i]=max(DP[i], DP[j]+mx[j][i<span class="number">-1</span>]*(i-j));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>逆序优化</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumAfterPartitioning</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="keyword">int</span> mx=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=max(<span class="number">0</span>, i-k);j--){ <span class="comment">//逆序找区间最值</span></span><br><span class="line">                mx=max(mx, arr[j]);</span><br><span class="line">                DP[i]=max(DP[i], DP[j]+mx*(i-j));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a>1143. 最长公共子序列</h4><p><strong>Description</strong><br>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。<br>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。<br>若这两个字符串没有公共子序列，则返回 0。<br><strong>Example</strong><br>示例 1:<br>输入：text1 = “abcde”, text2 = “ace”<br>输出：3<br>解释：最长公共子序列是 “ace”，它的长度为 3。</p><p>示例 2:<br>输入：text1 = “abc”, text2 = “abc”<br>输出：3<br>解释：最长公共子序列是 “abc”，它的长度为 3。</p><p>示例 3:<br>输入：text1 = “abc”, text2 = “def”<br>输出：0<br>解释：两个字符串没有公共子序列，返回 0。</p><p>提示:<br>1 &lt;= text1.length &lt;= 1000<br>1 &lt;= text2.length &lt;= 1000<br>输入的字符串只含有小写英文字符。<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m=text1.length(), n=text2.length();</span><br><span class="line">        <span class="keyword">int</span> DP[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line">                <span class="keyword">if</span>(text1[i<span class="number">-1</span>]==text2[j<span class="number">-1</span>]) DP[i][j]=DP[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> DP[i][j]=max(DP[i<span class="number">-1</span>][j], DP[i][j<span class="number">-1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[m][n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="1641-统计字典序元音字符串的数目"><a href="#1641-统计字典序元音字符串的数目" class="headerlink" title="1641. 统计字典序元音字符串的数目"></a>1641. 统计字典序元音字符串的数目</h4><p><strong>Description</strong><br>给你一个整数 n，请返回长度为 n 、仅由元音 (a, e, i, o, u) 组成且按 字典序排列 的字符串数量。<br>字符串 s 按 字典序排列 需要满足：对于所有有效的 i，s[i] 在字母表中的位置总是与 s[i+1] 相同或在 s[i+1] 之前。<br><strong>Example</strong><br>示例 1：<br>输入：n = 1<br>输出：5<br>解释：仅由元音组成的 5 个字典序字符串为 [“a”,”e”,”i”,”o”,”u”]</p><p>示例 2：<br>输入：n = 2<br>输出：15<br>解释：仅由元音组成的 15 个字典序字符串为<br>[“aa”,”ae”,”ai”,”ao”,”au”,”ee”,”ei”,”eo”,”eu”,”ii”,”io”,”iu”,”oo”,”ou”,”uu”]<br>注意，”ea” 不是符合题意的字符串，因为 ‘e’ 在字母表中的位置比 ‘a’ 靠后</p><p>示例 3：<br>输入：n = 33<br>输出：66045</p><p>提示：<br>1 &lt;= n &lt;= 50<br><strong>Program</strong><br>设DP[i][n]表示以某个元音结尾的长为n的满足条件的字符串个数，其中[0,1,2,3,4]分别表示[a,e,i,o,u]；<br>状态转移方程：<br>DP[0][i]=DP[0][i-1];<br>DP[1][i]=DP[1][i-1]+DP[0][i-1];<br>DP[2][i]=DP[2][i-1]+DP[1][i-1]+DP[0][i-1];<br>DP[3][i]=DP[3][i-1]+DP[2][i-1]+DP[1][i-1]+DP[0][i-1];<br>DP[4][i]=DP[4][i-1]+DP[3][i-1]+DP[2][i-1]+DP[1][i-1]+DP[0][i-1];</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countVowelStrings</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> DP[<span class="number">5</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) DP[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++){</span><br><span class="line">            DP[<span class="number">0</span>][i]=DP[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">            DP[<span class="number">1</span>][i]=DP[<span class="number">1</span>][i<span class="number">-1</span>]+DP[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">            DP[<span class="number">2</span>][i]=DP[<span class="number">2</span>][i<span class="number">-1</span>]+DP[<span class="number">1</span>][i<span class="number">-1</span>]+DP[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">            DP[<span class="number">3</span>][i]=DP[<span class="number">3</span>][i<span class="number">-1</span>]+DP[<span class="number">2</span>][i<span class="number">-1</span>]+DP[<span class="number">1</span>][i<span class="number">-1</span>]+DP[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">            DP[<span class="number">4</span>][i]=DP[<span class="number">4</span>][i<span class="number">-1</span>]+DP[<span class="number">3</span>][i<span class="number">-1</span>]+DP[<span class="number">2</span>][i<span class="number">-1</span>]+DP[<span class="number">1</span>][i<span class="number">-1</span>]+DP[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) ans+=DP[i][n];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="1626-无矛盾的最佳球队"><a href="#1626-无矛盾的最佳球队" class="headerlink" title="1626. 无矛盾的最佳球队"></a>1626. 无矛盾的最佳球队</h4><p><strong>Description</strong><br>假设你是球队的经理。对于即将到来的锦标赛，你想组合一支总体得分最高的球队。球队的得分是球队中所有球员的分数 总和 。<br>然而，球队中的矛盾会限制球员的发挥，所以必须选出一支 没有矛盾 的球队。如果一名年龄较小球员的分数 严格大于 一名年龄较大的球员，则存在矛盾。同龄球员之间不会发生矛盾。<br>给你两个列表 scores 和 ages，其中每组 scores[i] 和 ages[i] 表示第 i 名球员的分数和年龄。请你返回 所有可能的无矛盾球队中得分最高那支的分数 。<br><strong>Example</strong><br>示例 1：<br>输入：scores = [1,3,5,10,15], ages = [1,2,3,4,5]<br>输出：34<br>解释：你可以选中所有球员。</p><p>示例 2：<br>输入：scores = [4,5,6,5], ages = [2,1,2,1]<br>输出：16<br>解释：最佳的选择是后 3 名球员。注意，你可以选中多个同龄球员。</p><p>示例 3：<br>输入：scores = [1,2,3,5], ages = [8,9,10,1]<br>输出：6<br>解释：最佳的选择是前 3 名球员。</p><p>提示：<br>$1 &lt;= scores.length, ages.length &lt;= 1000$<br>$scores.length == ages.length$<br>$1 &lt;= scores[i] &lt;= 10^6$<br>$1 &lt;= ages[i] &lt;= 1000$<br><strong>Program</strong><br><strong>思路</strong><br>（1）首先根据年龄升序，年龄相同则根据分数升序排列；<br>（2）那么对于i，左边肯定年龄都不大于其自身年龄<br>（3）设DP[i]为以i为结尾的无矛盾分数最大值，状态转移方程：<br>①age[j]==age[i]:<br>DP[i]=max(DP[i], DP[j]+score[i])<br>②age[j]&lt;age[i],那么仅当score[j]&lt;=score[i]时：<br>DP[i]=max(DP[i], DP[j]+score[i])<br>时间复杂度：$O(n^2)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> score, age;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> _score, <span class="keyword">int</span> _age):score(_score), age(_age){}</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; other) <span class="keyword">const</span>{</span><br><span class="line">            <span class="keyword">return</span> age==other.age?score&lt;other.score:age&lt;other.age;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bestTeamScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; scores, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ages)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; vec;</span><br><span class="line">        <span class="keyword">int</span> n=scores.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) vec.push_back(Node(scores[i], ages[i]));</span><br><span class="line">        sort(vec.begin(), vec.end());</span><br><span class="line">        <span class="keyword">int</span> DP[n];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            DP[i]=vec[i].score;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++){</span><br><span class="line">                <span class="keyword">if</span>(vec[j].age==vec[i].age) DP[i]=max(DP[i], DP[j]+vec[i].score);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(vec[j].score&lt;=vec[i].score) DP[i]=max(DP[i], DP[j]+vec[i].score);</span><br><span class="line">            }</span><br><span class="line">            ans=max(ans, DP[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="面试题-08-01-三步问题"><a href="#面试题-08-01-三步问题" class="headerlink" title="面试题 08.01. 三步问题"></a>面试题 08.01. 三步问题</h4><p><strong>Description</strong><br>三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。<br><strong>Example</strong><br>示例1:<br> 输入：n = 3<br> 输出：4<br> 说明: 有四种走法</p><p>示例2:<br> 输入：n = 5<br> 输出：13<br>提示:<br>n范围在[1, 1000000]之间<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToStep</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> DP[n+<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        DP[<span class="number">0</span>]=DP[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        DP[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++){</span><br><span class="line">            DP[i]=((DP[i<span class="number">-1</span>]+DP[i<span class="number">-2</span>])%MOD+DP[i<span class="number">-3</span>])%MOD;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="面试题42-连续子数组的最大和"><a href="#面试题42-连续子数组的最大和" class="headerlink" title="面试题42. 连续子数组的最大和"></a>面试题42. 连续子数组的最大和</h4><p><strong>Description</strong><br>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。<br>要求时间复杂度为O(n)。<br><strong>Example</strong><br>示例1:<br>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><p>提示：<br>1 &lt;= arr.length &lt;= 10^5<br>-100 &lt;= arr[i] &lt;= 100</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> DP[n];</span><br><span class="line">        DP[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans=DP[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            DP[i]=max(DP[i<span class="number">-1</span>]+nums[i],nums[i]);</span><br><span class="line">            ans=max(ans, DP[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="面试题47-礼物的最大价值"><a href="#面试题47-礼物的最大价值" class="headerlink" title="面试题47. 礼物的最大价值"></a>面试题47. 礼物的最大价值</h4><p><strong>Description</strong><br>在一个 m<em>n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？<br>*</em>Example**<br>示例 1:<br>输入:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&nbsp; [1,3,1],</span><br><span class="line">&nbsp; [1,5,1],</span><br><span class="line">&nbsp; [4,2,1]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>输出: 12<br>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</p><p>提示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 &lt; grid.length &lt;= 200</span><br><span class="line">0 &lt; grid[0].length &lt;= 200</span><br></pre></td></tr></tbody></table></figure><p><strong>Program</strong><br><strong>动规</strong><br>状态转移方程：$DP[i][j]=grid[i][j]+max(DP[i+1][j],DP[i][j+1])$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>{</span><br><span class="line">        <span class="comment">//if(grid.size()==0) return 0;</span></span><br><span class="line">        <span class="keyword">int</span> m=grid.size();</span><br><span class="line">        <span class="keyword">int</span> n=grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> DP[m][n];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--){</span><br><span class="line">                DP[i][j]=grid[i][j];</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;m&amp;&amp;j+<span class="number">1</span>&lt;n) DP[i][j]+=max(DP[i+<span class="number">1</span>][j],DP[i][j+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i+<span class="number">1</span>&lt;m) DP[i][j]+=DP[i+<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j+<span class="number">1</span>&lt;n) DP[i][j]+=DP[i][j+<span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>空间优化</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>{</span><br><span class="line">        <span class="comment">//if(grid.size()==0) return 0;</span></span><br><span class="line">        <span class="keyword">int</span> m=grid.size();</span><br><span class="line">        <span class="keyword">int</span> n=grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> DP[n];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--){</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;m&amp;&amp;j+<span class="number">1</span>&lt;n) DP[j]=max(DP[j],DP[j+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i+<span class="number">1</span>&lt;m) DP[j]=DP[j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j+<span class="number">1</span>&lt;n) DP[j]=DP[j+<span class="number">1</span>];</span><br><span class="line">                DP[j]+=grid[i][j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="面试题-16-17-连续数列"><a href="#面试题-16-17-连续数列" class="headerlink" title="面试题 16.17. 连续数列"></a>面试题 16.17. 连续数列</h4><p><strong>Description</strong><br>给定一个整数数组，找出总和最大的连续数列，并返回总和。<br><strong>Example</strong><br>示例：<br>输入： [-2,1,-3,4,-1,2,1,-5,4]<br>输出： 6<br>解释： 连续子数组 [4,-1,2,1] 的和最大，为 6。<br>进阶：<br>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解<br><strong>Program</strong><br><strong>动规</strong><br>时间复杂度：$O(n)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> DP[n];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">int</span> ans=nums[<span class="number">0</span>];</span><br><span class="line">        DP[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            DP[i]=max(nums[i], DP[i<span class="number">-1</span>]+nums[i]);</span><br><span class="line">            ans=max(ans, DP[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>空间优化</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> s=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            s=max(nums[i], s+nums[i]);</span><br><span class="line">            ans=max(ans, s);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>分治</strong><br>和最大的连续序列只会出现在三个位置：<br>（1）数组左边；<br>（2）数组右边；<br>（3）数组中间；</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(left==right) <span class="keyword">return</span> nums[left];</span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> leftSum=dfs(nums, left, mid);</span><br><span class="line">        <span class="keyword">int</span> rightSum=dfs(nums, mid+<span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">int</span> midLeftSum=<span class="number">0</span>, midLeftMaxSum=-INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=mid;i&gt;=left;i--){</span><br><span class="line">            midLeftSum+=nums[i];</span><br><span class="line">            midLeftMaxSum=max(midLeftMaxSum, midLeftSum);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> midRightSum=<span class="number">0</span>, midRightMaxSum=-INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>;i&lt;=right;i++){</span><br><span class="line">            midRightSum+=nums[i];</span><br><span class="line">            midRightMaxSum=max(midRightMaxSum, midRightSum);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max(max(leftSum, rightSum), (midLeftMaxSum+midRightMaxSum));</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">return</span> dfs(nums, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="字符DP"><a href="#字符DP" class="headerlink" title="字符DP"></a>字符DP</h3><h4 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a>10. 正则表达式匹配</h4><p><strong>Description</strong><br>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p><p>说明:<br>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 <em>。<br>*</em>Example**<br>示例 1:<br>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。</p><p>示例 2:<br>输入:<br>s = “aa”<br>p = “a*”<br>输出: true<br>解释: 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p><p>示例 3:<br>输入:<br>s = “ab”<br>p = “.*”<br>输出: true<br>解释: “.*” 表示可匹配零个或多个（’*’）任意字符（’.’）。</p><p>示例 4:<br>输入:<br>s = “aab”<br>p = “c<em>a</em>b”<br>输出: true<br>解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。</p><p>示例 5:<br>输入:<br>s = “mississippi”<br>p = “mis<em>is*p</em>.”<br>输出: false<br><strong>Program</strong><br><strong>动态规划</strong><br>状态转移方程：<br>（1）s[i]==p[j]或p[j]==’.’, DP[i][j]=DP[i-1][j-1];<br>（2）p[j]==’*’:<br>①s[i]==p[j], DP[i][j]=DP[i-1][j]||DP[i][j-2];<br>②s[i]!=p[j], DP[i][j]=DP[i][j-2];<br>时间复杂度：$O(mn)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m=s.length(), n=p.length();</span><br><span class="line">        <span class="keyword">bool</span> DP[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="literal">false</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        DP[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line">                <span class="keyword">if</span>((i&gt;=<span class="number">1</span>&amp;&amp;s[i<span class="number">-1</span>]==p[j<span class="number">-1</span>])||p[j<span class="number">-1</span>]==<span class="string">'.'</span>) DP[i][j]=(i&gt;=<span class="number">1</span>?DP[i<span class="number">-1</span>][j<span class="number">-1</span>]:<span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p[j<span class="number">-1</span>]==<span class="string">'*'</span>){</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;=<span class="number">1</span>&amp;&amp;j&gt;=<span class="number">2</span>&amp;&amp;(s[i<span class="number">-1</span>]==p[j<span class="number">-2</span>]||p[j<span class="number">-2</span>]==<span class="string">'.'</span>)){ <span class="comment">//注意".*"组合</span></span><br><span class="line">                        DP[i][j]=DP[i<span class="number">-1</span>][j]||DP[i][j<span class="number">-2</span>];</span><br><span class="line">                    }<span class="keyword">else</span> DP[i][j]=(j&gt;=<span class="number">2</span>?DP[i][j<span class="number">-2</span>]:<span class="literal">false</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[m][n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a>32. 最长有效括号</h4><p><strong>Description</strong><br>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。<br><strong>Example</strong><br>示例 1:<br>输入: “(()”<br>输出: 2<br>解释: 最长有效括号子串为 “()”</p><p>示例 2:<br>输入: “)()())”<br>输出: 4<br>解释: 最长有效括号子串为 “()()”<br><strong>Program</strong><br><strong>①双指针</strong><br>lb,rb分别记录左右括号个数：<br>（1）从左往右遍历，如果lb==rb，则更新最大长度，如果rb&gt;lb，lb=rb=0；<br>这样的做法贪心地考虑了以当前字符下标结尾的有效括号长度，每次当右括号数量多于左括号数量的时候之前的字符我们都扔掉不再考虑，重新从下一个字符开始计算，但这样会漏掉一种情况，就是遍历的时候左括号的数量始终大于右括号的数量，例如”(()” ，这种时候最长有效括号是求不出来的。<br>（2）所以从右往左遍历：如果lb==rb，更新最大长度，如果lb&gt;rb，lb=rb=0;</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lb=<span class="number">0</span>, rb=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmpLen=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'('</span>) lb++;</span><br><span class="line">            <span class="keyword">else</span> rb++;</span><br><span class="line">            <span class="keyword">if</span>(lb==rb) ans=max(ans, <span class="number">2</span>*rb);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rb&gt;lb) rb=lb=<span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'('</span>) lb++;</span><br><span class="line">            <span class="keyword">else</span> rb++;</span><br><span class="line">            <span class="keyword">if</span>(lb==rb) ans=max(ans, <span class="number">2</span> * rb);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(lb&gt;rb) rb=lb=<span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>②动态规划</strong><br>设DP[i]为以i结尾的最长有效长度，那么s[i]==’(‘肯定为0，只有s[i]==’)’才有可能更新长度.<br>（1）s[i]==’)’且s[i-1]==’(‘: DP[i]=DP[i-1]+2；<br>（2）s[i]==’)’且s[i-1]==’)’：<br>如果s[i-1-DP[i-1]]==’(‘：DP[i]=DP[i-1]+2+DP[i-2-DP[i-1]] —— 即DP[i-1]这一段的前一个字符为’(‘，则DP[i]的长度应当是DP[i-1]+2，以及更前一段DP[i-2-DP[i-1]]</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> DP[n];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">')'</span>&amp;&amp;s[i<span class="number">-1</span>]==<span class="string">'('</span>) DP[i]=(i<span class="number">-2</span>&gt;=<span class="number">0</span>)?DP[i<span class="number">-2</span>]+<span class="number">2</span>:<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">')'</span>&amp;&amp;s[i<span class="number">-1</span>]==<span class="string">')'</span>){</span><br><span class="line">                <span class="keyword">if</span>(i<span class="number">-1</span>-DP[i<span class="number">-1</span>]&gt;=<span class="number">0</span>&amp;&amp;s[i<span class="number">-1</span>-DP[i<span class="number">-1</span>]]==<span class="string">'('</span>) DP[i]=DP[i<span class="number">-1</span>]+<span class="number">2</span>+(i<span class="number">-2</span>-DP[i<span class="number">-1</span>]&gt;=<span class="number">0</span>?DP[i<span class="number">-2</span>-DP[i<span class="number">-1</span>]]:<span class="number">0</span>);</span><br><span class="line">            }</span><br><span class="line">            ans=max(ans, DP[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="44-通配符匹配"><a href="#44-通配符匹配" class="headerlink" title="44. 通配符匹配"></a>44. 通配符匹配</h4><p><strong>Description</strong><br>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘ * ‘ 的通配符匹配。</p><p>‘ ? ‘ 可以匹配任何单个字符。<br>‘ * ‘ 可以匹配任意字符串（包括空字符串）。<br>两个字符串完全匹配才算匹配成功。</p><p>说明:</p><ul><li>s 可能为空，且只包含从 a-z 的小写字母。</li><li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 * 。</li></ul><p><strong>Example</strong><br>示例 1:<br>输入:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = "aa"</span><br><span class="line">p = "a"</span><br></pre></td></tr></tbody></table></figure><p>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。</p><p>示例 2:<br>输入:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = "aa"</span><br><span class="line">p = "*"</span><br></pre></td></tr></tbody></table></figure><p>输出: true<br>解释: ‘*’ 可以匹配任意字符串。</p><p>示例 3:<br>输入:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = "cb"</span><br><span class="line">p = "?a"</span><br></pre></td></tr></tbody></table></figure><p>输出: false<br>解释: ‘?’ 可以匹配 ‘c’, 但第二个 ‘a’ 无法匹配 ‘b’。</p><p>示例 4:<br>输入:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = "adceb"</span><br><span class="line">p = "*a*b"</span><br></pre></td></tr></tbody></table></figure><p>输出: true<br>解释: 第一个 ‘<em>‘ 可以匹配空字符串, 第二个 ‘</em>‘ 可以匹配字符串 “dce”.</p><p>示例 5:<br>输入:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = "acdcb"</span><br><span class="line">p = "a*c?b"</span><br></pre></td></tr></tbody></table></figure><p>输出: false<br><strong>Program</strong><br><strong>动态规划</strong><br>设DP[i][j]为s与p的前i，j字符串是否能匹配：<br>（1）s[i]==p[j]或p[j]==’？’, DP[i][j]=DP[i-1][j-1]，即匹配一个字符<br>（2）p[j]==’<em>‘，DP[i][j]=DP[i][j-1]||DP[i-1][j]，即匹配0个或匹配当前s[i]，但是j不减，因为可以匹配多个字符，这里分两种情况：匹配0个或1个，递推过程中可以匹配n个。<br>边界：<br>DP[0][0]=true，两字符串为空，显然；<br>DP[i][0]=false，显然<br>**DP[0][j]，看情况，当前p的前j个字符都为’</em>‘，为true，否则false！**</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m=s.length();</span><br><span class="line">        <span class="keyword">int</span> n=p.length();</span><br><span class="line">        <span class="keyword">bool</span> DP[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="literal">false</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        DP[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){ <span class="comment">//s为空，p的前j子串只有全为'*'才为真</span></span><br><span class="line">            <span class="keyword">if</span>(p[j<span class="number">-1</span>]==<span class="string">'*'</span>) DP[<span class="number">0</span>][j]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==p[j<span class="number">-1</span>]||p[j<span class="number">-1</span>]==<span class="string">'?'</span>) DP[i][j]=DP[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p[j<span class="number">-1</span>]==<span class="string">'*'</span>) DP[i][j]= DP[i][j<span class="number">-1</span>] || DP[i<span class="number">-1</span>][j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[m][n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a>91. 解码方法</h4><p><strong>Description</strong><br>一条包含字母 A-Z 的消息通过以下方式进行了编码：<br>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>给定一个只包含数字的非空字符串，请计算解码方法的总数。<br><strong>Example</strong><br>示例 1:<br>输入: “12”<br>输出: 2<br>解释: 它可以解码为 “AB”（1 2）或者 “L”（12）。</p><p>示例 2:<br>输入: “226”<br>输出: 3<br>解释: 它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。<br><strong>Program</strong><br>计算DP[n]时，<br>①若s[n]满足要求，DP[n]=DP[n-1];否则0;<br>②若s[n-1]与s[n]构成两位数满足条件(9&lt;value&lt;27), DP[n]+=DP[n-2];如果value==0,直接return 0;<br>注意DP[2]是关键！</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'0'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP(n, <span class="number">0</span>);</span><br><span class="line">        DP[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> value=(s[<span class="number">0</span>]-<span class="string">'0'</span>)*<span class="number">10</span>+(s[<span class="number">1</span>]-<span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span>(value==<span class="number">10</span>||value==<span class="number">20</span>) DP[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(value&gt;<span class="number">9</span>&amp;&amp;value&lt;<span class="number">27</span>) DP[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">1</span>]==<span class="string">'0'</span>) DP[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> DP[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++){</span><br><span class="line">            value=(s[i<span class="number">-1</span>]-<span class="string">'0'</span>)*<span class="number">10</span>+(s[i]-<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=<span class="string">'0'</span>) DP[i]=DP[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(value==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(value&gt;<span class="number">9</span>&amp;&amp;value&lt;<span class="number">27</span>) DP[i]+=DP[i<span class="number">-2</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="97-交错字符串"><a href="#97-交错字符串" class="headerlink" title="97. 交错字符串"></a>97. 交错字符串</h4><p><strong>Description</strong><br>给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。<br><strong>Example</strong><br>示例 1:<br>输入: s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbcbcac”<br>输出: true</p><p>示例 2:<br>输入: s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbbaccc”<br>输出: false<br><strong>Program</strong><br><strong>字符DP</strong><br>字符DP老套路，假设DP[i][j]表示s1前i个字符与s2前j个字符能够组成交错序列s3的前i+j个字符，故递推只需考虑s3[i+j-1]是否与s1[i-1]或s2[j-1]相等，<br>$DP[i][j]=(i&gt;0&amp;&amp;DP[i-1][j]&amp;&amp;s1[i-1]==s3[i+j-1])||(j&gt;0&amp;&amp;DP[i][j-1]&amp;&amp;s2[j-1]==s3[i+j-1]);$<br>注意：<br>m+n!=l，长度不等，直接false;<br>边界：DP[0][0]=true；<br>有可能一直是s1或s2的前几个元素与s3匹配，所以DP[m+1][n+1]必须从0开始DP</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m=s1.length(), n=s2.length(), l=s3.length();</span><br><span class="line">        <span class="keyword">if</span>(m+n!=l) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> DP[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="literal">false</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        DP[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++){ <span class="comment">//从0开始，因为可能其中一个为空</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++){</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">//特判</span></span><br><span class="line">                DP[i][j] = (i&gt;<span class="number">0</span>&amp;&amp;DP[i<span class="number">-1</span>][j]&amp;&amp;s1[i<span class="number">-1</span>]==s3[i+j<span class="number">-1</span>])||(j&gt;<span class="number">0</span>&amp;&amp;DP[i][j<span class="number">-1</span>]&amp;&amp;s2[j<span class="number">-1</span>]==s3[i+j<span class="number">-1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[m][n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a>139. 单词拆分</h4><p><strong>Description</strong><br>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。<br>说明：<br>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br><strong>Example</strong><br>示例 1：<br>输入: s = “leetcode”, wordDict = [“leet”, “code”]<br>输出: true<br>解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。</p><p>示例 2：<br>输入: s = “applepenapple”, wordDict = [“apple”, “pen”]<br>输出: true<br>解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。<br> 注意你可以重复使用字典中的单词。</p><p>示例 3：<br>输入: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出: false<br><strong>Program</strong><br>DP[n]=DP[i]&amp;&amp;has(s(i+1, n))</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>{</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; st(wordDict.begin(), wordDict.end());</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; DP(n+<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        DP[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++){</span><br><span class="line">                <span class="keyword">if</span>(DP[j<span class="number">-1</span>]&amp;&amp;st.find(s.substr(j<span class="number">-1</span>, i-j+<span class="number">1</span>))!=st.end()){</span><br><span class="line">                    DP[i]=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>字典树优化</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>{</span></span><br><span class="line">        <span class="keyword">bool</span> isEnd;</span><br><span class="line">        Trie* next[<span class="number">26</span>];</span><br><span class="line">        Trie(){</span><br><span class="line">            isEnd=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) next[i]=<span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertStr</span><span class="params">(Trie* root, <span class="built_in">string</span> str)</span></span>{</span><br><span class="line">        Trie* node=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=str.length()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">int</span> t=str[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[t]==<span class="literal">NULL</span>) node-&gt;next[t]=<span class="keyword">new</span> Trie();</span><br><span class="line">            node=node-&gt;next[t];</span><br><span class="line">        }</span><br><span class="line">        node-&gt;isEnd=<span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; DP(n+<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        Trie* root=<span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span>&amp; str:wordDict) insertStr(root, str);</span><br><span class="line">        DP[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            Trie* node=root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=<span class="number">1</span>;j--){</span><br><span class="line">                <span class="keyword">int</span> t=s[j<span class="number">-1</span>]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;next[t]==<span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">                node=node-&gt;next[t];</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;isEnd) DP[i]=DP[j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(DP[i]) <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="面试题-17-13-恢复空格"><a href="#面试题-17-13-恢复空格" class="headerlink" title="面试题 17.13. 恢复空格"></a>面试题 17.13. 恢复空格</h4><p><strong>Description</strong><br>哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子”I reset the computer. It still didn’t boot!”已经变成了”iresetthecomputeritstilldidntboot”。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。<br>注意：本题相对原题稍作改动，只需返回未识别的字符数<br><strong>Example</strong><br>示例：<br>输入：<br>dictionary = [“looked”,”just”,”like”,”her”,”brother”]<br>sentence = “jesslookedjustliketimherbrother”<br>输出： 7<br>解释： 断句后为”jess looked just like tim her brother”，共7个未识别字符。<br>提示：<br>0 &lt;= len(sentence) &lt;= 1000<br>dictionary中总字符数不超过 150000。<br>你可以认为dictionary和sentence中只包含小写字母。<br><strong>Program</strong><br><strong>字符DP</strong><br>与单词拆分类似，设DP[i]为前i个字符最小未识别数，那么：<br>（1）$j&lt;i$且sentence[j:i]子串能在字典中找到，则DP[i]=min(DP[i],DP[j-1]);<br>（2）否则，DP[i]=DP[i-1]+1，即第i个字符也没有被识别。<br>超时。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">respace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; dictionary, <span class="built_in">string</span> sentence)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(sentence.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=sentence.length();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; st(dictionary.begin(), dictionary.end());</span><br><span class="line">        <span class="keyword">int</span> DP[n];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            DP[i]=<span class="number">1</span>+(i&gt;<span class="number">0</span>?DP[i<span class="number">-1</span>]:<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++){</span><br><span class="line">                <span class="keyword">if</span>(st.find(sentence.substr(j,i-j+<span class="number">1</span>))!=st.end()){</span><br><span class="line">                    <span class="keyword">int</span> t=(j&gt;<span class="number">0</span>)?DP[j<span class="number">-1</span>]:<span class="number">0</span>;</span><br><span class="line">                    DP[i]=min(DP[i], t);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>字典树优化</strong><br>上面方法中，从前往后遍历j可以优化，因为sentence[j:i]这个子串，j递增时，<br>不失一般性，设$j_1&lt;j_2$，则sentence[j_1:i]和sentence[j_2:i]为两个可能子串，如果后者已经不可能为字典内的单词，那么前者就已经不用算了！<br>（1）j从i递减遍历：<br>（2）若[j,i]子串不在字典树中，提前终止；<br>（3）若[j,i]子串在字典树中，DP[i]=min(DP[i],DP[j-1])；</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>{</span></span><br><span class="line">        <span class="keyword">bool</span> isEnd;</span><br><span class="line">        Trie* next[<span class="number">26</span>];</span><br><span class="line">        Trie(){</span><br><span class="line">            isEnd=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) next[i]=<span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertStr</span><span class="params">(Trie* root, <span class="built_in">string</span> str)</span></span>{</span><br><span class="line">        Trie* node=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=str.length()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">int</span> t=str[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[t]==<span class="literal">NULL</span>) node-&gt;next[t]=<span class="keyword">new</span> Trie();</span><br><span class="line">            node=node-&gt;next[t];</span><br><span class="line">        }</span><br><span class="line">        node-&gt;isEnd=<span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">respace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; dictionary, <span class="built_in">string</span> sentence)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(sentence.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=sentence.length();</span><br><span class="line">        Trie* root=<span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span>&amp; str:dictionary) insertStr(root, str); <span class="comment">//建立字典树</span></span><br><span class="line">        <span class="keyword">int</span> DP[n];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            DP[i]=<span class="number">1</span>+(i&gt;<span class="number">0</span>?DP[i<span class="number">-1</span>]:<span class="number">0</span>);</span><br><span class="line">            Trie* node=root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=<span class="number">0</span>;j--){</span><br><span class="line">                <span class="keyword">int</span> t=sentence[j]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;next[t]==<span class="literal">NULL</span>) <span class="keyword">break</span>; <span class="comment">//[j,i]子串已经不再字典中，终止</span></span><br><span class="line">                node=node-&gt;next[t];</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;isEnd) DP[i]=min(DP[i], (j&gt;<span class="number">0</span>?DP[j<span class="number">-1</span>]:<span class="number">0</span>));</span><br><span class="line">                <span class="keyword">if</span>(DP[i]==<span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//0已经最小了，终止</span></span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="467-环绕字符串中唯一的子字符串"><a href="#467-环绕字符串中唯一的子字符串" class="headerlink" title="467. 环绕字符串中唯一的子字符串"></a>467. 环绕字符串中唯一的子字符串</h4><p><strong>Description</strong><br>把字符串 s 看作是“abcdefghijklmnopqrstuvwxyz”的无限环绕字符串，所以 s 看起来是这样的：”…zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd….”.<br>现在我们有了另一个字符串 p 。你需要的是找出 s 中有多少个唯一的 p 的非空子串，尤其是当你的输入是字符串 p ，你需要输出字符串 s 中 p 的不同的非空子串的数目。<br>注意: p 仅由小写的英文字母组成，p 的大小可能超过 10000。<br><strong>Example</strong><br>示例 1:<br>输入: “a”<br>输出: 1<br>解释: 字符串 S 中只有一个”a”子字符。</p><p>示例 2:<br>输入: “cac”<br>输出: 2<br>解释: 字符串 S 中的字符串“cac”只有两个子串“a”、“c”。.<br><strong>Program</strong><br>题目意思就是求字符串p中满足”…zabcd…”顺序的子串个数<br>设DP[i]是以字符p[i]为结尾的字符串最大长度，这是因为较长的以p[i]为结尾的子串串一定包含了较短的子串！不用重复计算！<br>DP[i]=max(DP[i], k)，其中k为满足条件子串长度</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isContinue</span><span class="params">(<span class="keyword">char</span> pre, <span class="keyword">char</span> next)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(pre==<span class="string">'z'</span>) <span class="keyword">return</span> next==<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">return</span> (pre+<span class="number">1</span>) == next;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSubstringInWraproundString</span><span class="params">(<span class="built_in">string</span> p)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p.length();i++){</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;isContinue(p[i<span class="number">-1</span>], p[i])){</span><br><span class="line">                k++;</span><br><span class="line">            }<span class="keyword">else</span> k=<span class="number">1</span>;</span><br><span class="line">            DP[p[i]-<span class="string">'a'</span>] = max(DP[p[i]-<span class="string">'a'</span>], k);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:DP) ans+=x;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="1048-最长字符串链"><a href="#1048-最长字符串链" class="headerlink" title="1048. 最长字符串链"></a>1048. 最长字符串链</h4><p><strong>Description</strong><br>给出一个单词列表，其中每个单词都由小写英文字母组成。<br>如果我们可以在 word1 的任何地方添加一个字母使其变成 word2，那么我们认为 word1 是 word2 的前身。例如，”abc” 是 “abac” 的前身。<br>词链是单词 [word_1, word_2, …, word_k] 组成的序列，k &gt;= 1，其中 word_1 是 word_2 的前身，word_2 是 word_3 的前身，依此类推。<br>从给定单词列表 words 中选择单词组成词链，返回词链的最长可能长度。<br><strong>Example</strong><br>示例：<br>输入：[“a”,”b”,”ba”,”bca”,”bda”,”bdca”]<br>输出：4<br>解释：最长单词链之一为 “a”,”ba”,”bda”,”bdca”。</p><p>提示：<br>1 &lt;= words.length &lt;= 1000<br>1 &lt;= words[i].length &lt;= 16<br>words[i] 仅由小写英文字母组成。<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestStrChain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=words.size();</span><br><span class="line">        sort(words.begin(), words.end(), [](<span class="built_in">string</span> a, <span class="built_in">string</span> b){<span class="keyword">return</span> a.length()&lt;b.length();});<span class="comment">//按长度排序，注意默认排序是字典序排序，例如"abcde"在"abdde"之前</span></span><br><span class="line">        <span class="keyword">int</span> DP[n];</span><br><span class="line">        fill(DP, DP+n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++){</span><br><span class="line">                <span class="keyword">if</span>(words[j].length()!=words[i].length()<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;words[i].length();k++){</span><br><span class="line">                    <span class="built_in">string</span> s=words[i];</span><br><span class="line">                    <span class="built_in">string</span> str=s.erase(k, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(str==words[j]){</span><br><span class="line">                        DP[i]=max(DP[i],DP[j]+<span class="number">1</span>);</span><br><span class="line">                        ans=max(ans, DP[i]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestStrChain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=words.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; DP;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> str:words) DP[str]=<span class="number">1</span>;</span><br><span class="line">        sort(words.begin(), words.end(), [](<span class="built_in">string</span> a, <span class="built_in">string</span> b){<span class="keyword">return</span> a.length()&lt;b.length();});<span class="comment">//按长度排序，注意默认排序是字典序排序，例如"abcde"在"abdde"之前</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;words[i].size();j++){</span><br><span class="line">                <span class="built_in">string</span> s=words[i];</span><br><span class="line">                <span class="built_in">string</span> ss=s.erase(j, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(DP.find(ss)!=DP.end()){</span><br><span class="line">                    DP[words[i]]=max(DP[words[i]], DP[ss]+<span class="number">1</span>);</span><br><span class="line">                    ans=max(ans, DP[words[i]]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="股票系列"><a href="#股票系列" class="headerlink" title="股票系列"></a>股票系列</h3><h4 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h4><p><strong>Description</strong><br>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。<br>注意你不能在买入股票前卖出股票。<br><strong>Example</strong><br>示例 1:<br>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br> 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p><p>示例 2:<br>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> minPrice=INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> maxProfit=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&lt;minPrice){</span><br><span class="line">                minPrice=prices[i];</span><br><span class="line">            }</span><br><span class="line">            maxProfit=max(maxProfit, prices[i]-minPrice);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(prices.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=prices.size();</span><br><span class="line">        <span class="keyword">int</span>** DP=<span class="keyword">new</span> <span class="keyword">int</span>*[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) DP[i]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i<span class="number">-1</span>&lt;<span class="number">0</span>){</span><br><span class="line">                DP[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">                DP[i][<span class="number">1</span>]=-prices[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            DP[i][<span class="number">0</span>]=max(DP[i<span class="number">-1</span>][<span class="number">0</span>], DP[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            DP[i][<span class="number">1</span>]=max(DP[i<span class="number">-1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(prices.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=prices.size();</span><br><span class="line">        <span class="keyword">int</span> dp_i_0=<span class="number">0</span>,dp_i_1=-INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">           dp_i_0=max(dp_i_0, dp_i_1+prices[i]);</span><br><span class="line">           dp_i_1=max(dp_i_1, -prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp_i_0;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a>122. 买卖股票的最佳时机 II</h4><p><strong>Description</strong><br>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br><strong>Example</strong><br>示例 1:<br>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br> 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p><p>示例 2:<br>输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br> 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br> 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p><p>示例 3:<br>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.size();i++){</span><br><span class="line">            result+=max(<span class="number">0</span>, prices[i]-prices[i<span class="number">-1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(prices.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=prices.size();</span><br><span class="line">        <span class="keyword">int</span>** DP=<span class="keyword">new</span> <span class="keyword">int</span>*[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) DP[i]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i<span class="number">-1</span>&lt;<span class="number">0</span>){</span><br><span class="line">                DP[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">                DP[i][<span class="number">1</span>]=-prices[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            DP[i][<span class="number">0</span>]=max(DP[i<span class="number">-1</span>][<span class="number">0</span>], DP[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            DP[i][<span class="number">1</span>]=max(DP[i<span class="number">-1</span>][<span class="number">1</span>], DP[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(prices.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=prices.size();</span><br><span class="line">        <span class="keyword">int</span> dp_i_0=<span class="number">0</span>, dp_i_1=-INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> temp=dp_i_0;</span><br><span class="line">            dp_i_0=max(dp_i_0, dp_i_1+prices[i]);</span><br><span class="line">            dp_i_1=max(dp_i_1, temp-prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp_i_0;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a>123. 买卖股票的最佳时机 III</h4><p><strong>Description</strong><br>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。<br>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br><strong>Example</strong><br>示例 1:<br>输入: [3,3,5,0,0,3,1,4]<br>输出: 6<br>解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br> 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</p><p>示例 2:<br>输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br> 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br> 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p><p>示例 3:<br>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。<br><strong>Progam</strong><br>注意：最多两次交易！可能一次！</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(prices.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=prices.size();</span><br><span class="line">        <span class="keyword">int</span>*** DP=<span class="keyword">new</span> <span class="keyword">int</span>**[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            DP[i]=<span class="keyword">new</span> <span class="keyword">int</span>*[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++) DP[i][j]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++){</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>){</span><br><span class="line">                    DP[i][j][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">                    DP[i][j][<span class="number">1</span>]=-INT_MAX;</span><br><span class="line">                    <span class="keyword">if</span>(j==<span class="number">1</span>)DP[i][j][<span class="number">1</span>]=-prices[i];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>){</span><br><span class="line">                    DP[i][j][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">                    DP[i][j][<span class="number">1</span>]=-INT_MAX;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                DP[i][j][<span class="number">0</span>]=max(DP[i<span class="number">-1</span>][j][<span class="number">0</span>], DP[i<span class="number">-1</span>][j][<span class="number">1</span>]+prices[i]);</span><br><span class="line">                DP[i][j][<span class="number">1</span>]=max(DP[i<span class="number">-1</span>][j][<span class="number">1</span>], DP[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max(DP[n<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>],DP[n<span class="number">-1</span>][<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a>188. 买卖股票的最佳时机 IV</h4><p><strong>Description</strong><br>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。<br>设计一<br>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br><strong>Example</strong><br>示例 1:<br>输入: [2,4,1], k = 2<br>输出: 2<br>解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</p><p>示例 2:<br>输入: [3,2,6,5,0,3], k = 2<br>输出: 7<br>解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。<br> 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit_inf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(prices.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=prices.size();</span><br><span class="line">        <span class="keyword">int</span> dp_i_0=<span class="number">0</span>, dp_i_1=-INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> temp=dp_i_0;</span><br><span class="line">            dp_i_0=max(dp_i_0, dp_i_1+prices[i]);</span><br><span class="line">            dp_i_1=max(dp_i_1, temp-prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp_i_0;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(prices.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=prices.size();</span><br><span class="line">        <span class="keyword">if</span>(k&gt;n/<span class="number">2</span>){</span><br><span class="line">            <span class="keyword">return</span> maxProfit_inf(prices);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span>*** DP=<span class="keyword">new</span> <span class="keyword">int</span>**[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            DP[i]=<span class="keyword">new</span> <span class="keyword">int</span>*[k+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k+<span class="number">1</span>;j++) DP[i][j]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k+<span class="number">1</span>;j++){</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>){</span><br><span class="line">                    DP[i][j][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">                    DP[i][j][<span class="number">1</span>]=-INT_MAX;</span><br><span class="line">                    <span class="keyword">if</span>(j==<span class="number">1</span>) DP[i][j][<span class="number">1</span>]=-prices[i];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>){</span><br><span class="line">                    DP[i][j][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">                    DP[i][j][<span class="number">1</span>]=-INT_MAX;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                DP[i][j][<span class="number">0</span>]=max(DP[i<span class="number">-1</span>][j][<span class="number">0</span>], DP[i<span class="number">-1</span>][j][<span class="number">1</span>]+prices[i]);</span><br><span class="line">                DP[i][j][<span class="number">1</span>]=max(DP[i<span class="number">-1</span>][j][<span class="number">1</span>], DP[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;k+<span class="number">1</span>;j++){</span><br><span class="line">            result=max(result, DP[n<span class="number">-1</span>][j][<span class="number">0</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>买卖股票问题通解</strong><br>很多读者抱怨股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？所以本文拒绝奇技淫巧，而是稳扎稳打，只用一种通用方法解决所用问题，以不变应万变。<br>这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。<br>先随便抽出一道题，看看别人的解法：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> s1=-prices[<span class="number">0</span>],s2=INT_MIN,s3=INT_MIN,s4=INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.size();++i) {            </span><br><span class="line">        s1 = max(s1, -prices[i]);</span><br><span class="line">        s2 = max(s2, s1+prices[i]);</span><br><span class="line">        s3 = max(s3, s2-prices[i]);</span><br><span class="line">        s4 = max(s4, s3+prices[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max(<span class="number">0</span>,s4);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>能看懂吧？会做了吗？不可能的，你看不懂，这才正常。就算你勉强看懂了，下一个问题你还是做不出来。为什么别人能写出这么诡异却又高效的解法呢？因为这类问题是有框架的，但是人家不会告诉你的，因为一旦告诉你，你五分钟就学会了，该算法题就不再神秘，变得不堪一击了。</p><p><strong>本文就来告诉你这个框架，然后带着你一道一道秒杀。</strong><br>这 6 道股票买卖问题是有共性的，我们通过对第四题（限制最大交易次数为 k）的分析一道一道解决。因为第四题是一个最泛化的形式，其他的问题都是这个形式的简化。<br>第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。<br><strong>一、穷举框架</strong><br>首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。<br>递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。<br>而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 择优(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></tbody></table></figure><p>比如说这个问题，每天都有三种「选择」：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k &gt; 0 的前提下操作。</p><p>很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：<br>dp[i][k][0 or 1]<br>0 &lt;= i &lt;= n-1, 1 &lt;= k &lt;= K<br>n 为天数，大 K 为最多交易数<br>此问题共 n × K × 2 种状态，全部穷举就能搞定。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 0 &lt;= i &lt; n:</span><br><span class="line">    for 1 &lt;= k &lt;= K:</span><br><span class="line">        for s in {0, 1}:</span><br><span class="line">            dp[i][k][s] = max(buy, sell, rest)</span><br></pre></td></tr></tbody></table></figure><p>而且我们可以用自然语言描述出每一个状态的含义，比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？<br>我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 dp[n - 1][K][1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。<br>记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。<br><strong>二、状态转移框架</strong><br>现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。<br><img src="/assets/img/algorithm/stock_309.png" alt="image"><br>通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])</span><br><span class="line">              = max(   选择 rest  ,           选择 sell      )</span><br></pre></td></tr></tbody></table></figure><p>解释：今天我没有持有股票，有两种可能：<br>要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；<br>要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</span><br><span class="line">              = max(   选择 rest  ,           选择 buy         )</span><br></pre></td></tr></tbody></table></figure><p>解释：今天我持有着股票，有两种可能：<br>要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；<br>要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。<br>这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。<br>现在，我们已经完成了动态规划中最困难的一步：状态转移方程。如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。不过还差最后一点点，就是定义 base case，即最简单的情况。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dp[-1][k][0] = 0</span><br><span class="line">解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。</span><br><span class="line">dp[-1][k][1] = -infinity</span><br><span class="line">解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。</span><br><span class="line">dp[i][0][0] = 0</span><br><span class="line">解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。</span><br><span class="line">dp[i][0][1] = -infinity</span><br><span class="line">解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。</span><br><span class="line">把上面的状态转移方程总结一下：</span><br><span class="line"></span><br><span class="line">base case：</span><br><span class="line">dp[-1][k][0] = dp[i][0][0] = 0</span><br><span class="line">dp[-1][k][1] = dp[i][0][1] = -infinity</span><br><span class="line"></span><br><span class="line">状态转移方程：</span><br><span class="line">dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])</span><br><span class="line">dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</span><br><span class="line">读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。</span><br></pre></td></tr></tbody></table></figure><p><strong>三、秒杀题目</strong><br><strong>第一题，k = 1</strong><br>直接套状态转移方程，根据 base case，可以做一些化简：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i])</span><br><span class="line">            = max(dp[i-1][1][1], -prices[i])</span><br></pre></td></tr></tbody></table></figure><p>解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。<br>现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。<br>可以进行进一步化简去掉所有 k：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span><br><span class="line">dp[i][1] = max(dp[i-1][1], -prices[i])</span><br></pre></td></tr></tbody></table></figure><p>直接写出代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = prices.length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">    dp[i][<span class="number">0</span>] = Math.max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = Math.max(dp[i<span class="number">-1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br></pre></td></tr></tbody></table></figure><p>显然 i = 0 时 dp[i-1] 是不合法的。这是因为我们没有对 i 的 base case 进行处理。可以这样处理：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; n; i++) {</span><br><span class="line">    if (i - 1 == -1) {</span><br><span class="line">        dp[i][0] = 0;</span><br><span class="line">        // 解释：</span><br><span class="line">        //   dp[i][0]</span><br><span class="line">        // = max(dp[-1][0], dp[-1][1] + prices[i])</span><br><span class="line">        // = max(0, -infinity + prices[i]) = 0</span><br><span class="line">        dp[i][1] = -prices[i];</span><br><span class="line">        //解释：</span><br><span class="line">        //   dp[i][1]</span><br><span class="line">        // = max(dp[-1][1], dp[-1][0] - prices[i])</span><br><span class="line">        // = max(-infinity, 0 - prices[i])</span><br><span class="line">        // = -prices[i]</span><br><span class="line">        continue;</span><br><span class="line">    }</span><br><span class="line">    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);</span><br><span class="line">    dp[i][1] = Math.max(dp[i-1][1], -prices[i]);</span><br><span class="line">}</span><br><span class="line">return dp[n - 1][0];</span><br></pre></td></tr></tbody></table></figure><p>第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1):</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// k == 1</span><br><span class="line">int maxProfit_k_1(int[] prices) {</span><br><span class="line">    int n = prices.length;</span><br><span class="line">    // base case: dp[-1][0] = 0, dp[-1][1] = -infinity</span><br><span class="line">    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) {</span><br><span class="line">        // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        // dp[i][1] = max(dp[i-1][1], -prices[i])</span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, -prices[i]);</span><br><span class="line">    }</span><br><span class="line">    return dp_i_0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 O(1) 的解法。</p><p><strong>第二题，k = +infinity</strong></p><p>如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])</span><br><span class="line">dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</span><br><span class="line">            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])</span><br></pre></td></tr></tbody></table></figure><p>我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：<br>$$dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])<br>dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])$$<br>直接翻译成代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_inf</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, temp - prices[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>第三题，k = +infinity with cooldown</strong><br>每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可：<br>$$dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])<br>dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])$$<br>解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。<br>翻译成代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_with_cool</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> dp_pre_0 = <span class="number">0</span>; <span class="comment">// 代表 dp[i-2][0]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]);</span><br><span class="line">        dp_pre_0 = temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>第四题，k = +infinity with fee</strong><br>每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span><br><span class="line">dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)</span><br></pre></td></tr></tbody></table></figure><p>解释：相当于买入股票的价格升高了。<br>在第一个式子里减也是一样的，相当于卖出股票的价格减小了。<br>直接翻译成代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_with_fee</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>第五题，k = 2</strong><br>k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。<br>这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。<br>原始的动态转移方程，没有可化简的地方</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])</span><br><span class="line">dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</span><br></pre></td></tr></tbody></table></figure><p>按照之前的代码，我们可能想当然这样写代码（错误的）：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">if</span> (i - <span class="number">1</span> == <span class="number">-1</span>) { <span class="comment">/* 处理一下 base case*/</span> }</span><br><span class="line">    dp[i][k][<span class="number">0</span>] = Math.max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][k][<span class="number">1</span>] = Math.max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][k][<span class="number">0</span>];</span><br></pre></td></tr></tbody></table></figure><p>为什么错误？我这不是照着状态转移方程写的吗？</p><p>还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max_k = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][max_k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = max_k; k &gt;= <span class="number">1</span>; k--) {</span><br><span class="line">        <span class="keyword">if</span> (i - <span class="number">1</span> == <span class="number">-1</span>) { <span class="comment">/*处理 base case */</span> }</span><br><span class="line">        dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 穷举了 n × max_k × 2 个状态，正确。</span></span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][max_k][<span class="number">0</span>];</span><br><span class="line">···</span><br><span class="line">如果你不理解，可以返回第一点「穷举框架」重新阅读体会一下。</span><br><span class="line">这里 k 取值范围比较小，所以可以不用 <span class="keyword">for</span> 循环，直接把 k = <span class="number">1</span> 和 <span class="number">2</span> 的情况手动列举出来也可以：</span><br></pre></td></tr></tbody></table></figure><p>dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])<br>dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])<br>dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])<br>dp[i][1][1] = max(dp[i-1][1][1], -prices[i])</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">```cpp</span><br><span class="line">int maxProfit_k_2(int[] prices) {</span><br><span class="line">    int dp_i10 = 0, dp_i11 = Integer.MIN_VALUE;</span><br><span class="line">    int dp_i20 = 0, dp_i21 = Integer.MIN_VALUE;</span><br><span class="line">    for (int price : prices) {</span><br><span class="line">        dp_i20 = Math.max(dp_i20, dp_i21 + price);</span><br><span class="line">        dp_i21 = Math.max(dp_i21, dp_i10 - price);</span><br><span class="line">        dp_i10 = Math.max(dp_i10, dp_i11 + price);</span><br><span class="line">        dp_i11 = Math.max(dp_i11, -price);</span><br><span class="line">    }</span><br><span class="line">    return dp_i20;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 a, b, c, d。这样当别人看到你的代码时就会一头雾水，大惊失色，不得不对你肃然起敬。<br><strong>第六题，k = any integer</strong><br>有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？<br>一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。<br>直接把之前的代码重用：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_any</span><span class="params">(<span class="keyword">int</span> max_k, <span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">if</span> (max_k &gt; n / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> maxProfit_k_inf(prices);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][max_k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = max_k; k &gt;= <span class="number">1</span>; k--) {</span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">1</span> == <span class="number">-1</span>) { <span class="comment">/* 处理 base case */</span> }</span><br><span class="line">            dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);     </span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][max_k][<span class="number">0</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>至此，6 道题目通过一个状态转移方程全部解决。<br><strong>四、最后总结</strong><br>本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。<br>关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？<br>具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」，怕不怕？这个大实话一说，立刻显得你高人一等，名利双收有没有。<br>所以，大家不要被各种高大上的名词吓到，再多的困难问题，奇技淫巧，也不过是基本套路的不断升级组合产生的。只要把住算法的底层原理，即可举一反三，逐个击破。<br>买卖股票的最佳时机<br>买卖股票的最佳时机 II<br>买卖股票的最佳时机 III<br>买卖股票的最佳时机 IV<br>最佳买卖股票时机含冷冻期<br>买卖股票的最佳时机含手续费</p><h4 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a>309. 最佳买卖股票时机含冷冻期</h4><p><strong>Description</strong><br>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​<br>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:<br>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br><strong>Example</strong><br>示例:<br>输入: [1,2,3,0,2]<br>输出: 3<br>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(prices.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=prices.size();</span><br><span class="line">        <span class="keyword">int</span>** DP=<span class="keyword">new</span> <span class="keyword">int</span>*[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) DP[i]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>){</span><br><span class="line">                DP[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">                DP[i][<span class="number">1</span>]=-prices[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>){</span><br><span class="line">                DP[i][<span class="number">0</span>]=max(DP[i<span class="number">-1</span>][<span class="number">0</span>], DP[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">                DP[i][<span class="number">1</span>]=max(DP[i<span class="number">-1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            DP[i][<span class="number">0</span>]=max(DP[i<span class="number">-1</span>][<span class="number">0</span>], DP[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            DP[i][<span class="number">1</span>]=max(DP[i<span class="number">-1</span>][<span class="number">1</span>], DP[i<span class="number">-2</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a>714. 买卖股票的最佳时机含手续费</h4><p><strong>Description</strong><br>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。<br>你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。<br>返回获得利润的最大值。<br><strong>Example</strong><br>示例 1:<br>输入: prices = [1, 3, 2, 8, 4, 9], fee = 2<br>输出: 8<br>解释: 能够达到的最大利润:<br>在此处买入 prices[0] = 1<br>在此处卖出 prices[3] = 8<br>在此处买入 prices[4] = 4<br>在此处卖出 prices[5] = 9<br>总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.<br>注意:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 &lt; prices.length &lt;= 50000.</span><br><span class="line">0 &lt; prices[i] &lt; 50000.</span><br><span class="line">0 &lt;= fee &lt; 50000.</span><br></pre></td></tr></tbody></table></figure><p><strong>Progam</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(prices.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=prices.size();</span><br><span class="line">        <span class="keyword">int</span>** DP=<span class="keyword">new</span> <span class="keyword">int</span>*[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) DP[i]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>){</span><br><span class="line">                DP[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">                DP[i][<span class="number">1</span>]=-prices[i]-fee;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            DP[i][<span class="number">0</span>]=max(DP[i<span class="number">-1</span>][<span class="number">0</span>], DP[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            DP[i][<span class="number">1</span>]=max(DP[i<span class="number">-1</span>][<span class="number">1</span>], DP[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i]-fee);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(prices.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=prices.size();</span><br><span class="line">        <span class="keyword">int</span> dp_i_0, dp_i_1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>){</span><br><span class="line">                dp_i_0=<span class="number">0</span>;</span><br><span class="line">                dp_i_1=-prices[i]-fee;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">int</span> tmp=dp_i_0;</span><br><span class="line">            dp_i_0=max(dp_i_0, dp_i_1+prices[i]);</span><br><span class="line">            dp_i_1=max(dp_i_1, tmp-prices[i]-fee);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp_i_0;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a>剑指 Offer 63. 股票的最大利润</h4><p><strong>Description</strong><br>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？<br><strong>Example</strong><br>示例 1:<br>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br> 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p><p>示例 2:<br>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><p>限制：<br>0 &lt;= 数组长度 &lt;= 10^5<br><strong>Program</strong><br><strong>动规</strong><br>画出价格折线图，找出当前最低价格，求差值最大即可</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(prices.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=prices.size();</span><br><span class="line">        <span class="keyword">int</span> minPrice=INT_MAX, ans=-INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            minPrice=min(minPrice, prices[i]);</span><br><span class="line">            ans=max(ans, prices[i]-minPrice);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="面试题-17-16-按摩师"><a href="#面试题-17-16-按摩师" class="headerlink" title="面试题 17.16. 按摩师"></a>面试题 17.16. 按摩师</h4><p><strong>Description</strong><br>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p><p>注意：本题相对原题稍作改动<br><strong>Example</strong><br>示例 1：<br>输入： [1,2,3,1]<br>输出： 4<br>解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。</p><p>示例 2：<br>输入： [2,7,9,3,1]<br>输出： 12<br>解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。</p><p>示例 3：<br>输入： [2,1,4,5,3,1,1,3]<br>输出： 12<br>解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。<br><strong>Program</strong><br><strong>思路</strong><br>设DP[i][0]为不接第i个预约，DP[i][1]为接第i个预约，状态转移方程：<br>$DP[i][0]=max(DP[i-1][0],DP[i-1][1])$<br>$DP[i][1]=D[i-1][0]+nums[i]$<br>时间复杂度：$O(n)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> DP[n][<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, inf ,<span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            DP[i][<span class="number">0</span>]=(i&gt;<span class="number">0</span>)?max(DP[i<span class="number">-1</span>][<span class="number">0</span>],DP[i<span class="number">-1</span>][<span class="number">1</span>]):<span class="number">0</span>;</span><br><span class="line">            DP[i][<span class="number">1</span>]=(i&gt;<span class="number">0</span>?DP[i<span class="number">-1</span>][<span class="number">0</span>]:<span class="number">0</span>)+nums[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max(DP[n<span class="number">-1</span>][<span class="number">0</span>], DP[n<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="丑数系列"><a href="#丑数系列" class="headerlink" title="丑数系列"></a>丑数系列</h3><h4 id="264-丑数-II"><a href="#264-丑数-II" class="headerlink" title="264. 丑数 II"></a>264. 丑数 II</h4><p><strong>Description</strong><br>编写一个程序，找出第 n 个丑数。<br>丑数就是只包含质因数 2, 3, 5 的正整数。<br><strong>Example</strong><br>示例:<br>输入: n = 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。<br>说明:<br>1 是丑数。<br>n 不超过1690。<br><strong>Program</strong><br>丑数：$X=2^m<em>3^n</em>5^t$，所以先整除2，余数整除3，最后余数整除5，如果整除结果为1，则为丑数；反之不是。<br>从DP[0]开始，每个数都必须乘以2,3,5各一次加入DP数组，问题使从小到大插入，所以每次去三个乘积最小的结果加入DP数组，那么必然存在重复计算，没得办法，问题在于比如DP[0] * 2在第一次三乘积最小，DP[0]后续不用乘以2了，所以2的指针后移，而3和5的指针还是指向DP[0]，所以三指针！</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP(n,<span class="number">0</span>);</span><br><span class="line">        DP[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2, p3, p5;</span><br><span class="line">        p2=p3=p5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> mVal=min(DP[p2]*<span class="number">2</span>, min(DP[p3]*<span class="number">3</span>, DP[p5]*<span class="number">5</span>));</span><br><span class="line">            <span class="keyword">if</span>(mVal==DP[p2]*<span class="number">2</span>) p2++;</span><br><span class="line">            <span class="keyword">if</span>(mVal==DP[p3]*<span class="number">3</span>) p3++;</span><br><span class="line">            <span class="keyword">if</span>(mVal==DP[p5]*<span class="number">5</span>) p5++;</span><br><span class="line">            DP[i]=mVal;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="313-超级丑数"><a href="#313-超级丑数" class="headerlink" title="313. 超级丑数"></a>313. 超级丑数</h4><p><strong>Description</strong><br>编写一段程序来查找第 n 个超级丑数。<br>超级丑数是指其所有质因数都是长度为 k 的质数列表 primes 中的正整数。<br><strong>Example</strong><br>示例:<br>输入: n = 12, primes = [2,7,13,19]<br>输出: 32<br>解释: 给定长度为 4 的质数列表 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。<br>说明:<br>1 是任何给定 primes 的超级丑数。<br> 给定 primes 中的数字以升序排列。<br>0 &lt; k ≤ 100, 0 &lt; n ≤ 106, 0 &lt; primes[i] &lt; 1000 。<br>第 n 个超级丑数确保在 32 位有符整数范围内。<br><strong>Program</strong><br><strong>堆</strong><br>与之前的<a href="https://leetcode-cn.com/problems/ugly-number-ii/" target="_blank" rel="noopener">丑数II</a>类似，不同的这里是一组素数<br>这里根据标签堆的做法；<br>此版本效率不高</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> idx;</span><br><span class="line">        Node(<span class="keyword">int</span> _val, <span class="keyword">int</span> _idx):val(_val), idx(_idx){}</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; other) <span class="keyword">const</span>{</span><br><span class="line">            <span class="keyword">return</span> val&gt;other.val;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthSuperUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; primes)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> k=primes.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index(k, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n, <span class="number">-1</span>);</span><br><span class="line">        res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            priority_queue&lt;Node&gt; pq;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++){</span><br><span class="line">                pq.push(Node(primes[j]*res[index[j]], j)); <span class="comment">//入堆</span></span><br><span class="line">            }  </span><br><span class="line">            Node node=pq.top();</span><br><span class="line">            res[i]=node.val;</span><br><span class="line">            index[node.idx]++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++){</span><br><span class="line">                <span class="keyword">if</span>(primes[j]*res[index[j]]==node.val) index[j]++; <span class="comment">//已选出当前最小值res[i]，如果其他primes[j]*res[index[j]]为res[i]，则会出现重复，故后移</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res[n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>直接数组</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=INT_MAX;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthSuperUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; primes)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> k=primes.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index(k, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n, inf);</span><br><span class="line">        res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++) res[i]=min(res[i], primes[j]*res[index[j]]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++){</span><br><span class="line">                <span class="keyword">if</span>(primes[j]*res[index[j]]==res[i]) index[j]++; <span class="comment">//已选出当前最小值res[i]，如果其他primes[j]*res[index[j]]为res[i]，则会出现重复，故后移</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res[n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a>343. 整数拆分</h4><p><strong>Description</strong><br>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。<br><strong>Example</strong><br>示例 1:<br>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1。</p><p>示例 2:<br>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。<br>说明: 你可以假设 n 不小于 2 且不大于 58。<br><strong>Program</strong><br>i&gt;3时，DP[i]&gt;=i，递推公式DP[i]=max(DP[i], DP[j]*(i-j))，但是注意到题目要求至少两个正整数之和，那么主要到1~3这三个数题目所求乘积小于自身，那么后面比这几个数大的数，在运用这个递推公式的时候回出现问题，所以要特判！！</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        DP[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n+<span class="number">1</span>;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++){</span><br><span class="line">                <span class="keyword">int</span> x=(j&lt;=<span class="number">3</span>)?j:DP[j];</span><br><span class="line">                DP[i]=max(DP[i], x*(i-j));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>见面试题14-I题解</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">3</span>) <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mod=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> res=n%mod;</span><br><span class="line">        <span class="keyword">int</span> count=n/mod;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(res==<span class="number">2</span>) ans=(<span class="keyword">int</span>)<span class="built_in">pow</span>(mod,count)*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(res==<span class="number">1</span>) ans=(<span class="keyword">int</span>)<span class="built_in">pow</span>(mod, count<span class="number">-1</span>)*<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">else</span> ans=(<span class="keyword">int</span>)<span class="built_in">pow</span>(mod, count);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="面试题14-I-剪绳子"><a href="#面试题14-I-剪绳子" class="headerlink" title="面试题14- I. 剪绳子"></a>面试题14- I. 剪绳子</h4><p><strong>Description</strong><br>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…<em>k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。<br>*</em>Example**<br>示例 1：<br>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1</p><p>示例 2:<br>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</p><p>提示：<br>2 &lt;= n &lt;= 58<br><strong>Program</strong><br><img src="/assets/img/algorithm/14_I_01.png" alt="image"><br><img src="/assets/img/algorithm/14_I_02.png" alt="image"><br><img src="/assets/img/algorithm/14_I_03.png" alt="image"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">3</span>) <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mod=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> res=n%mod;</span><br><span class="line">        <span class="keyword">int</span> count=n/mod;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(res==<span class="number">2</span>) ans=(<span class="keyword">int</span>)<span class="built_in">pow</span>(mod,count)*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(res==<span class="number">1</span>) ans=(<span class="keyword">int</span>)<span class="built_in">pow</span>(mod, count<span class="number">-1</span>)*<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">else</span> ans=(<span class="keyword">int</span>)<span class="built_in">pow</span>(mod, count);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="面试题14-II-剪绳子-II"><a href="#面试题14-II-剪绳子-II" class="headerlink" title="面试题14- II. 剪绳子 II"></a>面试题14- II. 剪绳子 II</h4><p><strong>Description</strong><br>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m] 。请问 $k[0] * k[1] * … * k[m]$ 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。<br>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。<br><strong>Example</strong><br>示例 1：<br>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1</p><p>示例 2:<br>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</p><p>提示：<br>2 &lt;= n &lt;= 1000<br><strong>Program</strong><br>动态规划不行，数值太大了。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> mod, <span class="keyword">int</span> count, <span class="keyword">int</span> res)</span></span>{</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(res==<span class="number">1</span>) count--;</span><br><span class="line">        <span class="keyword">while</span>(count&gt;<span class="number">0</span>){</span><br><span class="line">            ans=ans*mod%MOD;count--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(res==<span class="number">1</span>) ans=ans*<span class="number">4</span>%MOD;</span><br><span class="line">        <span class="keyword">if</span>(res==<span class="number">2</span>) ans=ans*<span class="number">2</span>%MOD;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">3</span>) <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mod=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> res=n%mod;</span><br><span class="line">        <span class="keyword">int</span> count=n/mod;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(res==<span class="number">2</span>) ans=cal(mod, count, res);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(res==<span class="number">1</span>) ans=cal(mod, count, res);</span><br><span class="line">        <span class="keyword">else</span> ans=cal(mod, count, res);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="优化DP"><a href="#优化DP" class="headerlink" title="优化DP"></a>优化DP</h3><h4 id="5631-跳跃游戏-VI"><a href="#5631-跳跃游戏-VI" class="headerlink" title="5631. 跳跃游戏 VI"></a>5631. 跳跃游戏 VI</h4><p><strong>Description</strong><br>给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。<br>一开始你在下标 0 处。每一步，你最多可以往前跳 k 步，但你不能跳出数组的边界。也就是说，你可以从下标 i 跳到 [i + 1， min(n - 1, i + k)] 包含 两个端点的任意位置。<br>你的目标是到达数组最后一个位置（下标为 n - 1 ），你的 得分 为经过的所有数字之和。<br>请你返回你能得到的 最大得分 。<br><strong>Example</strong><br>示例 1：<br>输入：nums = [1,-1,-2,4,-7,3], k = 2<br>输出：7<br>解释：你可以选择子序列 [1,-1,4,3] （上面加粗的数字），和为 7 。</p><p>示例 2：<br>输入：nums = [10,-5,-2,4,0,3], k = 3<br>输出：17<br>解释：你可以选择子序列 [10,4,3] （上面加粗数字），和为 17 。</p><p>示例 3：<br>输入：nums = [1,-5,-20,4,-1,3,-6,-3], k = 2<br>输出：0</p><p>提示：<br>$1 &lt;= nums.length, k &lt;= 10^5$<br>$-10^4 &lt;= nums[i] &lt;= 10^4$<br><strong>Program</strong><br>设DP[i]=max(DP[j])+nums[i]，其中i-k&lt;=j&lt;i，时间复杂度：$O(n^2)$<br>优化如下<br><strong>优先队列</strong><br>max(DP[j])通过优先队列查找，且窗口外的dp值全部抛出<br>时间复杂度：$O(n\log{n})$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxResult</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">        pq.push({nums[<span class="number">0</span>], <span class="number">0</span>});</span><br><span class="line">        <span class="keyword">int</span> ans=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">while</span>(i-pq.top().second&gt;k) pq.pop(); <span class="comment">//超过窗口k的全部剔除</span></span><br><span class="line">            ans=pq.top().first+nums[i];</span><br><span class="line">            pq.push({ans, i});</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>单调队列</strong><br>窗口内的dp值保持单调递减，因为对于i-k&lt;=j1,j2&lt;i来说，如果dp[j1]&lt;dp[j2]，那么j1就应当永久剔除，因为不影响后续结果；<br>时间复杂度：$O(n)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxResult</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">deque</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q; <span class="comment">//单调递减队列，p.first即dp[i]的值单调减</span></span><br><span class="line">        q.emplace_back(nums[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> ans=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">while</span>(i-q.front().second&gt;k) q.pop_front(); <span class="comment">//超过窗口范围</span></span><br><span class="line">            ans=q.front().first+nums[i];</span><br><span class="line">            <span class="keyword">while</span>(!q.empty()&amp;&amp;q.back().first&lt;ans) q.pop_back(); <span class="comment">//维持单调性</span></span><br><span class="line">            q.emplace_back(ans, i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a>279. 完全平方数</h4><p><strong>Description</strong><br>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。<br><strong>Example</strong><br>示例 1:<br>输入: n = 12<br>输出: 3<br>解释: 12 = 4 + 4 + 4.</p><p>示例 2:<br>输入: n = 13<br>输出: 2<br>解释: 13 = 4 + 9.<br><strong>Program</strong><br>初始化$DP[i]=i$表示最多i个1组成,$DP[i]=min(DP[i], DP[i-j<em>j]+1), if(j</em>j&lt;=i)$为状态转移方程</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        DP[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;i++){</span><br><span class="line">            DP[i]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;i&gt;=j*j;j++){</span><br><span class="line">                DP[i]=min(DP[i], DP[i-j*j]+<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a>338. 比特位计数</h4><p><strong>Description</strong><br>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。<br><strong>Example</strong><br>示例 1:<br>输入: 2<br>输出: [0,1,1]</p><p>示例 2:<br>输入: 5<br>输出: [0,1,1,2,1,2]<br>进阶:</p><p>给出时间复杂度为O(n<em>sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？<br>要求算法的空间复杂度为O(n)。<br>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 <code>__builtin_popcount</code>）来执行此操作。<br>*</em>Program**<br><strong>位运算+DP</strong><br>思路类似动态规划<br>偶数时，比如二进制 1010 其1的个数和它除以2的是一样的，即和 101 带1个数一致<br>奇数时，加一即可，可以得出<br>$res[i] = res[i &gt;&gt; 1] + (i &amp; 1)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> num) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result(num+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++){</span><br><span class="line">            result[i]=result[i&gt;&gt;<span class="number">1</span>]+(i%<span class="number">2</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="357-计算各个位数不同的数字个数"><a href="#357-计算各个位数不同的数字个数" class="headerlink" title="357. 计算各个位数不同的数字个数"></a>357. 计算各个位数不同的数字个数</h4><p><strong>Description</strong><br>给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 $0 ≤ x &lt; 10^n$ 。<br><strong>Example</strong><br>示例:<br>输入: 2<br>输出: 91<br>解释: 答案应为除去 11,22,33,44,55,66,77,88,99 外，在 [0,100) 区间内的所有数字。<br>。<br><strong>Program</strong><br>$DP[n]=DP[n-1]+9 * C_9^n * A_n^n=DP[n-1]+9*A_9^{(n-1)};$<br>区间$[0,10^n)=[0,1)+[1,10)+…+[10^{(n-1)}, 10^n)$，即不同的个数由各x位不同数字个数之和</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP(<span class="number">11</span>);</span><br><span class="line">        DP[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++){</span><br><span class="line">            DP[i]=DP[i<span class="number">-1</span>]+<span class="number">9</span>*pre;</span><br><span class="line">            pre=pre*(<span class="number">10</span>-i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">10</span>) <span class="keyword">return</span> DP[n];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> DP[<span class="number">10</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="368-最大整除子集"><a href="#368-最大整除子集" class="headerlink" title="368. 最大整除子集"></a>368. 最大整除子集</h4><p><strong>Description</strong><br>给出一个由无重复的正整数组成的集合，找出其中最大的整除子集，子集中任意一对 (Si，Sj) 都要满足：Si % Sj = 0 或 Sj % Si = 0。<br>如果有多个目标子集，返回其中任何一个均可。<br><strong>Example</strong><br>示例 1:<br>输入: [1,2,3]<br>输出: [1,2] (当然, [1,3] 也正确)</p><p>示例 2:<br>输入: [1,2,4,8]<br>输出: [1,2,4,8]<br><strong>Program</strong><br><strong>思路</strong><br>（1）取模的性质，如果x能够整除一个整除子集中的最大值，那么其可加入该子集构成新的整除子集；<br>（2）先对nums排序，设dp[i]为以a[i]为整除子集最大值且为结尾的最大个数；<br>（3）状态转移方程：dp[i]=max(dp[j])+1<br>（4）由于需要保留子集结果，则构造结构体存储dp[i]的值以及以a[i]为结尾升序排列的整除子集的前一个元素下标father；<br>（5）dp后，根据father可以获取整个结果子集！<br>时间复杂度：$O(n^2)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> father; <span class="comment">//以a[i]为结尾升序的整除子集的前一个值的索引</span></span><br><span class="line">        <span class="keyword">int</span> ans;  <span class="comment">//以a[i]为结尾的整除子集的元素个数</span></span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> _father, <span class="keyword">int</span> _ans, <span class="keyword">int</span> _value){</span><br><span class="line">            father=_father;</span><br><span class="line">            ans=_ans;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; largestDivisibleSubset(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        sort(nums.begin(), nums.end()); <span class="comment">//升序排列，方便后面dp</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; dp(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){ <span class="comment">//初始化</span></span><br><span class="line">            dp[i].father=<span class="number">-1</span>;</span><br><span class="line">            dp[i].ans=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> resCnt=<span class="number">0</span>, resIdx=<span class="number">-1</span>; <span class="comment">//最大整除子集元素个数及其索引（尾元素）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){  <span class="comment">//dp</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++){</span><br><span class="line">                <span class="keyword">if</span>(nums[i]%nums[j]==<span class="number">0</span>){</span><br><span class="line">                    <span class="keyword">if</span>(dp[j].ans+<span class="number">1</span>&gt;dp[i].ans){</span><br><span class="line">                        dp[i].ans=dp[j].ans+<span class="number">1</span>;</span><br><span class="line">                        dp[i].father=j;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(resCnt&lt;dp[i].ans){ <span class="comment">//更新</span></span><br><span class="line">                resCnt=dp[i].ans;</span><br><span class="line">                resIdx=i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res; <span class="comment">//计算结果子集</span></span><br><span class="line">        <span class="keyword">while</span>(resIdx!=<span class="number">-1</span>){</span><br><span class="line">            res.push_back(nums[resIdx]);</span><br><span class="line">            resIdx=dp[resIdx].father;</span><br><span class="line">        }</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; largestDivisibleSubset(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; DP;</span><br><span class="line">        DP.resize(n);</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        DP[<span class="number">0</span>]=<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>,nums[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++){</span><br><span class="line">                <span class="keyword">int</span> nTmp=DP[j].size();</span><br><span class="line">                <span class="keyword">int</span> x=DP[j][nTmp<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(nums[i]%x==<span class="number">0</span>&amp;&amp;nTmp+<span class="number">1</span>&gt;DP[i].size()){</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(DP[j].begin(), DP[j].end());</span><br><span class="line">                    vec.push_back(nums[i]);</span><br><span class="line">                    DP[i]=vec;</span><br><span class="line">                    <span class="keyword">if</span>(DP[idx].size()&lt;DP[i].size()) idx=i;</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span>(DP[i].size()==<span class="number">0</span>){</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">1</span>, nums[i]);</span><br><span class="line">                    DP[i]=vec;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[idx];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a>376. 摆动序列</h4><p><strong>Description</strong><br>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。<br>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。<br>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。<br><strong>Example</strong><br>示例 1:<br>输入: [1,7,4,9,2,5]<br>输出: 6<br>解释: 整个序列均为摆动序列。</p><p>示例 2:<br>输入: [1,17,5,10,13,15,10,5,16,8]<br>输出: 7<br>解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</p><p>示例 3:<br>输入: [1,2,3,4,5,6,7,8,9]<br>输出: 2<br>进阶:<br>你能否用$O(n)$时间复杂度完成此题?<br><strong>Program</strong><br>①$DP[i]=max(DP[i], DP[j]+1)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;DP(n, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; flag(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++){</span><br><span class="line">                <span class="keyword">if</span>(flag[j]&gt;=<span class="number">0</span>&amp;&amp;nums[i]&lt;nums[j]&amp;&amp;DP[i]&lt;DP[j]+<span class="number">1</span>){</span><br><span class="line">                    DP[i]=DP[j]+<span class="number">1</span>;</span><br><span class="line">                    flag[i]=<span class="number">-1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(flag[j]&lt;=<span class="number">0</span>&amp;&amp;nums[i]&gt;nums[j]&amp;&amp;DP[i]&lt;DP[j]+<span class="number">1</span>){</span><br><span class="line">                    DP[i]=DP[j]+<span class="number">1</span>;</span><br><span class="line">                    flag[i]=<span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                result=max(result, DP[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>②令$up[i]$表示以i为结尾的上升摆动序列，$down[i]$表示以i为结尾的下降摆动序列</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; up(n, <span class="number">0</span>), down(n ,<span class="number">0</span>);</span><br><span class="line">        up[<span class="number">0</span>]=down[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[i<span class="number">-1</span>]){</span><br><span class="line">                up[i]=down[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                down[i]=down[i<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[i<span class="number">-1</span>]){</span><br><span class="line">                down[i]=up[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                up[i]=up[i<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i<span class="number">-1</span>]){</span><br><span class="line">                down[i]=down[i<span class="number">-1</span>];</span><br><span class="line">                up[i]=up[i<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max(up[n<span class="number">-1</span>], down[n<span class="number">-1</span>]);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>③空间优化</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> up, down;</span><br><span class="line">        up=down=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[i<span class="number">-1</span>]){</span><br><span class="line">                up=down+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[i<span class="number">-1</span>]){</span><br><span class="line">                down=up+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max(up, down);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="413-等差数列划分"><a href="#413-等差数列划分" class="headerlink" title="413. 等差数列划分"></a>413. 等差数列划分</h4><p><strong>Description</strong><br>如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。<br>例如，以下数列为等差数列:<br>1, 3, 5, 7, 9<br>7, 7, 7, 7<br>3, -1, -5, -9<br>以下数列不是等差数列。<br>1, 1, 2, 5, 7<br>数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 $0&lt;=P&lt;Q&lt;N$ 。<br>如果满足以下条件，则称子数组(P, Q)为等差数组：<br>元素 A[P], A[p + 1], …, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。<br>函数要返回数组 A 中所有为等差数组的子数组个数。<br><strong>Example</strong><br>示例:<br>A = [1, 2, 3, 4]<br>返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。<br><strong>Program</strong><br>花里胡哨看不懂题目，题目就是求连续子序列满足等差数列的个数<br><strong>①暴力</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+<span class="number">2</span>&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">if</span>(j==i+<span class="number">1</span>){</span><br><span class="line">                    tmp=A[j]-A[j<span class="number">-1</span>];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(A[j]-A[j<span class="number">-1</span>]!=tmp) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> ans++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>②DP</strong><br>DP[i]表示以i为结尾的等差数列长度</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(DP[i<span class="number">-1</span>]==<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(A[i]-A[i<span class="number">-1</span>]==A[i<span class="number">-1</span>]-A[i<span class="number">-2</span>]) DP[i]=<span class="number">3</span>;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(A[i]-A[i<span class="number">-1</span>]==A[i<span class="number">-1</span>]-A[i<span class="number">-2</span>]) DP[i]=DP[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(DP[i]&gt;<span class="number">0</span>) ans+=DP[i]<span class="number">-2</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>DP[i]表示以i为结尾的等差子序列个数</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(A[i]-A[i<span class="number">-1</span>]==A[i<span class="number">-1</span>]-A[i<span class="number">-2</span>]) DP[i]=DP[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            ans+=DP[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>优化</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(A[i]-A[i<span class="number">-1</span>]==A[i<span class="number">-1</span>]-A[i<span class="number">-2</span>]) dp=dp+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp=<span class="number">0</span>;</span><br><span class="line">            ans+=dp;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="523-连续的子数组和"><a href="#523-连续的子数组和" class="headerlink" title="523. 连续的子数组和"></a>523. 连续的子数组和</h4><p><strong>Description</strong><br>给定一个包含非负数的数组和一个目标整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n<em>k，其中 n 也是一个整数。<br>*</em>Example**<br>示例 1:<br>输入: [23,2,4,6,7], k = 6<br>输出: True<br>解释: [2,4] 是一个大小为 2 的子数组，并且和为 6。<br>示例 2:</p><p>输入: [23,2,6,4,7], k = 6<br>输出: True<br>解释: [23,2,6,4,7]是大小为 5 的子数组，并且和为 42。<br>说明:<br>数组的长度不会超过10,000。<br>你可以认为所有数字总和在 32 位有符号整数范围内。<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;DP(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            DP[i]=sum;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">0</span>&amp;&amp;DP[i]==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(k!=<span class="number">0</span>&amp;&amp;DP[i]%k==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i<span class="number">-1</span>;j++){</span><br><span class="line">                <span class="keyword">if</span>(k==<span class="number">0</span>&amp;&amp;(DP[i]-DP[j])==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(k!=<span class="number">0</span>&amp;&amp;(DP[i]-DP[j])%k==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>用Hash存当前$sum[i]%k$，如果i和j位置的余数$sum[i]%k==sum[j]%k$说明$i+1…j$为所求子数组，因为设i位置和为$m*k+rem$,j位置和为$n*k+rem$，其中$rem=sum[i]%k$，那么$i+1…j$的和为$n*k+rem-m*k-rem=(m-n)*k$！！得证！！！</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m; <span class="comment">//m[rem]=i</span></span><br><span class="line">        m[<span class="number">0</span>]=<span class="number">-1</span>; <span class="comment">//精髓！i~j为所求子数组！当然要包括第一个数，因为sum%k==0，k==0时也满足</span></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(k!=<span class="number">0</span>) sum%=k;</span><br><span class="line">            <span class="keyword">if</span>(m.find(sum)!=m.end()){</span><br><span class="line">                <span class="keyword">if</span>(i-m[sum]&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//i和j位置的sum的余数都相同，所以i+1~j为所求子数组</span></span><br><span class="line">            }<span class="keyword">else</span> m[sum]=i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="646-最长数对链"><a href="#646-最长数对链" class="headerlink" title="646. 最长数对链"></a>646. 最长数对链</h4><p>给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。<br>现在，我们定义一种跟随关系，当且仅当 b &lt; c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。<br>给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。<br><strong>Example</strong><br>示例 :<br>输入: [[1,2], [2,3], [3,4]]<br>输出: 2<br>解释: 最长的数对链是 [1,2] -&gt; [3,4]<br>注意：<br>给出数对的个数在 [1, 1000] 范围内。<br><strong>Program</strong><br><strong>①DP</strong><br>DP[i]表示以i为结尾的最长数对链个数，DP[i]=max(DP[i], DP[j]+1) if pairs[i][0]&gt;pairs[j][1]，当然这里应当对pairs按照第一元素升序排列。<br>时间复杂度:$O(N^{2})$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(pairs.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=pairs.size();</span><br><span class="line">        sort(pairs.begin(), pairs.end(), cmp);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++){</span><br><span class="line">                <span class="keyword">if</span>(pairs[i][<span class="number">0</span>]&gt;pairs[j][<span class="number">1</span>]) DP[i]=max(DP[i], DP[j]+<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            ans=max(ans, DP[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>②贪心</strong><br>将pairs按第二个元素升序排列，贪心的思路就是选择第二个元素较小的数对，之后进行比较，时间复杂度:$O(N\log{N})$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>]&lt;b[<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(pairs.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=pairs.size();</span><br><span class="line">        sort(pairs.begin(), pairs.end(), cmp);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur=-inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(cur&lt;pairs[i][<span class="number">0</span>]){</span><br><span class="line">                cur=pairs[i][<span class="number">1</span>];</span><br><span class="line">                ans++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a>718. 最长重复子数组</h4><p><strong>Description</strong><br>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。<br><strong>Example</strong><br>示例 1:<br>输入:<br>A: [1,2,3,2,1]<br>B: [3,2,1,4,7]<br>输出: 3<br>解释:<br>长度最长的公共子数组是 [3, 2, 1]。<br>说明:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= len(A), len(B) &lt;= 1000</span><br><span class="line">0 &lt;= A[i], B[i] &lt; 100</span><br></pre></td></tr></tbody></table></figure><p><strong>Program</strong><br>子数组需要连续，DP[i][j]=DP[i-1][j-1]+1, if A[i]==B[i] else 0.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m=A.size();</span><br><span class="line">        <span class="keyword">int</span> n=B.size();</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>||n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; DP(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line">                <span class="keyword">if</span>(A[i<span class="number">-1</span>]==B[j<span class="number">-1</span>]) DP[i][j]=DP[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                ans=max(DP[i][j], ans);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="740-删除与获得点数"><a href="#740-删除与获得点数" class="headerlink" title="740. 删除与获得点数"></a>740. 删除与获得点数</h4><p><strong>Description</strong><br>给定一个整数数组 nums ，你可以对它进行一些操作。<br>每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。<br>开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。<br><strong>Example</strong><br>示例 1:<br>输入: nums = [3, 4, 2]<br>输出: 6<br>解释:<br>删除 4 来获得 4 个点数，因此 3 也被删除。<br>之后，删除 2 来获得 2 个点数。总共获得 6 个点数。</p><p>示例 2:<br>输入: nums = [2, 2, 3, 3, 3, 4]<br>输出: 9<br>解释:<br>删除 3 来获得 3 个点数，接着要删除两个 2 和 4 。<br>之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。<br>总共获得 9 个点数。<br>注意:<br>nums的长度最大为20000。<br>每个整数nums[i]的大小都在[1, 10000]范围内。<br><strong>Program</strong><br><strong>①暴力</strong><br>果断超时</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> sum)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()){</span><br><span class="line">            ans=max(ans, sum);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(m[nums[i]]!=<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">int</span> tmp1=m[nums[i]<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">int</span> tmp2=m[nums[i]+<span class="number">1</span>];</span><br><span class="line">                m[nums[i]<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">                m[nums[i]+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">                m[nums[i]]--;</span><br><span class="line">                dfs(nums, sum+nums[i]);</span><br><span class="line">                m[nums[i]]++;</span><br><span class="line">                m[nums[i]<span class="number">-1</span>]=tmp1;</span><br><span class="line">                m[nums[i]+<span class="number">1</span>]=tmp2;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10001</span>;i++) <span class="keyword">if</span>(m[i]!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteAndEarn</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10001</span>;i++) m[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums) m[x]++;</span><br><span class="line">        dfs(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>打家劫舍DP</strong><br>设DP[x]为数组[1…x]进行x的选择与否的点数，则DP[x]=max(DP[x-2]+m[x]*x,DP[x-1]);</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteAndEarn</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums) mx=max(mx, x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=mx;i++) m[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums) m[x]++;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP(mx+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        DP[<span class="number">1</span>]=m[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=mx;i++){</span><br><span class="line">            DP[i]=max(DP[i<span class="number">-2</span>]+m[i]*i, DP[i<span class="number">-1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[mx];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="790-多米诺和托米诺平铺"><a href="#790-多米诺和托米诺平铺" class="headerlink" title="790. 多米诺和托米诺平铺"></a>790. 多米诺和托米诺平铺</h4><p><strong>Description</strong><br>有两种形状的瓷砖：一种是 2x1 的多米诺形，另一种是形如 “L” 的托米诺形。两种形状都可以旋转。<br>XX &lt;- 多米诺<br>XX &lt;- “L” 托米诺<br>X<br>给定 N 的值，有多少种方法可以平铺 2 x N 的面板？返回值 mod 10^9 + 7。<br>（平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。）<br><strong>Example</strong><br>示例:<br>输入: 3<br>输出: 5<br>解释:<br>下面列出了五种不同的方法，不同字母代表不同瓷砖：<br>XYZ XXZ XYY XXY XYY<br>XYZ YYZ XZZ XYY XXY<br>提示：<br>N的范围是 [1, 1000]<br><strong>Program</strong><br><img src="/assets/img/algorithm/790.png" alt="image"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTilings</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; DP(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">        DP[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        DP[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        DP[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">        DP[<span class="number">3</span>]=<span class="number">5</span>;</span><br><span class="line">        DP.resize(N+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=N;i++){</span><br><span class="line">            DP[i]=(DP[i<span class="number">-1</span>]*<span class="number">2</span>%mod+DP[i<span class="number">-3</span>])%mod;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[N];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="801-使序列递增的最小交换次数"><a href="#801-使序列递增的最小交换次数" class="headerlink" title="801. 使序列递增的最小交换次数"></a>801. 使序列递增的最小交换次数</h4><p><strong>Description</strong><br>我们有两个长度相等且不为空的整型数组 A 和 B 。<br>我们可以交换 A[i] 和 B[i] 的元素。注意这两个元素在各自的序列中应该处于相同的位置。<br>在交换过一些元素之后，数组 A 和 B 都应该是严格递增的（数组严格递增的条件仅为A[0] &lt; A[1] &lt; A[2] &lt; … &lt; A[A.length - 1]）。<br>给定数组 A 和 B ，请返回使得两个数组均保持严格递增状态的最小交换次数。假设给定的输入总是有效的。<br><strong>Example</strong><br>示例:<br>输入: A = [1,3,5,4], B = [1,2,3,7]<br>输出: 1<br>解释:<br>交换 A[3] 和 B[3] 后，两个数组如下:<br>A = [1, 3, 5, 7] ， B = [1, 2, 3, 4]<br>两个数组均为严格递增的。<br>注意:<br>A, B 两个数组的长度总是相等的，且长度的范围为 [1, 1000]。<br>A[i], B[i] 均为 [0, 2000]区间内的整数。<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 解题思路：</span></span><br><span class="line"><span class="comment">  * 其实这道题并没有想象中那么难，只是因为题目对的描述有一些地方不到位，导致在求解过程中不能正确理解题意，做不出来。</span></span><br><span class="line"><span class="comment">  * 题目说到，我们*只可以交换两个数组同一个索引位置i*，最终要使得两个数组都呈现递增，随后题目说到假设输入总是有效的</span></span><br><span class="line"><span class="comment">  * 这句话的意思是说，题目的输入总是至少存在一种方法可以使两个数组变成递增数组，不存在如下的数组：</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *  A :  4 3</span></span><br><span class="line"><span class="comment">  *  B :  1 2</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *  上述的输入无论怎么样尝试，按照题目的方法是没办法将其转化成一个两个递增数组的，既然题目说了输入都是有效的那必然是不存在</span></span><br><span class="line"><span class="comment">  *  上面的输入的。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *  A: a1,a2,a3,a4...an</span></span><br><span class="line"><span class="comment">  *  B: b1.b2.b3,b4...bn</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *  其实我们可以根据上面的描述知道，对于任意一个位置i，必然有A[i] &gt; A[i-1] || A[i] &gt; B[i-1]</span></span><br><span class="line"><span class="comment">  *  可以简单证明一下 如果i位置有A[i] &lt;= A[i-1] &amp;&amp; A[i] &lt;= B[i-1]由于我们只能在同一个索引两个数组</span></span><br><span class="line"><span class="comment">  *  对应位置进行交换，那么可以看出A[i] &lt;= A[i-1] &amp;&amp; A[i] &lt;= B[i-1]时，无论怎么换在i位置都不能满足</span></span><br><span class="line"><span class="comment">  *  形成递增数组的要求，所以我们之前的假设成立。同理上面的公式对于B也成立，即B[i] &gt; B[i-1] || B[i] &gt; A[i-1]。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *  组合A,B的情况，合乎题意的无外乎两种 1. A[i] &gt; A[i-1] &amp;&amp; B[i] &gt; B[i-1] 2. B[i] &gt; A[i-1] &amp;&amp; A[i] &gt; B[i-1]</span></span><br><span class="line"><span class="comment">  *  对于A[i] &gt; A[i-1] &amp;&amp; B[i] &gt; A[i-1] 和 A[i] &gt; B[i-1] &amp;&amp; B[i] &gt; B[i-1]  都是一个问题 拿第一个举例，</span></span><br><span class="line"><span class="comment">  *  对于B[i-1]的情况我们无从知晓，这就导致了，没法确定一定在交换后可以形成递增序列，而题目又说输入一定是有效的</span></span><br><span class="line"><span class="comment">  *  那无外乎A[i]&gt;A[i-1]&gt;B[i-1] 或者 A[i] &gt; B[i-1] &gt; A[i-1] 而这又退化成了我们列举的两种情况，综上只需要讨论</span></span><br><span class="line"><span class="comment">  *  我们列举的两种情况即可。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *  对于某个索引i，如果满足A[i] &gt; A[i-1] &amp;&amp; B[i] &gt; B[i-1] 就认为在i位置时，是满足递增的要求的。</span></span><br><span class="line"><span class="comment">  *  对于某个索引i，如果满足A[i] &gt; B[i-1] &amp;&amp; B[i] &gt; A[i-1] 就认为需要进行交换才可以满足递增的要求。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *  在考虑时，每一次我们都只需要考虑当前位置是否可以和他的前面一个位置构成严格递增，针对每一个位置如此考虑最终我们会得到一个</span></span><br><span class="line"><span class="comment">  *  整个数组都是严格递增。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *  在考虑每一个位置时，需要计算当前位置进行交换使当前位置达到递增的代价和不交换达到递增的代价和不交换使当前位置达到递增的代价。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *  我们在某个位置上可能的序列有两种针对A[i] &gt; A[i - 1] &amp;&amp; B[i] &gt; B[i - 1]这种序列</span></span><br><span class="line"><span class="comment">  *  在该位置i上不交换的使得两数组递增的代价为：dp[0][i] = Math.min(dp[0][i], dp[0][i-1])，因为保持就好不用动就已经满足了递增要求</span></span><br><span class="line"><span class="comment">  *  在该位置上交换使得数组递增的代价为dp[1][i] = Math.min(dp[1][i], dp[1][i-1] + 1)，那么需要一起动这样才能保持递增的要求。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *  对于i位置序列为A[i] &gt; B[i-1] &amp;&amp; B[i] &gt; A[i-1]时</span></span><br><span class="line"><span class="comment">  *  如果该位置不交换，使得两数组递增的代价为（思路就是i不换，就让i-1换，换完自然就满足两数组都递增了）dp[0][i] = Math.min(dp[0][i], dp[1][i-1]);</span></span><br><span class="line"><span class="comment">  *  对于i位置交换，使得两数组递增的代价为（思路就是i换，那么i-1就不要动，换完就满足了两数组都递增）：dp[1][i] = Math.min(dp[1][i], dp[0][i-1] + 1)</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *  我们可以看到对于每一个位置都有两种方法使其呈现递增，那么最终的结果就是两者中的最小值。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSwap</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>{</span><br><span class="line">     <span class="keyword">int</span> len = A.length;</span><br><span class="line">     <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][len];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> inner[] : dp) {</span><br><span class="line">         Arrays.fill(inner, Integer.MAX_VALUE);</span><br><span class="line">     }</span><br><span class="line">     <span class="comment">//0 donate A[i-1] not swap 1 donate A[i-1] has swapped</span></span><br><span class="line">     dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">     dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) {</span><br><span class="line">         <span class="keyword">if</span> (A[i] &gt; A[i - <span class="number">1</span>] &amp;&amp; B[i] &gt; B[i - <span class="number">1</span>]) {</span><br><span class="line">             dp[<span class="number">0</span>][i] = Math.min(dp[<span class="number">0</span>][i], dp[<span class="number">0</span>][i<span class="number">-1</span>]);</span><br><span class="line">             dp[<span class="number">1</span>][i] = Math.min(dp[<span class="number">1</span>][i], dp[<span class="number">1</span>][i<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">         }</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(A[i] &gt; B[i<span class="number">-1</span>] &amp;&amp; B[i] &gt; A[i<span class="number">-1</span>]){</span><br><span class="line">             dp[<span class="number">0</span>][i] = Math.min(dp[<span class="number">0</span>][i], dp[<span class="number">1</span>][i<span class="number">-1</span>]);</span><br><span class="line">             dp[<span class="number">1</span>][i] = Math.min(dp[<span class="number">1</span>][i], dp[<span class="number">0</span>][i<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">         }</span><br><span class="line"></span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">return</span> Math.min(dp[<span class="number">0</span>][len - <span class="number">1</span>], dp[<span class="number">1</span>][len - <span class="number">1</span>]);</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="keyword">int</span> noChange=<span class="number">0</span>,change=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> noChange2=INF,change2=INF;</span><br><span class="line">            <span class="comment">//两个条件可能同时成立</span></span><br><span class="line">            <span class="keyword">if</span>(A[i<span class="number">-1</span>]&lt;A[i]&amp;&amp;B[i<span class="number">-1</span>]&lt;B[i]){</span><br><span class="line">                noChange2=min(noChange, noChange2); <span class="comment">//i位置不交换，i-1也不交换</span></span><br><span class="line">                change2=min(change2, change+<span class="number">1</span>);  <span class="comment">//i位置交换，那么i-1必交换</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(A[i<span class="number">-1</span>]&lt;B[i]&amp;&amp;B[i<span class="number">-1</span>]&lt;A[i]){  </span><br><span class="line">                noChange2=min(noChange2, change); <span class="comment">//i位置不交换，那么i-1必交换</span></span><br><span class="line">                change2=min(change2, noChange+<span class="number">1</span>); <span class="comment">//i位置交换，则i-1不交换</span></span><br><span class="line">            }</span><br><span class="line">            noChange=noChange2;</span><br><span class="line">            change=change2;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> min(noChange, change);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="813-最大平均值和的分组"><a href="#813-最大平均值和的分组" class="headerlink" title="813. 最大平均值和的分组"></a>813. 最大平均值和的分组</h4><p><strong>Description</strong><br>我们将给定的数组 A 分成 K 个相邻的非空子数组 ，我们的分数由每个子数组内的平均值的总和构成。计算我们所能得到的最大分数是多少。<br>注意我们必须使用 A 数组中的每一个数进行分组，并且分数不一定需要是整数。<br><strong>Example</strong><br>示例:<br>输入:<br>A = [9,1,2,3,9]<br>K = 3<br>输出: 20<br>解释:<br>A 的最优分组是[9], [1, 2, 3], [9]. 得到的分数是 9 + (1 + 2 + 3) / 3 + 9 = 20.<br>我们也可以把 A 分成[9, 1], [2], [3, 9].<br>这样的分组得到的分数为 5 + 2 + 6 = 13, 但不是最大值.<br>说明:<br>1 &lt;= A.length &lt;= 100.<br>1 &lt;= A[i] &lt;= 10000.<br>1 &lt;= K &lt;= A.length.<br>答案误差在 10^-6 内被视为是正确的。<br><strong>Program</strong><br>设DP[i]<a href="i从0开始，k从1开始">k</a>为将前i+1个元素分成k部分的最大均值和。<br>递推公式：$DP[i][k]=max(DP[j-1][k-1]+(preSum[i]-preSum[j-1])/(i-j+1)), j=0,…,i$<br>i+1&lt;k，DP[i][k]=0，i+1个元素分成k个部分，只有i+1大于等于k时才可能。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">largestSumOfAverages</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="keyword">double</span> DP[n][K+<span class="number">1</span>],preSum[n];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="built_in">memset</span>(preSum, <span class="number">0</span>, <span class="keyword">sizeof</span>(preSum));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            preSum[i]=A[i];</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>) preSum[i]+=preSum[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=K&amp;&amp;k&lt;=i+<span class="number">1</span>;k++){</span><br><span class="line">                <span class="keyword">if</span>(k==<span class="number">1</span>) {DP[i][k]=preSum[i]/(i+<span class="number">1</span>);<span class="keyword">continue</span>;} <span class="comment">//k==1时，只能全部分给这一份</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=k<span class="number">-1</span>;j&lt;=i;j++){ <span class="comment">//分成k分，那么0~j-1必须能够分成k-1分，即j&gt;=k-1</span></span><br><span class="line">                    DP[i][k]=max(DP[i][k], (preSum[i]-preSum[j<span class="number">-1</span>])/(i-j+<span class="number">1</span>) + DP[j<span class="number">-1</span>][k<span class="number">-1</span>]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n<span class="number">-1</span>][K];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="845-数组中的最长山脉"><a href="#845-数组中的最长山脉" class="headerlink" title="845. 数组中的最长山脉"></a>845. 数组中的最长山脉</h4><p><strong>Description</strong><br>我们把数组 A 中符合下列属性的任意连续子数组 B 称为 “山脉”：<br>$B.length &gt;= 3$<br>存在 $0 &lt; i &lt; B.length - 1$ 使得 $B[0] &lt; B[1] &lt; … B[i-1] &lt; B[i] &gt; B[i+1] &gt; … &gt; B[B.length - 1]$<br>（注意：B 可以是 A 的任意子数组，包括整个数组 A。）<br>给出一个整数数组 A，返回最长 “山脉” 的长度。<br>如果不含有 “山脉” 则返回 0。</p><p>示例 1：<br>输入：[2,1,4,7,3,2,5]<br>输出：5<br>解释：最长的 “山脉” 是 [1,4,7,3,2]，长度为 5。</p><p>示例 2：<br>输入：[2,2,2]<br>输出：0<br>解释：不含 “山脉”。</p><p>提示：<br>0 &lt;= A.length &lt;= 10000<br>0 &lt;= A[i] &lt;= 10000<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestMountain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n, <span class="number">0</span>), right(n, <span class="number">0</span>); <span class="comment">//记录i的左边和右边比i小的连续元素个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(A[i<span class="number">-1</span>]&lt;A[i]) left[i]+=left[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;A[i+<span class="number">1</span>]) right[i]+=right[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> mx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(left[i]&gt;<span class="number">0</span>&amp;&amp;right[i]&gt;<span class="number">0</span>)mx=max(mx, <span class="number">1</span>+left[i]+right[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> mx;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="935-骑士拨号器"><a href="#935-骑士拨号器" class="headerlink" title="935. 骑士拨号器"></a>935. 骑士拨号器</h4><p><strong>Description</strong><br>国际象棋中的骑士可以按下图所示进行移动：<br><img src="/assets/img/algorithm/935_example_01.png" alt="image">)<img src="/assets/img/algorithm/935_example_02.png" alt="image"><br>这一次，我们将 “骑士” 放在电话拨号盘的任意数字键（如上图所示）上，接下来，骑士将会跳 N-1 步。每一步必须是从一个数字键跳到另一个数字键。<br>每当它落在一个键上（包括骑士的初始位置），都会拨出键所对应的数字，总共按下 N 位数字。<br>你能用这种方式拨出多少个不同的号码？<br>因为答案可能很大，所以输出答案模 10^9 + 7。<br><strong>Example</strong><br>示例 1：<br>输入：1<br>输出：10</p><p>示例 2：<br>输入：2<br>输出：20</p><p>示例 3：<br>输入：3<br>输出：46</p><p>提示：<br>1 &lt;= N &lt;= 5000<br><strong>Program</strong><br>设DP[n][j]为第n步拨键j的总数。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; steps={</span><br><span class="line">        {<span class="number">4</span>,<span class="number">6</span>},</span><br><span class="line">        {<span class="number">6</span>,<span class="number">8</span>},</span><br><span class="line">        {<span class="number">7</span>,<span class="number">9</span>},</span><br><span class="line">        {<span class="number">4</span>,<span class="number">8</span>},</span><br><span class="line">        {<span class="number">0</span>,<span class="number">3</span>,<span class="number">9</span>},</span><br><span class="line">        {},</span><br><span class="line">        {<span class="number">0</span>,<span class="number">1</span>,<span class="number">7</span>},</span><br><span class="line">        {<span class="number">2</span>,<span class="number">6</span>},</span><br><span class="line">        {<span class="number">1</span>,<span class="number">3</span>},</span><br><span class="line">        {<span class="number">2</span>,<span class="number">4</span>}</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">knightDialer</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> DP[N+<span class="number">1</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++){</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">1</span>){</span><br><span class="line">                    DP[i][j]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;steps[j].size();k++){</span><br><span class="line">                    DP[i][j]+=DP[i<span class="number">-1</span>][steps[j][k]];</span><br><span class="line">                    DP[i][j]%=MOD;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++) ans=(ans+DP[N][i])%MOD;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>空间优化</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; steps={</span><br><span class="line">        {<span class="number">4</span>,<span class="number">6</span>},</span><br><span class="line">        {<span class="number">6</span>,<span class="number">8</span>},</span><br><span class="line">        {<span class="number">7</span>,<span class="number">9</span>},</span><br><span class="line">        {<span class="number">4</span>,<span class="number">8</span>},</span><br><span class="line">        {<span class="number">0</span>,<span class="number">3</span>,<span class="number">9</span>},</span><br><span class="line">        {},</span><br><span class="line">        {<span class="number">0</span>,<span class="number">1</span>,<span class="number">7</span>},</span><br><span class="line">        {<span class="number">2</span>,<span class="number">6</span>},</span><br><span class="line">        {<span class="number">1</span>,<span class="number">3</span>},</span><br><span class="line">        {<span class="number">2</span>,<span class="number">4</span>}</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">knightDialer</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> tmpDp[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">10</span>];</span><br><span class="line">        fill(dp, dp+<span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">        fill(tmpDp, tmpDp+<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;steps[j].size();k++){</span><br><span class="line">                    tmpDp[j]+=dp[steps[j][k]];</span><br><span class="line">                    tmpDp[j]%=MOD;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">9</span>;k++){dp[k]=tmpDp[k];tmpDp[k]=<span class="number">0</span>;}<span class="comment">//tmpDp记得每次初始化</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++) ans=(ans+dp[i])%MOD;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="978-最长湍流子数组"><a href="#978-最长湍流子数组" class="headerlink" title="978. 最长湍流子数组"></a>978. 最长湍流子数组</h4><p><strong>Description</strong><br>当 $A$ 的子数组 $A[i], A[i+1], …, A[j]$ 满足下列条件时，我们称其为湍流子数组：<br>若 $i &lt;= k &lt; j$，当 $k$ 为奇数时， $A[k] &gt; A[k+1]$，且当 $k$ 为偶数时，$A[k] &lt; A[k+1]$；<br>或 若 $i &lt;= k &lt; j$，当 $k$ 为偶数时，$A[k] &gt; A[k+1]$ ，且当 $k$ 为奇数时， $A[k] &lt; A[k+1]$。<br>也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。<br>返回 A 的最大湍流子数组的长度。<br><strong>Example</strong><br>示例 1：<br>输入：[9,4,2,10,7,8,8,1,9]<br>输出：5<br>解释：(A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; A[5])</p><p>示例 2：<br>输入：[4,8,12,16]<br>输出：2</p><p>示例 3：<br>输入：[100]<br>输出：1</p><p>提示：<br>1 &lt;= A.length &lt;= 40000<br>0 &lt;= A[i] &lt;= 10^9<br><strong>Program</strong><br><strong>动态规划</strong><br>按题意分两种情况，这里为了方便判断后一个位置是否为奇数或者偶数，所以要相应改变：<br>设DP1[i]为以i为结尾的满足第一种条件的序列，DP2[i]为以i为结尾的满足第二种条件的序列，则有：<br>(1)如果i为奇数且A[i-1]&lt;A[i]，或者i为偶数A[i-1]&gt;A[i]，则DP1[i]=DP1[i-1]+1,否则DP1[1]=1； //自身<br>(2)如果i为奇数且A[i-1]&gt;A[i],或者i为偶数A[i-1]&lt;A[i]，则DP2[i]=DP1[i-1]+1,否则DP2][i]=1;</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxTurbulenceSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP1(n, <span class="number">1</span>), DP2(n, <span class="number">1</span>); <span class="comment">//第一种序列，第二种序列</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>((i%<span class="number">2</span>==<span class="number">1</span>&amp;&amp;A[i<span class="number">-1</span>]&lt;A[i])||(i%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;A[i<span class="number">-1</span>]&gt;A[i])){</span><br><span class="line">                DP1[i]=DP1[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>((i%<span class="number">2</span>==<span class="number">1</span>&amp;&amp;A[i<span class="number">-1</span>]&gt;A[i])||(i%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;A[i<span class="number">-1</span>]&lt;A[i])){</span><br><span class="line">                DP2[i]=DP2[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            ans=max(ans, DP1[i]);</span><br><span class="line">            ans=max(ans, DP2[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>空间优化</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxTurbulenceSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="keyword">int</span> dp1=<span class="number">1</span>, dp2=<span class="number">1</span>; <span class="comment">//第一种序列，第二种序列</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>((i%<span class="number">2</span>==<span class="number">1</span>&amp;&amp;A[i<span class="number">-1</span>]&lt;A[i])||(i%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;A[i<span class="number">-1</span>]&gt;A[i])){</span><br><span class="line">                dp1+=<span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span> dp1=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>((i%<span class="number">2</span>==<span class="number">1</span>&amp;&amp;A[i<span class="number">-1</span>]&gt;A[i])||(i%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;A[i<span class="number">-1</span>]&lt;A[i])){</span><br><span class="line">                dp2+=<span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span> dp2=<span class="number">1</span>;</span><br><span class="line">            ans=max(ans, dp1);</span><br><span class="line">            ans=max(ans, dp2);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="1191-K-次串联后最大子数组之和"><a href="#1191-K-次串联后最大子数组之和" class="headerlink" title="1191. K 次串联后最大子数组之和"></a>1191. K 次串联后最大子数组之和</h4><p><strong>Description</strong><br>给你一个整数数组 arr 和一个整数 k。<br>首先，我们要对该数组进行修改，即把原数组 arr 重复 k 次。<br>举个例子，如果 arr = [1, 2] 且 k = 3，那么修改后的数组就是 [1, 2, 1, 2, 1, 2]。<br>然后，请你返回修改后的数组中的最大的子数组之和。<br>注意，子数组长度可以是 0，在这种情况下它的总和也是 0。<br>由于 结果可能会很大，所以需要 模（mod） 10^9 + 7 后再返回。<br><strong>Example</strong><br>示例 1：<br>输入：arr = [1,2], k = 3<br>输出：9</p><p>示例 2：<br>输入：arr = [1,-2,1], k = 5<br>输出：2</p><p>示例 3：<br>输入：arr = [-1,-2], k = 7<br>输出：0</p><p>提示：<br>1 &lt;= arr.length &lt;= 10^5<br>1 &lt;= k &lt;= 10^5<br>-10^4 &lt;= arr[i] &lt;= 10^4<br><strong>Program</strong><br>三种情况如下图所示，前两种好理解，只需返回对应的结果就行。<br>关键是第三种情况：<br>根据最大连续子数组之和的DP[i]=max(DP[i-1]+A[i],A[i])，可以知道当一段序列和大于0时，一定可以相连！<br>那么此时的结果为k-2个数组总和+2个数组中的最大DP值（注意此时2个数组中的最大DP值一定是与k-2个数组相连组成的最大子数组，因为若单个数组总和大于0，那么一定连接了整个数组，其次如果单个数组的后缀和使得整体和大于0，那么最后的结果肯定是包含单个数组的后缀+k-2个全数组+单个数组的前缀！这里单个数组的前缀后缀由两个数组的DP值决定）<br>例如:<br>-1,-2,4,5 | … | -1,-2,4,5<br>4,5,-1,-2|…|4,5,-1,-2<br>简单来说，<br>①单个数组和s大于0，直观来说k个数组都放在结果数组里和更大，但是最大的还得看两个单独数组的DP值组成的前后缀！如上面两个例子，结果都是从第一个4到最后一个5结束，但是分别不包含前面的-1，-2和最后的-1，-2！<br>②单个数组和s小于0（等于0没必要，抵消了，例如-1,-2,1,2），那么根据最大连续子数组之和的DP过程来看肯定会中断，如图第二种情况！即结果肯定在最多两个数组的DP结果产生。<br><img src="/assets/img/algorithm/1191.png" alt="image"><br>根据DP递推公式，只有前一项DP[i-1]+A[i]大于等于0时才能连续！<br><strong>第一种情况成立的条件，</strong></p><ul><li>考虑两个单独数组，第一个数组和第二个数组都有这一段<strong>最大子数组</strong>，那么第一个最大子数组的下一个位置的绝对值一定比该最大子数组的和大，且为负数！（中断了！）</li><li>两个最大子数组之间当然也可能存在连续子数组但不是最大子数组！那么这之间所有可能的子数组（如果有）肯定不连续既然各个子数组不连续，那么相邻两个子数组之间肯定有个负数绝对值大于前一个子数组之和！</li><li>而两个单独数组的最大子数组之间刚好又构成一个单独数组！根据分析，这个新的单独数组上的所有子数组（包括最大子数组），既然不连续，中断，一定有若干个负数绝对值大于这些子数组之和！</li><li>即该单独数组的和小于0！</li></ul><p><strong>第二种情况成立条件：</strong></p><ul><li>两个单独数组组成的最大子数组要想成立，这个最大子数组一定不会完全等于单独数组，也就是说由单独数组的后缀+前缀构成，<strong>而且不等价于单独数组，肯定元素比单独子数组个数少！。</strong></li><li>那么首先该最大子数组前面单独数组剩余部分的子数组（如果有），因为各个数组不连续，那么必然每个子数组后都有一个负数且绝对值比对应子数组之和大！</li><li>其次，该最大子数组后面，也就是第二个单独数组，对应最大子数组起始元素前一个位置（从最大子数组头元素到此元素刚好构成一个单独数组），这一段，最大子数组后的一个元素是负数且绝对值比最大子数组和大！这个元素之后到最大子数组起始元素前，如果有若干子数组，则每个子数组后必存在一个负数绝对值比对应子数组之和大！因为各个子数组不连续，中断！</li><li>即该单独数组之和小于0！（由上面分析，从最大子数组头元素到构成单独数组的最后一个元素这一段，每个子数组后都有个负数绝对值比该子数组和大！）</li></ul><p><strong>第三种情况成立条件：</strong></p><ul><li>这里刚好解释下为什么第二种情况最大子数组不等价于单独子数组且元素个数更少，如果最大子数组末尾元素超过了后一个单独数组对应最大数组头元素，也就是说最大子数组覆盖了整个单独数组，那么表明单独数组之和大于等于0！</li><li>如果单独数组之和大于等于0，那么必定后面一直连续到最后一个单独数组！也就是第三种情况了！</li><li>很明显此时分为三部分，<strong>单独数组的后缀+k-2个全数组+单独数组前缀</strong><br>特殊情况：<br>单独数组之和等于0！这个时候没必要连续到最后一个单独数组！因为中间这部分总和为0，最多只需求两个单独数组的最大子数组就可以了！<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">    <span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kConcatenationMaxSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        ll s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>&amp; x:arr) s+=x;</span><br><span class="line">        ll dp=<span class="number">0</span>;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>&amp; x:arr){</span><br><span class="line">            dp = dp + x&gt;x?dp+x:x;</span><br><span class="line">            ans = ans&gt;dp?ans:dp;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>&amp; x:arr){</span><br><span class="line">            dp = dp + x&gt;x?dp+x:x;</span><br><span class="line">            ans = ans&gt;dp?ans:dp;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">2</span>||s&lt;=<span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">return</span> (ans+((k<span class="number">-2</span>)*s%mod+mod)%mod+mod)%mod;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="1218-最长定差子序列"><a href="#1218-最长定差子序列" class="headerlink" title="1218. 最长定差子序列"></a>1218. 最长定差子序列</h4></li></ul><p><strong>Description</strong><br>给你一个整数数组 arr 和一个整数 difference，请你找出 arr 中所有相邻元素之间的差等于给定 difference 的等差子序列，并返回其中最长的等差子序列的长度。<br><strong>Example</strong><br>示例 1：<br>输入：arr = [1,2,3,4], difference = 1<br>输出：4<br>解释：最长的等差子序列是 [1,2,3,4]。</p><p>示例 2：<br>输入：arr = [1,3,5,7], difference = 1<br>输出：1<br>解释：最长的等差子序列是任意单个元素。</p><p>示例 3：<br>输入：arr = [1,5,7,8,5,3,4,2,1], difference = -2<br>输出：4<br>解释：最长的等差子序列是 [7,5,3,1]。</p><p>提示：<br>1 &lt;= arr.length &lt;= 10^5<br>-10^4 &lt;= arr[i], difference &lt;= 10^4<br><strong>Program</strong><br>动态规划：DP[i]=max(DP[i], DP[j]+1) if arr[i]-arr[j]==difference<br>但是时间复杂度$O(n^2)$，肯定超时。<br>那么这里记录arr[i]值最后出现的位置以及其dp值，因为同值arr[i]，后出现的dp值可能更高。<br>具体算法：<br>m记录值x最后出现时的dp值，m[x]=max(m[x], m[x-difference]+1)，注意x-difference有可能等于x，那么必须记录x值出现的位置，如果位置不同才能做max运算，否则m[x]=1；</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> difference)</span> </span>{</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m; <span class="comment">//记录值x最后出现时，dp值</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; loc; <span class="comment">//记录值x出现的位置</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.size();i++){</span><br><span class="line">            <span class="keyword">int</span> x=arr[i];</span><br><span class="line">            <span class="keyword">if</span>(m.find(x)==m.end()) {m[x] = <span class="number">1</span>;loc[x]=i;}</span><br><span class="line">            <span class="keyword">if</span>(m.find(x-difference)!=m.end()&amp;&amp;loc[x-difference]!=i) m[x] = max(m[x], m[x-difference]+<span class="number">1</span>);</span><br><span class="line">            ans=max(m[x], ans);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="1269-停在原地的方案数"><a href="#1269-停在原地的方案数" class="headerlink" title="1269. 停在原地的方案数"></a>1269. 停在原地的方案数</h4><p><strong>Description</strong><br>有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。<br>每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。<br>给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。<br>由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。<br><strong>Example</strong><br>示例 1：<br>输入：steps = 3, arrLen = 2<br>输出：4<br>解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。<br>向右，向左，不动<br>不动，向右，向左<br>向右，不动，向左<br>不动，不动，不动</p><p>示例 2：<br>输入：steps = 2, arrLen = 4<br>输出：2<br>解释：2 步后，总共有 2 种不同的方法可以停在索引 0 处。<br>向右，向左<br>不动，不动</p><p>示例 3：<br>输入：steps = 4, arrLen = 2<br>输出：8</p><p>提示：<br>1 &lt;= steps &lt;= 500<br>1 &lt;= arrLen &lt;= 10^6<br><strong>Progam</strong><br><strong>DP</strong><br>设dp[i][s]为走了s步到数组i位置的方案数，状态转移方程：<br>dp[i][s] = dp[i + 1][s - 1] + dp[i - 1][s - 1] + dp[i][s - 1]<br>画一下二维坐标图，可以发现dp[i][s]只与前一列的结果相关，所以先循环s再遍历i进行dp<br>边界：dp[0][0] = 1；<br>时间复杂度：$O(s * min(s, arrLen))$，s为最大步骤数<br>空间复杂度: $O(s * min(s, arrLen))$, 滚动数组优化的话空间复杂度为$O(min(s, arrLen))$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> steps, <span class="keyword">int</span> arrLen)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = min(steps, arrLen); <span class="comment">//找出最大可以到达的数组位置</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(steps + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= steps; s ++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++){</span><br><span class="line">                dp[i][s] = dp[i][s - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(i + <span class="number">1</span> &lt; n) dp[i][s] = (dp[i][s] + dp[i + <span class="number">1</span>][s - <span class="number">1</span>]) % MOD;</span><br><span class="line">                <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span>) dp[i][s] = (dp[i][s] + dp[i - <span class="number">1</span>][s - <span class="number">1</span>]) % MOD;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][steps];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="面试题-08-02-迷路的机器人"><a href="#面试题-08-02-迷路的机器人" class="headerlink" title="面试题 08.02. 迷路的机器人"></a>面试题 08.02. 迷路的机器人</h4><p><strong>Description</strong><br>设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。<br><img src="/assets/img/algorithm/robot_maze_1.png" alt="image"><br>网格中的障碍物和空位置分别用 1 和 0 来表示。<br>返回一条可行的路径，路径由经过的网格的行号和列号组成。左上角为 0 行 0 列。如果没有可行的路径，返回空数组。<br><strong>Example</strong><br>示例 1:<br>输入:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&nbsp; [0,0,0],</span><br><span class="line">&nbsp; [0,1,0],</span><br><span class="line">&nbsp; [0,0,0]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>输出: [[0,0],[0,1],[0,2],[1,2],[2,2]]<br>解释:<br>输入中标粗的位置即为输出表示的路径，即<br>0行0列（左上角） -&gt; 0行1列 -&gt; 0行2列 -&gt; 1行2列 -&gt; 2行2列（右下角）<br>说明：r 和 c 的值均不超过 100。<br><strong>Program</strong><br><strong>思路</strong><br>先用DP判断路径是否存在，若存在反向寻找路径。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathWithObstacles(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid) {</span><br><span class="line">        <span class="keyword">int</span> m=obstacleGrid.size();</span><br><span class="line">        <span class="keyword">int</span> n=obstacleGrid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>||obstacleGrid[m<span class="number">-1</span>][n<span class="number">-1</span>]==<span class="number">1</span>) <span class="keyword">return</span> {}; <span class="comment">//起点和终点时障碍物</span></span><br><span class="line">        <span class="keyword">bool</span> DP[m][n];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="literal">false</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        DP[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;j&gt;<span class="number">0</span>) DP[i][j]=DP[i<span class="number">-1</span>][j]||DP[i][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;<span class="number">0</span>) DP[i][j]=DP[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;<span class="number">0</span>) DP[i][j]=DP[i][j<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(!DP[m<span class="number">-1</span>][n<span class="number">-1</span>]) <span class="keyword">return</span> {}; <span class="comment">//无路径可达</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> row=m<span class="number">-1</span>, col=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row&gt;=<span class="number">0</span>&amp;&amp;col&gt;=<span class="number">0</span>){</span><br><span class="line">            res.push_back({row, col});</span><br><span class="line">            <span class="keyword">if</span>(row==<span class="number">0</span>&amp;&amp;col==<span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//退出循环</span></span><br><span class="line">            <span class="keyword">if</span>(row&gt;<span class="number">0</span>&amp;&amp;DP[row<span class="number">-1</span>][col]) row--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(col&gt;<span class="number">0</span>&amp;&amp;DP[row][col<span class="number">-1</span>])  col--;</span><br><span class="line">        }</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="LCP-13-寻宝"><a href="#LCP-13-寻宝" class="headerlink" title="LCP 13. 寻宝"></a>LCP 13. 寻宝</h4><p><strong>Description</strong><br>我们得到了一副藏宝图，藏宝图显示，在一个迷宫中存在着未被世人发现的宝藏。</p><p>迷宫是一个二维矩阵，用一个字符串数组表示。它标识了唯一的入口（用 ‘S’ 表示），和唯一的宝藏地点（用 ‘T’ 表示）。但是，宝藏被一些隐蔽的机关保护了起来。在地图上有若干个机关点（用 ‘M’ 表示），只有所有机关均被触发，才可以拿到宝藏。</p><p>要保持机关的触发，需要把一个重石放在上面。迷宫中有若干个石堆（用 ‘O’ 表示），每个石堆都有无限个足够触发机关的重石。但是由于石头太重，我们一次只能搬一个石头到指定地点。</p><p>迷宫中同样有一些墙壁（用 ‘#’ 表示），我们不能走入墙壁。剩余的都是可随意通行的点（用 ‘.’ 表示）。石堆、机关、起点和终点（无论是否能拿到宝藏）也是可以通行的。</p><p>我们每步可以选择向上/向下/向左/向右移动一格，并且不能移出迷宫。搬起石头和放下石头不算步数。那么，从起点开始，我们最少需要多少步才能最后拿到宝藏呢？如果无法拿到宝藏，返回 -1 。<br><strong>Example</strong><br>示例 1：<br>输入： [“S#O”, “M..”, “M.T”]<br>输出：16<br>解释：最优路线为： S-&gt;O, cost = 4, 去搬石头 O-&gt;第二行的M, cost = 3, M机关触发 第二行的M-&gt;O, cost = 3, 我们需要继续回去 O 搬石头。 O-&gt;第三行的M, cost = 4, 此时所有机关均触发 第三行的M-&gt;T, cost = 2，去T点拿宝藏。 总步数为16。</p><p>示例 2：<br>输入： [“S#O”, “M.#”, “M.T”]<br>输出：-1<br>解释：我们无法搬到石头触发机关</p><p>示例 3：<br>输入： [“S#O”, “M.T”, “M..”]<br>输出：17<br>解释：注意终点也是可以通行的。<br>限制：<br>1 &lt;= maze.length &lt;= 100<br>1 &lt;= maze[i].length &lt;= 100<br>maze[i].length == maze[j].length<br>S 和 T 有且只有一个<br>0 &lt;= M的数量 &lt;= 16<br>0 &lt;= O的数量 &lt;= 40，题目保证当迷宫中存在 M 时，一定存在至少一个 O 。<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = {<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>};</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>] = {<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>};</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">inBound</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; bfs(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; maze) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, <span class="number">-1</span>));</span><br><span class="line">        ret[x][y] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">        Q.push({x, y});</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) {</span><br><span class="line">            <span class="keyword">auto</span> p = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">int</span> x = p.first, y = p.second;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) {</span><br><span class="line">                <span class="keyword">int</span> nx = x + dx[k], ny = y + dy[k];</span><br><span class="line">                <span class="keyword">if</span> (inBound(nx, ny) &amp;&amp; maze[nx][ny] != <span class="string">'#'</span> &amp;&amp; ret[nx][ny] == <span class="number">-1</span>) {</span><br><span class="line">                    ret[nx][ny] = ret[x][y] + <span class="number">1</span>;</span><br><span class="line">                    Q.push({nx, ny});</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimalSteps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; maze)</span> </span>{</span><br><span class="line">        n = maze.size(), m = maze[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">// 机关 &amp; 石头</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; buttons, stones;</span><br><span class="line">        <span class="comment">// 起点 &amp; 终点</span></span><br><span class="line">        <span class="keyword">int</span> sx, sy, tx, ty;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) {</span><br><span class="line">                <span class="keyword">if</span> (maze[i][j] == <span class="string">'M'</span>) {</span><br><span class="line">                    buttons.push_back({i, j});</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (maze[i][j] == <span class="string">'O'</span>) {</span><br><span class="line">                    stones.push_back({i, j});</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (maze[i][j] == <span class="string">'S'</span>) {</span><br><span class="line">                    sx = i, sy = j;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (maze[i][j] == <span class="string">'T'</span>) {</span><br><span class="line">                    tx = i, ty = j;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> nb = buttons.size();</span><br><span class="line">        <span class="keyword">int</span> ns = stones.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; start_dist = bfs(sx, sy, maze);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边界情况：没有机关</span></span><br><span class="line">        <span class="keyword">if</span> (nb == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> start_dist[tx][ty];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 从某个机关到其他机关 / 起点与终点的最短距离。</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dist(nb, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nb + <span class="number">2</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="comment">// 中间结果</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; dd(nb);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nb; i++) {</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; d = bfs(buttons[i].first, buttons[i].second, maze);</span><br><span class="line">            dd[i] = d;</span><br><span class="line">            <span class="comment">// 从某个点到终点不需要拿石头</span></span><br><span class="line">            dist[i][nb + <span class="number">1</span>] = d[tx][ty];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nb; i++) {</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; ns; k++) {</span><br><span class="line">                <span class="keyword">int</span> mid_x = stones[k].first, mid_y = stones[k].second;</span><br><span class="line">                <span class="keyword">if</span> (dd[i][mid_x][mid_y] != <span class="number">-1</span> &amp;&amp; start_dist[mid_x][mid_y] != <span class="number">-1</span>) {</span><br><span class="line">                    <span class="keyword">if</span> (tmp == <span class="number">-1</span> || tmp &gt; dd[i][mid_x][mid_y] + start_dist[mid_x][mid_y]) {</span><br><span class="line">                        tmp = dd[i][mid_x][mid_y] + start_dist[mid_x][mid_y];</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            dist[i][nb] = tmp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nb; j++) {</span><br><span class="line">                <span class="keyword">int</span> mn = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; ns; k++) {</span><br><span class="line">                    <span class="keyword">int</span> mid_x = stones[k].first, mid_y = stones[k].second;</span><br><span class="line">                    <span class="keyword">if</span> (dd[i][mid_x][mid_y] != <span class="number">-1</span> &amp;&amp; dd[j][mid_x][mid_y] != <span class="number">-1</span>) {</span><br><span class="line">                        <span class="keyword">if</span> (mn == <span class="number">-1</span> || mn &gt; dd[i][mid_x][mid_y] + dd[j][mid_x][mid_y]) {</span><br><span class="line">                            mn = dd[i][mid_x][mid_y] + dd[j][mid_x][mid_y];</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                dist[i][j] = mn;</span><br><span class="line">                dist[j][i] = mn;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无法达成的情形</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nb; i++) {</span><br><span class="line">            <span class="keyword">if</span> (dist[i][nb] == <span class="number">-1</span> || dist[i][nb + <span class="number">1</span>] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp 数组， -1 代表没有遍历到</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(<span class="number">1</span> &lt;&lt; nb, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nb, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nb; i++) {</span><br><span class="line">            dp[<span class="number">1</span> &lt;&lt; i][i] = dist[i][nb];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于更新的状态都比未更新的大，所以直接从小到大遍历即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mask = <span class="number">1</span>; mask &lt; (<span class="number">1</span> &lt;&lt; nb); mask++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nb; i++) {</span><br><span class="line">                <span class="comment">// 当前 dp 是合法的</span></span><br><span class="line">                <span class="keyword">if</span> (mask &amp; (<span class="number">1</span> &lt;&lt; i)) {</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nb; j++) {</span><br><span class="line">                        <span class="comment">// j 不在 mask 里</span></span><br><span class="line">                        <span class="keyword">if</span> (!(mask &amp; (<span class="number">1</span> &lt;&lt; j))) {</span><br><span class="line">                            <span class="keyword">int</span> next = mask | (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                            <span class="keyword">if</span> (dp[next][j] == <span class="number">-1</span> || dp[next][j] &gt; dp[mask][i] + dist[i][j]) {</span><br><span class="line">                                dp[next][j] = dp[mask][i] + dist[i][j];</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> final_mask = (<span class="number">1</span> &lt;&lt; nb) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nb; i++) {</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="number">-1</span> || ret &gt; dp[final_mask][i] + dist[i][nb + <span class="number">1</span>]) {</span><br><span class="line">                ret = dp[final_mask][i] + dist[i][nb + <span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="前缀和系列"><a href="#前缀和系列" class="headerlink" title="前缀和系列"></a>前缀和系列</h2><h3 id="410-分割数组的最大值"><a href="#410-分割数组的最大值" class="headerlink" title="410. 分割数组的最大值"></a>410. 分割数组的最大值</h3><p><strong>Description</strong><br>给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。</p><p>注意:<br>数组长度 n 满足以下条件:<br>1 ≤ n ≤ 1000<br>1 ≤ m ≤ min(50, n)<br><strong>Example</strong><br>示例:<br>输入:<br>nums = [7,2,5,10,8]<br>m = 2<br>输出:<br>18</p><p>解释:<br>一共有四种方法将nums分割为2个子数组。<br>其中最好的方式是将其分为[7,2,5] 和 [10,8]，<br>因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。<br><strong>Program</strong><br>设DP[i][m]为将前i个元素划分成m份的目标值（最小和），则状态转移方程：<br>$DP[i][m]=min(max(DP[j][m-1], preSum[i]-perSum[j]))$，即前j个元素分成m-1份，后面(j,i]个元素成为一份！<br>时间复杂度：$O(m * n^2)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">long</span> inf=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> m)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">long</span> DP[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">long</span> preSum[n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(preSum, <span class="number">0</span>, <span class="keyword">sizeof</span>(preSum));</span><br><span class="line">        <span class="built_in">memset</span>(DP, inf, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){ <span class="comment">//前缀和</span></span><br><span class="line">            preSum[i]+=nums[i<span class="number">-1</span>];</span><br><span class="line">            preSum[i]+=preSum[i<span class="number">-1</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=min(i,m);k++){  <span class="comment">//前i个元素最多分成i份</span></span><br><span class="line">                <span class="keyword">if</span>(k==<span class="number">1</span>) {DP[i][<span class="number">1</span>]=preSum[i];<span class="keyword">continue</span>;}</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=k<span class="number">-1</span>;j&lt;i;j++){ <span class="comment">//前i个元素分成k份，则前i-1个元素分成k-1分时，至少需要存在k-1个元素</span></span><br><span class="line">                    <span class="comment">//后面若干个为一份，前面j个元素分成k-1分</span></span><br><span class="line">                    DP[i][k]=min(DP[i][k], max(DP[j][k<span class="number">-1</span>], preSum[i]-preSum[j]));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n][m];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1477-找两个和为目标值且不重叠的子数组"><a href="#1477-找两个和为目标值且不重叠的子数组" class="headerlink" title="1477. 找两个和为目标值且不重叠的子数组"></a>1477. 找两个和为目标值且不重叠的子数组</h3><p><strong>Description</strong><br>给你一个整数数组 arr 和一个整数值 target 。<br>请你在 arr 中找 两个互不重叠的子数组 且它们的和都等于 target 。可能会有多种方案，请你返回满足要求的两个子数组长度和的 最小值 。<br>请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 -1 。<br><strong>Example</strong><br>示例 1：<br>输入：arr = [3,2,2,4,3], target = 3<br>输出：2<br>解释：只有两个子数组和为 3 （[3] 和 [3]）。它们的长度和为 2 。</p><p>示例 2：<br>输入：arr = [7,3,4,7], target = 7<br>输出：2<br>解释：尽管我们有 3 个互不重叠的子数组和为 7 （[7], [3,4] 和 [7]），但我们会选择第一个和第三个子数组，因为它们的长度和 2 是最小值。</p><p>示例 3：<br>输入：arr = [4,3,2,6,2,3,4], target = 6<br>输出：-1<br>解释：我们只有一个和为 6 的子数组。</p><p>示例 4：<br>输入：arr = [5,5,4,4,5], target = 3<br>输出：-1<br>解释：我们无法找到和为 3 的子数组。</p><p>示例 5：<br>输入：arr = [3,1,1,1,5,1,2,1], target = 3<br>输出：3<br>解释：注意子数组 [1,2] 和 [2,1] 不能成为一个方案因为它们重叠了。</p><p>提示：<br>1 &lt;= arr.length &lt;= 10^5<br>1 &lt;= arr[i] &lt;= 1000<br>1 &lt;= target &lt;= 10^8<br><strong>Program</strong><br><strong>DP</strong><br>设DP[i]为前i个元素中存在子数组和为target的最小长度，我们希望状态转移方程：<br>（1）当[j+1, i]和为target时，$DP[i]=min(DP[i-1], i-j)$，其中[j+1,i]为和为target的子数组。关键在于找j，这里使用HashMap记录前缀和对应的下标！preSum[i]-target如果存在于HashMap，则进行DP；<br>（2）否则， DP[i]=DP[i-1]，表示与前i-1个元素的满足条件的子数组最小长度。<br>注意边界，以及题目要求的两满足条件的子数组的最小长度和！</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSumOfLengths</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; sToi; <span class="comment">//以i为结尾的前缀和对应的下标i</span></span><br><span class="line">        sToi[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res=inf;</span><br><span class="line">        <span class="keyword">int</span> DP[n];</span><br><span class="line">        <span class="built_in">memset</span>(DP, inf, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            sum+=arr[i];</span><br><span class="line">            sToi[sum]=i;</span><br><span class="line">            <span class="keyword">if</span>(sToi.count(sum-target)){</span><br><span class="line">                <span class="keyword">int</span> j=sToi[sum-target];</span><br><span class="line">                DP[i]=min(i&gt;<span class="number">0</span>?DP[i<span class="number">-1</span>]:inf, i-j);</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>) res=min(res, DP[j]+i-j); <span class="comment">//j&gt;0表示res必须计算两个子数组的长度和</span></span><br><span class="line">            }<span class="keyword">else</span> DP[i]=i&gt;<span class="number">0</span>?DP[i<span class="number">-1</span>]:inf;<span class="comment">//不能构成连续和为Target子数组</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(res==inf) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//无解</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1664-生成平衡数组的方案数"><a href="#1664-生成平衡数组的方案数" class="headerlink" title="1664. 生成平衡数组的方案数"></a>1664. 生成平衡数组的方案数</h3><p><strong>Description</strong><br>给你一个整数数组 nums 。你需要选择 恰好 一个下标（下标从 0 开始）并删除对应的元素。请注意剩下元素的下标可能会因为删除操作而发生改变。<br>比方说，如果 nums = [6,1,7,4,1] ，那么：<br>选择删除下标 1 ，剩下的数组为 nums = [6,7,4,1] 。<br>选择删除下标 2 ，剩下的数组为 nums = [6,1,4,1] 。<br>选择删除下标 4 ，剩下的数组为 nums = [6,1,7,4] 。<br>如果一个数组满足奇数下标元素的和与偶数下标元素的和相等，该数组就是一个 平衡数组 。<br>请你返回删除操作后，剩下的数组 nums 是 平衡数组 的 方案数 。<br><strong>Example</strong><br>示例 1：<br>输入：nums = [2,1,6,4]<br>输出：1<br>解释：<br>删除下标 0 ：[1,6,4] -&gt; 偶数元素下标为：1 + 4 = 5 。奇数元素下标为：6 。不平衡。<br>删除下标 1 ：[2,6,4] -&gt; 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：6 。平衡。<br>删除下标 2 ：[2,1,4] -&gt; 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：1 。不平衡。<br>删除下标 3 ：[2,1,6] -&gt; 偶数元素下标为：2 + 6 = 8 。奇数元素下标为：1 。不平衡。<br>只有一种让剩余数组成为平衡数组的方案。</p><p>示例 2：<br>输入：nums = [1,1,1]<br>输出：3<br>解释：你可以删除任意元素，剩余数组都是平衡数组。</p><p>示例 3：<br>输入：nums = [1,2,3]<br>输出：0<br>解释：不管删除哪个元素，剩下数组都不是平衡数组。</p><p>提示：<br>1 &lt;= nums.length &lt;= 105<br>1 &lt;= nums[i] &lt;= 104<br><strong>Program</strong><br><strong>思路</strong><br>（1）第i个位置删除后，后面[i+1, n]的奇变偶，偶变奇；<br>（2）所以直接一次遍历，判断两侧奇偶和是否相等；</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToMakeFair</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; odd(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; even(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>){</span><br><span class="line">                odd[i]=odd[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>];</span><br><span class="line">                even[i]=even[i<span class="number">-1</span>];</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                even[i]=even[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>];</span><br><span class="line">                odd[i]=odd[i<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="keyword">int</span> o=odd[i<span class="number">-1</span>]+even[n]-even[i];</span><br><span class="line">            <span class="keyword">int</span> e=even[i<span class="number">-1</span>]+odd[n]-odd[i];</span><br><span class="line">            <span class="keyword">if</span>(o==e) ans++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>巧妙</strong><br>去除索引为ii的元素后，ii之前元素的奇偶性不变，ii之后元素的奇偶性改变，即ii之后奇/偶数下标元素的和变成了偶/奇数下标。<br>考虑奇偶元素的差值，我们求正负交替的前缀和 $dp[i] = \sum_{j=0}^{i} (-1)^j nums[j-1]$<br>那么dp[i-1]dp[i−1]表示索引ii左边部分奇偶元素差值，$dp[n] - dp[i]$表示索引ii右边部分奇偶元素差值，去除索引i后，$dp[n]−dp[i]$表示索引i右边部分奇偶元素差值的相反数。<br>因此，对任意i，只要$dp[i-1] == dp[n] - dp[i]$，即满足题目要求。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToMakeFair</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>]*(i%<span class="number">2</span>==<span class="number">0</span>?<span class="number">1</span>:<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>]==dp[n]-dp[i]) ans++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="5471-和为目标值的最大数目不重叠非空子数组数目"><a href="#5471-和为目标值的最大数目不重叠非空子数组数目" class="headerlink" title="5471. 和为目标值的最大数目不重叠非空子数组数目"></a>5471. 和为目标值的最大数目不重叠非空子数组数目</h3><p><strong>Description</strong><br>给你一个数组 nums 和一个整数 target 。<br>请你返回 非空不重叠 子数组的最大数目，且每个子数组中数字和都为 target 。<br><strong>Example</strong><br>示例 1：<br>输入：nums = [1,1,1,1,1], target = 2<br>输出：2<br>解释：总共有 2 个不重叠子数组（加粗数字表示） [1,1,1,1,1] ，它们的和为目标值 2 。</p><p>示例 2：<br>输入：nums = [-1,3,5,1,4,2,-9], target = 6<br>输出：2<br>解释：总共有 3 个子数组和为 6 。<br>([5,1], [4,2], [3,5,1,4,2,-9]) 但只有前 2 个是不重叠的。</p><p>示例 3：<br>输入：nums = [-2,6,6,3,5,4,1,2,8], target = 10<br>输出：3</p><p>示例 4：<br>输入：nums = [0,0,0], target = 0<br>输出：3</p><p>提示：<br>1 &lt;= nums.length &lt;= 10^5<br>-10^4 &lt;= nums[i] &lt;= 10^4<br>0 &lt;= target &lt;= 10^6<br><strong>Program</strong><br><strong>动态规划</strong><br>设DP[i]是前i个中满足题意的最大个数，那么状态转移方程为：<br>如果[j+1,i]和为target，那么DP[i]=max(DP[i-1], DP[j]+1);<br>否则DP[i]=DP[i-1]；<br>时间复杂度：$O(n^2)$，显然对于这样的复杂度是不可接受的，超时！<br>这里利用Hash表存储以i为结尾的前缀和的下标i，通过hash表找出preSum[i]-target的j是否存在，如果存在进行DP，否则DP[i]=DP[i-1]；<br>注意边界，Hash[0]=-1，因为可能存在[0..i]为target的情况！<br>时间复杂度：$O(n)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNonOverlapping</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> DP[n];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; sToi;<span class="comment">//前缀和的尾元素坐标</span></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        sToi[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sToi.find(sum-target)!=sToi.end()){</span><br><span class="line">                <span class="keyword">int</span> j=sToi[sum-target];</span><br><span class="line">                DP[i]=max((i&gt;<span class="number">0</span>?DP[i<span class="number">-1</span>]:<span class="number">0</span>), ((j&gt;=<span class="number">0</span>?DP[j]:<span class="number">0</span>)+<span class="number">1</span>));</span><br><span class="line">            }<span class="keyword">else</span> DP[i]=(i&gt;<span class="number">0</span>?DP[i<span class="number">-1</span>]:<span class="number">0</span>);</span><br><span class="line">            sToi[sum]=i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h3><p><strong>Description</strong><br>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br><strong>Example</strong><br>示例 1：<br>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。</p><p>示例 2：<br>输入: “cbbd”<br>输出: “bb”<br><strong>Program</strong><br><strong>动态规划</strong><br>设DP[i][j]为[i,j]是否为回文串，是为1，否为0；<br>状态转移方程：DP[i][j]=DP[i+1][j-1]&amp;(s[i]==s[j])<br>时间复杂度：$O(n^2)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; DP;</span><br><span class="line">        DP.resize(n);</span><br><span class="line">        <span class="keyword">int</span> maxLen=<span class="number">1</span>, l=<span class="number">0</span>, r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            DP[i].resize(n, <span class="number">0</span>);</span><br><span class="line">            DP[i][i]=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++){</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[i+<span class="number">1</span>]){</span><br><span class="line">                DP[i][i+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(maxLen==<span class="number">1</span>){</span><br><span class="line">                    maxLen=<span class="number">2</span>;</span><br><span class="line">                    l=i;</span><br><span class="line">                    r=i+<span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">3</span>;len&lt;=n;len++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+len<span class="number">-1</span>&lt;n;i++){</span><br><span class="line">                <span class="keyword">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j]) DP[i][j]=DP[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(DP[i][j]==<span class="number">1</span>&amp;&amp;len&gt;maxLen){</span><br><span class="line">                    maxLen=len;</span><br><span class="line">                    l=i;</span><br><span class="line">                    r=j;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s.substr(l, maxLen);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>中心扩展法</strong><br><img src="/assets/img/algorithm/Palindrome_01.png" alt="image"><br>由于存在奇数的回文串和偶数的回文串，所以需要从一个字符开始扩展或者从两个字符之间进行扩展。<br>时间复杂度：$O(n^2)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">int</span> start, end;</span><br><span class="line">        start=end=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p1=expandAroundCenter(s, i, i);</span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p2=expandAroundCenter(s, i, i+<span class="number">1</span>);</span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p;</span><br><span class="line">            <span class="keyword">if</span>(p1.second-p1.first&gt;=p2.second-p2.first) p=p1;</span><br><span class="line">            <span class="keyword">else</span> p=p2;</span><br><span class="line">            <span class="keyword">if</span>(p.second-p.first&gt;end-start){</span><br><span class="line">                start=p.first;</span><br><span class="line">                end=p.second;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, end-start+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; expandAroundCenter(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right){</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;n&amp;&amp;s[left]==s[right]){</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> {++left, --right};</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>马拉车算法</strong><br>（1）首先对原始字符串用其不包含的字符进行扩充，例如用’#’，得到的字符串长度一定为奇数<br>（2）其次设P[i]为处理后的串的每个字符对应的以i为中心的回文串长度，其在原始字符串的起始坐标为(i-P[i])/2<br>（3）利用对称性，更新P[i]、R、C。详见参考：<br><a href="https://www.cxyxiaowu.com/2665.html" target="_blank" rel="noopener">参考链接</a><br>时间复杂度：$O(n)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="built_in">string</span> str=addBoundaries(s, <span class="string">'#'</span>);</span><br><span class="line">        n=str.length();</span><br><span class="line">        <span class="keyword">int</span> P[n];</span><br><span class="line">        <span class="built_in">memset</span>(P, <span class="number">0</span>, <span class="keyword">sizeof</span>(P));</span><br><span class="line">        <span class="keyword">int</span> R=<span class="number">0</span>,C=<span class="number">0</span>; <span class="comment">//右边界与中心点,R=C+P[C],P[i]表示以i为中心点的原始回文串长度，也可以表示处理后的字符串的以i为中心的回文串半径，处理后的字符串长度一定为奇数</span></span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>, end=<span class="number">0</span>; <span class="comment">//最长回文串的起始位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i&lt;R){</span><br><span class="line">                <span class="keyword">int</span> i_mirror = <span class="number">2</span> * C - i;<span class="comment">//i关于center对承德店i_mirror</span></span><br><span class="line">                <span class="comment">//P[i_mirror]的三种情况</span></span><br><span class="line">                <span class="comment">//①P[i_mirror]&lt;R-i,P[i]=P[i_mirror],无需扩展</span></span><br><span class="line">                <span class="comment">//②P[i_mirror]=R-i,P[i]=P[i_mirror]，需要扩展</span></span><br><span class="line">                <span class="comment">//③P[i_mirror]&gt;R-i，P[i]=R-i，无需扩展</span></span><br><span class="line">                <span class="comment">//min精髓，当然后面还要考虑是否中心扩展</span></span><br><span class="line">                P[i]=min(R-i, P[i_mirror]);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> left=i-P[i]<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> right=i+P[i]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;n&amp;&amp;str[left]==str[right]){</span><br><span class="line">                P[i]++;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(i+P[i]&gt;R){ <span class="comment">//更新R,C</span></span><br><span class="line">                R=i+P[i];</span><br><span class="line">                C=i;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(P[i]&gt;end-start+<span class="number">1</span>){</span><br><span class="line">                start=(i-P[i])/<span class="number">2</span>; <span class="comment">//起始点关系</span></span><br><span class="line">                end=start+P[i]<span class="number">-1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, end-start+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBoundaries</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">char</span> divide)</span></span>{ <span class="comment">//分隔符divide必须是字符串中未出现的字符</span></span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            res+=divide;</span><br><span class="line">            res+=s[i];</span><br><span class="line">        }</span><br><span class="line">        res+=divide;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a>303. 区域和检索 - 数组不可变</h3><p><strong>Description</strong><br>给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。<br><strong>Example</strong><br>示例：<br>给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></tbody></table></figure><p>说明:<br>你可以假设数组不可变。<br>会多次调用 sumRange 方法。<br><strong>Progam</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP;</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums){</span><br><span class="line">            sum+=x;</span><br><span class="line">            DP.push_back(sum);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">return</span> DP[j];</span><br><span class="line">        <span class="keyword">return</span> DP[j]-DP[i<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray* obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h3 id="304-二维区域和检索-矩阵不可变"><a href="#304-二维区域和检索-矩阵不可变" class="headerlink" title="304. 二维区域和检索 - 矩阵不可变"></a>304. 二维区域和检索 - 矩阵不可变</h3><p><strong>Description</strong><br>给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2)。<br><img src="/assets/img/algorithm/304.png" alt="image"><br>上图子矩阵左上角 (row1, col1) = (2, 1) ，右下角(row2, col2) = (4, 3)，该子矩形内元素的总和为 8。<br><strong>Example</strong><br>示例:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix = [</span><br><span class="line">  [3, 0, 1, 4, 2],</span><br><span class="line">  [5, 6, 3, 2, 1],</span><br><span class="line">  [1, 2, 0, 1, 5],</span><br><span class="line">  [4, 1, 0, 1, 7],</span><br><span class="line">  [1, 0, 3, 0, 5]</span><br><span class="line">]</span><br><span class="line">sumRegion(2, 1, 4, 3) -&gt; 8</span><br><span class="line">sumRegion(1, 1, 2, 2) -&gt; 11</span><br><span class="line">sumRegion(1, 2, 2, 4) -&gt; 12</span><br></pre></td></tr></tbody></table></figure><p>说明:</p><p>你可以假设矩阵不可变。<br>会多次调用 sumRegion 方法。<br>你可以假设 row1 ≤ row2 且 col1 ≤ col2。<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; DP;</span><br><span class="line">    NumMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) {</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m=matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n=matrix[<span class="number">0</span>].size();</span><br><span class="line">        DP.resize(m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) DP[i].resize(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                DP[i][j]+=matrix[i][j];</span><br><span class="line">                <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>) DP[i][j]+=DP[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j<span class="number">-1</span>&gt;=<span class="number">0</span>) DP[i][j]+=DP[i][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;j<span class="number">-1</span>&gt;=<span class="number">0</span>) DP[i][j]-=DP[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(DP.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result=DP[row2][col2];</span><br><span class="line">        <span class="keyword">if</span>(row1==<span class="number">0</span>&amp;&amp;col1==<span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">if</span>(row1<span class="number">-1</span>&gt;=<span class="number">0</span>) result-=DP[row1<span class="number">-1</span>][col2];</span><br><span class="line">        <span class="keyword">if</span>(col1<span class="number">-1</span>&gt;=<span class="number">0</span>) result-=DP[row2][col1<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(row1<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;col1<span class="number">-1</span>&gt;=<span class="number">0</span>) result+=DP[row1<span class="number">-1</span>][col1<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumMatrix* obj = new NumMatrix(matrix);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;sumRegion(row1,col1,row2,col2);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h3 id="375-猜数字大小-II"><a href="#375-猜数字大小-II" class="headerlink" title="375. 猜数字大小 II"></a>375. 猜数字大小 II</h3><p><strong>Description</strong><br>我们正在玩一个猜数游戏，游戏规则如下：<br>我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。<br>每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。<br>然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。<br><strong>Example</strong><br>示例:<br>n = 10, 我选择了8.<br>第一轮: 你猜我选择的数字是5，我会告诉你，我的数字更大一些，然后你需要支付5块。<br>第二轮: 你猜是7，我告诉你，我的数字更大一些，你支付7块。<br>第三轮: 你猜是9，我告诉你，我的数字更小一些，你支付9块。<br>游戏结束。8 就是我选的数字。<br>你最终要支付 5 + 7 + 9 = 21 块钱。<br>给定 n ≥ 1，计算你至少需要拥有多少现金才能确保你能赢得这个游戏。<br><strong>Program</strong><br><strong>①暴力</strong><br>$DP[1, n]=min(i+max(DP[1, i-1], DP[i+1, n])), i\in[1, n]$;<br>选择第i个数，然后比较左右两边值大小去最大值，最后去所有i下最小值<br>时间复杂度: $O(n!)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minValue=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++){</span><br><span class="line">            <span class="keyword">int</span> value=i+max(cal(l,i<span class="number">-1</span>), cal(i+<span class="number">1</span>, r));</span><br><span class="line">            minValue=min(minValue, value);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> minValue;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMoneyAmount</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> cal(<span class="number">1</span>, n);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>②DP</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMoneyAmount</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; DP(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++) DP[i].resize(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line">                <span class="keyword">int</span> minValue=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=j;k++){</span><br><span class="line">                    <span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(k+<span class="number">1</span>&lt;=j) value=k+max(DP[i][k<span class="number">-1</span>], DP[k+<span class="number">1</span>][j]);</span><br><span class="line">                    <span class="keyword">else</span> value=k+DP[i][k<span class="number">-1</span>];</span><br><span class="line">                    minValue=min(minValue, value);</span><br><span class="line">                }</span><br><span class="line">                DP[i][j]=minValue;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[<span class="number">1</span>][n];</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>一般思路可能那么写代码，但是注意这种写法顺序$DP[k+1][j]$在没计算出来之前就被用到了！！！<br>所以就不能那么写！<br>注意每次抽取k值，那么会导致一段一段的$DP[i][j]$，有没有感觉？？最长回文子串的写法！！！<br>时间复杂度：$O(n^3)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMoneyAmount</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; DP(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++) DP[i].resize(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-len+<span class="number">1</span>;i++){</span><br><span class="line">                <span class="keyword">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">int</span> minValue=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=j;k++){</span><br><span class="line">                    <span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(k==j) value=k+DP[i][k<span class="number">-1</span>];</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(k==i) value=k+DP[k+<span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">else</span> value=k+max(DP[i][k<span class="number">-1</span>], DP[k+<span class="number">1</span>][j]);</span><br><span class="line">                    minValue=min(minValue, value);</span><br><span class="line">                }</span><br><span class="line">                DP[i][j]=minValue;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[<span class="number">1</span>][n];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a>516. 最长回文子序列</h3><p><strong>Description</strong><br>给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。<br><strong>Example</strong><br>示例 1:<br>输入:<br>“bbbab”<br>输出:<br>4<br>一个可能的最长回文子序列为 “bbbb”。</p><p>示例 2:<br>输入:<br>“cbbd”<br>输出:<br>2<br>一个可能的最长回文子序列为 “bb”。<br><strong>Program</strong><br>最长回文子串以及最长公共子序列的翻版！注意子串以及子序列的区别！<br>设DP[i][j]表示i…j这部分的回文子序列，那么当s[i]=s[j]时，明显DP[i][j]=DP[i+1][j-1]+2,反之DP[i][j]=max(DP[i][j-1], DP[i+1][j]);</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; DP(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n ,<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n&amp;&amp;s[i]==s[i+<span class="number">1</span>]) DP[i][i+<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">3</span>;len&lt;=n;len++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+len<span class="number">-1</span>&lt;n;i++){</span><br><span class="line">                <span class="keyword">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j]) DP[i][j]=DP[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> DP[i][j]=max(DP[i+<span class="number">1</span>][j], DP[i][j<span class="number">-1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a>647. 回文子串</h3><p><strong>Description</strong><br>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。<br>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。<br><strong>Example</strong><br>示例 1:<br>输入: “abc”<br>输出: 3<br>解释: 三个回文子串: “a”, “b”, “c”.</p><p>示例 2:<br>输入: “aaa”<br>输出: 6<br>说明: 6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”.<br>注意:<br>输入的字符串长度不会超过1000。<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;DP(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            DP[i][i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n&amp;&amp;s[i]==s[i+<span class="number">1</span>]) DP[i][i+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">3</span>;len&lt;=n;len++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+len<span class="number">-1</span>&lt;n;i++){</span><br><span class="line">                <span class="keyword">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j]) DP[i][j]=DP[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) ans+=DP[i][j];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="764-最大加号标志"><a href="#764-最大加号标志" class="headerlink" title="764. 最大加号标志"></a>764. 最大加号标志</h3><p><strong>Description</strong><br>在一个大小在 (0, 0) 到 (N-1, N-1) 的2D网格 grid 中，除了在 mines 中给出的单元为 0，其他每个单元都是 1。网格中包含 1 的最大的轴对齐加号标志是多少阶？返回加号标志的阶数。如果未找到加号标志，则返回 0。</p><p>一个 k” 阶由 1 组成的“轴对称”加号标志具有中心网格 grid[x][y] = 1 ，以及4个从中心向上、向下、向左、向右延伸，长度为 k-1，由 1 组成的臂。下面给出 k” 阶“轴对称”加号标志的示例。注意，只有加号标志的所有网格要求为 1，别的网格可能为 0 也可能为 1。</p><p>k 阶轴对称加号标志示例:</p><p>阶 1:<br>000<br>010<br>000</p><p>阶 2:<br>00000<br>00100<br>01110<br>00100<br>00000</p><p>阶 3:<br>0000000<br>0001000<br>0001000<br>0111110<br>0001000<br>0001000<br>0000000<br><strong>Example</strong><br>示例 1：<br>输入: N = 5, mines = [[4, 2]]<br>输出: 2<br>解释:<br>11111<br>11111<br>11111<br>11111<br>11011<br>在上面的网格中，最大加号标志的阶只能是2。一个标志已在图中标出。</p><p>示例 2：<br>输入: N = 2, mines = []<br>输出: 1<br>解释:<br>11<br>11<br>没有 2 阶加号标志，有 1 阶加号标志。</p><p>示例 3：<br>输入: N = 1, mines = [[0, 0]]<br>输出: 0<br>解释:<br>0<br>没有加号标志，返回 0 。</p><p>提示：<br>整数N 的范围： [1, 500].<br>mines 的最大长度为 5000.<br>mines[i] 是长度为2的由2个 [0, N-1] 中的数组成.<br>(另外,使用 C, C++, 或者 C# 编程将以稍小的时间限制进行​​判断.)<br><strong>Progarm</strong><br>1，定义数组arm[N][N][4]为点在四方向上延伸的最大长度<br>arm[i][j][0]代表点[i, j]向上最长延伸的1的最大长度<br>arm[i][j][1]代表点[i, j]向左最长延伸的1的最大长度<br>arm[i][j][2]代表点[i, j]向下最长延伸的1的最大长度<br>arm[i][j][3]代表点[i, j]向右最长延伸的1的最大长度<br>2，遍历所有点四方向延伸手臂最小值的最大值即可<br>找到max{min{arm[i][j][0], arm[i][j][1], arm[i][j][2], arm[i][j][3]}}即是答案</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">orderOfLargestPlusSign</span><span class="params">(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mines)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m[N][N];</span><br><span class="line">        <span class="keyword">int</span> arms[N][N][<span class="number">4</span>];</span><br><span class="line">        <span class="built_in">memset</span>(m, <span class="number">-1</span>, <span class="keyword">sizeof</span>(m));</span><br><span class="line">        <span class="built_in">memset</span>(arms, <span class="number">0</span>, <span class="keyword">sizeof</span>(arms));</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec:mines){</span><br><span class="line">            <span class="keyword">int</span> x=vec[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y=vec[<span class="number">1</span>];</span><br><span class="line">            m[x][y]=<span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++){</span><br><span class="line">                <span class="keyword">if</span>(m[i][j]!=<span class="number">0</span>){</span><br><span class="line">                    arms[i][j][<span class="number">0</span>]=(i&gt;<span class="number">0</span>?arms[i<span class="number">-1</span>][j][<span class="number">0</span>]:<span class="number">0</span>)+<span class="number">1</span>;</span><br><span class="line">                    arms[i][j][<span class="number">1</span>]=(j&gt;<span class="number">0</span>?arms[i][j<span class="number">-1</span>][<span class="number">1</span>]:<span class="number">0</span>)+<span class="number">1</span>;</span><br><span class="line">                }   </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=N<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=N<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--){</span><br><span class="line">                <span class="keyword">if</span>(m[i][j]!=<span class="number">0</span>){</span><br><span class="line">                    arms[i][j][<span class="number">2</span>]=(i&lt;N<span class="number">-1</span>?arms[i+<span class="number">1</span>][j][<span class="number">2</span>]:<span class="number">0</span>)+<span class="number">1</span>;</span><br><span class="line">                    arms[i][j][<span class="number">3</span>]=(j&lt;N<span class="number">-1</span>?arms[i][j+<span class="number">1</span>][<span class="number">3</span>]:<span class="number">0</span>)+<span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++){</span><br><span class="line">                <span class="keyword">int</span> min1=min(arms[i][j][<span class="number">0</span>],arms[i][j][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">int</span> min2=min(arms[i][j][<span class="number">2</span>],arms[i][j][<span class="number">3</span>]);</span><br><span class="line">                min1=min(min1,min2);</span><br><span class="line">                ans=max(ans,min1);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1024-视频拼接"><a href="#1024-视频拼接" class="headerlink" title="1024. 视频拼接"></a>1024. 视频拼接</h3><p><strong>Description</strong><br>你将会获得一系列视频片段，这些片段来自于一项持续时长为 T 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。<br>视频片段 clips[i] 都用区间进行表示：开始于 clips[i][0] 并于 clips[i][1] 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 [0, 7] 可以剪切成 [0, 1] + [1, 3] + [3, 7] 三部分。<br>我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, T]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。<br><strong>Example</strong><br>示例 1：<br>输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10<br>输出：3<br>解释：<br>我们选中 [0,2], [8,10], [1,9] 这三个片段。<br>然后，按下面的方案重制比赛片段：<br>将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。<br>现在我们手上有 [0,2] + [2,8] + [8,10]，而这些涵盖了整场比赛 [0, 10]。</p><p>示例 2：<br>输入：clips = [[0,1],[1,2]], T = 5<br>输出：-1<br>解释：<br>我们无法只用 [0,1] 和 [0,2] 覆盖 [0,5] 的整个过程。</p><p>示例 3：<br>输入：clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9<br>输出：3<br>解释：<br>我们选取片段 [0,4], [4,7] 和 [6,9] 。</p><p>示例 4：<br>输入：clips = [[0,4],[2,8]], T = 5<br>输出：2<br>解释：<br>注意，你可能录制超过比赛结束时间的视频。</p><p>提示：<br>1 &lt;= clips.length &lt;= 100<br>0 &lt;= clips[i][0] &lt;= clips[i][1] &lt;= 100<br>0 &lt;= T &lt;= 100<br><strong>Program</strong><br><strong>动态规划</strong><br>设DP[i]是以i为结束的最小数目：<br>（1）以HashMap记录以i为结尾的所有区间的起始点，这里需要将区间[s,e]中每个以s开头，j(j=s,…e)为结尾的区间都算进去；<br>（2）递推方程：DP[i]=min(DP[i],1+DP[m[i][j])，其中j为以i结尾的区间的索引，0表示该区间起始。<br>边界：</p><ul><li>如果m[0].size()==0，表示没有以0开头的区间，如果m[T].size()==0，表示没有以T为结尾的区间，所以直接返回false；</li><li>否则DP[0]=0<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">videoStitching</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; clips, <span class="keyword">int</span> T)</span> </span>{</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; m;<span class="comment">//记录以i为结尾的区间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec:clips){</span><br><span class="line">            <span class="keyword">int</span> s=vec[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> e=vec[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=s;i&lt;=e;i++){ <span class="comment">//拆分区间</span></span><br><span class="line">                m[i].push_back(s);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> DP[T+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, inf, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">if</span>(m[T].size()==<span class="number">0</span>||m[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        DP[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=T;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m[i].size();j++){</span><br><span class="line">                <span class="keyword">int</span> s=m[i][j];</span><br><span class="line">                DP[i]=min(DP[i], <span class="number">1</span>+DP[s]);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//cout&lt;&lt;DP[i]&lt;&lt;endl;</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[T]==inf?<span class="number">-1</span>:DP[T]; <span class="comment">//未找到连通区间</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li></ul><p><strong>贪心</strong><br>DP[i]记录以i为起点的最远可达距离。<br>思路还是挺简洁的，先按照其实时间位置正序排序。对于每一个clip,当超过前一次跳跃所能达到的最大位置时，跳跃次数加一并更新临界位置的坐标。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">videoStitching</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; clips, <span class="keyword">int</span> T)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">101</span>] ={<span class="number">0</span>};</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>, ans = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; clip : clips) {</span><br><span class="line">            dp[clip[<span class="number">0</span>]] = max(dp[clip[<span class="number">0</span>]], clip[<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) {</span><br><span class="line">            mx = max(mx, dp[i]);</span><br><span class="line">            <span class="keyword">if</span> (i == pre) { <span class="comment">//已到达上一区间所能到达的最远距离</span></span><br><span class="line">                ans++;  </span><br><span class="line">                pre = mx;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (i == mx) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//不可达</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1039-多边形三角剖分的最低得分"><a href="#1039-多边形三角剖分的最低得分" class="headerlink" title="1039. 多边形三角剖分的最低得分"></a>1039. 多边形三角剖分的最低得分</h3><p><strong>Description</strong><br>给定 N，想象一个凸 N 边多边形，其顶点按顺时针顺序依次标记为 A[0], A[i], …, A[N-1]。<br>假设您将多边形剖分为 N-2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 N-2 个三角形的值之和。<br>返回多边形进行三角剖分后可以得到的最低分。<br><strong>Example</strong><br>示例 1：<br>输入：[1,2,3]<br>输出：6<br>解释：多边形已经三角化，唯一三角形的分数为 6。</p><p>示例 2：<br><img src="/assets/img/algorithm/minimum-score-triangulation-of-polygon-1.png" alt="image"><br>输入：[3,7,4,5]<br>输出：144<br>解释：有两种三角剖分，可能得分分别为：$3<em>7</em>5 + 4<em>5</em>7 = 245，或 3<em>4</em>5 + 3<em>4</em>7 = 144$。最低分数为 144。</p><p>示例 3：<br>输入：[1,3,1,4,1,5]<br>输出：13<br>解释：最低分数三角剖分的得分情况为 $1<em>1</em>3 + 1<em>1</em>4 + 1<em>1</em>5 + 1<em>1</em>1 = 13$。</p><p>提示：<br>3 &lt;= A.length &lt;= 50<br>1 &lt;= A[i] &lt;= 100<br><strong>Program</strong><br><strong>动态规划</strong><br>设DP[i][j]为以[i,j]为多边形的最低得分，则$DP[i][j]=min(DP[i][m]+A[i]<em>A[m]</em>A[j]+DP[m][j]), m=i+1,…,j-1$<br>即DP[i][j]划分成N-2个三角形，恰好以i,j为三角形两端点，m为另一端点，然后将多边形划分成DP[i][m],以及i,j,m组成的三角形，以及DP[m][j]三个部分，<br>可以发现DP[i][m]为m-i+1-2个划分，DP[m][j]为j-m+1-2个划分，<br>所以总的划分刚好为$m-i+1-2+j-m+1-2+1=j-i+1-2$满足题意。<br>注意DP[i][j]与后面某行DP[m][j]以及左侧DP[i][m]有关，所以应当从下往上，从左往右DP。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minScoreTriangulation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="keyword">int</span> DP[n][n];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-3</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">2</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> m=i+<span class="number">1</span>;m&lt;j;m++){</span><br><span class="line">                    <span class="keyword">if</span>(DP[i][j]==<span class="number">0</span>) DP[i][j]=DP[i][m]+A[i] * A[j] * A[m]+DP[m][j]; <span class="comment">//初始化</span></span><br><span class="line">                    <span class="keyword">else</span> DP[i][j]=min(DP[i][j], DP[i][m]+A[i] * A[j] * A[m]+DP[m][j]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1105-填充书架"><a href="#1105-填充书架" class="headerlink" title="1105. 填充书架"></a>1105. 填充书架</h3><p><strong>Description</strong><br>给你一个 m * n 的矩阵 mat 和一个整数 K ，请你返回一个矩阵 answer ，其中每个 answer[i][j] 是所有满足下述条件的元素 mat[r][c] 的和：</p><ul><li>i - K &lt;= r &lt;= i + K, j - K &lt;= c &lt;= j + K</li><li>(r, c) 在矩阵内。</li></ul><p><strong>Example</strong><br>示例 1：<br>输入：mat = [[1,2,3],[4,5,6],[7,8,9]], K = 1<br>输出：[[12,21,16],[27,45,33],[24,39,28]]</p><p>示例 2：<br>输入：mat = [[1,2,3],[4,5,6],[7,8,9]], K = 2<br>输出：[[45,45,45],[45,45,45],[45,45,45]]</p><p>提示：<br>m == mat.length<br>n == mat[i].length<br>1 &lt;= m, n, K &lt;= 100<br>1 &lt;= mat[i][j] &lt;= 100<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrixBlockSum(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat, <span class="keyword">int</span> K) {</span><br><span class="line">        m=mat.size(), n=mat[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> DP[m+<span class="number">1</span>][n+<span class="number">1</span>]; <span class="comment">//多开一维，免得边界判断</span></span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line">                DP[i][j]=DP[i][j<span class="number">-1</span>]+DP[i<span class="number">-1</span>][j]-DP[i<span class="number">-1</span>][j<span class="number">-1</span>]+mat[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; A(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>)); <span class="comment">//多开一维，方便边界运算，比如i-K,j-K不在矩阵范围内，可以使用A[0][X]以及A[X][0]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line">                <span class="keyword">int</span> down=(i-K<span class="number">-1</span>&lt;<span class="number">1</span>)?<span class="number">0</span>:i-K<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">int</span> up=(i+K&gt;m)?m:i+K;</span><br><span class="line">                <span class="keyword">int</span> left=(j-K<span class="number">-1</span>&lt;<span class="number">1</span>)?<span class="number">0</span>:j-K<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">int</span> right=(j+K&gt;n)?n:j+K;</span><br><span class="line">                A[i][j]=DP[up][right]-DP[up][left]-DP[down][right]+DP[down][left];</span><br><span class="line">                mat[i<span class="number">-1</span>][j<span class="number">-1</span>]=A[i][j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> mat;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>Description</strong><br>附近的家居城促销，你买回了一直心仪的可调节书架，打算把自己的书都整理到新的书架上。<br>你把要摆放的书 books 都整理好，叠成一摞：从上往下，第 i 本书的厚度为 books[i][0]，高度为 books[i][1]。<br><strong>按顺序</strong> 将这些书摆放到总宽度为 shelf_width 的书架上。<br>先选几本书放在书架上（它们的厚度之和小于等于书架的宽度 shelf_width），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。<br>需要注意的是，在上述过程的每个步骤中，<strong>摆放书的顺序与你整理好的顺序相同</strong>。 例如，如果这里有 5 本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。<br>每一层所摆放的书的最大高度就是这一层书架的层高，书架整体的高度为各层高之和。<br>以这种方式布置书架，返回书架整体可能的最小高度。<br><strong>Example</strong><br>示例：<br><img src="/assets/img/algorithm/shelves.png" alt="image"><br>输入：books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4<br>输出：6<br>解释：<br>3 层书架的高度和为 1 + 3 + 2 = 6 。<br>第 2 本书不必放在第一层书架上。</p><p>提示：<br>1 &lt;= books.length &lt;= 1000<br>1 &lt;= books[i][0] &lt;= shelf_width &lt;= 1000<br>1 &lt;= books[i][1] &lt;= 1000<br><strong>Program</strong><br><strong>深搜</strong><br>超时。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> minH;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> shelfWidth;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; books, <span class="keyword">int</span> i, <span class="keyword">int</span> sumH)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(i==n){</span><br><span class="line">            minH=min(minH, sumH);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> nowWidth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxH=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n&amp;&amp;nowWidth+books[j][<span class="number">0</span>]&lt;=shelfWidth;j++){</span><br><span class="line">            nowWidth+=books[j][<span class="number">0</span>];</span><br><span class="line">            maxH=max(maxH, books[j][<span class="number">1</span>]);</span><br><span class="line">            dfs(books, j+<span class="number">1</span>, sumH+maxH);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minHeightShelves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; books, <span class="keyword">int</span> shelf_width)</span> </span>{</span><br><span class="line">        minH=INT_MAX;</span><br><span class="line">        shelfWidth=shelf_width;</span><br><span class="line">        n=books.size();</span><br><span class="line">        dfs(books, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> minH;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>动规</strong><br>设DP[i]为i本书取得的最小高度，前i-1本书分别已求得最小高度值，求i本书最小高度：<br>可以知道第i本书一定在最后一层，那么其最多有满足witdh&lt;=shelf_w的书在同一层，即最后一层，求其中最小高度即可：<br>DP[i]=min(DP[i], DP[j-1]+h)，其中j为最后一层书籍的头一本书索引，h为最后一层书的最大高度。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minHeightShelves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; books, <span class="keyword">int</span> shelf_width)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=books.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP(n, inf);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> width=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> h=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=<span class="number">0</span>;j--){</span><br><span class="line">                width+=books[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(width&gt;shelf_width) <span class="keyword">break</span>;</span><br><span class="line">                h=max(h, books[j][<span class="number">1</span>]);</span><br><span class="line">                DP[i]=min(DP[i], ((j&gt;=<span class="number">1</span>)?DP[j<span class="number">-1</span>]+h:h));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1139-最大的以-1-为边界的正方形"><a href="#1139-最大的以-1-为边界的正方形" class="headerlink" title="1139. 最大的以 1 为边界的正方形"></a>1139. 最大的以 1 为边界的正方形</h3><p><strong>Description</strong><br>给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。<br><strong>Example</strong><br>示例 1：<br>输入：grid = [[1,1,1],[1,0,1],[1,1,1]]<br>输出：9</p><p>示例 2：<br>输入：grid = [[1,1,0,0]]<br>输出：1</p><p>提示：<br>1 &lt;= grid.length &lt;= 100<br>1 &lt;= grid[0].length &lt;= 100<br>grid[i][j] 为 0 或 1<br><strong>Program</strong><br>与最大正方形类似，这里需要记录grid[i][j]==1时 <strong>包含自身</strong> 的左边与上边连续1的个数。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largest1BorderedSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; leftOnes(m ,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n ,<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; upOnes(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                leftOnes[i][j]=<span class="number">1</span>;</span><br><span class="line">                upOnes[i][j]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>) upOnes[i][j]+=upOnes[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>) leftOnes[i][j]+=leftOnes[i][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=min(upOnes[i][j], leftOnes[i][j]);k++){</span><br><span class="line">                    <span class="keyword">if</span>(k&gt;ans&amp;&amp;upOnes[i][j-k+<span class="number">1</span>]&gt;=k&amp;&amp;leftOnes[i-k+<span class="number">1</span>][j]&gt;=k){</span><br><span class="line">                        ans=k;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans*ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1240-铺瓷砖"><a href="#1240-铺瓷砖" class="headerlink" title="1240. 铺瓷砖"></a>1240. 铺瓷砖</h3><p><strong>Description</strong><br>你是一位施工队的工长，根据设计师的要求准备为一套设计风格独特的房子进行室内装修。<br>房子的客厅大小为 n x m，为保持极简的风格，需要使用尽可能少的 正方形 瓷砖来铺盖地面。<br>假设正方形瓷砖的规格不限，边长都是整数。<br>请你帮设计师计算一下，最少需要用到多少块方形瓷砖？<br><strong>Example</strong><br>示例 1：<br><img src="/assets/img/algorithm/sample_11_1592.png" alt="image"><br>输入：n = 2, m = 3<br>输出：3<br>解释：3 块地砖就可以铺满卧室。<br> 2 块 1x1 地砖<br> 1 块 2x2 地砖</p><p>示例 2：<br><img src="/assets/img/algorithm/sample_22_1592.png" alt="image"><br>输入：n = 5, m = 8<br>输出：5</p><p>示例 3：<br><img src="/assets/img/algorithm/sample_33_1592.png" alt="image"><br>输入：n = 11, m = 13<br>输出：6</p><p>提示：<br>1 &lt;= n &lt;= 13<br>1 &lt;= m &lt;= 13<br><strong>Program</strong><br><strong>动态规划</strong><br><img src="/assets/img/algorithm/1240_exampler_01.png" alt="image"><br>时间复杂度：$O(n^4)$<br>空间复杂度：$O(n^2)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calMin</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> x&lt;y?x:y;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">tilingRectangle</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> DP[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) {</span><br><span class="line">                <span class="keyword">if</span>(i==j){ <span class="comment">//正方形</span></span><br><span class="line">                    DP[i][j]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;i;k++){ <span class="comment">//横切</span></span><br><span class="line">                    DP[i][j]=calMin(DP[i][j], DP[k][j]+DP[i-k][j]);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;j;k++){ <span class="comment">//竖切</span></span><br><span class="line">                    DP[i][j]=calMin(DP[i][j], DP[i][k]+DP[i][j-k]);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=min(i, j);p++){ <span class="comment">//横竖切</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=p;k++){</span><br><span class="line">                        <span class="keyword">if</span>(p-k&lt;=<span class="number">0</span>||j-p&lt;=<span class="number">0</span>||i-p+k&lt;=<span class="number">0</span>||j-p-k&lt;=<span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">//不能构成横竖切</span></span><br><span class="line">                        DP[i][j]=calMin(DP[i][j], DP[p-k][j-p]+DP[i-p+k][j-p-k]+DP[i-p][p+k]+<span class="number">2</span>);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n][m];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="面试题-08-14-布尔运算"><a href="#面试题-08-14-布尔运算" class="headerlink" title="面试题 08.14. 布尔运算"></a>面试题 08.14. 布尔运算</h3><p><strong>Description</strong><br>给定一个布尔表达式和一个期望的布尔结果 result，布尔表达式由 0 (false)、1 (true)、&amp; (AND)、 | (OR) 和 ^ (XOR) 符号组成。实现一个函数，算出有几种可使该表达式得出 result 值的括号方法。<br><strong>Example</strong><br>示例 1:<br>输入: s = “1^0|0|1”, result = 0<br>输出: 2<br>解释: 两种可能的括号方法是<br>1^(0|(0|1))<br>1^((0|0)|1)</p><p>示例 2:<br>输入: s = “0&amp;0&amp;0&amp;1^1|0”, result = 1<br>输出: 10<br>提示：<br>运算符的数量不超过 19 个<br><strong>Program</strong><br>设DP[i][j][0/1]为区间[i,j]结果为0/1的个数</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countEval</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> result)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">int</span> DP[n+<span class="number">1</span>][n+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'0'</span>||s[i]==<span class="string">'1'</span>) DP[i+<span class="number">1</span>][i+<span class="number">1</span>][s[i]-<span class="string">'0'</span>]=<span class="number">1</span>, DP[i+<span class="number">1</span>][i+<span class="number">1</span>][((s[i]-<span class="string">'0'</span>)^<span class="number">1</span>)]=<span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--){</span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'&amp;'</span>||s[i<span class="number">-1</span>]==<span class="string">'|'</span>||s[i<span class="number">-1</span>]==<span class="string">'^'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line">                <span class="keyword">if</span>(s[j<span class="number">-1</span>]==<span class="string">'&amp;'</span>||s[j<span class="number">-1</span>]==<span class="string">'|'</span>||s[j<span class="number">-1</span>]==<span class="string">'^'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;j;k++){</span><br><span class="line">                    <span class="keyword">if</span>(s[k<span class="number">-1</span>]==<span class="string">'&amp;'</span>){</span><br><span class="line">                        DP[i][j][<span class="number">0</span>]+=DP[i][k<span class="number">-1</span>][<span class="number">0</span>]*DP[k+<span class="number">1</span>][j][<span class="number">0</span>]</span><br><span class="line">                                    +DP[i][k<span class="number">-1</span>][<span class="number">0</span>]*DP[k+<span class="number">1</span>][j][<span class="number">1</span>]</span><br><span class="line">                                    +DP[i][k<span class="number">-1</span>][<span class="number">1</span>]*DP[k+<span class="number">1</span>][j][<span class="number">0</span>];</span><br><span class="line">                        DP[i][j][<span class="number">1</span>]+=DP[i][k<span class="number">-1</span>][<span class="number">1</span>]*DP[k+<span class="number">1</span>][j][<span class="number">1</span>];</span><br><span class="line">                    }<span class="keyword">else</span> <span class="keyword">if</span>(s[k<span class="number">-1</span>]==<span class="string">'|'</span>){</span><br><span class="line">                        DP[i][j][<span class="number">0</span>]+=DP[i][k<span class="number">-1</span>][<span class="number">0</span>]*DP[k+<span class="number">1</span>][j][<span class="number">0</span>];</span><br><span class="line">                        DP[i][j][<span class="number">1</span>]+=DP[i][k<span class="number">-1</span>][<span class="number">1</span>]*DP[k+<span class="number">1</span>][j][<span class="number">1</span>]</span><br><span class="line">                                    +DP[i][k<span class="number">-1</span>][<span class="number">0</span>]*DP[k+<span class="number">1</span>][j][<span class="number">1</span>]</span><br><span class="line">                                    +DP[i][k<span class="number">-1</span>][<span class="number">1</span>]*DP[k+<span class="number">1</span>][j][<span class="number">0</span>];</span><br><span class="line">                    }<span class="keyword">else</span> <span class="keyword">if</span>(s[k<span class="number">-1</span>]==<span class="string">'^'</span>){</span><br><span class="line">                        DP[i][j][<span class="number">0</span>]+=DP[i][k<span class="number">-1</span>][<span class="number">0</span>]*DP[k+<span class="number">1</span>][j][<span class="number">0</span>]</span><br><span class="line">                                    +DP[i][k<span class="number">-1</span>][<span class="number">1</span>]*DP[k+<span class="number">1</span>][j][<span class="number">1</span>];</span><br><span class="line">                        DP[i][j][<span class="number">1</span>]+=DP[i][k<span class="number">-1</span>][<span class="number">0</span>]*DP[k+<span class="number">1</span>][j][<span class="number">1</span>]</span><br><span class="line">                                    +DP[i][k<span class="number">-1</span>][<span class="number">1</span>]*DP[k+<span class="number">1</span>][j][<span class="number">0</span>];</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[<span class="number">1</span>][n][result];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="面试题-17-23-最大黑方阵"><a href="#面试题-17-23-最大黑方阵" class="headerlink" title="面试题 17.23. 最大黑方阵"></a>面试题 17.23. 最大黑方阵</h3><p><strong>Description</strong><br>给定一个方阵，其中每个单元(像素)非黑即白。设计一个算法，找出 4 条边皆为黑色像素的最大子方阵。<br>返回一个数组 [r, c, size] ，其中 r, c 分别代表子方阵左上角的行号和列号，size 是子方阵的边长。若有多个满足条件的子方阵，返回 r 最小的，若 r 相同，返回 c 最小的子方阵。若无满足条件的子方阵，返回空数组。<br><strong>Example</strong><br>示例 1:<br>输入:<br>[<br> [1,0,1],<br> [0,0,1],<br> [0,0,1]<br>]<br>输出: [1,0,2]<br>解释: 输入中 0 代表黑色，1 代表白色，标粗的元素即为满足条件的最大子方阵</p><p>示例 2:<br>输入:<br>[<br> [0,1,1],<br> [1,0,1],<br> [1,1,0]<br>]<br>输出: [0,0,1]<br>提示：<br>matrix.length == matrix[0].length &lt;= 200<br><strong>Program</strong><br><strong>动态规划</strong><br>设down[i][j],right[i][j]分别表示以[i,j]为左上角往下和往右的连续0个数，<br>那么以[i,j]为左上角的四条边全为0的方形边长radius=k+1，其中k为满足三条件的最大值:<br>$k&lt;min(down[i][j], right[i][j])且right[i+k][j]&gt;=k+1且down[i][j+k]&gt;=k+1)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSquare(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) {</span><br><span class="line">        <span class="keyword">int</span> n=matrix.size();</span><br><span class="line">        <span class="keyword">int</span> right[n+<span class="number">1</span>][n+<span class="number">1</span>], down[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(right, <span class="number">0</span>, <span class="keyword">sizeof</span>(right));</span><br><span class="line">        <span class="built_in">memset</span>(down, <span class="number">0</span>, <span class="keyword">sizeof</span>(down));</span><br><span class="line">        <span class="keyword">int</span> maxRadius=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r=<span class="number">-1</span>, c=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--){</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                right[i][j]=down[i][j]=<span class="number">1</span>;</span><br><span class="line">                right[i][j]+=right[i][j+<span class="number">1</span>];</span><br><span class="line">                down[i][j]+=down[i+<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;min(down[i][j], right[i][j]);k++){</span><br><span class="line">                    <span class="keyword">if</span>(k+<span class="number">1</span>&gt;=maxRadius&amp;&amp;right[i+k][j]&gt;=k+<span class="number">1</span>&amp;&amp;down[i][j+k]&gt;=k){</span><br><span class="line">                        maxRadius=k+<span class="number">1</span>;</span><br><span class="line">                        r=i;</span><br><span class="line">                        c=j;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(maxRadius==<span class="number">0</span>) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="keyword">return</span> {r, c, maxRadius};</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1277-统计全为-1-的正方形子矩阵"><a href="#1277-统计全为-1-的正方形子矩阵" class="headerlink" title="1277. 统计全为 1 的正方形子矩阵"></a>1277. 统计全为 1 的正方形子矩阵</h3><p><strong>Description</strong><br>给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。<br><strong>Example</strong><br>示例 1：<br>输入：matrix =<br>[<br> [0,1,1,1],<br> [1,1,1,1],<br> [0,1,1,1]<br>]<br>输出：15<br>解释：<br>边长为 1 的正方形有 10 个。<br>边长为 2 的正方形有 4 个。<br>边长为 3 的正方形有 1 个。<br>正方形的总数 = 10 + 4 + 1 = 15.</p><p>示例 2：<br>输入：matrix =<br>[<br> [1,0,1],<br> [1,1,0],<br> [1,1,0]<br>]<br>输出：7<br>解释：<br>边长为 1 的正方形有 6 个。<br>边长为 2 的正方形有 1 个。<br>正方形的总数 = 6 + 1 = 7.</p><p>提示：<br>1 &lt;= arr.length &lt;= 300<br>1 &lt;= arr[0].length &lt;= 300<br>0 &lt;= arr[i][j] &lt;= 1<br><strong>Program</strong><br><strong>动规</strong><br>设DP[i][j]为以i,j为右下角的正方形最大正方形边长，则状态转移方程：<br>当matrix[i][j]==1时，$DP[i][j]=min(DP[i][j-1],min(DP[i-1][j],DP[i-1][j-1]))+1;$<br>否则，DP[i][j]=0：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSquares</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m=matrix.size(), n=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> DP[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line">                <span class="keyword">if</span>(matrix[i<span class="number">-1</span>][j<span class="number">-1</span>]==<span class="number">1</span>) DP[i][j]=min(DP[i][j<span class="number">-1</span>],min(DP[i<span class="number">-1</span>][j],DP[i<span class="number">-1</span>][j<span class="number">-1</span>]))+<span class="number">1</span>;</span><br><span class="line">                ans+=DP[i][j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1314-矩阵区域和"><a href="#1314-矩阵区域和" class="headerlink" title="1314. 矩阵区域和"></a>1314. 矩阵区域和</h3><p><strong>Description</strong><br>给你一个 m * n 的矩阵 mat 和一个整数 K ，请你返回一个矩阵 answer ，其中每个 answer[i][j] 是所有满足下述条件的元素 mat[r][c] 的和：</p><ul><li>i - K &lt;= r &lt;= i + K, j - K &lt;= c &lt;= j + K</li><li>(r, c) 在矩阵内。</li></ul><p><strong>Example</strong><br>示例 1：<br>输入：mat = [[1,2,3],[4,5,6],[7,8,9]], K = 1<br>输出：[[12,21,16],[27,45,33],[24,39,28]]</p><p>示例 2：<br>输入：mat = [[1,2,3],[4,5,6],[7,8,9]], K = 2<br>输出：[[45,45,45],[45,45,45],[45,45,45]]</p><p>提示：<br>m == mat.length<br>n == mat[i].length<br>1 &lt;= m, n, K &lt;= 100<br>1 &lt;= mat[i][j] &lt;= 100<br><strong>Program</strong><br><strong>DP</strong><br>设DP[i][j]为以i,j为右下角的从矩阵左上角开始的矩阵区域和，状态转移方程：<br>$DP[i][j]=DP[i][j-1]+DP[i-1][j]-DP[i-1][j-1]+mat[i-1][j-1];$<br>Mat[i][j]就是对应目标值为DP[up][right]-DP[up][left]-DP[down][right]+DP[down][left];<br>详见代码</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrixBlockSum(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat, <span class="keyword">int</span> K) {</span><br><span class="line">        m=mat.size(), n=mat[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> DP[m+<span class="number">1</span>][n+<span class="number">1</span>]; <span class="comment">//多开一维，免得边界判断</span></span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line">                DP[i][j]=DP[i][j<span class="number">-1</span>]+DP[i<span class="number">-1</span>][j]-DP[i<span class="number">-1</span>][j<span class="number">-1</span>]+mat[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; A(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>)); <span class="comment">//多开一维，方便边界运算，比如i-K,j-K不在矩阵范围内，可以使用A[0][X]以及A[X][0]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line">                <span class="keyword">int</span> down=(i-K<span class="number">-1</span>&lt;<span class="number">1</span>)?<span class="number">0</span>:i-K<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">int</span> up=(i+K&gt;m)?m:i+K;</span><br><span class="line">                <span class="keyword">int</span> left=(j-K<span class="number">-1</span>&lt;<span class="number">1</span>)?<span class="number">0</span>:j-K<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">int</span> right=(j+K&gt;n)?n:j+K;</span><br><span class="line">                A[i][j]=DP[up][right]-DP[up][left]-DP[down][right]+DP[down][left];</span><br><span class="line">                mat[i<span class="number">-1</span>][j<span class="number">-1</span>]=A[i][j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> mat;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1504-统计全-1-子矩形"><a href="#1504-统计全-1-子矩形" class="headerlink" title="1504. 统计全 1 子矩形"></a>1504. 统计全 1 子矩形</h3><p><strong>Description</strong><br>给你一个只包含 0 和 1 的 rows * columns 矩阵 mat ，请你返回有多少个 子矩形 的元素全部都是 1 。<br><strong>Example</strong><br>示例 1：<br>输入：mat = [[1,0,1],<br> [1,1,0],<br> [1,1,0]]<br>输出：13<br>解释：<br>有 6 个 1x1 的矩形。<br>有 2 个 1x2 的矩形。<br>有 3 个 2x1 的矩形。<br>有 1 个 2x2 的矩形。<br>有 1 个 3x1 的矩形。<br>矩形数目总共 = 6 + 2 + 3 + 1 + 1 = 13 。</p><p>示例 2：<br>输入：mat = [[0,1,1,0],<br> [0,1,1,1],<br> [1,1,1,0]]<br>输出：24<br>解释：<br>有 8 个 1x1 的子矩形。<br>有 5 个 1x2 的子矩形。<br>有 2 个 1x3 的子矩形。<br>有 4 个 2x1 的子矩形。<br>有 2 个 2x2 的子矩形。<br>有 2 个 3x1 的子矩形。<br>有 1 个 3x2 的子矩形。<br>矩形数目总共 = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24 。</p><p>示例 3：<br>输入：mat = [[1,1,1,1,1,1]]<br>输出：21</p><p>示例 4：<br>输入：mat = [[1,0,1],[0,1,0],[1,0,1]]<br>输出：5</p><p>提示：<br>1 &lt;= rows &lt;= 150<br>1 &lt;= columns &lt;= 150<br>0 &lt;= mat[i][j] &lt;= 1<br><strong>Program</strong><br><strong>DP</strong><br>根据之前DP做正方形类似的题目的经验，有时会需要left[i][j]和up[i][j]记录两个方向的边长，这里同样记录以[i,j]为右止点的连续1的长度，那么设DP[i][j]为所求以i,j为右下角的举行个数，明显有：<br>$DP[i][j]=\sum_{k=i}^{0}(row[k][j])$其中一但row[i][j]==0就终止因为其表示第k行没有1断层了。整个思路就是计算第k层的以[i,j]为右下角的矩形数，(k=i…0)，也就是以第i行为底边[i,j]为右下角，第k行为上边的矩形。<br>时间复杂度：$O(m^2 n)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubmat</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m=mat.size(), n=mat[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> row[m][n];</span><br><span class="line">        <span class="built_in">memset</span>(row, <span class="number">0</span>, <span class="keyword">sizeof</span>(row));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j]==<span class="number">1</span>) row[i][j]=(j&gt;<span class="number">0</span>?row[i][j<span class="number">-1</span>]:<span class="number">0</span>)+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// cout&lt;&lt;row[i][j]&lt;&lt;" ";</span></span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">int</span> width=row[i][j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&gt;=<span class="number">0</span>&amp;&amp;width&gt;<span class="number">0</span>;k--){</span><br><span class="line">                    width=min(width, row[k][j]);</span><br><span class="line">                    ans+=width;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="计数DP"><a href="#计数DP" class="headerlink" title="计数DP"></a>计数DP</h2><h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a>62. 不同路径</h3><p><strong>Description</strong><br>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>问总共有多少条不同的路径？<br><img src="/assets/img/algorithm/robot_maze.png" alt="image"><br>例如，上图是一个7 x 3 的网格。有多少可能的路径？<br>说明：m 和 n 的值均不超过 100。<br><strong>Example</strong><br>示例 1:<br>输入: m = 3, n = 2<br>输出: 3<br>解释:<br>从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li>向右 -&gt; 向右 -&gt; 向下</li><li>向右 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向右</li></ol><p>示例 2:<br>输入: m = 7, n = 3<br>输出: 28<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP;</span><br><span class="line">        DP.resize(n,<span class="number">0</span>);</span><br><span class="line">        DP[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>) DP[j]+=DP[j<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a>63. 不同路径 II</h3><p><strong>Description</strong><br>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？<br><img src="/assets/img/algorithm/robot_maze.png" alt="image"><br>网格中的障碍物和空位置分别用 1 和 0 来表示。<br>说明：m 和 n 的值均不超过 100。<br><strong>Example</strong><br>示例 1:<br>输入:<br>[<br> [0,0,0],<br> [0,1,0],<br> [0,0,0]<br>]<br>输出: 2<br>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p><ol><li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li></ol><p><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m=obstacleGrid.size();</span><br><span class="line">        <span class="keyword">int</span> n=obstacleGrid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; DP;</span><br><span class="line">        DP.resize(n, <span class="number">0</span>);</span><br><span class="line">        DP[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>) DP[j]+=DP[j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>) DP[j]=<span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a>96. 不同的二叉搜索树</h3><p><strong>Description</strong><br>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？<br><strong>Example</strong><br>示例:<br>输入: 3<br>输出: 5<br>解释:<br>给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1         3     3      2      1</span><br><span class="line"> \       /     /      / \      \</span><br><span class="line">  3     2     1      1   3      2</span><br><span class="line"> /     /       \                 \</span><br><span class="line">2     1         2                 3</span><br></pre></td></tr></tbody></table></figure><p><strong>Program</strong><br>DP[n]：序列n为节点组成的二叉搜索树的个数<br>$DP[n]=sum((DP[i-1]*DP[n-i]) for i in range(1, n))$<br>DP[i-1] 为选择i为根结点下左子树组成的个数，DP[n-i]表示选择i为根结点下右子树组成的个数<br>边界条件DP[0]=DP[1]=1</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        DP[<span class="number">0</span>]=DP[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//DP[n]=sum((DP[i-1]*DP[n-i]) for i in range(1, n))</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++){</span><br><span class="line">                DP[i]+=DP[j<span class="number">-1</span>]*DP[i-j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>DP[n]满足卡特兰数！</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; DP(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        DP[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            DP[i+<span class="number">1</span>]=DP[i]*<span class="number">2</span>*(<span class="number">2</span>*i+<span class="number">1</span>)/(i+<span class="number">2</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a>377. 组合总和 Ⅳ</h3><p><strong>Description</strong><br>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。<br><strong>Example</strong><br>示例:<br>nums = [1, 2, 3]<br>target = 4<br>所有可能的组合为：<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)<br>请注意，顺序不同的序列被视作不同的组合。<br>因此输出为 7。<br><strong>Program</strong><br>暴力就是深搜，动规就是深搜的记忆化搜索翻版，$DP[v]=sum(DP[v-nums[i]]), i\in{[1, n)}$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>&amp;&amp;target!=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt; DP(target+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        DP[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=target;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v:nums){</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=v){</span><br><span class="line">                    DP[i]+=DP[i-v];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[target];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="576-出界的路径数"><a href="#576-出界的路径数" class="headerlink" title="576. 出界的路径数"></a>576. 出界的路径数</h3><p><strong>Description</strong><br>给定一个 m × n 的网格和一个球。球的起始坐标为 (i,j) ，你可以将球移到相邻的单元格内，或者往上、下、左、右四个方向上移动使球穿过网格边界。但是，你最多可以移动 N 次。找出可以将球移出边界的路径数量。答案可能非常大，返回 结果 mod 109 + 7 的值。<br><strong>Example</strong><br>示例 1：<br>输入: m = 2, n = 2, N = 2, i = 0, j = 0<br>输出: 6<br>解释:<br><img src="/assets/img/algorithm/out_of_boundary_paths_1.png" alt="image"><br>示例 2：<br>输入: m = 1, n = 3, N = 3, i = 0, j = 1<br>输出: 12<br>解释:<br><img src="/assets/img/algorithm/out_of_boundary_paths_2.png" alt="image"><br>说明:<br>球一旦出界，就不能再被移动回网格内。<br>网格的长度和高度在 [1,50] 的范围内。<br>N 在 [0,50] 的范围内。<br><strong>Program</strong><br>DP[i][j][v]表示<strong>恰好</strong>走出v步的路径数！但最后要求总数，肯定包括富裕步数走出边界的情况，所以要累加！<br>即走1…N步总的结果</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> step[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        {<span class="number">1</span>, <span class="number">0</span>},</span><br><span class="line">        {<span class="number">-1</span>, <span class="number">0</span>},</span><br><span class="line">        {<span class="number">0</span>, <span class="number">-1</span>},</span><br><span class="line">        {<span class="number">0</span>, <span class="number">1</span>}</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> N, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt;&gt; DP(m, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(N+<span class="number">1</span>, <span class="number">0</span>)));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">            DP[i][<span class="number">0</span>][<span class="number">1</span>]+=<span class="number">1</span>;</span><br><span class="line">            DP[i][n<span class="number">-1</span>][<span class="number">1</span>]+=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            DP[<span class="number">0</span>][i][<span class="number">1</span>]+=<span class="number">1</span>;</span><br><span class="line">            DP[m<span class="number">-1</span>][i][<span class="number">1</span>]+=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">1</span>;v&lt;=N;v++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++){</span><br><span class="line">                        <span class="keyword">int</span> x=i+step[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y=j+step[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;=m||y&lt;<span class="number">0</span>||y&gt;=n) <span class="keyword">continue</span>;</span><br><span class="line">                        DP[i][j][v]+=DP[x][y][v<span class="number">-1</span>];</span><br><span class="line">                        DP[i][j][v]%=mod;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=N;x++){</span><br><span class="line">            DP[i][j][x]+=DP[i][j][x<span class="number">-1</span>];</span><br><span class="line">            DP[i][j][x]%=mod;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> DP[i][j][N];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>DP[i][j][v]表示最终结果，可以有步数v富裕！！相比于记忆化搜索，这个慢了。注意先步数循环，注意DP需要四个方位下的数据都先算出来的！</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> step[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        {<span class="number">1</span>, <span class="number">0</span>},</span><br><span class="line">        {<span class="number">-1</span>, <span class="number">0</span>},</span><br><span class="line">        {<span class="number">0</span>, <span class="number">-1</span>},</span><br><span class="line">        {<span class="number">0</span>, <span class="number">1</span>}</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> N, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt;&gt; DP(m, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(N+<span class="number">1</span>, <span class="number">0</span>)));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">1</span>;v&lt;=N;v++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++){</span><br><span class="line">                        <span class="keyword">int</span> x=i+step[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y=j+step[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;=m||y&lt;<span class="number">0</span>||y&gt;=n){</span><br><span class="line">                            DP[i][j][v]+=<span class="number">1</span>;</span><br><span class="line">                        }<span class="keyword">else</span> DP[i][j][v]+=DP[x][y][v<span class="number">-1</span>];</span><br><span class="line">                        DP[i][j][v]%=mod;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[i][j][N];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>记忆化搜索</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> step[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        {<span class="number">1</span>, <span class="number">0</span>},</span><br><span class="line">        {<span class="number">-1</span>, <span class="number">0</span>},</span><br><span class="line">        {<span class="number">0</span>, <span class="number">-1</span>},</span><br><span class="line">        {<span class="number">0</span>, <span class="number">1</span>}</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> N, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt;&gt; DP(m, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(N+<span class="number">1</span>, <span class="number">-1</span>)));</span><br><span class="line">        <span class="keyword">return</span> findPath(m,n,N,i,j, DP);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPath</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> N,<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt;&gt;&amp; DP)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(N&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=m||j&lt;<span class="number">0</span>||j&gt;=n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(DP[i][j][N]==<span class="number">-1</span>){</span><br><span class="line">            DP[i][j][N]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++){</span><br><span class="line">                <span class="keyword">int</span> x=i+step[k][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y=j+step[k][<span class="number">1</span>];</span><br><span class="line">                DP[i][j][N]+=findPath(m,n,N<span class="number">-1</span>,x, y, DP);</span><br><span class="line">                DP[i][j][N]%=mod;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[i][j][N];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="673-最长递增子序列的个数"><a href="#673-最长递增子序列的个数" class="headerlink" title="673. 最长递增子序列的个数"></a>673. 最长递增子序列的个数</h3><p><strong>Description</strong><br>给定一个未排序的整数数组，找到最长递增子序列的个数。<br><strong>Example</strong><br>示例 1:<br>输入: [1,3,5,4,7]<br>输出: 2<br>解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。</p><p>示例 2:<br>输入: [2,2,2,2,2]<br>输出: 5<br>解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。<br>注意: 给定的数组长度不超过 2000 并且结果一定是32位有符号整数。<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNumberOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP(n, <span class="number">1</span>), count(n ,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> maxN=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++){</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[j]){</span><br><span class="line">                    <span class="keyword">if</span>(DP[j]+<span class="number">1</span>==DP[i]) count[i]+=count[j];</span><br><span class="line">                    <span class="keyword">if</span>(DP[j]+<span class="number">1</span>&gt;DP[i]){</span><br><span class="line">                        DP[i]=DP[j]+<span class="number">1</span>;</span><br><span class="line">                        count[i]=count[j];</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            maxN=max(maxN, DP[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(DP[i]==maxN) ans+=count[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1155-掷骰子的N种方法"><a href="#1155-掷骰子的N种方法" class="headerlink" title="1155. 掷骰子的N种方法"></a>1155. 掷骰子的N种方法</h3><p><strong>Description</strong><br>这里有 d 个一样的骰子，每个骰子上都有 f 个面，分别标号为 1, 2, …, f。<br>我们约定：掷骰子的得到总点数为各骰子面朝上的数字的总和。<br>如果需要掷出的总点数为 target，请你计算出有多少种不同的组合情况（所有的组合情况总共有 f^d 种），模 10^9 + 7 后返回。<br><strong>Example</strong><br>示例 1：<br>输入：d = 1, f = 6, target = 3<br>输出：1</p><p>示例 2：<br>输入：d = 2, f = 6, target = 7<br>输出：6</p><p>示例 3：<br>输入：d = 2, f = 5, target = 10<br>输出：1</p><p>示例 4：<br>输入：d = 1, f = 2, target = 3<br>输出：0</p><p>示例 5：<br>输入：d = 30, f = 30, target = 500<br>输出：222616187</p><p>提示：<br>1 &lt;= d, f &lt;= 30<br>1 &lt;= target &lt;= 1000<br><strong>Program</strong><br>设DP[i][j][t]为前i个骰子在第i个骰子为j，分数为t的总数，则：<br>$DP[i][j][t]=\sum_{k=1}^{f} DP[i-1][k][t-j]$<br>时间复杂度：$O(n^5)，n=30$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> f, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(target&lt;d||target&gt;d*f) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> DP[d+<span class="number">1</span>][f+<span class="number">1</span>][d*f+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=d;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=f;j++){</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">1</span>){</span><br><span class="line">                    DP[<span class="number">1</span>][j][j]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> t=j;t&lt;=d*f;t++){</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=f;k++){</span><br><span class="line">                        DP[i][j][t]=(DP[i][j][t]+DP[i<span class="number">-1</span>][k][t-j])%MOD;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=f;j++){</span><br><span class="line">            ans=(ans+DP[d][j][target])%MOD;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>设DP[i][j]为前i个骰子总分为j的总数，则：<br>$DP[i][j]=\sum_{k=1}^{f} DP[i-1][j-k]$<br>时间复杂度：$O(n^3),n=30$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> f, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(target&lt;d||target&gt;d*f) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> DP[d+<span class="number">1</span>][d*f+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=f;j++) DP[<span class="number">1</span>][j]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=d;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=target;j++){ <span class="comment">//j从i开始，因为i个骰子最低得分为i,如果低于i，则总数为0，这里已经初始化过了，不用计算</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=f&amp;&amp;k&lt;=j;k++){</span><br><span class="line">                    DP[i][j]=(DP[i][j]+DP[i<span class="number">-1</span>][j-k])%MOD;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[d][target];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>空间优化</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> f, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(target&lt;d||target&gt;d*f) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> DP[d*f+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=f;j++) DP[j]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=d;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=target;j&gt;=<span class="number">1</span>;j--){ <span class="comment">//注意j从1开始，因为需要初始化每一行DP[j]，下一行会用到上一行的DP[j]，而上一行某些部分应当为0，即必须全部初始化</span></span><br><span class="line">                DP[j]=<span class="number">0</span>; <span class="comment">//每一行记得初始化！</span></span><br><span class="line">                <span class="keyword">if</span>(j&lt;i) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=f&amp;&amp;k&lt;=j;k++){</span><br><span class="line">                    DP[j]=(DP[j]+DP[j-k])%MOD;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[target];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1223-掷骰子模拟"><a href="#1223-掷骰子模拟" class="headerlink" title="1223. 掷骰子模拟"></a>1223. 掷骰子模拟</h3><p><strong>Description</strong><br>有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。<br>不过我们在使用它时有个约束，就是使得投掷骰子时，连续 掷出数字 i 的次数不能超过 rollMax[i]（i 从 1 开始编号）。<br>现在，给你一个整数数组 rollMax 和一个整数 n，请你来计算掷 n 次骰子可得到的不同点数序列的数量。<br>假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 模 10^9 + 7 之后的结果。<br><strong>Example</strong><br>示例 1：<br>输入：n = 2, rollMax = [1,1,2,2,2,3]<br>输出：34<br>解释：我们掷 2 次骰子，如果没有约束的话，共有 6 * 6 = 36 种可能的组合。但是根据 rollMax 数组，数字 1 和 2 最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36 -2 = 34。</p><p>示例 2：<br>输入：n = 2, rollMax = [1,1,1,1,1,1]<br>输出：30</p><p>示例 3：<br>输入：n = 3, rollMax = [1,1,1,2,2,3]<br>输出：181</p><p>提示：<br>1 &lt;= n &lt;= 5000<br>rollMax.length == 6<br>1 &lt;= rollMax[i] &lt;= 15<br><strong>Program</strong><br><strong>思路</strong><br>用 dp[i][j][k] 表示第 i 轮掷骰子掷出数字 j 时 j 连续出现 k 次的组合数量。<br>那么有状态转移如下：<br>(1)当 j 并非在连续出现时（即 k == 1 时）：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// j 出现 1 次的组合数等于上一轮投出非数字 j 的所有情况和</span><br><span class="line">dp[i][j][1] = sum(dp[i - 1][l != j][:])</span><br></pre></td></tr></tbody></table></figure><p>(2)当 j 连续出现 k(k &gt; 1) 次时：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if k &lt;= rollMax[j]:</span><br><span class="line">    // 本轮投出连续出现 k 次数字 j 的情况数量等于：上一轮连续投掷出 k - 1 次 j 的情况数量</span><br><span class="line">    dp[i][j][k] = dp[i - 1][j][k - 1]</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dieSimulator</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rollMax)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> DP[n+<span class="number">1</span>][<span class="number">7</span>][<span class="number">16</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">6</span>;j++){</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">1</span>){</span><br><span class="line">                    DP[i][j][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">//k==1，第一次j</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=<span class="number">6</span>;l++){</span><br><span class="line">                    <span class="keyword">if</span>(l==j) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">15</span>;k++){</span><br><span class="line">                        DP[i][j][<span class="number">1</span>]=(DP[i][j][<span class="number">1</span>]+DP[i<span class="number">-1</span>][l][k])%MOD;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">//k&gt;1，连续j</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;=rollMax[j<span class="number">-1</span>];k++){</span><br><span class="line">                    DP[i][j][k]=DP[i<span class="number">-1</span>][j][k<span class="number">-1</span>];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">6</span>;j++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">15</span>;k++){</span><br><span class="line">                ans=(ans+DP[n][j][k])%MOD;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="面试题-17-06-2出现的次数"><a href="#面试题-17-06-2出现的次数" class="headerlink" title="面试题 17.06. 2出现的次数"></a>面试题 17.06. 2出现的次数</h3><p><strong>Description</strong><br>编写一个方法，计算从 0 到 n (含 n) 中数字 2 出现的次数。<br><strong>Example</strong><br>示例:<br>输入: 25<br>输出: 9<br>解释: (2, 12, 20, 21, 22, 23, 24, 25)(注意 22 应该算作两次)<br>提示：<br>$n &lt;= 10^9$<br><strong>Program</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">以前写过的都忘了。。。</span><br><span class="line">思路：计算每一位2出现的个数！</span><br><span class="line">以13a31一般式子为例，计算百位2的个数</span><br><span class="line">a=3&gt;2时，有200~299,...,13200~13299一共(13+1)×100个2，注意13是前缀！</span><br><span class="line">a=2==2时，有200~299,...,12200~12299以及13200~13231，一共13×100+31+1个数，注意13是前缀，31是后缀</span><br><span class="line">a=1&lt;2时，有200~299,...,12200~12299一共13×100个数！</span><br><span class="line">所以不失一般性：</span><br><span class="line">xxxayyy</span><br><span class="line">a&gt;3时，一共(xxx+1)×len(yyy)</span><br><span class="line">a==2时，一共xxx×len(yyy)+yyy+1</span><br><span class="line">a&lt;2时，一共xxx×len(yyy)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOf2sInRange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> base=<span class="number">1</span>, post=<span class="number">0</span>; <span class="comment">//基数、后缀</span></span><br><span class="line">        <span class="keyword">int</span> pre=n/<span class="number">10</span>; <span class="comment">//前缀数</span></span><br><span class="line">        <span class="keyword">int</span> res=n%<span class="number">10</span>; <span class="comment">//当前以10*base为基的余数</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=post){</span><br><span class="line">            <span class="keyword">if</span>(res&gt;<span class="number">2</span>) ans+=(pre+<span class="number">1</span>)*base;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(res==<span class="number">2</span>) ans+=pre*base + post + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> ans+=pre*base;</span><br><span class="line">            post+=res*base;</span><br><span class="line">            base*=<span class="number">10</span>;</span><br><span class="line">            res=pre%<span class="number">10</span>;</span><br><span class="line">            pre/=<span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="递推DP"><a href="#递推DP" class="headerlink" title="递推DP"></a>递推DP</h2><h3 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a>64. 最小路径和</h3><p><strong>Description</strong><br>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br>说明：每次只能向下或者向右移动一步。<br><strong>Example</strong><br>示例:<br>输入:<br>[<br> [1,3,1],<br> [1,5,1],<br> [4,2,1]<br>]<br>输出: 7<br>解释: 因为路径 1→3→1→1→1 的总和最小。<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(grid.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m=grid.size();</span><br><span class="line">        <span class="keyword">int</span> n=grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP=grid[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) DP[i]+=DP[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>) DP[j]=min(DP[j], DP[j<span class="number">-1</span>]);</span><br><span class="line">                DP[j]+=grid[i][j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h3><p><strong>Description</strong><br>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数。<br><strong>Example</strong><br>示例 1：<br>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li>2 阶</li></ol><p>示例 2：<br>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol><p><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP;</span><br><span class="line">        DP.resize(n+<span class="number">1</span>);</span><br><span class="line">        DP[<span class="number">0</span>]=DP[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++){</span><br><span class="line">            DP[i]=DP[i<span class="number">-1</span>]+DP[i<span class="number">-2</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1423-可获得的最大点数"><a href="#1423-可获得的最大点数" class="headerlink" title="1423. 可获得的最大点数"></a>1423. 可获得的最大点数</h3><p><strong>Description</strong><br>几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。<br>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。<br>你的点数就是你拿到手中的所有卡牌的点数之和。<br>给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。<br><strong>Example</strong><br>示例 1：<br>输入：cardPoints = [1,2,3,4,5,6,1], k = 3<br>输出：12<br>解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。</p><p>示例 2：<br>输入：cardPoints = [2,2,2], k = 2<br>输出：4<br>解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。</p><p>示例 3：<br>输入：cardPoints = [9,7,7,9,7,7,9], k = 7<br>输出：55<br>解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。</p><p>示例 4：<br>输入：cardPoints = [1,1000,1], k = 1<br>输出：1<br>解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。</p><p>示例 5：<br>输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3<br>输出：202</p><p>提示：<br>1 &lt;= cardPoints.length &lt;= 10^5<br>1 &lt;= cardPoints[i] &lt;= 10^4<br>1 &lt;= k &lt;= cardPoints.length<br><strong>Program</strong><br><strong>常规dfs/动规</strong><br>无论dfs还是动规都超时超限。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// const int inf=0x3f3f3f3f;</span></span><br><span class="line">    <span class="keyword">int</span> vis[<span class="number">100000</span>][<span class="number">100000</span>][<span class="number">100000</span>]={<span class="number">-1</span>};</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cardPoints, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(i&gt;j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(vis[i][j][k]!=<span class="number">-1</span>) <span class="keyword">return</span> vis[i][j][k];</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        ans=max(cardPoints[i]+dfs(cardPoints, i+<span class="number">1</span>, j, k<span class="number">-1</span>), cardPoints[j]+dfs(cardPoints, i, j<span class="number">-1</span>, k<span class="number">-1</span>));</span><br><span class="line">        vis[i][j][k]=ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cardPoints, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> dfs(cardPoints, <span class="number">0</span>, cardPoints.size()<span class="number">-1</span>, k);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>动规变形</strong><br>考虑拿k个，无非数组前后总和k个，可以是：<br>前0，后1<br>…<br>前k，后0<br>即动规递推公式：$DP[n]=max(preSum[i]+preSum[n]-preSum[n-(k-i)]),i=0,1,2,…,k$<br>时间复杂度：$O(n)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cardPoints, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=cardPoints.size();</span><br><span class="line">        <span class="keyword">int</span> preSum[n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(preSum, <span class="number">0</span>, <span class="keyword">sizeof</span>(preSum));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            preSum[i+<span class="number">1</span>]+=cardPoints[i];</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>) preSum[i+<span class="number">1</span>]+=preSum[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++){</span><br><span class="line">            ans=max(ans, preSum[i]+preSum[n]-preSum[n-(k-i)]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1621-大小为-K-的不重叠线段的数目"><a href="#1621-大小为-K-的不重叠线段的数目" class="headerlink" title="1621. 大小为 K 的不重叠线段的数目"></a>1621. 大小为 K 的不重叠线段的数目</h3><p><strong>Description</strong><br>给你一维空间的 n 个点，其中第 i 个点（编号从 0 到 n-1）位于 x = i 处，请你找到 恰好 k 个不重叠 线段且每个线段至少覆盖两个点的方案数。线段的两个端点必须都是 整数坐标 。这 k 个线段不需要全部覆盖全部 n 个点，且它们的端点 可以 重合。<br>请你返回 k 个不重叠线段的方案数。由于答案可能很大，请将结果对 109 + 7 取余 后返回。<br><strong>Example</strong><br>示例 1：<br>输入：n = 4, k = 2<br>输出：5<br>解释：<br>如图所示，两个线段分别用红色和蓝色标出。<br>上图展示了 5 种不同的方案 {(0,2),(2,3)}，{(0,1),(1,3)}，{(0,1),(2,3)}，{(1,2),(2,3)}，{(0,1),(1,2)} 。</p><p>示例 2：<br>输入：n = 3, k = 1<br>输出：3<br>解释：总共有 3 种不同的方案 {(0,1)}, {(0,2)}, {(1,2)} 。</p><p>示例 3：<br>输入：n = 30, k = 7<br>输出：796297179<br>解释：画 7 条线段的总方案数为 3796297200 种。将这个数对 109 + 7 取余得到 796297179 。</p><p>示例 4：<br>输入：n = 5, k = 3<br>输出：7</p><p>示例 5：<br>输入：n = 3, k = 2<br>输出：1</p><p>提示：<br>2 &lt;= n &lt;= 1000<br>1 &lt;= k &lt;= n-1<br><strong>Program</strong><br><strong>动态规划</strong><br>基于之前做过题目的思考，DP[i]为最终答案的话，那么肯定得考虑i是否为最后一条线段的终点，定义就变成了DP[i][2]，DP[i][0]表示最后一条线段不以i为结尾，DP[i][1]表示最后一条线段以i为结尾，但是这还不够，一般来讲需要以最后一条路径DP[0,k],DP[i,j]来递推，类似于单词拆分。但DP[i][j][0]再加上线段数量DP[I][J][K][2]复杂度过高，那么可以考虑类似LCP 秋叶收藏集的做法：<br>设DP[i][j][0]表示[0..i]构造了j条线段且最后一条线段不以i为结尾的方案数，DP[i][j][1]表示[0…i]构造了j条线段且最后一条线段以i为结尾的方案数<br>状态转移方程：<br>（1）$DP[i][j][0]=DP[i-1][j][0]+D[i-1][j][1]$<br>（2）最后一条线段长度为1<br>$DP[i][j][1]=DP[i-1][j-1][0]+DP[i-1][j-1][1]$<br>最后一条线段长度大于1<br>$DP[i][j][1]+=DP[i-1][j][1];<br>时间复杂度：$O(nk)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1001</span>][<span class="number">1001</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfSets</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>, dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=k;j++){</span><br><span class="line">                dp[i][j][<span class="number">0</span>]=(dp[i<span class="number">-1</span>][j][<span class="number">0</span>]+dp[i<span class="number">-1</span>][j][<span class="number">1</span>])%MOD;</span><br><span class="line">                dp[i][j][<span class="number">1</span>]=dp[i<span class="number">-1</span>][j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>){</span><br><span class="line">                    dp[i][j][<span class="number">1</span>]+=dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">                    dp[i][j][<span class="number">1</span>]%=MOD;</span><br><span class="line">                    dp[i][j][<span class="number">1</span>]+=dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">                    dp[i][j][<span class="number">1</span>]%=MOD;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> (dp[n<span class="number">-1</span>][k][<span class="number">0</span>]+dp[n<span class="number">-1</span>][k][<span class="number">1</span>])%MOD;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="背包DP"><a href="#背包DP" class="headerlink" title="背包DP"></a>背包DP</h2><h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a>322. 零钱兑换</h3><p><strong>Description</strong><br>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。<br><strong>Example</strong><br>示例 1:<br>输入: coins = [1, 2, 5], amount = 11<br>输出: 3<br>解释: 11 = 5 + 5 + 1</p><p>示例 2:<br>输入: coins = [2], amount = 3<br>输出: -1<br><strong>Program</strong><br>DP[m][i]=min{DP[m][i-1], DP[m-v[i]][i]+1}，注意边界：DP[0][i]=0, DP[m][0]=inf if m&lt;v[i] else DP[m-v[i]][i]+1;</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(coins.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> n=coins.size();</span><br><span class="line">        <span class="keyword">int</span>** DP=<span class="keyword">new</span> <span class="keyword">int</span>*[amount+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;amount+<span class="number">1</span>;i++) DP[i]=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;amount+<span class="number">1</span>;m++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">                <span class="keyword">if</span>(m==<span class="number">0</span>){</span><br><span class="line">                    DP[m][i]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>){</span><br><span class="line">                    <span class="keyword">if</span>(m&gt;=coins[i]) DP[m][i]=DP[m-coins[i]][i]+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> DP[m][i]=<span class="number">0X3f3f3f3f</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(m&gt;=coins[i]) DP[m][i]=min(DP[m][i<span class="number">-1</span>], DP[m-coins[i]][i]+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> DP[m][i]=DP[m][i<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> (DP[amount][n<span class="number">-1</span>]&gt;=<span class="number">0x3f3f3f3f</span>)?<span class="number">-1</span>:DP[amount][n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>$DP[m]=1+min(DP[m-c_i]+1), i\in{[1, k]}$，边界DP[0]=0;</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(coins.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> n=coins.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP(amount+<span class="number">1</span>, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">        DP[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;amount+<span class="number">1</span>;m++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> w:coins){</span><br><span class="line">                <span class="keyword">if</span>(w&lt;=m) DP[m]=min(DP[m], DP[m-w]+<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> (DP[amount]&gt;=<span class="number">0x3f3f3f3f</span>)?<span class="number">-1</span>:DP[amount];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h3><p><strong>Description</strong><br>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。<br>注意:<br>每个数组中的元素不会超过 100<br>数组的大小不会超过 200<br><strong>Example</strong><br>示例 1:<br>输入: [1, 5, 11, 5]<br>输出: true<br>解释: 数组可以分割成 [1, 5, 5] 和 [11].</p><p>示例 2:<br>输入: [1, 2, 3, 5]<br>输出: false<br>解释: 数组不能分割成两个元素和相等的子集.<br><strong>Program</strong><br>0-1背包，只要满足整个数组和的一半，取或不取就行了。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums) ans+=x;</span><br><span class="line">        <span class="keyword">if</span>((ans&amp;<span class="number">1</span>)!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ans/=<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; DP(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) DP[i].resize(ans+<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;=ans;v++){</span><br><span class="line">                <span class="keyword">if</span>(v==<span class="number">0</span>){</span><br><span class="line">                    DP[i][v]=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;v&gt;=nums[i]) DP[i][v]=DP[i<span class="number">-1</span>][v]||DP[i<span class="number">-1</span>][v-nums[i]];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i!=<span class="number">0</span>) DP[i][v]=DP[i<span class="number">-1</span>][v];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n<span class="number">-1</span>][ans];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>空间优化</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums) ans+=x;</span><br><span class="line">        <span class="keyword">if</span>((ans&amp;<span class="number">1</span>)!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ans/=<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; DP(ans+<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        DP[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v=ans;v&gt;=nums[i];v--){</span><br><span class="line">                DP[v]=DP[v]||DP[v-nums[i]];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[ans];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a>474. 一和零</h3><p><strong>Description</strong><br>在计算机界中，我们总是追求用有限的资源获取最大的收益。<br>现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。<br>你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。<br>注意:<br>给定 0 和 1 的数量都不会超过 100。<br>给定字符串数组的长度不会超过 600。<br><strong>Example</strong><br>示例 1:<br>输入: Array = {“10”, “0001”, “111001”, “1”, “0”}, m = 5, n = 3<br>输出: 4<br>解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 “10”,”0001”,”1”,”0” 。</p><p>示例 2:<br>输入: Array = {“10”, “0”, “1”}, m = 1, n = 1<br>输出: 2<br>解释: 你可以拼出 “10”，但之后就没有剩余数字了。更好的选择是拼出 “0” 和 “1” 。<br><strong>Program</strong><br><strong>①暴力</strong><br>超时</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; zeros, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ones, <span class="keyword">int</span> i, <span class="keyword">int</span> num, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(i==len){</span><br><span class="line">            maxn=max(maxn, num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(zeros[i]&lt;=m&amp;&amp;ones[i]&lt;=n) find(zeros, ones, i+<span class="number">1</span>, num+<span class="number">1</span>, m-zeros[i], n-ones[i]);</span><br><span class="line">        find(zeros, ones, i+<span class="number">1</span>, num, m, n);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(strs.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        len=strs.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; zeros(len, <span class="number">0</span>), ones(len, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++){</span><br><span class="line">            <span class="built_in">string</span> str=strs[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;str.length();j++){</span><br><span class="line">                <span class="keyword">if</span>(str[j]==<span class="string">'1'</span>) ones[i]++;</span><br><span class="line">                <span class="keyword">else</span> zeros[i]++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        find(zeros, ones, <span class="number">0</span>, <span class="number">0</span>, m, n);</span><br><span class="line">        <span class="keyword">return</span> maxn;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>②DP</strong><br>0-1背包，$DP[i][m][n]=max(1+DP[i-1][m-zeros[i]][n-ones[i]], DP[i-1][m][n])$，注意边界</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(strs.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len=strs.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; zeros(len, <span class="number">0</span>), ones(len, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++){</span><br><span class="line">            <span class="built_in">string</span> str=strs[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;str.length();j++){</span><br><span class="line">                <span class="keyword">if</span>(str[j]==<span class="string">'1'</span>) ones[i]++;</span><br><span class="line">                <span class="keyword">else</span> zeros[i]++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; DP(len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++){</span><br><span class="line">            DP[i].resize(m+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m+<span class="number">1</span>;j++) DP[i][j].resize(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=n;k++){</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span>){</span><br><span class="line">                        <span class="keyword">if</span>(j&gt;=zeros[i]&amp;&amp;k&gt;=ones[i]) DP[i][j][k]=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=zeros[i]&amp;&amp;k&gt;=ones[i]){</span><br><span class="line">                        DP[i][j][k]=max(<span class="number">1</span>+DP[i<span class="number">-1</span>][j-zeros[i]][k-ones[i]], DP[i<span class="number">-1</span>][j][k]);</span><br><span class="line">                    }<span class="keyword">else</span>{</span><br><span class="line">                        DP[i][j][k]=DP[i<span class="number">-1</span>][j][k];</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[len<span class="number">-1</span>][m][n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>状态压缩</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(strs.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len=strs.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; zeros(len, <span class="number">0</span>), ones(len, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++){</span><br><span class="line">            <span class="built_in">string</span> str=strs[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;str.length();j++){</span><br><span class="line">                <span class="keyword">if</span>(str[j]==<span class="string">'1'</span>) ones[i]++;</span><br><span class="line">                <span class="keyword">else</span> zeros[i]++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; DP(m+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m+<span class="number">1</span>;i++) DP[i].resize(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">0</span>;j--){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=n;k&gt;=<span class="number">0</span>;k--){</span><br><span class="line">                    <span class="keyword">if</span>(zeros[i]&lt;=j&amp;&amp;ones[i]&lt;=k){</span><br><span class="line">                        DP[j][k]=max(<span class="number">1</span>+DP[j-zeros[i]][k-ones[i]], DP[j][k]);</span><br><span class="line">                    }              </span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[m][n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = strs.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; DP(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i){</span><br><span class="line">            <span class="keyword">int</span> zeros = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> ones = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;strs[i].size();++j){</span><br><span class="line">                <span class="keyword">if</span>(strs[i][j] == <span class="string">'1'</span>) ++ones;</span><br><span class="line">                <span class="keyword">else</span> ++zeros;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= zeros; --j){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = n; k &gt;= ones; --k){</span><br><span class="line">                    DP[j][k] = max(<span class="number">1</span> + DP[j-zeros][k-ones], DP[j][k]);             </span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[m][n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a>494. 目标和</h3><p><strong>Description</strong><br>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。<br>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。<br><strong>Example</strong><br>示例 1:<br>输入: nums: [1, 1, 1, 1, 1], S: 3<br>输出: 5<br>解释:<br>-1+1+1+1+1 = 3<br>+1-1+1+1+1 = 3<br>+1+1-1+1+1 = 3<br>+1+1+1-1+1 = 3<br>+1+1+1+1-1 = 3</p><p>一共有5种方法让最终目标和为3。<br>注意:<br>数组非空，且长度不会超过20。<br>初始的数组的和不会超过1000。<br>保证返回的最终结果能被32位整数存下。<br><strong>Program</strong><br><strong>①暴力</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums, <span class="keyword">int</span> i, <span class="keyword">int</span> S, <span class="keyword">int</span> sum)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(i==nums.size()){</span><br><span class="line">            <span class="keyword">if</span>(sum==S){</span><br><span class="line">                ans++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        helper(nums, i+<span class="number">1</span>, S, sum+nums[i]);</span><br><span class="line">        helper(nums, i+<span class="number">1</span>, S, sum-nums[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>{</span><br><span class="line">        helper(nums, <span class="number">0</span>, S, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>②DP</strong><br>类似于背包问题，设DP[i][j]为0…i中结果为j的个数，那么DP[i][j]=DP[i-1][j-nums[i]]+DP[i-1][j+nums[i]]</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums) sum+=x;</span><br><span class="line">        <span class="keyword">if</span>(S&gt;sum) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//特判</span></span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">2</span>*sum+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; DP(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(t, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;t;j++){</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>){</span><br><span class="line">                    <span class="keyword">if</span>(j==sum-nums[i]) DP[i][j]+=<span class="number">1</span>; <span class="comment">//注意sum-nums[i]可能等于sum+nums[i]</span></span><br><span class="line">                    <span class="keyword">if</span>(j==sum+nums[i]) DP[i][j]+=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(j-nums[i]&gt;=<span class="number">0</span>&amp;&amp;j+nums[i]&lt;t) DP[i][j]=DP[i<span class="number">-1</span>][j-nums[i]]+DP[i<span class="number">-1</span>][j+nums[i]];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j-nums[i]&gt;=<span class="number">0</span>) DP[i][j]=DP[i<span class="number">-1</span>][j-nums[i]];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j+nums[i]&lt;t) DP[i][j]=DP[i<span class="number">-1</span>][j+nums[i]];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n<span class="number">-1</span>][sum+S];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>③DP优化</strong><br>DP[i][j]=DP[i-1][j-nums[i]]+DP[i-1][j+nums[i]]只与前一行有关，所以只需要两个一维数组即可！</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums) sum+=x;</span><br><span class="line">        <span class="keyword">if</span>(S&gt;sum) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//特判</span></span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">2</span>*sum+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP(t, <span class="number">0</span>), preDP(t, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;t;j++){</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>){</span><br><span class="line">                    <span class="keyword">if</span>(j==sum-nums[i]) DP[j]+=<span class="number">1</span>; <span class="comment">//注意sum-nums[i]可能等于sum+nums[i]</span></span><br><span class="line">                    <span class="keyword">if</span>(j==sum+nums[i]) DP[j]+=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(j-nums[i]&gt;=<span class="number">0</span>&amp;&amp;j+nums[i]&lt;t) DP[j]=preDP[j-nums[i]]+preDP[j+nums[i]];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j-nums[i]&gt;=<span class="number">0</span>) DP[j]=preDP[j-nums[i]];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j+nums[i]&lt;t) DP[j]=preDP[j+nums[i]];</span><br><span class="line">            }</span><br><span class="line">            preDP=DP;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[sum+S];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="面试题-08-11-硬币"><a href="#面试题-08-11-硬币" class="headerlink" title="面试题 08.11. 硬币"></a>面试题 08.11. 硬币</h3><p><strong>Description</strong><br>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)<br><strong>Example</strong><br>示例1:<br> 输入: n = 5<br> 输出：2<br> 解释: 有两种方式可以凑成总金额:<br>5=5<br>5=1+1+1+1+1<br>示例2:<br> 输入: n = 10<br> 输出：4<br> 解释: 有四种方式可以凑成总金额:<br>10=10<br>10=5+5<br>10=5+1+1+1+1+1<br>10=1+1+1+1+1+1+1+1+1+1</p><p>说明：<br>注意:<br>你可以假设：<br>0 &lt;= n (总金额) &lt;= 1000000<br><strong>Program</strong><br>典型动规，DP[m][i]=DP[m][i-1]+DP[m-w[i]][i],边界DP[0][i]=1；</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> w[<span class="number">5</span>]={<span class="number">0</span>, <span class="number">25</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>};</span><br><span class="line">        <span class="keyword">int</span> DP[n+<span class="number">1</span>][<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="comment">//vector&lt;vector&lt;int&gt;&gt; DP(n+1, vector&lt;int&gt;(5, 0));</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) DP[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">1</span>;m&lt;=n;m++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++){</span><br><span class="line">                DP[m][i]=DP[m][i<span class="number">-1</span>]%MOD;</span><br><span class="line">                <span class="keyword">if</span>(m&gt;=w[i])DP[m][i]=(DP[m][i<span class="number">-1</span>]+DP[m-w[i]][i])%MOD;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n][<span class="number">4</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049. 最后一块石头的重量 II"></a>1049. 最后一块石头的重量 II</h3><p><strong>Description</strong><br>有一堆石头，每块石头的重量都是正整数。<br>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：<br>如果 x == y，那么两块石头都会被完全粉碎；<br>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。<br>最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。<br><strong>Example</strong><br>示例：<br>输入：[2,7,4,1,8,1]<br>输出：1<br>解释：<br>组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，<br>组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，<br>组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，<br>组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</p><p>提示：<br>1 &lt;= stones.length &lt;= 30<br>1 &lt;= stones[i] &lt;= 1000<br><strong>Program</strong><br><strong>0-1背包问题</strong><br>此题要求最后剩余石头重量最小，那么可以考虑将石头分成两堆，使得两堆的和尽可能接近，所以类似于背包容量为$sum/2$，尽可能装满，最后$sum-DP[n-1][target] * 2$就是答案。<br>$DP[i][j]$代表前i种已经出现的石头，背包容量为j的情况下，能得到的最大值。<br>$DP[i][j]=max(DP[i-1][j],DP[i-1][j-stones[i]]+stones[i]);$<br>注意边界；</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=stones.size();</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:stones) sum+=x;</span><br><span class="line">        <span class="keyword">int</span> target=sum/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> DP[n+<span class="number">1</span>][target+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=target;j++){</span><br><span class="line">                <span class="keyword">if</span>(j&lt;stones[i<span class="number">-1</span>]) DP[i][j]=DP[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> DP[i][j]=max(DP[i<span class="number">-1</span>][j], DP[i<span class="number">-1</span>][j-stones[i<span class="number">-1</span>]]+stones[i<span class="number">-1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum-DP[n][target]*<span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="博弈DP"><a href="#博弈DP" class="headerlink" title="博弈DP"></a>博弈DP</h2><h3 id="464-我能赢吗"><a href="#464-我能赢吗" class="headerlink" title="464. 我能赢吗"></a>464. 我能赢吗</h3><p><strong>Description</strong><br>在 “100 game” 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和达到 100 的玩家，即为胜者。<br>如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？<br>例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &gt;= 100。<br>给定一个整数 maxChoosableInteger （整数池中可选择的最大数）和另一个整数 desiredTotal（累计和），判断先出手的玩家是否能稳赢（假设两位玩家游戏时都表现最佳）？<br>你可以假设 maxChoosableInteger 不会大于 20， desiredTotal 不会大于 300。<br><strong>Example</strong><br>示例：<br>输入：<br>maxChoosableInteger = 10<br>desiredTotal = 11<br>输出：<br>false<br>解释：<br>无论第一个玩家选择哪个整数，他都会失败。<br>第一个玩家可以选择从 1 到 10 的整数。<br>如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。<br>第二个玩家可以通过选择整数 10（那么累积和为 11 &gt;= desiredTotal），从而取得胜利.<br>同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。<br><strong>Program</strong><br>DP[num][total]=!DP[num|i][total-i] if i&lt;total else 1;<br>num用二进制表示共有maxChoosableInteger位，选择了i则其第i-1为数字为1，表示已选。<br>DP[num][total]表示当前选取的num组合下先手在total下的输赢情况。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vis, <span class="keyword">int</span> num, <span class="keyword">int</span> mvalue, <span class="keyword">int</span> total)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(vis[num]!=<span class="number">-1</span>) <span class="keyword">return</span> vis[num];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mvalue;i++){</span><br><span class="line">            <span class="keyword">int</span> cur=(<span class="number">1</span>&lt;&lt;i); <span class="comment">//选择i+1</span></span><br><span class="line">            <span class="keyword">if</span>((num&amp;cur)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&gt;=total){</span><br><span class="line">                vis[num]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">bool</span> next=helper(vis, (num|cur), mvalue, total-i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(next==<span class="literal">false</span>){</span><br><span class="line">                vis[num]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(vis[num]==<span class="number">-1</span>) vis[num]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> vis[num];</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canIWin</span><span class="params">(<span class="keyword">int</span> maxChoosableInteger, <span class="keyword">int</span> desiredTotal)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>((maxChoosableInteger*(maxChoosableInteger+<span class="number">1</span>)/<span class="number">2</span>)&lt;desiredTotal) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vis((<span class="number">1</span>&lt;&lt;maxChoosableInteger)<span class="number">-1</span>, <span class="number">-1</span>); <span class="comment">//-1没计算，0和1代表计算后不能赢和能赢</span></span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(vis, num, maxChoosableInteger, desiredTotal);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="486-预测赢家"><a href="#486-预测赢家" class="headerlink" title="486. 预测赢家"></a>486. 预测赢家</h3><p><strong>Description</strong><br>给定一个表示分数的非负整数数组。 玩家1从数组任意一端拿取一个分数，随后玩家2继续从剩余数组任意一端拿取分数，然后玩家1拿，……。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。<br>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。<br><strong>Example</strong><br>示例 1:<br>输入: [1, 5, 2]<br>输出: False<br>解释: 一开始，玩家1可以从1和2中进行选择。<br>如果他选择2（或者1），那么玩家2可以从1（或者2）和5中进行选择。如果玩家2选择了5，那么玩家1则只剩下1（或者2）可选。<br>所以，玩家1的最终分数为 1 + 2 = 3，而玩家2为 5。<br>因此，玩家1永远不会成为赢家，返回 False。</p><p>示例 2:<br>输入: [1, 5, 233, 7]<br>输出: True<br>解释: 玩家1一开始选择1。然后玩家2必须从5和7中进行选择。无论玩家2选择了哪个，玩家1都可以选择233。<br>最终，玩家1（234分）比玩家2（12分）获得更多的分数，所以返回 True，表示玩家1可以成为赢家。<br>注意:<br>1 &lt;= 给定的数组长度 &lt;= 20.<br>数组里所有分数都为非负数且不会大于10000000。<br>如果最终两个玩家的分数相等，那么玩家1仍为赢家。<br><strong>Program</strong><br>博弈论还是不会，太菜了…<br><strong>①暴力深搜</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> helper(<span class="number">0</span>, nums.size() - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, nums);</span><br><span class="line">	}</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> score_A, <span class="keyword">int</span> score_B, <span class="keyword">bool</span> isA_B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right){</span><br><span class="line">            <span class="keyword">return</span> score_A&gt;=score_B;  <span class="comment">//平局也算A胜</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(isA_B){ <span class="comment">//A无论选左还是右，满足一项即可</span></span><br><span class="line">            <span class="keyword">bool</span> bL=helper(left+<span class="number">1</span>, right, score_A+nums[left], score_B, !isA_B, nums);</span><br><span class="line">            <span class="keyword">bool</span> bR=helper(left, right<span class="number">-1</span>, score_A+nums[right], score_B, !isA_B, nums);</span><br><span class="line">            <span class="keyword">return</span> (bL||bR);</span><br><span class="line">        }<span class="keyword">else</span>{ <span class="comment">//B只有左右都满足才能保证A胜</span></span><br><span class="line">            <span class="keyword">bool</span> bL=helper(left+<span class="number">1</span>, right, score_A, score_B+nums[left], !isA_B, nums);</span><br><span class="line">            <span class="keyword">bool</span> bR=helper(left, right<span class="number">-1</span>, score_A, score_B+nums[right], !isA_B, nums);</span><br><span class="line">            <span class="keyword">return</span> (bL&amp;&amp;bR);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>, <span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> factor)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(left==right) <span class="keyword">return</span> factor*nums[left];</span><br><span class="line">        <span class="keyword">int</span> a=factor*nums[left]+helper(nums, left+<span class="number">1</span>, right, -factor);</span><br><span class="line">        <span class="keyword">int</span> b=factor*nums[right]+helper(nums,left, right<span class="number">-1</span>, -factor);</span><br><span class="line">        <span class="keyword">return</span> (factor==<span class="number">1</span>)?max(a, b):min(a, b);  <span class="comment">//对弈双方都希望利益最大化，先手来说，差越大越好，反手来说，差越小越好。</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>②DP</strong><br>设DP[i][j]表示选择了nums[i, j]后两个对手分数之差（这个是关键，博弈论关键找到一个联系点才能统一！），<br>$DP[i][j]=max(nums[i]-DP[i+1][j], nums[j]-DP[i][j-1])$ 注意体会！两个对手状态统一于DP，逆向思维，由里向外<br>例如：[1, 5, 2, 7]<br>A:1<br>B:5<br>A:2<br>B:7<br>差为1-5+2-7=1-[5-(2-7)]<br>可以发现，差本来是摆动的，全部可以转成减法</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">		    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; DP(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            DP[i][i]=nums[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+len<span class="number">-1</span>&lt;n;i++){</span><br><span class="line">                <span class="keyword">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line">                DP[i][j]=max(nums[i]-DP[i+<span class="number">1</span>][j], nums[j]-DP[i][j<span class="number">-1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[<span class="number">0</span>][n<span class="number">-1</span>]&gt;=<span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>记忆化搜索</strong><br>helper记录先手在[left,right]下的最高得分，所以递推公式：<br>score=max(sum-helper(left+1, right, sum-nums[left]), sum-helper(left, right-1, sum-nums[right]));<br>即先手在[left,right]的最高得分，与两种情况有关：<br>①先手选择nums[left]，则其最高得分为sum-helper(left+1,right, sum-nums[left]),其中helper(left+1,right,sum-nums[left])为后手在[left+1, right]区间上先手的最高得分！<br>②同理，先手选择nums[right]，则其最高得分为sum-helper(left, right-1, sum-nums[right])，其中helper(left, right-1, sum-nums[right])为后手在[left, right-1]区间上先手的最高得分！<br>最后判断先手在[left, right]上的最高得分是否超过floor((sum+1)/2)即可。<br>由于存在重复计算，所以需要vis[left][right]记录当前计算的区间[left, right]的结果，避免重复计算。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> sum)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(vis[left][right]!=<span class="number">-1</span>) <span class="keyword">return</span> vis[left][right];</span><br><span class="line">        <span class="keyword">int</span> score1=sum-helper(nums, left+<span class="number">1</span>, right, sum-nums[left]);</span><br><span class="line">        <span class="keyword">int</span> score2=sum-helper(nums, left, right<span class="number">-1</span>, sum-nums[right]);</span><br><span class="line">        <span class="keyword">int</span> score=max(score1, score2);</span><br><span class="line">        vis[left][right]=score;</span><br><span class="line">        <span class="keyword">return</span> vis[left][right];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> sum=accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">        vis.resize(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">int</span> score=helper(nums, <span class="number">0</span>, n<span class="number">-1</span>, sum);</span><br><span class="line">        <span class="keyword">return</span> score&gt;=(sum+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>DP</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> DP[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> preSum[n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="built_in">memset</span>(preSum, <span class="number">0</span>, <span class="keyword">sizeof</span>(preSum));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            preSum[i]+=preSum[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>];</span><br><span class="line">            DP[i][i]=preSum[i]-preSum[i<span class="number">-1</span>]; <span class="comment">//i==j时特判</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line">                DP[i][j]=max(preSum[j]-preSum[i<span class="number">-1</span>]-DP[i+<span class="number">1</span>][j],</span><br><span class="line">                             preSum[j]-preSum[i<span class="number">-1</span>]-DP[i][j<span class="number">-1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[<span class="number">1</span>][n]&gt;=(preSum[n]+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1140-石子游戏-II"><a href="#1140-石子游戏-II" class="headerlink" title="1140. 石子游戏 II"></a>1140. 石子游戏 II</h3><p><strong>Description</strong><br>亚历克斯和李继续他们的石子游戏。许多堆石子 排成一行，每堆都有正整数颗石子 piles[i]。游戏以谁手中的石子最多来决出胜负。<br>亚历克斯和李轮流进行，亚历克斯先开始。最初，M = 1。<br>在每个玩家的回合中，该玩家可以拿走剩下的 前 X 堆的所有石子，其中 1 &lt;= X &lt;= 2M。然后，令 M = max(M, X)。<br>游戏一直持续到所有石子都被拿走。<br>假设亚历克斯和李都发挥出最佳水平，返回亚历克斯可以得到的最大数量的石头。<br><strong>Example</strong><br>示例：<br>输入：piles = [2,7,9,4,4]<br>输出：10<br>解释：<br>如果亚历克斯在开始时拿走一堆石子，李拿走两堆，接着亚历克斯也拿走两堆。在这种情况下，亚历克斯可以拿到 2 + 4 + 4 = 10 颗石子。<br>如果亚历克斯在开始时拿走两堆石子，那么李就可以拿走剩下全部三堆石子。在这种情况下，亚历克斯可以拿到 2 + 7 = 9 颗石子。<br>所以我们返回更大的 10。</p><p>提示：<br>1 &lt;= piles.length &lt;= 100<br>1 &lt;= piles[i] &lt;= 10 ^ 4<br><strong>Program</strong><br>思路：<br>本题难点在于理解两者都发挥“最佳水平”，“最佳水平”在于，每当轮到自己拿石子的时候，要在后继的所有状态中，选择对自己最有利的，那么也就是要遍历后继的所有状态，并选择一个最优解。我们设 dfs(i, M) 表示，当从第 i 堆石子开始拿，允许拿 M &lt;= x &lt;= 2 * M 时，在剩余石子中所能拿到的最大值，那么我们最终要返回的结果就是 dfs(0, 1)。搜索状态时，我们要遵循以下几个原则：</p><ul><li>如果 i &gt;= n，那么说明石子都已经拿完，直接返回 0；</li><li>如果 i + M * 2 &gt;= n，那么说明可以把剩余石子一起拿到，就可以直接返回剩余石子的数目 sum(piles[i:])；</li><li>如果不属于以上两种情况，那么我们需要遍历 1 &lt;= x &lt;= 2 * M，求剩余的最小 dfs(i + x, max(x, M))，也就是自己拿多少的时候，对手拿的石子最少（由于剩余石子数固定，那么最小化对手石子数，就是最大化自己的石子数）。<br>为了防止重复搜索，可以采用记忆化的方法。为了快速求剩余石子数目，可以提前处理后缀和。<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum;</span><br><span class="line">    <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> n, <span class="keyword">int</span> start, <span class="keyword">int</span> m)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(vis.find(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(start, m))!=vis.end()) <span class="keyword">return</span> vis[pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(start, m)];</span><br><span class="line">        <span class="keyword">if</span>(start&gt;=n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(start+<span class="number">2</span>*m&gt;=n) <span class="keyword">return</span> sum[start];</span><br><span class="line">        <span class="keyword">int</span> best=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;<span class="number">2</span>*m;x++){</span><br><span class="line">            best=max(best, sum[start]-dfs(piles, n, start+x+<span class="number">1</span>, max(x+<span class="number">1</span>,m)));</span><br><span class="line">        }</span><br><span class="line">        vis[pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(start, m)]=best;</span><br><span class="line">        <span class="keyword">return</span> best;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stoneGameII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=piles.size();</span><br><span class="line">        sum.resize(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            sum[i]=piles[i];</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&lt;=n<span class="number">-1</span>)sum[i]+=sum[i+<span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dfs(piles, n, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stoneGameII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=piles.size();</span><br><span class="line">        <span class="keyword">int</span> DP[n][n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            sum+=piles[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">1</span>;m&lt;=n;m++){</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">2</span>*m&gt;=n){</span><br><span class="line">                    DP[i][m]=sum;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;<span class="number">2</span>*m&amp;&amp;i+x&lt;n;x++){</span><br><span class="line">                    DP[i][m]=max(DP[i][m], sum-DP[i+x+<span class="number">1</span>][max(x+<span class="number">1</span>,m)]);</span><br><span class="line">                }</span><br><span class="line">            }  </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="292-Nim-游戏"><a href="#292-Nim-游戏" class="headerlink" title="292. Nim 游戏"></a>292. Nim 游戏</h3></li></ul><p><strong>Description</strong><br>你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。<br>你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。<br><strong>Example</strong><br>示例:<br>输入: 4<br>输出: false<br>解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；<br> 因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。<br><strong>Program</strong><br><strong>动规</strong><br>动规的思路，从当前i+1~i+3选，如果能赢就返回，或者后一个选手能输，就能赢。<br>很遗憾，超时。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="keyword">return</span> vis[i];</span><br><span class="line">        <span class="keyword">bool</span> isWin=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">3</span>;s&gt;=<span class="number">1</span>;s--){</span><br><span class="line">            <span class="keyword">if</span>(i+s&gt;=N) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!dfs(i+s)) isWin=<span class="literal">true</span>;;</span><br><span class="line">        }</span><br><span class="line">        vis[i]=isWin;</span><br><span class="line">        <span class="keyword">return</span> isWin;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        N=n;</span><br><span class="line">        vis.resize(n+<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>另一个动规，然而n范围太大，内存超了。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> DP[n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="literal">false</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        DP[<span class="number">1</span>]=DP[<span class="number">2</span>]=DP[<span class="number">3</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>;s&lt;=<span class="number">3</span>;s++){</span><br><span class="line">                <span class="keyword">if</span>(!DP[i-s]){</span><br><span class="line">                    DP[i]=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>空间优化还是超时！</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// bool DP[n+1];</span></span><br><span class="line">        <span class="comment">// memset(DP, false, sizeof(DP));</span></span><br><span class="line">        <span class="comment">// DP[1]=DP[2]=DP[3]=true;</span></span><br><span class="line">        <span class="keyword">bool</span> dp[<span class="number">4</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=dp[<span class="number">2</span>]=dp[<span class="number">3</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> nowDP=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=n;i++){</span><br><span class="line">            nowDP=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>;s&lt;=<span class="number">3</span>;s++){</span><br><span class="line">                <span class="keyword">if</span>(!dp[s]){</span><br><span class="line">                    nowDP=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            dp[<span class="number">1</span>]=dp[<span class="number">2</span>];</span><br><span class="line">            dp[<span class="number">2</span>]=dp[<span class="number">3</span>];</span><br><span class="line">            dp[<span class="number">3</span>]=nowDP;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nowDP;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>博弈论</strong><br>由于选手足够聪明和规则巧妙设计，先手在给出的状态下总是必胜或者必败的。</p><p>必败态和必胜态的定义：<br>必胜态：如果一个状态的后继状态中存在必败态，那么这种该状态下，先手必胜。<br>必败态：如果一个状态的所有后继状态都是必胜态，那么这种状态下，先手必败。</p><p>（1）无法进行任何移动的局面（也就是terminal position）是必败态；<br>（2）可以移动到必败态的局面是必胜态；<br>（3）所有移动都导致必胜态的局面是必败态。<br>（4）若面临末状态者为获胜则末状态为胜态否则末状态为必败态。<br>（5）一个局面是胜态的充要条件是该局面进行某种决策后会成为必败态。<br>（6）一个局面是必败态的充要条件是该局面无论进行何种决策均会成为胜态</p><p>这与我们的dfs思路是一致的。<br>根据以上两个DP的分析，一个必败态（比如4）必能转成三个必胜态（1,2,3）。<br>而4为必败态，可以推到5,6,7为必胜态；<br>由必胜态5,6,7，可得8为必败态；<br>同理，9,10,11,必胜态，12必败态…<br>所以凡为4的倍数都为必败态，包括0.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> n%(<span class="number">3</span>+<span class="number">1</span>)!=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1025-除数博弈"><a href="#1025-除数博弈" class="headerlink" title="1025. 除数博弈"></a>1025. 除数博弈</h3><p><strong>Description</strong><br>爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。<br>最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：<br>选出任一 x，满足 $0 &lt; x &lt; N 且 N % x == 0$ 。<br>用 N - x 替换黑板上的数字 N 。<br>如果玩家无法执行这些操作，就会输掉游戏。<br>只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。<br><strong>Example</strong><br>示例 1：<br>输入：2<br>输出：true<br>解释：爱丽丝选择 1，鲍勃无法进行操作。</p><p>示例 2：<br>输入：3<br>输出：false<br>解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。</p><p>提示：<br>1 &lt;= N &lt;= 1000<br><strong>Program</strong><br><strong>记忆化搜索</strong><br>只要当前选择x后，对手会输，则自己会赢！<br>超时。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> vis[<span class="number">1001</span>];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> N)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(vis[N]!=<span class="number">-1</span>) <span class="keyword">return</span> vis[N];</span><br><span class="line">        <span class="keyword">bool</span> isWin=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;N;x++){</span><br><span class="line">            <span class="keyword">if</span>(N%x==<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(!divisorGame(N-x)){</span><br><span class="line">                    isWin=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                };</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// cout&lt;&lt;N&lt;&lt;" "&lt;&lt;isWin&lt;&lt;endl;</span></span><br><span class="line">        vis[N]=isWin;</span><br><span class="line">        <span class="keyword">return</span> isWin;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">-1</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">return</span> dfs(N);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; m;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//必败</span></span><br><span class="line">        <span class="keyword">if</span>(m.find(n)!=m.end()) <span class="keyword">return</span> m[n];</span><br><span class="line">        <span class="keyword">bool</span> isWin=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(n%i==<span class="number">0</span>) isWin|=!dfs(n-i);</span><br><span class="line">        }</span><br><span class="line">        m[n]=isWin;</span><br><span class="line">        <span class="keyword">return</span> m[n];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> dfs(N);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>动态规划</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        <span class="keyword">bool</span> DP[<span class="number">1001</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="literal">false</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;i;x++){</span><br><span class="line">                <span class="keyword">if</span>(i%x==<span class="number">0</span>&amp;&amp;!DP[i-x]){</span><br><span class="line">                    DP[i]=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//cout&lt;&lt;DP[i]&lt;&lt;endl;</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[N];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        <span class="keyword">bool</span> DP[N+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="literal">false</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++){</span><br><span class="line">                <span class="keyword">if</span>(i%j==<span class="number">0</span>) DP[i]|=!DP[i-j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[N];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>博弈论</strong><br>由于选手足够聪明和规则巧妙设计，先手在给出的状态下总是必胜或者必败的。</p><p>必败态和必胜态的定义：<br>必胜态：如果一个状态的后继状态中存在必败态，那么这种该状态下，先手必胜。<br>必败态：如果一个状态的所有后继状态都是必胜态，那么这种状态下，先手必败。</p><p>（1）无法进行任何移动的局面（也就是terminal position）是必败态；<br>（2）可以移动到必败态的局面是必胜态；<br>（3）所有移动都导致必胜态的局面是必败态。<br>（4）若面临末状态者为获胜则末状态为胜态否则末状态为必败态。<br>（5）一个局面是胜态的充要条件是该局面进行某种决策后会成为必败态。<br>（6）一个局面是必败态的充要条件是该局面无论进行何种决策均会成为胜态<br><img src="/assets/img/algorithm/1025_example_01.jpg" alt="image"><br>与上文dfs和动规思路一致，这里设P为必胜态，N为必败态，那么一个状态能够转到另一个必败态则该状态为必胜态！<br>如图所示：<br>1：可见无法操作，必败态！<br>2：只有一种操作，到1，所以必胜态！<br>3：只有一种操作，到2，必败态！<br>4：两种操作，到3和2，可以到达必败态，所以此为必胜态！<br>…<br>可以看出规律，偶数必胜，奇数必败！</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> N%<span class="number">2</span>==<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="877-石子游戏"><a href="#877-石子游戏" class="headerlink" title="877. 石子游戏"></a>877. 石子游戏</h3><p><strong>Description</strong><br>亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。<br>游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。<br>亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。<br>假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。<br><strong>Example</strong><br>示例：<br>输入：[5,3,4,5]<br>输出：true<br>解释：<br>亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。<br>假设他取了前 5 颗，这一行就变成了 [3,4,5] 。<br>如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。<br>如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。<br>这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。</p><p>提示：<br>2 &lt;= piles.length &lt;= 500<br>piles.length 是偶数。<br>1 &lt;= piles[i] &lt;= 500<br>sum(piles) 是奇数。<br><strong>Program</strong><br><strong>记忆化搜索</strong><br>记dfs(sum, i, j)为当前区间[i,j]，和为sum时，选手最优得分，<br>很明显：<br>(1)$i&gt;j$时，return 0;</p><p>(2)计算区间[i,j]时，选手的最优得分</p><ul><li>选择头元素，score1=piles[i]+sum-piles[i]-dfs(sum-piles[i], i+1, j); //此时dfs为另一个选手的最优得分，本选手最优得分当然是区间[i+1,j]和减去下个选手在[i+1,j]上的最优得分，以下同理。</li><li>选择尾元素，score2=piles[j]+sum-piles[j]-dfs(sum-piles[j], i,j-1);<br>所以当前选手最优得分：score=max(score1, score2);</li></ul><p>(3)有重复计算，记录vis[i][j]即可。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles,<span class="keyword">int</span> sum, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(i&gt;j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(vis[i][j]!=<span class="number">-1</span>) <span class="keyword">return</span> vis[i][j];</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> score1=piles[i]+sum-piles[i]-dfs(piles, sum-piles[i], i+<span class="number">1</span>,j);</span><br><span class="line">        <span class="keyword">int</span> score2=piles[j]+sum-piles[j]-dfs(piles, sum-piles[j], i, j<span class="number">-1</span>);</span><br><span class="line">        ans=max(score1, score2);</span><br><span class="line">        vis[i][j]=ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">stoneGame</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=piles.size();</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        vis.resize(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:piles) sum+=x;</span><br><span class="line">        <span class="keyword">return</span> dfs(piles, sum, <span class="number">0</span>, n<span class="number">-1</span>)&gt;sum/<span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>动态规划</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">stoneGame</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=piles.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum(n, <span class="number">0</span>);  <span class="comment">//前缀和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            sum[i]+=piles[i];</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>) sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; DP(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">int</span> s=(i&gt;<span class="number">0</span>)?sum[j]-sum[i<span class="number">-1</span>]:sum[j];</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n) DP[i][j]=max(DP[i][j], piles[i]+s-piles[i]-DP[i+<span class="number">1</span>][j]);</span><br><span class="line">                <span class="keyword">if</span>(j<span class="number">-1</span>&gt;=<span class="number">0</span>)DP[i][j]=max(DP[i][j], piles[j]+s-piles[j]-DP[i][j<span class="number">-1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[<span class="number">0</span>][n<span class="number">-1</span>]&gt;sum[n<span class="number">-1</span>]/<span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="dfs-记忆化搜索"><a href="#dfs-记忆化搜索" class="headerlink" title="dfs/记忆化搜索"></a>dfs/记忆化搜索</h2><h3 id="638-大礼包"><a href="#638-大礼包" class="headerlink" title="638. 大礼包"></a>638. 大礼包</h3><p><strong>Description</strong><br>在LeetCode商店中， 有许多在售的物品。<br>然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。<br>现给定每个物品的价格，每个大礼包包含物品的清单，以及待购物品清单。请输出确切完成待购清单的最低花费。<br>每个大礼包的由一个数组中的一组数据描述，最后一个数字代表大礼包的价格，其他数字分别表示内含的其他种类物品的数量。<br>任意大礼包可无限次购买。<br><strong>Example</strong><br>示例 1:<br>输入: [2,5], [[3,0,5],[1,2,10]], [3,2]<br>输出: 14<br>解释:<br>有A和B两种物品，价格分别为¥2和¥5。<br>大礼包1，你可以以¥5的价格购买3A和0B。<br>大礼包2， 你可以以¥10的价格购买1A和2B。<br>你需要购买3个A和2个B， 所以你付了¥10购买了1A和2B（大礼包2），以及¥4购买2A。</p><p>示例 2:<br>输入: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]<br>输出: 11<br>解释:<br>A，B，C的价格分别为¥2，¥3，¥4.<br>你可以用¥4购买1A和1B，也可以用¥9购买2A，2B和1C。<br>你需要买1A，2B和1C，所以你付了¥4买了1A和1B（大礼包1），以及¥3购买1B， ¥4购买1C。<br>你不可以购买超出待购清单的物品，尽管购买大礼包2更加便宜。</p><p>说明:<br>最多6种物品， 100种大礼包。<br>每种物品，你最多只需要购买6个。<br>你不可以购买超出待购清单的物品，即使更便宜。<br><strong>Program</strong><br><strong>①暴力</strong><br>这题不好DP，相反深搜更容易些，因为物品种类会变化。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> minSum=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; price, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; needs, <span class="keyword">int</span> sum)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;minSum) <span class="keyword">return</span>;  <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;special.size();i++){</span><br><span class="line">            <span class="keyword">int</span> n=special[i].size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmpNeeds(needs.begin(), needs.end());</span><br><span class="line">            <span class="keyword">bool</span> isPass=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>;j++){</span><br><span class="line">                <span class="keyword">if</span>(special[i][j]&gt;needs[j]){</span><br><span class="line">                    isPass=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> tmpNeeds[j]-=special[i][j];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(isPass) DFS(price, special, tmpNeeds, sum+special[i][n<span class="number">-1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;needs.size();i++){</span><br><span class="line">            sum+=needs[i]*price[i];</span><br><span class="line">        }</span><br><span class="line">        minSum=min(minSum, sum);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shoppingOffers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; price, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; special,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; needs)</span> </span>{</span><br><span class="line">        DFS(price, special, needs, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> minSum;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>②记忆化搜索</strong><br>注意到needs可能会重复计算！所以可以记忆化搜索！然而，好像和暴力的做法速度差不多，leetcode判题的时间结果有浮动啊。。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> minSum=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; needs)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:needs){</span><br><span class="line">            ans=ans*<span class="number">10</span>+x;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; price, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; needs, <span class="keyword">int</span> sum)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;minSum) <span class="keyword">return</span>;  <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(vis.find(cal(needs))!=vis.end()) <span class="keyword">return</span>; <span class="comment">//已记录</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;special.size();i++){</span><br><span class="line">            <span class="keyword">int</span> n=special[i].size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmpNeeds(needs.begin(), needs.end());</span><br><span class="line">            <span class="keyword">bool</span> isPass=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>;j++){</span><br><span class="line">                <span class="keyword">if</span>(special[i][j]&gt;needs[j]){</span><br><span class="line">                    isPass=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> tmpNeeds[j]-=special[i][j];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(isPass) DFS(price, special, tmpNeeds, sum+special[i][n<span class="number">-1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;needs.size();i++){</span><br><span class="line">            sum+=needs[i]*price[i];</span><br><span class="line">        }</span><br><span class="line">        minSum=min(minSum, sum);</span><br><span class="line">        vis[cal(needs)] = minSum;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shoppingOffers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; price, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; special,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; needs)</span> </span>{</span><br><span class="line">        DFS(price, special, needs, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> minSum;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="650-只有两个键的键盘"><a href="#650-只有两个键的键盘" class="headerlink" title="650. 只有两个键的键盘"></a>650. 只有两个键的键盘</h3><p><strong>Description</strong><br>最初在一个记事本上只有一个字符 ‘A’。你每次可以对这个记事本进行两种操作：<br>Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。<br>Paste (粘贴) : 你可以粘贴你上一次复制的字符。<br>给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 ‘A’。输出能够打印出 n 个 ‘A’ 的最少操作次数。<br><strong>Example</strong><br>示例 1:<br>输入: 3<br>输出: 3<br>解释:<br>最初, 我们只有一个字符 ‘A’。<br>第 1 步, 我们使用 Copy All 操作。<br>第 2 步, 我们使用 Paste 操作来获得 ‘AA’。<br>第 3 步, 我们使用 Paste 操作来获得 ‘AAA’。<br>说明:<br>n 的取值范围是 [1, 1000] 。<br><strong>Program</strong><br><strong>①暴力</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> minStep=inf;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> cur, <span class="keyword">int</span> step, <span class="keyword">int</span> c, <span class="keyword">bool</span> isCopy)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(step&gt;minStep) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur&gt;n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur==n){</span><br><span class="line">            minStep=min(minStep, step);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(!isCopy)helper(n, cur, step+<span class="number">1</span>, cur, <span class="literal">true</span>); <span class="comment">//isCopy防止重复copy</span></span><br><span class="line">        <span class="keyword">if</span>(c!=<span class="number">0</span>) helper(n, cur+c, step+<span class="number">1</span>, c, <span class="literal">false</span>);    </span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        helper(n, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> minStep;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>②分解质因数</strong><br>将所有操作分成以 copy 为首的多组，形如 (copy, paste, …, paste)，再使用 C 代表 copy，P 代表 paste。例如操作 CPPCPPPPCP 可以分为 [CPP][CPPPP][CP] 三组。<br>假设每组的长度为 g_1, g_2, …。完成第一组操作后，字符串有 g_1 个 A，完成第二组操作后字符串有 g_1 * g_2 个 A。当完成所有操作时，共有 g_1 * g_2 * … * g_n 个 ‘A’。<br>我们最终想要 N = g_1 * g_2 * … * g_n 个 A。如果 g_i 是合数，存在 g_i = p * q，那么这组操作可以分解为两组，第一组包含 1 个 C 和 p-1 个 P，第二组包含 1 个 C 和 q-1 个 P。<br>现在证明这种分割方式使用的操作最少。原本需要 pq 步操作，分解后需要 p+q 步。因为 p+q &lt;= pq，等价于 1 &lt;= (p-1)(q-1)，当 p &gt;= 2 且 q &gt;= 2 时上式永远成立。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++){</span><br><span class="line">            <span class="keyword">if</span>(n%i==<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(m.find(i)==m.end()) m[i]=minSteps(i);</span><br><span class="line">                <span class="keyword">if</span>(m.find(n/i)==m.end()) m[n/i]=minSteps(n/i);</span><br><span class="line">                <span class="keyword">return</span> m[i]+m[n/i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(m.find(n)==m.end()) m[n]=n;</span><br><span class="line">        <span class="keyword">return</span> m[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>因式分解</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, prime = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">1</span>){</span><br><span class="line">            <span class="keyword">while</span>(n % prime == <span class="number">0</span>){</span><br><span class="line">                ans += prime;</span><br><span class="line">                n /= prime;</span><br><span class="line">            }</span><br><span class="line">            prime ++ ;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>动态规划</strong><br>设dp[i]为i个A的最小操作数，状态转移方程：<br>dp[i] = min(dp[j] + i / j), i %j ==0 —— i个A可以由j个A copy一次以及paste i / j - 1次<br>初始化<br>dp[1] = 0<br>dp[i] = i</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> dp[n + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++){</span><br><span class="line">            dp[i] = i; <span class="comment">//初始化</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; j ++){</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>) dp[i] = min(dp[i], dp[j] + i / j);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="698-划分为k个相等的子集"><a href="#698-划分为k个相等的子集" class="headerlink" title="698. 划分为k个相等的子集"></a>698. 划分为k个相等的子集</h3><p><strong>Description</strong><br>给定一个整数数组 nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。<br><strong>Example</strong><br>示例 1：<br>输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4<br>输出： True<br>说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。<br>注意:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= k &lt;= len(nums) &lt;= 16</span><br><span class="line">0 &lt; nums[i] &lt; 10000</span><br></pre></td></tr></tbody></table></figure><p><strong>Program</strong><br><strong>①暴力枚举集合</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; h;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(u==h.size()) <span class="keyword">return</span> p == (<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;    <span class="comment">//关键，少于k也能判断</span></span><br><span class="line">        <span class="keyword">return</span> dfs(u+<span class="number">1</span>,p) || (!(h[u]&amp;p) &amp;&amp; dfs(u+<span class="number">1</span>,p|h[u]));</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums) target += x;</span><br><span class="line">        <span class="keyword">if</span>(target % k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        target /= k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">1</span>&lt;&lt;n ; i++) {</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j++)</span><br><span class="line">                <span class="keyword">if</span>(i&gt;&gt;j&amp;<span class="number">1</span>)</span><br><span class="line">                    s += nums[j];</span><br><span class="line">            <span class="keyword">if</span>(s==target) h.push_back(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>DFS</strong><br>分成k个集合，依次枚举，然鹅还是的优化，对nums降序排列！较大的数更容易确定位置！减少递归次数！</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; h;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> target=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> u)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(u==n){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x:path) <span class="keyword">if</span>(x!=target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(nums[u]&gt;target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;path.size();i++){</span><br><span class="line">            <span class="keyword">if</span>(nums[u]+path[i]&gt;target)<span class="keyword">continue</span>;</span><br><span class="line">            path[i]+=nums[u];</span><br><span class="line">            <span class="keyword">if</span>(dfs(nums, u+<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            path[i]-=nums[u];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        n=nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums) target+=x;</span><br><span class="line">        <span class="keyword">if</span>((target%k)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        path.resize(k ,<span class="number">0</span>);</span><br><span class="line">        target/=k;</span><br><span class="line">        sort(nums.begin(), nums.end(), greater&lt;<span class="keyword">int</span>&gt;());  <span class="comment">//优化</span></span><br><span class="line">        <span class="keyword">return</span> dfs(nums,<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="983-最低票价"><a href="#983-最低票价" class="headerlink" title="983. 最低票价"></a>983. 最低票价</h3><p><strong>Description</strong><br>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。<br>火车票有三种不同的销售方式：</p><ul><li>一张为期一天的通行证售价为 costs[0] 美元；</li><li>一张为期七天的通行证售价为 costs[1] 美元；</li><li>一张为期三十天的通行证售价为 costs[2] 美元。<br>通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。<br>返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。</li></ul><p><strong>Example</strong><br>示例 1：<br>输入：days = [1,4,6,7,8,20], costs = [2,7,15]<br>输出：11<br>解释：<br>例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：<br>在第 1 天，你花了 costs[0] = 2 买了一张为期 1 天的通行证，它将在第 1 天生效。<br>在第 3 天，你花了 costs[1] = 7 买了一张为期 7 天的通行证，它将在第 3, 4, …, 9 天生效。<br>在第 20 天，你花了 costs[0] = 2 买了一张为期 1 天的通行证，它将在第 20 天生效。<br>你总共花了 11，并完成了你计划的每一天旅行。</p><p>示例 2：<br>输入：days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]<br>输出：17<br>解释：<br>例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：<br>在第 1 天，你花了 costs[2] = 15 买了一张为期 30 天的通行证，它将在第 1, 2, …, 30 天生效。<br>在第 31 天，你花了 costs[0] = 2 买了一张为期 1 天的通行证，它将在第 31 天生效。<br>你总共花了 17，并完成了你计划的每一天旅行。</p><p>提示：<br>1 &lt;= days.length &lt;= 365<br>1 &lt;= days[i] &lt;= 365<br>days 按顺序严格递增<br>costs.length == 3<br>1 &lt;= costs[i] &lt;= 1000<br><strong>Program</strong><br><strong>记忆化搜索</strong><br>首先定义dfs(i, resDay)为当前第days[i]天，通行证有效期的截止时间为resDay的最低消费。<br>设n为days长度<br>①i&gt;n，return 0；超出days的日期长度了<br>②days[i]&lt;=resDay，当前第days[i]天在前一次通行证有效期内，计算下一天dfs(i+1,resDay)即可<br>③days[i]&gt;resDay，<br>那么当前第days[i]天可以买三种票价<br>ans=min(ans, costs[j]+dfs(i+1,days[j]+cosDays[j]-1)), j=0,1,2即可</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> cosDays[<span class="number">3</span>]={<span class="number">1</span>,<span class="number">7</span>,<span class="number">30</span>};</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; days, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs,<span class="keyword">int</span> i, <span class="keyword">int</span> resDay)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(m.find(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(i, resDay))!=m.end()) <span class="keyword">return</span> m[pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(i, resDay)];</span><br><span class="line">        <span class="keyword">if</span>(days[i]&lt;=resDay) <span class="keyword">return</span> dfs(days, costs, i+<span class="number">1</span>, resDay);</span><br><span class="line">        <span class="keyword">int</span> ans=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++){</span><br><span class="line">            ans=min(ans, costs[j]+dfs(days, costs, i+<span class="number">1</span>, days[i]+cosDays[j]<span class="number">-1</span>));</span><br><span class="line">        }</span><br><span class="line">        m[pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(i, resDay)] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; days, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs)</span> </span>{</span><br><span class="line">        n=days.size();</span><br><span class="line">        <span class="keyword">return</span> dfs(days, costs, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>resDay表示剩余天数</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> cosDays[<span class="number">3</span>]={<span class="number">1</span>,<span class="number">7</span>,<span class="number">30</span>};</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; days, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs, <span class="keyword">int</span> i, <span class="keyword">int</span> resDay)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(vis[i][resDay]!=<span class="number">-1</span>) <span class="keyword">return</span> vis[i][resDay];</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">int</span> rd=resDay-(days[i]-days[i<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(rd&gt;=<span class="number">0</span>) <span class="keyword">return</span> dfs(days, costs, i+<span class="number">1</span>, rd);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++){</span><br><span class="line">            ans=min(ans, costs[j]+dfs(days, costs, i+<span class="number">1</span>, cosDays[j]<span class="number">-1</span>));</span><br><span class="line">        }</span><br><span class="line">        vis[i][resDay]=ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; days, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs)</span> </span>{</span><br><span class="line">        n=days.size();</span><br><span class="line">        vis.resize(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">31</span>,<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> dfs(days, costs, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>动态规划</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> cosDays[<span class="number">3</span>]={<span class="number">1</span>,<span class="number">7</span>,<span class="number">30</span>};</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; days, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs)</span> </span>{</span><br><span class="line">        n=days.size();</span><br><span class="line">        <span class="keyword">int</span> DP[n][<span class="number">396</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, inf, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> d=<span class="number">0</span>;d&lt;=<span class="number">395</span>;d++){</span><br><span class="line">                <span class="keyword">if</span>(d&gt;=days[i]){</span><br><span class="line">                    <span class="keyword">if</span>(i&lt;n<span class="number">-1</span>) DP[i][d]=DP[i+<span class="number">1</span>][d];</span><br><span class="line">                    <span class="keyword">else</span> DP[i][d]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++){</span><br><span class="line">                    <span class="keyword">if</span>(i&lt;n<span class="number">-1</span>)DP[i][d]=min(DP[i][d], costs[j]+DP[i+<span class="number">1</span>][days[i]+cosDays[j]<span class="number">-1</span>]);</span><br><span class="line">                    <span class="keyword">else</span> DP[i][d]=min(DP[i][d], costs[j]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> cosDays[<span class="number">3</span>]={<span class="number">1</span>,<span class="number">7</span>,<span class="number">30</span>};</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; days, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs)</span> </span>{</span><br><span class="line">        n=days.size();</span><br><span class="line">        <span class="keyword">int</span> DP[n][<span class="number">31</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, inf, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> d=<span class="number">0</span>;d&lt;=<span class="number">30</span>;d++){</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>){</span><br><span class="line">                    <span class="keyword">int</span> rd=d-(days[i]-days[i<span class="number">-1</span>]);</span><br><span class="line">                    <span class="keyword">if</span>(rd&gt;=<span class="number">0</span>){</span><br><span class="line">                        <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n)DP[i][d]=DP[i+<span class="number">1</span>][rd];</span><br><span class="line">                        <span class="keyword">else</span> DP[i][d]=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++){</span><br><span class="line">                    <span class="keyword">if</span>(i&lt;n<span class="number">-1</span>)DP[i][d]=min(DP[i][d], costs[j]+DP[i+<span class="number">1</span>][cosDays[j]<span class="number">-1</span>]);</span><br><span class="line">                    <span class="keyword">else</span> DP[i][d]=min(DP[i][d], costs[j]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>一维DP</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; days, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> last = days[days.size()<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(last+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= last; i++) {</span><br><span class="line">            <span class="keyword">if</span> (i == days[idx]) {</span><br><span class="line">                <span class="keyword">int</span> cost = INT_MAX;</span><br><span class="line">                <span class="keyword">int</span> oneDayAgo = i<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">int</span> sevenDaysAgo = i<span class="number">-7</span>&gt;<span class="number">0</span>?i<span class="number">-7</span>:<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> thirtyDaysAgo = i<span class="number">-30</span>&gt;<span class="number">0</span>?i<span class="number">-30</span>:<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                cost = min(dp[oneDayAgo] + costs[<span class="number">0</span>], cost);</span><br><span class="line">                cost = min(dp[sevenDaysAgo] + costs[<span class="number">1</span>], cost);</span><br><span class="line">                cost = min(dp[thirtyDaysAgo] + costs[<span class="number">2</span>], cost);</span><br><span class="line"></span><br><span class="line">                dp[i] = cost;</span><br><span class="line"></span><br><span class="line">                idx++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[last];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1339-分裂二叉树的最大乘积"><a href="#1339-分裂二叉树的最大乘积" class="headerlink" title="1339. 分裂二叉树的最大乘积"></a>1339. 分裂二叉树的最大乘积</h3><p><strong>Description</strong><br>给你一棵二叉树，它的根为 root 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。<br>由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。<br><strong>Example</strong><br>示例 1：</p><p>输入：root = [1,2,3,4,5,6]<br>输出：110<br>解释：删除红色的边，得到 2 棵子树，和分别为 11 和 10 。它们的乘积是 110 （11*10）</p><p>示例 2：<br>输入：root = [1,null,2,3,4,null,null,5,6]<br>输出：90<br>解释：移除红色的边，得到 2 棵子树，和分别是 15 和 6 。它们的乘积为 90 （15*6）</p><p>示例 3：<br>输入：root = [2,3,9,10,7,8,6,5,4,11,1]<br>输出：1025</p><p>示例 4：<br>输入：root = [1,1]<br>输出：1</p><p>提示：<br>每棵树最多有 50000 个节点，且至少有 2 个节点。<br>每个节点的值在 [1, 10000] 之间。<br><strong>Program</strong><br><strong>思路</strong><br>二叉树总和为totalSum,子树和为sum，则最终答案取$(totalSum-sum) * sum$最大的即可。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;TreeNode*, <span class="keyword">long</span> <span class="keyword">long</span>&gt; m;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calSum</span><span class="params">(TreeNode* root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum=root-&gt;val;</span><br><span class="line">        sum+=calSum(root-&gt;left);</span><br><span class="line">        sum+=calSum(root-&gt;right);</span><br><span class="line">        m[root]=sum;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> totalSum=calSum(root);</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            TreeNode* node=q.front();q.pop();</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left!=<span class="literal">NULL</span>){</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> sum=m[node-&gt;left];</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> x=sum*(totalSum-sum);</span><br><span class="line">                ans=ans&gt;x?ans:x;</span><br><span class="line">                q.push(node-&gt;left);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right!=<span class="literal">NULL</span>){</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> sum=m[node-&gt;right];</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> x=sum*(totalSum-sum);</span><br><span class="line">                ans=ans&gt;x?ans:x;</span><br><span class="line">                q.push(node-&gt;right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans%MOD;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>计算子树和最接近totalSum的一半</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> totalSum=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calSum</span><span class="params">(TreeNode* root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        totalSum+=root-&gt;val;</span><br><span class="line">        calSum(root-&gt;left);</span><br><span class="line">        calSum(root-&gt;right);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calBest</span><span class="params">(TreeNode* root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=root-&gt;val+calBest(root-&gt;left)+calBest(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(sum*<span class="number">2</span>-totalSum)&lt;<span class="built_in">abs</span>(ans*<span class="number">2</span>-totalSum)) ans=sum; <span class="comment">//记录最接近totalSum一半的数！</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        calSum(root);</span><br><span class="line">        calBest(root);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">long</span>)ans*(totalSum-ans)%MOD;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1367-二叉树中的列表"><a href="#1367-二叉树中的列表" class="headerlink" title="1367. 二叉树中的列表"></a>1367. 二叉树中的列表</h3><p><strong>Description</strong><br>给你一棵以 root 为根的二叉树和一个 head 为第一个节点的链表。<br>如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 head 为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。<br>一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。<br><strong>Example</strong><br>示例 1：<br><img src="/assets/img/algorithm/1367_example_01.png" alt="image"><br>输入：head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]<br>输出：true<br>解释：树中蓝色的节点构成了与链表对应的子路径。</p><p>示例 2：<br><img src="/assets/img/algorithm/1367_example_02.png" alt="image"><br>输入：head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]<br>输出：true</p><p>示例 3：<br>输入：head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]<br>输出：false<br>解释：二叉树中不存在一一对应链表的路径。</p><p>提示：<br>二叉树和链表中的每个节点的值都满足 1 &lt;= node.val &lt;= 100 。<br>链表包含的节点数目在 1 到 100 之间。<br>二叉树包含的节点数目在 1 到 2500 之间。<br><strong>Program</strong><br>枚举二叉树每个节点进行链表头结点进行匹配。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, ListNode* head)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//完成匹配</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//匹配不完全</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val!=head-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//匹配不成功</span></span><br><span class="line">        <span class="keyword">return</span> dfs(root-&gt;left, head-&gt;next) || dfs(root-&gt;right, head-&gt;next); <span class="comment">//匹配孩子</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubPath</span><span class="params">(ListNode* head, TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, head) || isSubPath(head, root-&gt;left) || isSubPath(head, root-&gt;right); <span class="comment">//枚举每个节点当成链表头结点</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="967-连续差相同的数字"><a href="#967-连续差相同的数字" class="headerlink" title="967. 连续差相同的数字"></a>967. 连续差相同的数字</h3><p><strong>Description</strong><br>返回所有长度为 N 且满足其每两个连续位上的数字之间的差的绝对值为 K 的非负整数。<br>请注意，除了数字 0 本身之外，答案中的每个数字都不能有前导零。例如，01 因为有一个前导零，所以是无效的；但 0 是有效的。<br>你可以按任何顺序返回答案。<br><strong>Example</strong><br>示例 1：<br>输入：N = 3, K = 7<br>输出：[181,292,707,818,929]<br>解释：注意，070 不是一个有效的数字，因为它有前导零。</p><p>示例 2：<br>输入：N = 2, K = 1<br>输出：[10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]</p><p>提示：<br>1 &lt;= N &lt;= 9<br>0 &lt;= K &lt;= 9<br><strong>Program</strong><br><strong>暴力dfs</strong><br>最差时间复杂度：$O(9 * 2^8)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> num, <span class="keyword">int</span> bit, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(i==n){</span><br><span class="line">            res.push_back(num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(k!=<span class="number">0</span>&amp;&amp;bit-k&gt;=<span class="number">0</span>) dfs(i+<span class="number">1</span>, num*<span class="number">10</span>+bit-k, bit-k, n, k);</span><br><span class="line">        <span class="keyword">if</span>(k!=<span class="number">0</span>&amp;&amp;bit+k&lt;=<span class="number">9</span>) dfs(i+<span class="number">1</span>, num*<span class="number">10</span>+bit+k, bit+k, n, k);</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) dfs(i+<span class="number">1</span>, num*<span class="number">10</span>+bit, bit, n, k);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numsSameConsecDiff(<span class="keyword">int</span> N, <span class="keyword">int</span> K) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++){</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;N!=<span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">//1,0特例</span></span><br><span class="line">            dfs(<span class="number">1</span>, i, i, N, K);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="概率DP"><a href="#概率DP" class="headerlink" title="概率DP"></a>概率DP</h2><h3 id="688-“马”在棋盘上的概率"><a href="#688-“马”在棋盘上的概率" class="headerlink" title="688. “马”在棋盘上的概率"></a>688. “马”在棋盘上的概率</h3><p><strong>Description</strong><br>已知一个 NxN 的国际象棋棋盘，棋盘的行号和列号都是从 0 开始。即最左上角的格子记为 (0, 0)，最右下角的记为 (N-1, N-1)。<br>现有一个 “马”（也译作 “骑士”）位于 (r, c) ，并打算进行 K 次移动。<br>如下图所示，国际象棋的 “马” 每一步先沿水平或垂直方向移动 2 个格子，然后向与之相垂直的方向再移动 1 个格子，共有 8 个可选的位置。<br><img src="/assets/img/algorithm/knight.png" alt="image"><br>现在 “马” 每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了 K 次或跳到了棋盘外面。<br>求移动结束后，“马” 仍留在棋盘上的概率。<br><strong>Example</strong><br>示例：<br>输入: 3, 2, 0, 0<br>输出: 0.0625<br>解释:<br>输入的数据依次为 N, K, r, c<br>第 1 步时，有且只有 2 种走法令 “马” 可以留在棋盘上（跳到（1,2）或（2,1））。对于以上的两种情况，各自在第2步均有且只有2种走法令 “马” 仍然留在棋盘上。<br>所以 “马” 在结束后仍在棋盘上的概率为 0.0625。</p><p>注意：<br>N 的取值范围为 [1, 25]<br>K 的取值范围为 [0, 100]<br>开始时，“马” 总是位于棋盘上<br><strong>Program</strong><br>设DP[k][i][j]为在位置(i, j)时已走过k步的概率，注意如果表示可能走的路径数则会超数值范围。<br>那么$DP[k][i][j]=\frac{\sum{DP[k-1][x][y]}}{8}$其中x,y为可走的位置</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> step[<span class="number">8</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">-2</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">-1</span>, <span class="number">2</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">        <span class="number">2</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">2</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">-2</span>,</span><br><span class="line">        <span class="number">-1</span>, <span class="number">-2</span>,</span><br><span class="line">        <span class="number">-2</span>, <span class="number">-1</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;=N||y&lt;<span class="number">0</span>||y&gt;=N) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">knightProbability</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt;&gt; DP(K+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt;(N, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;(N, <span class="number">0</span>)));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=K;k++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++){</span><br><span class="line">                    <span class="keyword">if</span>(k==<span class="number">0</span>){</span><br><span class="line">                        DP[k][i][j]=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;<span class="number">8</span>;s++){</span><br><span class="line">                        <span class="keyword">int</span> x=i+step[s][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y=j+step[s][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(judge(N, x, y)){</span><br><span class="line">                            DP[k][i][j]+=DP[k<span class="number">-1</span>][x][y];    </span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    DP[k][i][j]/=<span class="number">8</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[K][r][c];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="808-分汤"><a href="#808-分汤" class="headerlink" title="808. 分汤"></a>808. 分汤</h3><p><strong>Description</strong><br>有 A 和 B 两种类型的汤。一开始每种类型的汤有 N 毫升。有四种分配操作：<br>提供 100ml 的汤A 和 0ml 的汤B。<br>提供 75ml 的汤A 和 25ml 的汤B。<br>提供 50ml 的汤A 和 50ml 的汤B。<br>提供 25ml 的汤A 和 75ml 的汤B。<br>当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为0.25的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。<br>注意不存在先分配100 ml汤B的操作。<br>需要返回的值： 汤A先分配完的概率 + 汤A和汤B同时分配完的概率 / 2。<br><strong>Example</strong><br>示例:<br>输入: N = 50<br>输出: 0.625<br>解释:<br>如果我们选择前两个操作，A将首先变为空。对于第三个操作，A和B会同时变为空。对于第四个操作，B将首先变为空。<br>所以A变为空的总概率加上A和B同时变为空的概率的一半是 $0.25 <em>(1 + 1 + 0.5 + 0)= 0.625$。<br>注释:<br>0 &lt;= N &lt;= 10^9。<br>返回值在 10^-6 的范围将被认为是正确的。<br>*</em>Program**<br><strong>DP</strong><br>$DP[i][j]=\sum{DP[i-x[k]][j-y[k]]}$，注意边界，超内存！！</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> step[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">100</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">75</span>, <span class="number">25</span>,</span><br><span class="line">        <span class="number">50</span>, <span class="number">50</span>,</span><br><span class="line">        <span class="number">25</span>, <span class="number">75</span></span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">soupServings</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; DP(N+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;(N+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=N;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=N;j++){</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>){</span><br><span class="line">                    DP[i][j]=<span class="number">0.5</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>){</span><br><span class="line">                    DP[i][j]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>){</span><br><span class="line">                    DP[i][j]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++){</span><br><span class="line">                    <span class="keyword">int</span> x=i-step[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y=j-step[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(x&lt;=<span class="number">0</span>&amp;&amp;y&lt;=<span class="number">0</span>) DP[i][j]+=<span class="number">0.25</span>*DP[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;=<span class="number">0</span>) DP[i][j]+=<span class="number">0.25</span>*DP[<span class="number">0</span>][y];</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(y&lt;=<span class="number">0</span>) DP[i][j]+=<span class="number">0.25</span>*DP[x][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">else</span> DP[i][j]+=<span class="number">0.25</span>*DP[x][y];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[N][N];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>优化</strong><br>四种操作都是25的倍数，所以可以N/25(有余数，加1)来减少内存。即使将 N 除以 25 之后，仍然没法在短时间内得到答案，因此我们需要尝试一些别的思路。可以发现，分配操作有 (4, 0)，(3, 1)，(2, 2) 和 (1, 3) 四种，那么在一次分配中，汤 A 平均会少 (4 + 3 + 2 + 1) / 4 = 2.5 份，汤 B 平均会少 (0 + 1 + 2 + 3) / 4 = 1.5 份。因此在 N 非常大的时候，A 会有很大的概率比 B 先分配完，所有概率应该非常接近 1。事实上，当 N &gt;= 500 * 25 时，所求概率已经大于 0.999999 了（可以通过上面的动态规划方法求出），它和 1 的误差（无论是绝对误差还是相对误差）都小于 10^-6。因此在 N &gt;= 500 * 25 时，我们只需要输出 1 作为答案即可。在其它的情况下，我们使用动态规划计算出答案。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> step[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">100</span>/<span class="number">25</span>, <span class="number">0</span>/<span class="number">25</span>,</span><br><span class="line">        <span class="number">75</span>/<span class="number">25</span>, <span class="number">25</span>/<span class="number">25</span>,</span><br><span class="line">        <span class="number">50</span>/<span class="number">25</span>, <span class="number">50</span>/<span class="number">25</span>,</span><br><span class="line">        <span class="number">25</span>/<span class="number">25</span>, <span class="number">75</span>/<span class="number">25</span></span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">soupServings</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        N=N/<span class="number">25</span>+((N%<span class="number">25</span>)?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(N&gt;=<span class="number">500</span>) <span class="keyword">return</span> <span class="number">0.999999</span>;</span><br><span class="line">        <span class="keyword">double</span> DP[N+<span class="number">1</span>][N+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0.0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=N;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=N;j++){</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>){</span><br><span class="line">                    DP[i][j]=<span class="number">0.5</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>){</span><br><span class="line">                    DP[i][j]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>){</span><br><span class="line">                    DP[i][j]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++){</span><br><span class="line">                    <span class="keyword">int</span> x=i-step[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y=j-step[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(x&lt;=<span class="number">0</span>&amp;&amp;y&lt;=<span class="number">0</span>) DP[i][j]+=<span class="number">0.25</span>*DP[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;=<span class="number">0</span>) DP[i][j]+=<span class="number">0.25</span>*DP[<span class="number">0</span>][y];</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(y&lt;=<span class="number">0</span>) DP[i][j]+=<span class="number">0.25</span>*DP[x][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">else</span> DP[i][j]+=<span class="number">0.25</span>*DP[x][y];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[N][N];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="837-新21点"><a href="#837-新21点" class="headerlink" title="837. 新21点"></a>837. 新21点</h3><p><strong>Description</strong><br>爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：<br>爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。<br>当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？<br><strong>Example</strong><br>示例 1：<br>输入：N = 10, K = 1, W = 10<br>输出：1.00000<br>说明：爱丽丝得到一张卡，然后停止。</p><p>示例 2：<br>输入：N = 6, K = 1, W = 10<br>输出：0.60000<br>说明：爱丽丝得到一张卡，然后停止。<br>在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。</p><p>示例 3：<br>输入：N = 21, K = 17, W = 10<br>输出：0.73278</p><p>提示：<br>0 &lt;= K &lt;= N &lt;= 10000<br>1 &lt;= W &lt;= 10000<br>如果答案与正确答案的误差不超过 10^-5，则该答案将被视为正确答案通过。<br>此问题的判断限制时间已经减少。<br><strong>Program</strong><br><strong>思路</strong><br>设DP[i]得分为i开始到最后得分在$[K,N]$内的概率：<br>（1）$i\in [K,N]$，明显概率就是1；<br>（2）$i&gt;N$，概率为0；<br>（3）$0&lt;=i&lt;K$，$DP[i]=\frac{1}{W}\sum^{W}_{j=1}(DP[i+j])$.<br>但是这里求和的话需要重循环，时间复杂度：$O(n^2)$超时！<br>优化：后面求和可以通过后缀和求得：<br>$DP[i]=\frac{1}{W}(lastSum[i+1]-lastSum[i+W+1]))$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=K<span class="number">-1</span>+W;</span><br><span class="line">        <span class="keyword">double</span> DP[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">double</span> lastSum[n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="built_in">memset</span>(lastSum, <span class="number">0</span>, <span class="keyword">sizeof</span>(lastSum));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">if</span>(K&lt;=i&amp;&amp;i&lt;=min(N,n)) DP[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;N) DP[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                <span class="comment">// for(int j=1;j&lt;=W;j++){</span></span><br><span class="line">                <span class="comment">//     DP[i]+=DP[i+j]/W;</span></span><br><span class="line">                <span class="comment">// }</span></span><br><span class="line">                <span class="keyword">if</span>(i+W+<span class="number">1</span>&lt;=n) DP[i]+=(lastSum[i+<span class="number">1</span>]-lastSum[i+W+<span class="number">1</span>])/W;</span><br><span class="line">                <span class="keyword">else</span> DP[i]+=lastSum[i+<span class="number">1</span>]/W;</span><br><span class="line">            }</span><br><span class="line">            lastSum[i]+=DP[i];</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&lt;=n) lastSum[i]+=lastSum[i+<span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1227-飞机座位分配概率"><a href="#1227-飞机座位分配概率" class="headerlink" title="1227. 飞机座位分配概率"></a>1227. 飞机座位分配概率</h3><p><strong>Description</strong><br>有 n 位乘客即将登机，飞机正好有 n 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。<br>剩下的乘客将会：<br>如果他们自己的座位还空着，就坐到自己的座位上，<br>当他们自己的座位被占用时，随机选择其他座位<br>第 n 位乘客坐在自己的座位上的概率是多少？<br><strong>Example</strong><br>示例 1：<br>输入：n = 1<br>输出：1.00000<br>解释：第一个人只会坐在自己的位置上。</p><p>示例 2：<br>输入: n = 2<br>输出: 0.50000<br>解释：在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。</p><p>提示：<br>1 &lt;= n &lt;= 10^5<br><strong>Program</strong><br><strong>动态规划</strong><br>不妨设$1 ~ n$乘客自己的座位分别为$1 ~ n$,考虑结果DP[n]，第一个乘客选择：<br>（1）选择1，那么后面每个人都能做到自己的位置，结果$\frac{1}{n}$;<br>（2）选择n，那么$\frac{1}{n} * 0=0$；<br>（3）选择$k\in [2,n-1]$，那么$[2,k-1]$的所有人归位正确，第k个乘客进入子问题：</p><ul><li>选择乘客1的原位置，则所有人皆大欢喜——与第一个乘客的(1)一样，即此时应当将1座位乘客原本位置作为第k个乘客的原位置！——结果为$\frac{1}{n} * \frac{1}{n-k+1}$；</li><li>选择其他位置，同（3）；<br>即第k个乘客的选择可以看成DP[n-k+1]。<br>故递推公式：$DP[n]=\frac{1}{n}+\frac{1}{n} * \sum^{n-1}<em>{2} * DP[n-k+1]=\frac{1}{n} * (1 + \sum^{n-1}</em>{2} * DP[n-k+1])$。<br>时间复杂度：$O(n^2)$，很遗憾n的范围限制超时。<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">nthPersonGetsNthSeat</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; DP(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            DP[i]=<span class="number">1</span>/(<span class="keyword">double</span>)i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;i<span class="number">-1</span>;j++){</span><br><span class="line">                DP[i]+=<span class="number">1</span>/(<span class="keyword">double</span>)i * DP[i-j+<span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li></ul><p><strong>优化</strong><br>看到递推公式后一项，可以通过前缀和化简为:$DP[n]=\frac{1}{n} * (1 + preSum[n-1] - preSum[1])$.<br>时间复杂度：$O(n)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">nthPersonGetsNthSeat</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; DP(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; preSum(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            DP[i]=<span class="number">1</span>/(<span class="keyword">double</span>)i;</span><br><span class="line">            DP[i]+=<span class="number">1</span>/(<span class="keyword">double</span>)i * (preSum[i<span class="number">-1</span>]-preSum[<span class="number">1</span>]); <span class="comment">//DP[1]用到preSum[0]-preSum[1]=0，以及DP[2]用到preSum[1]-preSum[1]=0刚好不会错</span></span><br><span class="line">            preSum[i]+=DP[i]+preSum[i<span class="number">-1</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>继续优化</strong><br>由递推公式:$DP[n]=\frac{1}{n} * (1 + preSum[n-1] - preSum[1]), n \geq 2$<br>$DP[n+1]=\frac{1}{n+1} * (1 + preSum[n] - preSum[1])$<br>则$(n+1) * DP[n+1] - n * DP[n] = preSum[n]- preSum[n-1]=DP[n]$<br>所以$DP[n+1]==DP[n], n \geq 2$。<br>时间复杂度：$O(1)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">nthPersonGetsNthSeat</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> n==<span class="number">1</span>?<span class="number">1</span>:<span class="number">0.5</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="位DP"><a href="#位DP" class="headerlink" title="位DP"></a>位DP</h2><h3 id="898-子数组按位或操作"><a href="#898-子数组按位或操作" class="headerlink" title="898. 子数组按位或操作"></a>898. 子数组按位或操作</h3><p><strong>Description</strong><br>我们有一个非负整数数组 A。<br>对于每个（连续的）子数组 B = [A[i], A[i+1], …, A[j]] （ i &lt;= j），我们对 B 中的每个元素进行按位或操作，获得结果 $A[i] | A[i+1] | … | A[j]$。<br>返回可能结果的数量。 （多次出现的结果在最终答案中仅计算一次。）<br><strong>Example</strong><br>示例 1：<br>输入：[0]<br>输出：1<br>解释：<br>只有一个可能的结果 0 。</p><p>示例 2：<br>输入：[1,1,2]<br>输出：3<br>解释：<br>可能的子数组为 [1]，[1]，[2]，[1, 1]，[1, 2]，[1, 1, 2]。<br>产生的结果为 1，1，2，1，3，3 。<br>有三个唯一值，所以答案是 3 。</p><p>示例 3：<br>输入：[1,2,4]<br>输出：6<br>解释：<br>可能的结果是 1，2，3，4，6，以及 7 。<br>提示：<br>$1 &lt;= A.length &lt;= 50000$<br>$0 &lt;= A[i] &lt;= 10^9$<br><strong>Program</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Result[i,j]=A[i]|A[i+1]|...|A[j], i&lt;=j</span><br><span class="line">A: 1 2 3 4</span><br><span class="line">1: [1]</span><br><span class="line">2: [1, 2], [2]</span><br><span class="line">3: [1, 2, 3], [2,3], [3]</span><br><span class="line">4: [1, 2, 3, 4], [3, 4]</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarrayBitwiseORs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>{</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x: A){</span><br><span class="line">            tmp.clear();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y:cur){</span><br><span class="line">                tmp.insert(x|y);</span><br><span class="line">            }</span><br><span class="line">            tmp.insert(x);</span><br><span class="line">            cur=tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> z:cur) result.insert(z);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result.size();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h2><h3 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a>337. 打家劫舍 III</h3><p><strong>Description</strong><br>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。<br>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。<br><strong>Example</strong><br>示例 1:<br>输入: [3,2,3,null,3,null,1]</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line"> \   \</span><br><span class="line">  3   1</span><br></pre></td></tr></tbody></table></figure><p>输出: 7<br>解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.</p><p>示例 2:<br>输入: [3,4,5,1,3,null,1]</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&nbsp;    3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br><span class="line"> / \   \</span><br><span class="line">1   3   1</span><br></pre></td></tr></tbody></table></figure><p>输出: 9<br>解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;pair&lt;TreeNode*, <span class="keyword">bool</span>&gt;, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">bool</span> isSteal)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(m.find(pair&lt;TreeNode*,<span class="keyword">bool</span>&gt;(root, isSteal))!=m.end()){</span><br><span class="line">            <span class="keyword">return</span> m[make_pair(root, isSteal)];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(isSteal){ <span class="comment">//本节点可偷</span></span><br><span class="line">            <span class="comment">//偷</span></span><br><span class="line">            <span class="keyword">int</span> leftSum=dfs(root-&gt;left, !isSteal);</span><br><span class="line">            <span class="keyword">int</span> rightSum=dfs(root-&gt;right, !isSteal);</span><br><span class="line">            <span class="keyword">int</span> stealSum=leftSum+rightSum+root-&gt;val;</span><br><span class="line">            <span class="comment">//不偷</span></span><br><span class="line">            leftSum=dfs(root-&gt;left, isSteal);</span><br><span class="line">            rightSum=dfs(root-&gt;right, isSteal);</span><br><span class="line">            <span class="keyword">int</span> nstealSum=leftSum+rightSum;</span><br><span class="line">            m[make_pair(root, isSteal)]=max(stealSum, nstealSum);</span><br><span class="line">            <span class="keyword">return</span> m[make_pair(root, isSteal)];</span><br><span class="line">        }<span class="keyword">else</span>{ <span class="comment">//本节点不可偷</span></span><br><span class="line">            <span class="keyword">int</span> leftSum=dfs(root-&gt;left, !isSteal);</span><br><span class="line">            <span class="keyword">int</span> rightSum=dfs(root-&gt;right, !isSteal);</span><br><span class="line">            m[make_pair(root, isSteal)]=leftSum+rightSum;</span><br><span class="line">            <span class="keyword">return</span> m[make_pair(root, isSteal)];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> max(dfs(root, <span class="literal">true</span>), dfs(root, <span class="literal">false</span>));</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>树形DP</strong><br>我们可以用 f(o)表示选择 o 节点的情况下，o 节点的子树上被选择的节点的最大权值和；<br>g(o) 表示不选择 o 节点的情况下，o 节点的子树上被选择的节点的最大权值和；l 和 r 代表 o 的左右孩子。</p><ul><li>当 o 被选中时，o 的左右孩子都不能被选中，故 o 被选中情况下子树上被选中点的最大权值和为 l 和 r 不被选中的最大权值和相加，即 $f(o) = g(l) + g(r); f(o)=g(l)+g(r)$。</li><li>当 o 不被选中时，o 的左右孩子可以被选中，也可以不被选中。对于 o 的某个具体的孩子 x，它对 o 的贡献是 x 被选中和不被选中情况下权值和的较大值。故 $g(o) = \max { f(l) , g(l)}+\max{ f(r) , g(r) }g(o)=max{f(l),g(l)}+max{f(r),g(r)}$。</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span> &lt;TreeNode*, <span class="keyword">int</span>&gt; f, g;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* o)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!o) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        dfs(o-&gt;left);</span><br><span class="line">        dfs(o-&gt;right);</span><br><span class="line">        f[o] = o-&gt;val + g[o-&gt;left] + g[o-&gt;right];</span><br><span class="line">        g[o] = max(f[o-&gt;left], g[o-&gt;left]) + max(f[o-&gt;right], g[o-&gt;right]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* o)</span> </span>{</span><br><span class="line">        dfs(o);</span><br><span class="line">        <span class="keyword">return</span> max(f[o], g[o]);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>优化</strong><br>假设二叉树的节点个数为 nn。</p><p>我们可以看出，以上的算法对二叉树做了一次后序遍历，时间复杂度是 O(n)；由于递归会使用到栈空间，空间代价是 O(n)，哈希映射的空间代价也是 O(n)，故空间复杂度也是 O(n)。</p><p>我们可以做一个小小的优化，我们发现无论是f(o) 还是 g(o)，他们最终的值只和 f(l)、g(l)、f(r)、g(r) 有关，所以对于每个节点，我们只关心它的孩子节点们的 f 和 g 是多少。我们可以设计一个结构，表示某个节点的 f 和 g 值，在每次递归返回的时候，都把这个点对应的 f 和 g 返回给上一级调用，这样可以省去哈希映射的空间。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubtreeStatus</span> {</span></span><br><span class="line">    <span class="keyword">int</span> selected;</span><br><span class="line">    <span class="keyword">int</span> notSelected;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">SubtreeStatus <span class="title">dfs</span><span class="params">(TreeNode* o)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!o) {</span><br><span class="line">            <span class="keyword">return</span> {<span class="number">0</span>, <span class="number">0</span>};</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">auto</span> l = dfs(o-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> r = dfs(o-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> selected = o-&gt;val + l.notSelected + r.notSelected;</span><br><span class="line">        <span class="keyword">int</span> notSelected = max(l.selected, l.notSelected) + max(r.selected, r.notSelected);</span><br><span class="line">        <span class="keyword">return</span> {selected, notSelected};</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* o)</span> </span>{</span><br><span class="line">        <span class="keyword">auto</span> rootStatus = dfs(o);</span><br><span class="line">        <span class="keyword">return</span> max(rootStatus.selected, rootStatus.notSelected);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="834-树中距离之和"><a href="#834-树中距离之和" class="headerlink" title="834. 树中距离之和"></a>834. 树中距离之和</h3><p><strong>Description</strong><br>给定一个无向、连通的树。树中有 N 个标记为 0…N-1 的节点以及 N-1 条边 。<br>第 i 条边连接节点 edges[i][0] 和 edges[i][1] 。<br>返回一个表示节点 i 与其他所有节点距离之和的列表 ans。<br><strong>Example</strong><br>示例 1:<br>输入: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]<br>输出: [8,12,6,10,10,10]<br>解释:<br>如下为给定的树的示意图：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  0</span><br><span class="line"> / \</span><br><span class="line">1   2</span><br><span class="line">   /|\</span><br><span class="line">  3 4 5</span><br></pre></td></tr></tbody></table></figure><p>我们可以计算出 dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)<br>也就是 1 + 1 + 2 + 2 + 2 = 8。 因此，answer[0] = 8，以此类推。<br>说明: 1 &lt;= N &lt;= 10000<br><strong>Program</strong><br>详见高赞题解<br><strong>思路</strong><br>（1）设distSum[root]为以root为根的子树root距离子树其他节点的距离和，递推公式：<br>$distSum[root]=\sum{(dist[Sum[child]]+nodeNum[child])}$<br>其中nodeNum[root]为以root为根的子节点个数。<br><strong>明显后序遍历自底而上更新distSum[root]；</strong><br>（2）以distSum[root]表示root距离其他所有节点（包括非子树的其他节点）的距离和：<br>可以看到整个树的根distSum[root]一定是最终所求，而其他所有节点的distSum[i]则是部分距离和（i距离其子树其他节点的距离和），以现有结果更新distSum[i]得到其最终所求：<br>root到除了以child为根的子树的距离和为$distSum[root]-nodeNum[child]-distSum[child]=S$，此时的distSum[root]为最终所求，distSum[child]为部分距离和；<br>则$S+N-nodeNum[child+distSum[child]$为最终的distSum[child]（child到其他所有节点的距离和）；<br>即$distSum[child]=distSum[root]-nodeNum[child]+N-nodeNum[child]$<br><strong>前序遍历更新distSum[child]即可</strong><br>（3）由于0未必是整个树的根结点，所以构建领接表时，需要双向连通，然后以0为根结点进行计算。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; Adj;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nodeNum;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; distSum;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> parent)</span></span>{ <span class="comment">//自底而上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[root].size();i++){</span><br><span class="line">            <span class="keyword">int</span> child=Adj[root][i];</span><br><span class="line">            <span class="keyword">if</span>(child==parent) <span class="keyword">continue</span>; <span class="comment">//排除连接根的那条边</span></span><br><span class="line">            postOrder(child, root);</span><br><span class="line">            nodeNum[root]+=nodeNum[child];</span><br><span class="line">            distSum[root]+=distSum[child];</span><br><span class="line">        }</span><br><span class="line">        distSum[root]+=nodeNum[root];</span><br><span class="line">        nodeNum[root]+=<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> parent)</span></span>{ <span class="comment">//自顶而下</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[root].size();i++){</span><br><span class="line">            <span class="keyword">int</span> child=Adj[root][i];</span><br><span class="line">            <span class="keyword">if</span>(child==parent) <span class="keyword">continue</span>;</span><br><span class="line">            distSum[child]=distSum[root]-nodeNum[child]+N-nodeNum[child]; <span class="comment">//得到最终的距离和</span></span><br><span class="line">            preOrder(child, root);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sumOfDistancesInTree(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;N=N;</span><br><span class="line">        Adj.resize(N);</span><br><span class="line">        distSum.resize(N, <span class="number">0</span>);</span><br><span class="line">        nodeNum.resize(N, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N<span class="number">-1</span>;i++){</span><br><span class="line">            <span class="keyword">int</span> u=edges[i][<span class="number">0</span>], v=edges[i][<span class="number">1</span>];</span><br><span class="line">            Adj[u].push_back(v);  <span class="comment">//不知道根为哪个节点，所以双向连通，以0作为根结点</span></span><br><span class="line">            Adj[v].push_back(u);</span><br><span class="line">        }</span><br><span class="line">        postOrder(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        preOrder(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> distSum;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1130-叶值的最小代价生成树"><a href="#1130-叶值的最小代价生成树" class="headerlink" title="1130. 叶值的最小代价生成树"></a>1130. 叶值的最小代价生成树</h3><p><strong>Description</strong><br>给你一个正整数数组 arr，考虑所有满足以下条件的二叉树：</p><p>每个节点都有 0 个或是 2 个子节点。<br>数组 arr 中的值与树的中序遍历中每个叶节点的值一一对应。（知识回顾：如果一个节点有 0 个子节点，那么该节点为叶节点。）<br>每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。<br>在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。这个和的值是一个 32 位整数。<br><strong>Example</strong><br>示例：<br>输入：arr = [6,2,4]<br>输出：32<br>解释：<br>有两种可能的树，第一种的非叶节点的总和为 36，第二种非叶节点的总和为 32。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    24            24</span><br><span class="line">   /  \          /  \</span><br><span class="line">  12   4        6    8</span><br><span class="line"> /  \               / \</span><br><span class="line">6    2             2   4</span><br></pre></td></tr></tbody></table></figure><p>提示：<br>2 &lt;= arr.length &lt;= 40<br>1 &lt;= arr[i] &lt;= 15<br>答案保证是一个 32 位带符号整数，即小于 2^31。<br><strong>Program</strong><br><strong>动态规划</strong><br>（1）首先数组元素顺序为二叉搜索树中序遍历时叶子节点顺序，而树中非叶子节点的值为左右子树最大叶子节点的乘积，<strong>可以发现需要计算左右子树的最大叶子结点</strong>；<br>（2）而每个子树的最大叶子节点为此子树所包含叶子的最大值，即数组[i,j]中最大的值！<strong>设M[i][j]为包含[i,j]叶子的子树中最大叶子值。</strong><br>（3）题目要求树中节点只有0或2个孩子这两种情况，不包含只有一个孩子的节点！<strong>那么根据分治的思想，每棵子树至少包含一个叶子!</strong>；<br>（4）根据分治的思想，数组[0,n-1]这n个数可以划分成左右两部分，且每部分至少包含一个元素(叶子)，可以发现子问题也是[i.j]这j-i+1个数分成左右两部分，每部分至少包含一个元素(叶子)，现在就好办了；<br>（5）设DP[i][j]为所求[i,j]所组成的子树非叶子节点目标最小和，则状态转移方程为：<br>$DP[i][j]=max(M[i][k] * M[k+1][j] + DP[i][k] + DP[k+1][j]);$<br>注意边界DP[i][i]=0，即子树为叶子。<br>时间复杂度：$O(n^3)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mctFromLeafValues</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        <span class="keyword">int</span> M[n][n];</span><br><span class="line">        <span class="keyword">int</span> DP[n][n];</span><br><span class="line">        <span class="built_in">memset</span>(M, <span class="number">0</span>, <span class="keyword">sizeof</span>(M));</span><br><span class="line">        <span class="built_in">memset</span>(DP, inf, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){ <span class="comment">//求[i,j]范围内最大元素值M[i][j]</span></span><br><span class="line">            <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++){</span><br><span class="line">                ans=max(ans, arr[j]);</span><br><span class="line">                M[i][j]=ans;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">if</span>(i==j) {DP[i][j]=<span class="number">0</span>;<span class="keyword">continue</span>;} <span class="comment">//单个叶子</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++){ <span class="comment">//左右子树至少分得一个叶子</span></span><br><span class="line">                    DP[i][j]=min(DP[i][j], M[i][k]*M[k+<span class="number">1</span>][j]+DP[i][k]+DP[k+<span class="number">1</span>][j]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>单调递减栈</strong><br>通过贪心的思想，a,b,c为三个相邻的叶子，那么b肯定选择a,c中较小的组成一棵子树，然后去掉b，保留a,c再组成更高一层的子树。<br>如果a,b,c单调递减，那么情况不明，因为后续可能出现比c小的叶子，那么需要维护一个单调递减栈，即每个叶子与其左右相邻的叶子中较小的组成子树，得到的结果是最小的。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mctFromLeafValues</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        st.push(inf);</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:arr){</span><br><span class="line">            <span class="keyword">while</span>(x&gt;=st.top()){</span><br><span class="line">                <span class="keyword">int</span> oldTop=st.top();st.pop();</span><br><span class="line">                res+=oldTop * min(x, st.top());</span><br><span class="line">            }</span><br><span class="line">            st.push(x);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(st.size()&gt;<span class="number">2</span>){</span><br><span class="line">            <span class="keyword">int</span> oldTop=st.top();st.pop();</span><br><span class="line">            res+=oldTop * st.top();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1372-二叉树中的最长交错路径"><a href="#1372-二叉树中的最长交错路径" class="headerlink" title="1372. 二叉树中的最长交错路径"></a>1372. 二叉树中的最长交错路径</h3><p><strong>Description</strong><br>给你一棵以 root 为根的二叉树，二叉树中的交错路径定义如下：</p><p>选择二叉树中 任意 节点和一个方向（左或者右）。<br>如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。<br>改变前进方向：左变右或者右变左。<br>重复第二步和第三步，直到你在树中无法继续移动。<br>交错路径的长度定义为：访问过的节点数目 - 1（单个节点的路径长度为 0 ）。</p><p>请你返回给定树中最长 交错路径 的长度。<br><strong>Example</strong><br>示例 1：<br><img src="/assets/img/algorithm/1372_example_01.png" alt="image"><br>输入：root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]<br>输出：3<br>解释：蓝色节点为树中最长交错路径（右 -&gt; 左 -&gt; 右）。</p><p>示例 2：<br><img src="/assets/img/algorithm/1372_example_02.png" alt="image"><br>输入：root = [1,1,1,null,1,null,null,1,1,null,1]<br>输出：4<br>解释：蓝色节点为树中最长交错路径（左 -&gt; 右 -&gt; 左 -&gt; 右）。</p><p>示例 3：<br>输入：root = [1]<br>输出：0<br><strong>Program</strong><br><strong>深搜超时</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> len, <span class="keyword">bool</span> isRight)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> len;</span><br><span class="line">        maxLen=max(maxLen, ++len);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!isRight) ans=dfs(root-&gt;left, len, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span>(isRight) ans=dfs(root-&gt;right, len, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode* root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        dfs(root, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">        recur(root-&gt;right);</span><br><span class="line">        recur(root-&gt;left);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestZigZag</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        recur(root);</span><br><span class="line">        <span class="keyword">return</span> maxLen<span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>记忆化搜索</strong><br>上述dfs有重复计算，比如一条交错路径上的所有节点都不必再次以其为根结点遍历了。<br>时间复杂度还是太高</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;pair&lt;TreeNode*, <span class="keyword">bool</span>&gt;, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> len, <span class="keyword">bool</span> isRight)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) {</span><br><span class="line">            maxLen=max(maxLen, len);</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(m.find(pair&lt;TreeNode*, <span class="keyword">bool</span>&gt;(root, isRight))!=m.end()) <span class="keyword">return</span> m[pair&lt;TreeNode*, <span class="keyword">bool</span>&gt;(root, isRight)];</span><br><span class="line">        ++len;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!isRight) ans=dfs(root-&gt;left, len, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span>(isRight) ans=dfs(root-&gt;right, len, <span class="literal">false</span>);</span><br><span class="line">        m[pair&lt;TreeNode*, <span class="keyword">bool</span>&gt;(root, isRight)]=ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode* root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        dfs(root, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">        recur(root-&gt;right);</span><br><span class="line">        recur(root-&gt;left);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestZigZag</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        recur(root);</span><br><span class="line">        <span class="keyword">return</span> maxLen<span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>优化搜索</strong><br>进一步分析可以发现，如果是一条交错路径，上述记忆化搜索没有必要，因为是交错路径无论从哪个节点遍历不会变长，只会变短！也就是说路径上的节点都不必再次遍历了。<strong>那么有可能有更长的路径就是从每个交错节点开始，朝原本方向反向交错的路径！</strong><br>时间复杂度：$O(n)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> len, <span class="keyword">bool</span> isRight)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) {maxLen=max(maxLen, len);<span class="keyword">return</span>;}</span><br><span class="line">        <span class="keyword">if</span>(!isRight){</span><br><span class="line">            dfs(root-&gt;left, len+<span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">            dfs(root-&gt;right, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(isRight){</span><br><span class="line">            dfs(root-&gt;right, len+<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">            dfs(root-&gt;left, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestZigZag</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        dfs(root, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        dfs(root, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> maxLen<span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>树形DP</strong><br>设leftDP[node]为以node为fahter左孩子且为交错路径终节点的长度，<br>rightDP[node]为以node为father右孩子且为交错路径终节点的长度。<br>则有：<br>leftDP[node]=rightDP[father]+1; //以当前节点为左孩子且为路径终点路径的长度为：其父节点(父节点是其父节点右孩子且为终结点)对应路径长度+1<br>rightDP[node]=leftDP[father]+1; //以当前节点为右孩子且为路径终点路径的长度为：其父节点(父节点是其父节点左孩子且为终结点)对应路径长度+1<br>时间复杂度：$O(n)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestZigZag</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt; leftDP, rightDP;</span><br><span class="line">        leftDP[root]=rightDP[root]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;TreeNode*,TreeNode*&gt;&gt; q;</span><br><span class="line">        q.push({<span class="literal">NULL</span>, root});</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            pair&lt;TreeNode*,TreeNode*&gt; p=q.front();q.pop();</span><br><span class="line">            TreeNode* father=p.first;</span><br><span class="line">            TreeNode* node=p.second;</span><br><span class="line">            <span class="keyword">if</span>(father!=<span class="literal">NULL</span>){</span><br><span class="line">                <span class="keyword">if</span>(father-&gt;left==node) {</span><br><span class="line">                    leftDP[node]=rightDP[father]+<span class="number">1</span>;</span><br><span class="line">                    ans=max(ans, leftDP[node]);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(father-&gt;right==node) {</span><br><span class="line">                    rightDP[node]=leftDP[father]+<span class="number">1</span>;</span><br><span class="line">                    ans=max(ans, rightDP[node]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left!=<span class="literal">NULL</span>) q.push({node, node-&gt;left});</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right!=<span class="literal">NULL</span>) q.push({node, node-&gt;right});</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="环状DP"><a href="#环状DP" class="headerlink" title="环状DP"></a>环状DP</h2><h3 id="873-最长的斐波那契子序列的长度"><a href="#873-最长的斐波那契子序列的长度" class="headerlink" title="873. 最长的斐波那契子序列的长度"></a>873. 最长的斐波那契子序列的长度</h3><p><strong>Description</strong><br>如果序列 X_1, X_2, …, X_n 满足下列条件，就说它是 斐波那契式 的：</p><ul><li>n &gt;= 3</li><li>对于所有 i + 2 &lt;= n，都有 X_i + X_{i+1} = X_{i+2}<br>给定一个严格递增的正整数数组形成序列，找到 A 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。<br>（回想一下，子序列是从原序列 A 中派生出来的，它从 A 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）</li></ul><p><strong>Example</strong><br>示例 1：<br>输入: [1,2,3,4,5,6,7,8]<br>输出: 5<br>解释:<br>最长的斐波那契式子序列为：[1,2,3,5,8] 。</p><p>示例 2：<br>输入: [1,3,7,11,12,14,18]<br>输出: 3<br>解释:<br>最长的斐波那契式子序列有：<br>[1,11,12]，[3,11,14] 以及 [7,11,18] 。</p><p>提示：<br>3 &lt;= A.length &lt;= 1000<br>1 &lt;= A[0] &lt; A[1] &lt; … &lt; A[A.length - 1] &lt;= 10^9<br>（对于以 Java，C，C++，以及 C# 的提交，时间限制被减少了 50%）<br><strong>Program</strong><br><strong>动态规划</strong><br>（1）如果设DP[i]为以i为结尾的满足条件的序列长度，那么在更新的时候无法保证结果是对的：<br>即$DP[i]=max(DP[j]+DP[k]), j=0,1,…,i-1, A[i]-A[j]=A[k]$，即[k,j,i]满足序列后三个元素，但是以第k个元素为结尾的序列(假设其末尾三个元素为[m,n,k])，这里[n,k,j]未必满足题意！<br>（2）故设DP[j][i]表示以j,i为序列末尾两个元素的满足条件的序列长度，递推公式：<br>$DP[j][i]=DP[k][j]+1$,即[k,j]与[j,i]可以相连，注意DP[j][i]初始化为2，因为任意两个不同的数都可以，但是这里要求A[i]&gt;A[j]，此题严格递增，无影响，全部初始化为2.<br>（3）现在来看(2)中是否存在(1)的问题，可以发现已经严格满足序列前两个元素之和等于后一个元素了。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) index[A[i]]=i;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> DP[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            fill(DP[i], DP[i]+n, <span class="number">2</span>); <span class="comment">//初始化</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++){</span><br><span class="line">                <span class="keyword">if</span>(A[i]-A[j]&lt;A[j]&amp;&amp;index.find(A[i]-A[j])!=index.end()){</span><br><span class="line">                    <span class="keyword">int</span> idx=index[A[i]-A[j]];</span><br><span class="line">                    DP[j][i]=DP[idx][j]+<span class="number">1</span>;</span><br><span class="line">                    ans=max(ans, DP[j][i]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans&gt;=<span class="number">3</span>?ans:<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="446-等差数列划分-II-子序列"><a href="#446-等差数列划分-II-子序列" class="headerlink" title="446. 等差数列划分 II - 子序列"></a>446. 等差数列划分 II - 子序列</h3><p><strong>Description</strong><br>如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。<br>例如，以下数列为等差数列:<br>1, 3, 5, 7, 9<br>7, 7, 7, 7<br>3, -1, -5, -9<br>以下数列不是等差数列。<br>1, 1, 2, 5, 7<br>数组 A 包含 N 个数，且索引从 0 开始。该数组子序列将划分为整数序列 (P0, P1, …, Pk)，满足 0 ≤ P0 &lt; P1 &lt; … &lt; Pk &lt; N。<br>如果序列 A[P0]，A[P1]，…，A[Pk-1]，A[Pk] 是等差的，那么数组 A 的子序列 (P0，P1，…，PK) 称为等差序列。值得注意的是，这意味着 k ≥ 2。<br>函数要返回数组 A 中所有等差子序列的个数。<br>输入包含 N 个整数。每个整数都在 -231 和 231-1 之间，另外 0 ≤ N ≤ 1000。保证输出小于 231-1。<br><strong>Example</strong><br>示例：<br>输入：[2, 4, 6, 8, 10]<br>输出：7<br>解释：<br>所有的等差子序列为：<br>[2,4,6]<br>[4,6,8]<br>[6,8,10]<br>[2,4,6,8]<br>[4,6,8,10]<br>[2,4,6,8,10]<br>[2,6,10]<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(A.size()&lt;=<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt;&gt; dp(n);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++){</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> diff=(<span class="keyword">long</span> <span class="keyword">long</span>)A[i]-(<span class="keyword">long</span> <span class="keyword">long</span>)A[j];</span><br><span class="line">                <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[j].find(diff)!=dp[j].end()) s=dp[j][diff];</span><br><span class="line">                dp[i][diff]+=s+<span class="number">1</span>;</span><br><span class="line">                ans+=s;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1027-最长等差数列"><a href="#1027-最长等差数列" class="headerlink" title="1027. 最长等差数列"></a>1027. 最长等差数列</h3><p><strong>Description</strong><br>给定一个整数数组 A，返回 A 中最长等差子序列的长度。<br>回想一下，A 的子序列是列表 A[i_1], A[i_2], …, A[i_k] 其中 0 &lt;= i_1 &lt; i_2 &lt; … &lt; i_k &lt;= A.length - 1。并且如果 B[i+1] - B[i]( 0 &lt;= i &lt; B.length - 1) 的值都相同，那么序列 B 是等差的。<br><strong>Example</strong><br>示例 1：<br>输入：[3,6,9,12]<br>输出：4<br>解释：<br>整个数组是公差为 3 的等差数列。</p><p>示例 2：<br>输入：[9,4,7,2,10]<br>输出：3<br>解释：<br>最长的等差子序列是 [4,7,10]。</p><p>示例 3：<br>输入：[20,1,15,3,10,5,8]<br>输出：4<br>解释：<br>最长的等差子序列是 [20,15,10,5]。</p><p>提示：<br>2 &lt;= A.length &lt;= 2000<br>0 &lt;= A[i] &lt;= 10000<br><strong>Program</strong><br><strong>思路</strong><br>设DP[i][diff]为以i为结尾，diff为差的最长等差子序列的长度；<br>与最长上升子序列类似，状态转移方程:<br>$DP[i][diff]=max(DP[j][diff]+1)$,其中$j&lt;i&lt;n,A[i]-A[j]=diff$<br>初始化DP[i][diff]=1，因为单个元素组成的子序列长度为1，diff任意。<br>时间复杂度:$O(n^2)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestArithSeqLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">20001</span>, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++){</span><br><span class="line">                <span class="keyword">int</span> diff=A[i]-A[j]+<span class="number">10000</span>;</span><br><span class="line">                dp[i][diff]=max(dp[i][diff], dp[j][diff]+<span class="number">1</span>);</span><br><span class="line">                res=max(res, dp[i][diff]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="多DP递推"><a href="#多DP递推" class="headerlink" title="多DP递推"></a>多DP递推</h2><h3 id="1186-删除一次得到子数组最大和"><a href="#1186-删除一次得到子数组最大和" class="headerlink" title="1186. 删除一次得到子数组最大和"></a>1186. 删除一次得到子数组最大和</h3><p><strong>Description</strong><br>给你一个整数数组，返回它的某个 非空 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。<br>换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。<br>注意，删除一个元素后，子数组 不能为空。<br>请看示例：<br><strong>Example</strong><br>示例 1：<br>输入：arr = [1,-2,0,3]<br>输出：4<br>解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。</p><p>示例 2：<br>输入：arr = [1,-2,-2,3]<br>输出：3<br>解释：我们直接选出 [3]，这就是最大和。</p><p>示例 3：<br>输入：arr = [-1,-1,-1,-1]<br>输出：-1<br>解释：最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。<br> 我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。</p><p>提示：<br>1 &lt;= arr.length &lt;= 10^5<br>-10^4 &lt;= arr[i] &lt;= 10^4<br><strong>Program</strong><br><strong>思路</strong><br>本题的关键点就是在于有无删除元素，这个用一个DP很难表示，所以用两个DP，即DP1和DP2，分别表示以第i个元素为结尾的不删除和删除一次的最大和！<br>（1）那么不删除的DP1就是平常的连续子数组最大和：$DP1[i]=max(DP[i-1]+arr[i], arr[i])$；<br>（2）而删除的DP2的状态转移方程为：$DP2[i]=max(DP1[i-1], DP2[i-1]+arr[i])$，max中前一项表示删除arr[i]，后一项表示在前i-1项中删除一个，保留arr[i]！！<br>这样思路就清晰了！<br>时间复杂度：$O(n)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(arr.size()==<span class="number">1</span>) <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        <span class="keyword">int</span> DP1[n]; <span class="comment">//以arr[i]为结尾，不删除的最大和</span></span><br><span class="line">        <span class="keyword">int</span> DP2[n]; <span class="comment">//以arr[i]为结尾，删除元素后的最大和（可能删除了自己）</span></span><br><span class="line">        DP1[<span class="number">0</span>]=arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) DP1[i]=max(DP1[i<span class="number">-1</span>]+arr[i], arr[i]);</span><br><span class="line">        DP2[<span class="number">0</span>]=arr[<span class="number">0</span>];</span><br><span class="line">        DP2[<span class="number">1</span>]=max(arr[<span class="number">0</span>], arr[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++) DP2[i]=max(DP1[i<span class="number">-1</span>], DP2[i<span class="number">-1</span>]+arr[i]); <span class="comment">//前一项为删除自己，后一项为删除了的元素非自己</span></span><br><span class="line">        <span class="keyword">int</span> res=INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            res=max(res, DP1[i]);</span><br><span class="line">            res=max(res, DP2[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1262-可被三整除的最大和"><a href="#1262-可被三整除的最大和" class="headerlink" title="1262. 可被三整除的最大和"></a>1262. 可被三整除的最大和</h3><p><strong>Description</strong><br>给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。<br><strong>Example</strong><br>示例 1：<br>输入：nums = [3,6,5,1,8]<br>输出：18<br>解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。</p><p>示例 2：<br>输入：nums = [4]<br>输出：0<br>解释：4 不能被 3 整除，所以无法选出数字，返回 0。</p><p>示例 3：<br>输入：nums = [1,2,3,4,4]<br>输出：12<br>解释：选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。</p><p>提示：<br>1 &lt;= nums.length &lt;= 4 * 10^4<br>1 &lt;= nums[i] &lt;= 10^4<br><strong>Program</strong><br>设DP[i][3]为前i个元素总和为模3余0,1,2的最大和。<br>边界：DP[0][0]=0表示没有，DP[0][1]=INT_MIN表示无定义</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumDivThree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> dp[n+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; dp[<span class="number">0</span>][<span class="number">1</span>] = INT_MIN; dp[<span class="number">0</span>][<span class="number">2</span>] = INT_MIN;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i - <span class="number">1</span>] % <span class="number">3</span> == <span class="number">0</span>) {</span><br><span class="line">                dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">2</span>] = max(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i - <span class="number">1</span>] % <span class="number">3</span> == <span class="number">1</span>) {</span><br><span class="line">                dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">2</span>] = max(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i - <span class="number">1</span>] % <span class="number">3</span> == <span class="number">2</span>) {</span><br><span class="line">                dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">2</span>] = max(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="特殊DP"><a href="#特殊DP" class="headerlink" title="特殊DP"></a>特殊DP</h2><h3 id="312-戳气球"><a href="#312-戳气球" class="headerlink" title="312. 戳气球"></a>312. 戳气球</h3><p><strong>Description</strong><br>有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。<br>现在要求你戳破所有的气球。如果你戳破气球 i ，就可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。<br>求所能获得硬币的最大数量。<br>说明:<br>你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。<br>0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100<br><strong>Example</strong><br>示例:<br>输入: [3,1,5,8]<br>输出: 167<br>解释: nums = [3,1,5,8] –&gt; [3,5,8] –&gt; [3,8] –&gt; [8] –&gt; []<br> coins = 3<em>1</em>5 + 3<em>5</em>8 + 1<em>3</em>8 + 1<em>8</em>1 = 167<br><strong>Program</strong><br><strong>dfs</strong><br>一般思路就是深搜，如下所示，然而分析发现存在重复计算！—— 画出树形图就会发现</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans=INT_MIN;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> sum)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>){</span><br><span class="line">            ans=max(ans, sum);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++){</span><br><span class="line">            <span class="keyword">int</span> s=(i<span class="number">-1</span>&gt;=<span class="number">0</span>?nums[i<span class="number">-1</span>]:<span class="number">1</span>)*nums[i]*(i+<span class="number">1</span>&lt;nums.size()?nums[i+<span class="number">1</span>]:<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp=nums;</span><br><span class="line">            tmp.erase(tmp.begin()+i);</span><br><span class="line">            dfs(tmp, s+sum);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        dfs(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>记忆化搜索</strong><br>换个思路，直接剔除的方法太过复杂，可以逆向推理，先在原数组基础上添加头尾元素值为1，然后假设中间全为空，一个个插入！</p><ul><li>left&gt;=right-1, return 0;</li><li>vis[left][right]=max(vec[left]<em>vec[k]</em>vec[right]+dfs(left,k)+dfs(k, right))<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vis;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(vis[left][right]!=<span class="number">-1</span>) <span class="keyword">return</span> vis[left][right];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left+<span class="number">1</span>;i&lt;right;i++){</span><br><span class="line">            <span class="keyword">int</span> sum=vec[left]*vec[i]*vec[right];</span><br><span class="line">            sum+=dfs(left, i)+dfs(i, right);</span><br><span class="line">            vis[left][right]=max(vis[left][right], sum);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> vis[left][right];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        n=nums.size();</span><br><span class="line">        vec.resize(n+<span class="number">2</span>);</span><br><span class="line">        vis.resize(n+<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">2</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            vec[i]=nums[i<span class="number">-1</span>];</span><br><span class="line">        }</span><br><span class="line">        vec[<span class="number">0</span>]=vec[n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, n+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li></ul><p><strong>动态规划</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        n=nums.size();</span><br><span class="line">        vec.resize(n+<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            vec[i]=nums[i<span class="number">-1</span>];</span><br><span class="line">        }</span><br><span class="line">        vec[<span class="number">0</span>]=vec[n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> DP[n+<span class="number">2</span>][n+<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;j;k++){</span><br><span class="line">                    DP[i][j]=max(DP[i][j], vec[i]*vec[k]*vec[j]+DP[i][k]+DP[k][j]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[<span class="number">0</span>][n+<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="403-青蛙过河"><a href="#403-青蛙过河" class="headerlink" title="403. 青蛙过河"></a>403. 青蛙过河</h3><p><strong>Description</strong><br>一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。<br>给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。<br>如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。<br>请注意：<br>石子的数量 ≥ 2 且 &lt; 1100；<br>每一个石子的位置序号都是一个非负整数，且其 &lt; 231；<br>第一个石子的位置永远是0。<br><strong>Example</strong><br>示例 1:<br>[0,1,3,5,6,8,12,17]<br>总共有8个石子。<br>第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,<br>第三个石子在序号为3的单元格的位置， 以此定义整个数组…<br>最后一个石子处于序号为17的单元格的位置。</p><p>返回 true。即青蛙可以成功过河，按照如下方案跳跃：<br>跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着<br>跳2个单位到第4块石子, 然后跳3个单位到第6块石子,<br>跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。</p><p>示例 2:<br>[0,1,2,3,4,8,9,11]<br>返回 false。青蛙没有办法过河。<br>这是因为第5和第6个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。<br><strong>Program</strong><br><strong>思路</strong><br>记忆化搜索，记录vis[startIdx][step]表示从索引startIdx开始跳step步长的搜索结果，-1,0,1分别表示未计算，不可达，可达！</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vis; <span class="comment">//0不可达，1可达，-1未计算</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones, <span class="keyword">int</span> startIdx, <span class="keyword">int</span> step)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(vis[startIdx][step]!=<span class="number">-1</span>) <span class="keyword">return</span> vis[startIdx][step];</span><br><span class="line">        <span class="keyword">bool</span> isPass=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=startIdx+<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> sp=stones[i]-stones[startIdx];</span><br><span class="line">            <span class="keyword">if</span>(sp&gt;=step<span class="number">-1</span>&amp;&amp;sp&lt;=step+<span class="number">1</span>){</span><br><span class="line">                isPass|=dfs(stones, i, sp);</span><br><span class="line">                <span class="keyword">if</span>(isPass) <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        vis[startIdx][step]=(isPass||startIdx==n<span class="number">-1</span>)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> vis[startIdx][step];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>{</span><br><span class="line">        n=stones.size();</span><br><span class="line">        vis.resize(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> dfs(stones, <span class="number">0</span>, <span class="number">0</span>) == <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>动态规划</strong><br>map记录能够到每个石子位置key的前一次跳的部署value</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=stones.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:stones) m[x]=<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        m[<span class="number">0</span>].insert(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:stones){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k:m[x]){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> s=k<span class="number">-1</span>;s&lt;=k+<span class="number">1</span>;s++){</span><br><span class="line">                    <span class="keyword">if</span>(s&gt;<span class="number">0</span>&amp;&amp;m.find(x+s)!=m.end()){</span><br><span class="line">                        m[x+s].insert(s);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> m[stones[n<span class="number">-1</span>]].size()&gt;<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="514-自由之路"><a href="#514-自由之路" class="headerlink" title="514. 自由之路"></a>514. 自由之路</h3><p><strong>Description</strong><br>电子游戏“辐射4”中，任务“通向自由”要求玩家到达名为“Freedom Trail Ring”的金属表盘，并使用表盘拼写特定关键词才能开门。<br>给定一个字符串 ring，表示刻在外环上的编码；给定另一个字符串 key，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的最少步数。<br>最初，ring 的第一个字符与12:00方向对齐。您需要顺时针或逆时针旋转 ring 以使 key 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 key 中的所有字符。<br>旋转 ring 拼出 key 字符 key[i] 的阶段中：<br>您可以将 ring 顺时针或逆时针旋转一个位置，计为1步。旋转的最终目的是将字符串 ring 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 key[i] 。<br>如果字符 key[i] 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 1 步。按完之后，您可以开始拼写 key 的下一个字符（下一阶段）, 直至完成所有拼写。<br><strong>Example</strong><br>示例：<br><img src="/assets/img/algorithm/ring.jpg" alt="image"><br>输入: ring = “godding”, key = “gd”<br>输出: 4<br>解释:<br> 对于 key 的第一个字符 ‘g’，已经在正确的位置, 我们只需要1步来拼写这个字符。<br> 对于 key 的第二个字符 ‘d’，我们需要逆时针旋转 ring “godding” 2步使它变成 “ddinggo”。<br> 当然, 我们还需要1步进行拼写。<br> 因此最终的输出是 4。<br>提示：<br>ring 和 key 的字符串长度取值范围均为 1 至 100；<br>两个字符串中都只有小写字符，并且均可能存在重复字符；<br>字符串 key 一定可以由字符串 ring 旋转拼出。<br><strong>Program</strong><br><strong>动态规划</strong><br>（1）定义$dp[i][j]$表示从前往后拼写出key的第i个字符，ring的第j个字符与12:00方向对齐的最小步数<br>（2）只有当字符串ring的第j个字符与key的第i个字符相同时才能拼写出key的第i个字符，因此，对于key的第i个字符，需要考虑计算的ring的第j个字符只有key[i]在ring中出现的下标集合。<br>（3）对于ring的每个字符维护一个位置数组pos[j]，表示字符j在ring中出现的位置集合；<br>（4）状态转移方程：<br>$dp[i][j]=min_{k\in{pos[key[i-1]]}}{\lbrace dp[i-1][k] + min\lbrace abs(j-k), n -abs(j-k)\rbrace + 1\rbrace}$<br>其中$min{abs(j-k), n-abs(j-k)}+1$表示在当前第k个字符与12:00方向对齐时第j个字符旋转到12:00方向并按下拼写的最少步数。<br>时间复杂度：$O(mn^2)$,m为key的长度，n为ring的长度<br>空间复杂度：$O(mn)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRotateSteps</span><span class="params">(<span class="built_in">string</span> ring, <span class="built_in">string</span> key)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m=key.length(), n=ring.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){ <span class="comment">//记录每个ring元素出现的位置</span></span><br><span class="line">            pos[ring[i] - <span class="string">'a'</span>].push_back(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> dp[m][n];</span><br><span class="line">        <span class="built_in">memset</span>(dp, inf, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j:pos[key[<span class="number">0</span>] - <span class="string">'a'</span>]){</span><br><span class="line">            dp[<span class="number">0</span>][j]=min(j, n-j)+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j:pos[key[i]- <span class="string">'a'</span>]){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k:pos[key[i<span class="number">-1</span>] -<span class="string">'a'</span>]){</span><br><span class="line">                    dp[i][j]=min(dp[i][j], dp[i<span class="number">-1</span>][k]+min(<span class="built_in">abs</span>(j-k), n-<span class="built_in">abs</span>(j-k))+<span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans=inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) ans=min(ans, dp[m<span class="number">-1</span>][j]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="546-移除盒子"><a href="#546-移除盒子" class="headerlink" title="546. 移除盒子"></a>546. 移除盒子</h3><p><strong>Description</strong><br>给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色。<br>你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k &gt;= 1），这样一轮之后你将得到 k<em>k 个积分。<br>当你将所有盒子都去掉之后，求你能获得的最大积分和。<br>*</em>Example**<br>示例：<br>输入：boxes = [1,3,2,2,2,3,4,3,1]<br>输出：23<br>解释：<br>[1, 3, 2, 2, 2, 3, 4, 3, 1]<br>—-&gt; [1, 3, 3, 4, 3, 1] (3<em>3=9 分)<br>—-&gt; [1, 3, 3, 3, 1] (1</em>1=1 分)<br>—-&gt; [1, 1] (3<em>3=9 分)<br>—-&gt; [] (2</em>2=4 分)</p><p>提示：<br>1 &lt;= boxes.length &lt;= 100<br>1 &lt;= boxes[i] &lt;= 100<br><strong>Program</strong><br>设DP[l][r][k]为区间[l,r]<strong>且右边有与r相同的相连k个元素</strong> 的分数，对于r来说有两种决策：<br>（1）直接删除r以及右边与其相连的k个相同元素，DP[l][r-1][0]+(k+1) * (k+1) —— DP[l][r-1][0]中k==0表示r及右边k个元素删除后，与r-1右边没有相连了。<br>（2）不删除r，将其与[l,r-1]中 <strong>某个与r相同的元素i</strong> 相连，DP[l][i][k+1]+DP[i+1][r][0] —— DP[l][i][k+1]表示r不删除与i相连了，而DP[i+1][r][0]为删除[i+1,r]这部分的分数，k==0表示右边没有与r相连的相同元素了，因为r及右边k个相同相连元素全部跳过区间[i+1,r]而直接与i相连了。<br>时间复杂度：$O(n^4)$，最坏情况下每个 DP(l, r, k) 被计算一次，每次状态转移需要 $O(n)$ 的时间复杂度。<br>空间复杂度：$O(n^3)$，dp 数组的空间代价是 $O(n^3)$，递归使用栈空间的代价为 $O(n)$。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> DP[<span class="number">100</span>][<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeBoxes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; boxes)</span> </span>{</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">int</span> n=boxes.size();</span><br><span class="line">        <span class="keyword">return</span> calPoints(boxes, <span class="number">0</span>, n<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; boxes, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(DP[left][right][k]!=<span class="number">0</span>) <span class="keyword">return</span> DP[left][right][k];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;boxes[right]==boxes[right<span class="number">-1</span>]){</span><br><span class="line">            right--;</span><br><span class="line">            k++;</span><br><span class="line">        }</span><br><span class="line">        DP[left][right][k]=calPoints(boxes, left, right<span class="number">-1</span>, <span class="number">0</span>) + (k+<span class="number">1</span>)*(k+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;right;i++){</span><br><span class="line">            <span class="keyword">if</span>(boxes[right]==boxes[i]){</span><br><span class="line">                DP[left][right][k]=max(</span><br><span class="line">                    DP[left][right][k],</span><br><span class="line">                    calPoints(boxes, left, i, k+<span class="number">1</span>) + calPoints(boxes, i+<span class="number">1</span>, right<span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">                );</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[left][right][k];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="956-最高的广告牌"><a href="#956-最高的广告牌" class="headerlink" title="956. 最高的广告牌"></a>956. 最高的广告牌</h3><p><strong>Description</strong><br>你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。<br>你有一堆可以焊接在一起的钢筋 rods。举个例子，如果钢筋的长度为 1、2 和 3，则可以将它们焊接在一起形成长度为 6 的支架。<br>返回广告牌的最大可能安装高度。如果没法安装广告牌，请返回 0。<br><strong>Example</strong><br>示例 1：<br>输入：[1,2,3,6]<br>输出：6<br>解释：我们有两个不相交的子集 {1,2,3} 和 {6}，它们具有相同的和 sum = 6。</p><p>示例 2：<br>输入：[1,2,3,4,5,6]<br>输出：10<br>解释：我们有两个不相交的子集 {2,3,5} 和 {4,6}，它们具有相同的和 sum = 10。</p><p>示例 3：<br>输入：[1,2]<br>输出：0<br>解释：没法安装广告牌，所以返回 0。</p><p>提示：<br>0 &lt;= rods.length &lt;= 20<br>1 &lt;= rods[i] &lt;= 1000<br>钢筋的长度总和最多为 5000<br><strong>Program</strong><br><strong>深搜</strong><br>一个很正常的思路，对于每个rods[i]，可以给左边、右边、丢弃，然后通过后缀进行剪枝，然而还是超时！</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> resH;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> i, ls, rs;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> _i, <span class="keyword">int</span> _ls, <span class="keyword">int</span> _rs):i(_i),ls(_ls),rs(_rs){}</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; suffix;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rods, <span class="keyword">int</span> i, <span class="keyword">int</span> leftSum, <span class="keyword">int</span> rightSum)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(i==n){</span><br><span class="line">            <span class="keyword">if</span>(leftSum==rightSum){</span><br><span class="line">                resH=max(resH, leftSum);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(leftSum&gt;rightSum&amp;&amp;suffix[i]+rightSum&lt;leftSum) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rightSum&gt;leftSum&amp;&amp;suffix[i]+leftSum&lt;rightSum) <span class="keyword">return</span>;</span><br><span class="line">        dfs(rods, i+<span class="number">1</span>, leftSum+rods[i], rightSum);</span><br><span class="line">        dfs(rods, i+<span class="number">1</span>, leftSum, rightSum+rods[i]);</span><br><span class="line">        dfs(rods, i+<span class="number">1</span>, leftSum, rightSum);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">tallestBillboard</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rods)</span> </span>{</span><br><span class="line">        n=rods.size();</span><br><span class="line">        resH=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        suffix.resize(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=rods.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            sum+=rods[i];</span><br><span class="line">            suffix[i]=sum;</span><br><span class="line">        }</span><br><span class="line">        dfs(rods, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> resH;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>动态规划</strong><br>设DP[i][j]为前i+1个元素的两个子集差为j的最大总和，例如[1,2,3]，DP[2][1]可以有{1,2},{2,3}，DP[2][1]为5；<br>状态转移方程：<br>（1）丢弃，DP[i][j]=max(DP[i][j],DP[i-1][j])，即与前一个相同；<br>（2）放入和较大的一方，DP[i][j+rods[i]]=max(DP[i][j+rods[i]], DP[i-1][j]+rods[i]);<br>（3）放入和较小的一方，DP[i][abs(j-rods[i])]=max(DP[i][abs(j-rods[i])], DP[i-1][j]+rods[i]);</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">tallestBillboard</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rods)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(rods.size()&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=rods.size();</span><br><span class="line">        <span class="keyword">int</span> sum=accumulate(rods.begin(), rods.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> DP[n][sum+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">int</span> preSum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=preSum;j++){</span><br><span class="line">                <span class="comment">//差为j的和至少为j</span></span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;DP[i<span class="number">-1</span>][j]&lt;j) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//丢弃</span></span><br><span class="line">                DP[i][j]=max(DP[i][j], (i&gt;<span class="number">0</span>?DP[i<span class="number">-1</span>][j]:<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//加到大的集合</span></span><br><span class="line">                <span class="keyword">int</span> k=j+rods[i];</span><br><span class="line">                DP[i][k]=max(DP[i][k], (i&gt;<span class="number">0</span>?DP[i<span class="number">-1</span>][j]:<span class="number">0</span>)+rods[i]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//加到小的集合</span></span><br><span class="line">                k=<span class="built_in">abs</span>(j-rods[i]);</span><br><span class="line">                DP[i][k]=max(DP[i][k], (i&gt;<span class="number">0</span>?DP[i<span class="number">-1</span>][j]:<span class="number">0</span>)+rods[i]);</span><br><span class="line">            }</span><br><span class="line">            preSum+=rods[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[n<span class="number">-1</span>][<span class="number">0</span>]/<span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>状态压缩</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">tallestBillboard</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rods)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(rods.size()&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=rods.size();</span><br><span class="line">        <span class="keyword">int</span> sum=accumulate(rods.begin(), rods.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP(sum+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> preSum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; newDP(sum+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=preSum;j++){</span><br><span class="line">                <span class="comment">//差为j的和至少为j</span></span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;DP[j]&lt;j) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//丢弃</span></span><br><span class="line">                newDP[j]=max(newDP[j], DP[j]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//加到大的集合</span></span><br><span class="line">                <span class="keyword">int</span> k=j+rods[i];</span><br><span class="line">                newDP[k]=max(newDP[k], DP[j]+rods[i]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//加到小的集合</span></span><br><span class="line">                k=<span class="built_in">abs</span>(j-rods[i]);</span><br><span class="line">                newDP[k]=max(newDP[k], DP[j]+rods[i]);</span><br><span class="line">            }</span><br><span class="line">            preSum+=rods[i];</span><br><span class="line">            swap(DP, newDP);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[<span class="number">0</span>]/<span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1631-最小体力消耗路径"><a href="#1631-最小体力消耗路径" class="headerlink" title="1631. 最小体力消耗路径"></a>1631. 最小体力消耗路径</h3><p><strong>Description</strong><br>你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上，下，左，右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。<br>一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。<br>请你返回从左上角走到右下角的最小 体力消耗值 。<br><strong>Example</strong><br>示例 1：<br><img src="/assets/img/algorithm/ex1.png" alt="image"><br>输入：heights = [[1,2,2],[3,8,2],[5,3,5]]<br>输出：2<br>解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。<br>这条路径比路径 [1,2,2,2,5] 更优，因为另一条路劲差值最大值为 3 。</p><p>示例 2：<br><img src="/assets/img/algorithm/ex2.png" alt="image"><br>输入：heights = [[1,2,3],[3,8,4],[5,3,5]]<br>输出：1<br>解释：路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。</p><p>示例 3：<br><img src="/assets/img/algorithm/ex3.png" alt="image"><br>输入：heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]<br>输出：0<br>解释：上图所示路径不需要消耗任何体力。</p><p>提示：<br>rows == heights.length<br>columns == heights[i].length<br>1 &lt;= rows, columns &lt;= 100<br>1 &lt;= heights[i][j] &lt;= 106<br><strong>Program</strong><br><strong>思路</strong><br>（1）设DP[i][j]为从[0][0]到[i][j]路径的最小体力消耗；<br>（2）通过优先队列广搜更新DP值，出队列的元素用vis标记；<br>（3）因为可能同时搜索到同一个位置[i][j]，更新DP[i][j]，所以优先队列，根据DP值更小的先出队列；</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> steps[<span class="number">4</span>][<span class="number">2</span>]={</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; DP;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; vis;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="keyword">int</span> dis;</span><br><span class="line">        Node(){}</span><br><span class="line">        Node(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y, <span class="keyword">int</span> _dis){</span><br><span class="line">            x=_x;</span><br><span class="line">            y=_y;</span><br><span class="line">            dis=_dis;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; other) <span class="keyword">const</span>{</span><br><span class="line">            <span class="keyword">return</span> dis&gt;other.dis;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    priority_queue&lt;Node&gt; pq;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumEffortPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; heights)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m=heights.size(), n=heights[<span class="number">0</span>].size();</span><br><span class="line">        DP.resize(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, inf));</span><br><span class="line">        vis.resize(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        DP[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        pq.push(Node(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty()){</span><br><span class="line">            Node node=pq.top(); pq.pop();</span><br><span class="line">            <span class="keyword">if</span>(vis[node.x][node.y]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> x=node.x, y=node.y;</span><br><span class="line">            vis[x][y]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line">                <span class="keyword">int</span> new_x=x+steps[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> new_y=y+steps[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(new_x&gt;=<span class="number">0</span>&amp;&amp;new_x&lt;m&amp;&amp;new_y&gt;=<span class="number">0</span>&amp;&amp;new_y&lt;n&amp;&amp;!vis[new_x][new_y]){</span><br><span class="line">                    <span class="keyword">int</span> d=max(node.dis, <span class="built_in">abs</span>(heights[x][y]-heights[new_x][new_y]));</span><br><span class="line">                    DP[new_x][new_y]=min(d, DP[new_x][new_y]);</span><br><span class="line">                    pq.push(Node(new_x, new_y, DP[new_x][new_y]));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h2><h3 id="464-我能赢吗-1"><a href="#464-我能赢吗-1" class="headerlink" title="464. 我能赢吗"></a>464. 我能赢吗</h3><p><strong>Description</strong><br>在 “100 game” 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和达到 100 的玩家，即为胜者。<br>如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？<br>例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &gt;= 100。<br>给定一个整数 maxChoosableInteger （整数池中可选择的最大数）和另一个整数 desiredTotal（累计和），判断先出手的玩家是否能稳赢（假设两位玩家游戏时都表现最佳）？<br>你可以假设 maxChoosableInteger 不会大于 20， desiredTotal 不会大于 300。<br><strong>Example</strong><br>示例：<br>输入：<br>maxChoosableInteger = 10<br>desiredTotal = 11<br>输出：<br>false<br>解释：<br>无论第一个玩家选择哪个整数，他都会失败。<br>第一个玩家可以选择从 1 到 10 的整数。<br>如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。<br>第二个玩家可以通过选择整数 10（那么累积和为 11 &gt;= desiredTotal），从而取得胜利.<br>同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。<br><strong>Program</strong><br>DP[num][total]=!DP[num|i][total-i] if i&lt;total else 1;<br>num用二进制表示共有maxChoosableInteger位，选择了i则其第i-1为数字为1，表示已选。<br>DP[num][total]表示当前选取的num组合下先手在total下的输赢情况。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vis, <span class="keyword">int</span> num, <span class="keyword">int</span> mvalue, <span class="keyword">int</span> total)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(vis[num]!=<span class="number">-1</span>) <span class="keyword">return</span> vis[num];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mvalue;i++){</span><br><span class="line">            <span class="keyword">int</span> cur=(<span class="number">1</span>&lt;&lt;i); <span class="comment">//选择i+1</span></span><br><span class="line">            <span class="keyword">if</span>((num&amp;cur)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&gt;=total){</span><br><span class="line">                vis[num]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">bool</span> next=helper(vis, (num|cur), mvalue, total-i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(next==<span class="literal">false</span>){</span><br><span class="line">                vis[num]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(vis[num]==<span class="number">-1</span>) vis[num]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> vis[num];</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canIWin</span><span class="params">(<span class="keyword">int</span> maxChoosableInteger, <span class="keyword">int</span> desiredTotal)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>((maxChoosableInteger*(maxChoosableInteger+<span class="number">1</span>)/<span class="number">2</span>)&lt;desiredTotal) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vis((<span class="number">1</span>&lt;&lt;maxChoosableInteger)<span class="number">-1</span>, <span class="number">-1</span>); <span class="comment">//-1没计算，0和1代表计算后不能赢和能赢</span></span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(vis, num, maxChoosableInteger, desiredTotal);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="526-优美的排列"><a href="#526-优美的排列" class="headerlink" title="526. 优美的排列"></a>526. 优美的排列</h3><p><strong>Description</strong><br>假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 &lt;= i &lt;= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：</p><p>第 i 位的数字能被 i 整除<br>i 能被第 i 位上的数字整除<br>现在给定一个整数 N，请问可以构造多少个优美的排列？<br><strong>Example</strong><br>示例1:<br>输入: 2<br>输出: 2<br>解释:<br>第 1 个优美的排列是 [1, 2]:<br> 第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除<br> 第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除</p><p>第 2 个优美的排列是 [2, 1]:<br> 第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除<br> 第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除<br>说明:<br>N 是一个正整数，并且不会超过15。<br><strong>Program</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(s==n){</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="keyword">if</span>(!vis[i]){</span><br><span class="line">                <span class="keyword">if</span>(((s+<span class="number">1</span>)%i==<span class="number">0</span>)||(i%(s+<span class="number">1</span>)==<span class="number">0</span>)){</span><br><span class="line">                    vis[i]=<span class="literal">true</span>;</span><br><span class="line">                    dfs(s+<span class="number">1</span>);</span><br><span class="line">                    vis[i]=<span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countArrangement</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        n=N;</span><br><span class="line">        vis.resize(n+<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>状态压缩DP</strong><br>设DP[i]为排列i的个数，其中i用二进制表示，例如1011表示数1,2,4被使用:<br>令j为待排列的数字(1…N)，那么i中第j-1位必须为0表示未用，状态转移方程：<br>DP[i|(1&lt;&lt;(j-1))]+=DP[i]，当i的第j-1位未使用，且j与s成倍数关系（s为当前待排的第s个数）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countArrangement</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP(<span class="number">1</span>&lt;&lt;N, <span class="number">0</span>);</span><br><span class="line">        DP[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;N);i++){</span><br><span class="line">            <span class="keyword">int</span> s=<span class="number">0</span>; <span class="comment">//已经使用的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++){</span><br><span class="line">                s+=(i&gt;&gt;j)&amp;<span class="number">1</span>; <span class="comment">//第j位是否为1,1表示使用，0表示未使用</span></span><br><span class="line">            }</span><br><span class="line">            s++;<span class="comment">//正在使用的第s个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++){ <span class="comment">//遍历第s个数的可能值</span></span><br><span class="line">                <span class="keyword">if</span>(((i&gt;&gt;(j<span class="number">-1</span>))&amp;<span class="number">1</span>)==<span class="number">0</span>&amp;&amp;(j%s==<span class="number">0</span>||s%j==<span class="number">0</span>)){</span><br><span class="line">                    DP[i|(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))]+=DP[i];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DP[(<span class="number">1</span>&lt;&lt;N)<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="698-划分为k个相等的子集-1"><a href="#698-划分为k个相等的子集-1" class="headerlink" title="698. 划分为k个相等的子集"></a>698. 划分为k个相等的子集</h3><p><strong>Description</strong><br>给定一个整数数组 nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。<br><strong>Example</strong><br>示例 1：<br>输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4<br>输出： True<br>说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。</p><p>提示：<br>1 &lt;= k &lt;= len(nums) &lt;= 16<br>0 &lt; nums[i] &lt; 10000<br><strong>Program</strong><br><strong>回溯</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> target;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i)</span></span>{ <span class="comment">//每个元素都有k种选择</span></span><br><span class="line">        <span class="keyword">if</span>(i == n){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j ++){</span><br><span class="line">                <span class="keyword">if</span>(st[j] != target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j ++){</span><br><span class="line">            <span class="keyword">if</span>(st[j] + nums[i] &gt; target) <span class="keyword">continue</span>;</span><br><span class="line">            st[j] += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(helper(nums, i + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            st[j] -= nums[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        st.resize(k, <span class="number">0</span>);</span><br><span class="line">        target = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span> -&gt; k = k;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(target % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        target /= k;</span><br><span class="line">        sort(nums.begin(), nums.end(), greater&lt;<span class="keyword">int</span>&gt;()); <span class="comment">//大的值更容易确定位置，减少递归次数，否则超时</span></span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>状压DP</strong><br>设dp[s]表示集合s能够组成的分组个数，st_sum[s]为集合s的和<br>状态转移方程：<br>当st_sum[s | (1 &lt;&lt; i)] % target == 0时，dp[s | (1 &lt;&lt; i)] = max(dp[s | (1 &lt;&lt; i)], dp[s] + 1)；<br>否则，dp[s | (1 &lt;&lt; i)] = max(dp[s | (1 &lt;&lt; i)], dp[s])；<br>st_sum[s | (1 &lt;&lt; i)] = st_sum[s] + nums[i];<br>时间复杂度：$O(2^n * n)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> target = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(target % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        target /= k;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">1</span> &lt;&lt; n, <span class="number">0</span>); <span class="comment">//表示集合s能够构成的分组个数</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; st_sum(<span class="number">1</span> &lt;&lt; n, <span class="number">0</span>); <span class="comment">//集合s的和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); s ++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++){</span><br><span class="line">                <span class="keyword">if</span>((s &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">//集合s已经包含i</span></span><br><span class="line">                <span class="keyword">int</span> new_s = s | (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                st_sum[new_s] = st_sum[s] + nums[i];</span><br><span class="line">                <span class="keyword">if</span>(st_sum[new_s] % target == <span class="number">0</span>) dp[new_s] = max(dp[new_s], dp[s] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> dp[new_s] = max(dp[new_s], dp[s]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>] == k;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="1723-完成所有工作的最短时间"><a href="#1723-完成所有工作的最短时间" class="headerlink" title="1723. 完成所有工作的最短时间"></a>1723. 完成所有工作的最短时间</h3><p><strong>Description</strong><br>给你一个整数数组 jobs ，其中 jobs[i] 是完成第 i 项工作要花费的时间。<br>请你将这些工作分配给 k 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 工作时间 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 最大工作时间 得以 最小化 。<br>返回分配方案中尽可能 最小 的 最大工作时间 。<br><strong>Example</strong><br>示例 1：<br>输入：jobs = [3,2,3], k = 3<br>输出：3<br>解释：给每位工人分配一项工作，最大工作时间是 3 。</p><p>示例 2：<br>输入：jobs = [1,2,4,7,8], k = 2<br>输出：11<br>解释：按下述方式分配工作：<br>1 号工人：1、2、8（工作时间 = 1 + 2 + 8 = 11）<br>2 号工人：4、7（工作时间 = 4 + 7 = 11）<br>最大工作时间是 11 。</p><p>提示：<br>1 &lt;= k &lt;= jobs.length &lt;= 12<br>1 &lt;= jobs[i] &lt;= 107<br><strong>Program</strong><br><strong>极大极小化/状压DP</strong><br>设dp[k][s]为前k个工人，分配了二进制s集合任务(s中1的位置表示选择第i个任务)，状态转移方程：<br>$dp[k][s] = min(max(dp[k - 1][t], total[t]))$，其中t是s所有1的子集<br>total[i]表示集合i的总用时</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTimeRequired</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; jobs, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n =jobs.size();</span><br><span class="line">        <span class="keyword">int</span> dp[k][<span class="number">1</span> &lt;&lt; n];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">int</span> total[<span class="number">1</span> &lt;&lt; n]; <span class="comment">//任务子集所耗的总时间</span></span><br><span class="line">        <span class="built_in">memset</span>(total, <span class="number">0</span>, <span class="keyword">sizeof</span>(total));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i ++ ){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++ ){</span><br><span class="line">                <span class="keyword">if</span>((i &amp; (<span class="number">1</span> &lt;&lt; j)) == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">//i不包含j</span></span><br><span class="line">                total[i] = total[i - (<span class="number">1</span> &lt;&lt; j)] + jobs[j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j ++ ){</span><br><span class="line">            dp[<span class="number">0</span>][j] = total[j];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i ++ ){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); s ++ ){</span><br><span class="line">                <span class="keyword">int</span> minValue = inf;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> t = s; t &gt; <span class="number">0</span>; t = (t - <span class="number">1</span>) &amp; s){ <span class="comment">//枚举s的子集</span></span><br><span class="line">                    <span class="keyword">int</span> value = max(dp[i - <span class="number">1</span>][t], total[s - t]); <span class="comment">//最大工作时间</span></span><br><span class="line">                    minValue = min(minValue, value); <span class="comment">//求所有可能值的最小值</span></span><br><span class="line">                }</span><br><span class="line">                dp[i][s] = minValue;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[k - <span class="number">1</span>][(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="关联DP"><a href="#关联DP" class="headerlink" title="关联DP"></a>关联DP</h2><h3 id="1473-粉刷房子-III"><a href="#1473-粉刷房子-III" class="headerlink" title="1473. 粉刷房子 III"></a>1473. 粉刷房子 III</h3><p><strong>Program</strong><br>在一个小城市里，有 m 个房子排成一排，你需要给每个房子涂上 n 种颜色之一（颜色编号为 1 到 n ）。有的房子去年夏天已经涂过颜色了，所以这些房子不需要被重新涂色。<br>我们将连续相同颜色尽可能多的房子称为一个街区。（比方说 houses = [1,2,2,3,3,2,1,1] ，它包含 5 个街区 [{1}, {2,2}, {3,3}, {2}, {1,1}] 。）<br>给你一个数组 houses ，一个 m * n 的矩阵 cost 和一个整数 target ，其中：<br>houses[i]：是第 i 个房子的颜色，0 表示这个房子还没有被涂色。<br>cost[i][j]：是将第 i 个房子涂成颜色 j+1 的花费。<br>请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成 target 个街区。如果没有可用的涂色方案，请返回 -1 。<br><strong>Example</strong><br>示例 1：<br>输入：houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3<br>输出：9<br>解释：房子涂色方案为 [1,2,2,1,1]<br>此方案包含 target = 3 个街区，分别是 [{1}, {2,2}, {1,1}]。<br>涂色的总花费为 (1 + 1 + 1 + 1 + 5) = 9。</p><p>示例 2：<br>输入：houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3<br>输出：11<br>解释：有的房子已经被涂色了，在此基础上涂色方案为 [2,2,1,2,2]<br>此方案包含 target = 3 个街区，分别是 [{2,2}, {1}, {2,2}]。<br>给第一个和最后一个房子涂色的花费为 (10 + 1) = 11。</p><p>示例 3：<br>输入：houses = [0,0,0,0,0], cost = [[1,10],[10,1],[1,10],[10,1],[1,10]], m = 5, n = 2, target = 5<br>输出：5</p><p>示例 4：<br>输入：houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3<br>输出：-1<br>解释：房子已经被涂色并组成了 4 个街区，分别是 [{3},{1},{2},{3}] ，无法形成 target = 3 个街区。</p><p>提示：<br>m == houses.length == cost.length<br>n == cost[i].length<br>1 &lt;= m &lt;= 100<br>1 &lt;= n &lt;= 20<br>1 &lt;= target &lt;= m<br>0 &lt;= houses[i] &lt;= n<br>1 &lt;= cost[i][j] &lt;= 10^4<br><strong>Program</strong><br><strong>动归</strong><br>设dp[i][j][k]为刷第i个房子为颜色j属于第k个分区的最小花费，状态转移方程：<br>初始化dp[i][j][k]为inf；<br>当house[i] == 0未上色时，<br>$$<br>dp[i][j][k] = min(dp[i - 1][j][k], dp[i - 1][p][k - 1] + cost[i][j], p != j<br>$$<br>即前一个房子与当前房子颜色是否相同两种情况<br>当house[i] != 0已上色时，<br>$$<br>dp[i][j][k] = min(dp[i - 1][j][k], dp[i - 1][p][k - 1] , p != j<br>$$<br>边界：<br>当house[i] == 0未上色时，dp[0][j][0] = cost[0][j];<br>当house[i] != 0已上色且j == house[i]时，dp[0][j][0] = 0<br>时间复杂度：$O(m * n^2 * target)$<br>空间复杂度：$O(m * n * target)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; houses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; cost, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> dp[m + <span class="number">1</span>][n + <span class="number">1</span>][target + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, inf, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="comment">//边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++ ){</span><br><span class="line">            <span class="keyword">if</span>(houses[<span class="number">0</span>] != <span class="number">0</span>){ <span class="comment">//已染色</span></span><br><span class="line">                <span class="keyword">if</span>(houses[<span class="number">0</span>] == j) dp[<span class="number">1</span>][j][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            }<span class="keyword">else</span> dp[<span class="number">1</span>][j][<span class="number">1</span>] = cost[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i ++ ){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= target &amp;&amp; k &lt;= i; k ++ ){</span><br><span class="line">                    <span class="keyword">int</span> color = houses[i - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(color == <span class="number">0</span>){ <span class="comment">//未染色</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">1</span>; p &lt;= n; p ++ ){</span><br><span class="line">                            <span class="keyword">if</span>(p == j) dp[i][j][k] = min(dp[i][j][k], dp[i - <span class="number">1</span>][j][k]);</span><br><span class="line">                            <span class="keyword">else</span> dp[i][j][k] = min(dp[i][j][k], dp[i - <span class="number">1</span>][p][k - <span class="number">1</span>]);</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">if</span>(dp[i][j][k] != inf) dp[i][j][k] += cost[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    }<span class="keyword">else</span>{ <span class="comment">//已染色</span></span><br><span class="line">                        <span class="keyword">if</span>(j != color) <span class="keyword">continue</span>; <span class="comment">//颜色不对</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">1</span>; p &lt;= n; p ++ ){</span><br><span class="line">                            <span class="keyword">if</span>(p == j) dp[i][j][k] = min(dp[i][j][k], dp[i - <span class="number">1</span>][j][k]);</span><br><span class="line">                            <span class="keyword">else</span> dp[i][j][k] = min(dp[i][j][k], dp[i - <span class="number">1</span>][p][k - <span class="number">1</span>]);</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ){</span><br><span class="line">            ans = min(ans, dp[m][j][target]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans == inf ? <span class="number">-1</span> : ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><h1 id="POJ"><a href="#POJ" class="headerlink" title="POJ"></a>POJ</h1></blockquote><h2 id="3616-Milking-Time"><a href="#3616-Milking-Time" class="headerlink" title="3616 Milking Time"></a>3616 Milking Time</h2><table><thead><tr><th align="center">Time Limit: 1000MS</th><th align="center">Memory Limit: 65536K</th></tr></thead><tbody><tr><td align="center">Total Submissions: 19649</td><td align="center">Accepted: 8598</td></tr></tbody></table><p><strong>Description</strong><br>Bessie is such a hard-working cow. In fact, she is so focused on maximizing her productivity that she decides to schedule her next $N (1 ≤ N ≤ 1,000,000)$ hours (conveniently labeled $0..N-1$) so that she produces as much milk as possible.</p><p>Farmer John has a list of $M$ ($1 ≤ M ≤ 1,000$) possibly overlapping intervals in which he is available for milking. Each interval i has a starting hour $(0 ≤ starting_houri ≤ N)$, an ending hour (starting_houri &lt; ending_houri ≤ N), and a corresponding efficiency $(1 ≤ efficiencyi ≤ 1,000,000)$ which indicates how many gallons of milk that he can get out of Bessie in that interval. Farmer John starts and stops milking at the beginning of the starting hour and ending hour, respectively. When being milked, Bessie must be milked through an entire interval.</p><p>Even Bessie has her limitations, though. After being milked during any interval, she must rest R (1 ≤ R ≤ N) hours before she can start milking again. Given Farmer Johns list of intervals, determine the maximum amount of milk that Bessie can produce in the N hours.</p><p><strong>Input</strong></p><ul><li>Line 1: Three space-separated integers: N, M, and R</li><li>Lines 2..M+1: Line i+1 describes FJ’s ith milking interval withthree space-separated integers: starting_houri , ending_houri , and efficiencyi</li></ul><p><strong>Output</strong></p><ul><li>Line 1: The maximum number of gallons of milk that Bessie can product in the N hours</li></ul><p>Sample Input<br>12 4 2<br>1 2 8<br>10 12 19<br>3 6 24<br>7 10 31<br>Sample Output<br>43<br><strong>Program</strong><br><strong>DP</strong><br>设DP[i]为以i为结尾的最大分数，状态转移方程：DP[i]=max(DP[i], DP[j]+nums[i].w); 其中j为i左边与其不重叠的区间索引。<br>时间复杂度：$O(n^2)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">	<span class="keyword">int</span> l, r, w;</span><br><span class="line">	Node(){}</span><br><span class="line">	Node(<span class="keyword">int</span> _l, <span class="keyword">int</span> _r, <span class="keyword">int</span> _w):l(_l),r(_r),w(_w){}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; tmp) <span class="keyword">const</span>{</span><br><span class="line">		<span class="keyword">return</span> l&lt;tmp.l;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n,m,r;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;r;</span><br><span class="line">	<span class="built_in">vector</span>&lt;Node&gt; vec;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">		<span class="keyword">int</span> l,r,w;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;w;</span><br><span class="line">		vec.push_back(Node(l,r,w));</span><br><span class="line">	}</span><br><span class="line">	sort(vec.begin(), vec.end());</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP(m, <span class="number">0</span>); <span class="comment">//前i个的最大金额</span></span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">		DP[i]=vec[i].w;<span class="comment">//初始化</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--){</span><br><span class="line">			<span class="keyword">if</span>(vec[j].r+r&lt;=vec[i].l){</span><br><span class="line">				DP[i]=max(DP[i], DP[j]+vec[i].w);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		ans=max(ans, DP[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="经典DP题"><a href="#经典DP题" class="headerlink" title="经典DP题"></a>经典DP题</h2><h2 id="885-螺旋矩阵-III"><a href="#885-螺旋矩阵-III" class="headerlink" title="885. 螺旋矩阵 III"></a>885. 螺旋矩阵 III</h2><p><strong>Description</strong><br>给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。<br>已知存在楼层 f ，满足 0 &lt;= f &lt;= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。<br>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 &lt;= x &lt;= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。<br>请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？<br><strong>Example</strong><br>示例 1：<br>输入：k = 1, n = 2<br>输出：2<br>解释：<br>鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。<br>否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。<br>如果它没碎，那么肯定能得出 f = 2 。<br>因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。</p><p>示例 2：<br>输入：k = 2, n = 6<br>输出：3</p><p>示例 3：<br>输入：k = 3, n = 14<br>输出：4</p><p>提示：<br>1 &lt;= k &lt;= 100<br>1 &lt;= n &lt;= 104<br><strong>Program</strong><br><strong>动态规划</strong><br>设dp[i][k]表示i层k枚鸡蛋的最小操作次数：<br>（1）dp[0][k] = 0；<br>（2）dp[i][1] = i;<br>（3）试第j层，<br>①若摔碎，dp[i][k] = dp[j - 1][k - 1];<br>②若没摔碎，dp[i][k] = dp[i - j][k]<br>所以对于的那个j，dp[i][k]=max(dp[ j - 1][k - 1], dp[i - j][k]) + 1;<br>而对于每个j，有$1 &lt;= j &lt;= i$，dp[i][k] = min(max(dp[ j - 1][k - 1], dp[i - j][k])) + 1；<br>时间复杂度：$O(n^2 * k)$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || K == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(K == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> dp[n + <span class="number">1</span>][K + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) dp[i][<span class="number">1</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= K; k ++){</span><br><span class="line">                <span class="keyword">int</span> minValue = inf;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++){</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; dp[j - 1][k - 1] &lt;&lt; " " &lt;&lt; dp[i - j][k] &lt;&lt; " ";</span></span><br><span class="line">                    minValue = min(minValue, max(dp[j - <span class="number">1</span>][k - <span class="number">1</span>], dp[i - j][k])) ;</span><br><span class="line">                }</span><br><span class="line">                dp[i][k] = minValue + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; dp[i][k] &lt;&lt; " ";</span></span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n][K];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>最优解</strong><br><a href="https://www.cnblogs.com/willwuss/p/12256475.html" target="_blank" rel="noopener">参考</a></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(K &lt;= <span class="number">0</span> || N &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> btTimes = log2(N) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(K &gt;= btTimes) <span class="keyword">return</span> btTimes;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(K + <span class="number">1</span>, <span class="number">0</span>), g(K + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; ; j ++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i ++){</span><br><span class="line">                f[i] = g[i] + g[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(f[i] &gt;= N) <span class="keyword">return</span> j;</span><br><span class="line">            }</span><br><span class="line">            swap(f, g);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><div class="page-reward"><a href="javascript:;" class="page-reward-btn tooltip-top"><div class="tooltip tooltip-east"> <span class="tooltip-item">赏</span><span class="tooltip-content"><span class="tooltip-text"><span class="tooltip-inner"><p class="reward-p"><i class="icon icon-quo-left"></i>Thank you for inviting me to have candy.<i class="icon icon-quo-right"></i></p><div class="reward-box"><div class="reward-box-item"> <img class="reward-img" src="/assets/img/blog/zhifubao.png"> <span class="reward-type">支付宝</span></div><div class="reward-box-item"> <img class="reward-img" src="/assets/img/blog/weixin.jpg"> <span class="reward-type">微信</span></div></div></span></span></span></div></a></div></div><div class="article-info article-info-index"><div class="article-tag tagcloud"><i class="icon-price-tags icon"></i><ul class="article-tag-list"><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag article-tag-list-link color5">Algorithm</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag article-tag-list-link color4">C++</a></li></ul></div><div class="share-btn share-icons tooltip-left"><div class="tooltip tooltip-east"><span class="tooltip-item"><a href="javascript:;" class="share-sns share-outer"><i class="icon icon-share"></i></a></span><span class="tooltip-content"><div class="share-wrap"><div class="share-icons"><a class="weibo share-sns" href="javascript:;" data-type="weibo"><i class="icon icon-weibo"></i></a><a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin"><i class="icon icon-weixin"></i></a><a class="qq share-sns" href="javascript:;" data-type="qq"><i class="icon icon-qq"></i></a><a class="douban share-sns" href="javascript:;" data-type="douban"><i class="icon icon-douban"></i></a><a class="qzone share-sns" href="javascript:;" data-type="qzone"><i class="icon icon-qzone"></i></a><a class="facebook share-sns" href="javascript:;" data-type="facebook"><i class="icon icon-facebook"></i></a><a class="twitter share-sns" href="javascript:;" data-type="twitter"><i class="icon icon-twitter"></i></a><a class="google share-sns" href="javascript:;" data-type="google"><i class="icon icon-google"></i></a></div></div></span></div></div><div class="page-modal wx-share js-wx-box"><a class="close js-modal-close" href="javascript:;"><i class="icon icon-close"></i></a><p>扫一扫，分享到微信</p><div class="wx-qrcode"> <img src="http://s.jiathis.com/qrcode.php?url=https://lourisxu.github.io/2020/07/02/leetcodedynamic-programming.html/" alt="微信分享二维码"></div></div><div class="mask js-mask"></div><div class="clearfix"></div></div></div></article><nav id="article-nav"><a href="/2020/07/17/tripleclassification-of-respiratory-sounds-using-optimized-stransform-and-deep-residual-networks.html/" id="article-nav-newer" class="article-nav-link-wrap"><i class="icon-circle-left"></i><div class="article-nav-title"> Triple-Classification of Respiratory Sounds Using Optimized S-Transform and Deep Residual Networks</div></a><a href="/2020/06/29/lung-sounds-classification-using-convolutional-neural-networks.html/" id="article-nav-older" class="article-nav-link-wrap"><div class="article-nav-title">Lung sounds classification using convolutional neural networks</div><i class="icon-circle-right"></i></a></nav><aside class="wrap-side-operation"><div class="mod-side-operation"><div class="jump-container" id="js-jump-container" style="display:none"><a href="javascript:void(0)" class="mod-side-operation__jump-to-top"><i class="icon-font icon-back"></i></a><div id="js-jump-plan-container" class="jump-plan-container" style="top:-11px"><i class="icon-font icon-plane jump-plane"></i></div></div><div class="toc-container tooltip-left"><i class="icon-font icon-category"></i><div class="tooltip tooltip-east"><span class="tooltip-item"></span><span class="tooltip-content"><div class="toc-article"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#动态规划"><span class="toc-number">1.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#线性DP"><span class="toc-number">1.1.</span> <span class="toc-text">线性DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#经典DP"><span class="toc-number">1.1.1.</span> <span class="toc-text">经典DP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#53-最大子序和"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">53. 最大子序和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#120-三角形最小路径和"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">120. 三角形最小路径和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#132-分割回文串-II"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">132. 分割回文串 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#152-乘积最大子序列"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">152. 乘积最大子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#174-地下城游戏"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">174. 地下城游戏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#198-打家劫舍"><span class="toc-number">1.1.1.6.</span> <span class="toc-text">198. 打家劫舍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#213-打家劫舍-II"><span class="toc-number">1.1.1.7.</span> <span class="toc-text">213. 打家劫舍 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#256-粉刷房子"><span class="toc-number">1.1.1.8.</span> <span class="toc-text">256. 粉刷房子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#276-栅栏涂色"><span class="toc-number">1.1.1.9.</span> <span class="toc-text">276. 栅栏涂色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#300-最长上升子序列"><span class="toc-number">1.1.1.10.</span> <span class="toc-text">300. 最长上升子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#354-俄罗斯套娃信封问题"><span class="toc-number">1.1.1.11.</span> <span class="toc-text">354. 俄罗斯套娃信封问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#面试题-17-08-马戏团人塔"><span class="toc-number">1.1.1.12.</span> <span class="toc-text">面试题 17.08. 马戏团人塔</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#712-两个字符串的最小ASCII删除和"><span class="toc-number">1.1.1.13.</span> <span class="toc-text">712. 两个字符串的最小ASCII删除和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#746-使用最小花费爬楼梯"><span class="toc-number">1.1.1.14.</span> <span class="toc-text">746. 使用最小花费爬楼梯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#799-香槟塔"><span class="toc-number">1.1.1.15.</span> <span class="toc-text">799. 香槟塔</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#931-下降路径最小和"><span class="toc-number">1.1.1.16.</span> <span class="toc-text">931. 下降路径最小和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1043-分隔数组以得到最大和"><span class="toc-number">1.1.1.17.</span> <span class="toc-text">1043. 分隔数组以得到最大和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1143-最长公共子序列"><span class="toc-number">1.1.1.18.</span> <span class="toc-text">1143. 最长公共子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1641-统计字典序元音字符串的数目"><span class="toc-number">1.1.1.19.</span> <span class="toc-text">1641. 统计字典序元音字符串的数目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1626-无矛盾的最佳球队"><span class="toc-number">1.1.1.20.</span> <span class="toc-text">1626. 无矛盾的最佳球队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#面试题-08-01-三步问题"><span class="toc-number">1.1.1.21.</span> <span class="toc-text">面试题 08.01. 三步问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#面试题42-连续子数组的最大和"><span class="toc-number">1.1.1.22.</span> <span class="toc-text">面试题42. 连续子数组的最大和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#面试题47-礼物的最大价值"><span class="toc-number">1.1.1.23.</span> <span class="toc-text">面试题47. 礼物的最大价值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#面试题-16-17-连续数列"><span class="toc-number">1.1.1.24.</span> <span class="toc-text">面试题 16.17. 连续数列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符DP"><span class="toc-number">1.1.2.</span> <span class="toc-text">字符DP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-正则表达式匹配"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">10. 正则表达式匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-最长有效括号"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">32. 最长有效括号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#44-通配符匹配"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">44. 通配符匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#91-解码方法"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">91. 解码方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#97-交错字符串"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">97. 交错字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#139-单词拆分"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">139. 单词拆分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#面试题-17-13-恢复空格"><span class="toc-number">1.1.2.7.</span> <span class="toc-text">面试题 17.13. 恢复空格</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#467-环绕字符串中唯一的子字符串"><span class="toc-number">1.1.2.8.</span> <span class="toc-text">467. 环绕字符串中唯一的子字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1048-最长字符串链"><span class="toc-number">1.1.2.9.</span> <span class="toc-text">1048. 最长字符串链</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#股票系列"><span class="toc-number">1.1.3.</span> <span class="toc-text">股票系列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#121-买卖股票的最佳时机"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">121. 买卖股票的最佳时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#122-买卖股票的最佳时机-II"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">122. 买卖股票的最佳时机 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#123-买卖股票的最佳时机-III"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">123. 买卖股票的最佳时机 III</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#188-买卖股票的最佳时机-IV"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">188. 买卖股票的最佳时机 IV</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#309-最佳买卖股票时机含冷冻期"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">309. 最佳买卖股票时机含冷冻期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#714-买卖股票的最佳时机含手续费"><span class="toc-number">1.1.3.6.</span> <span class="toc-text">714. 买卖股票的最佳时机含手续费</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#剑指-Offer-63-股票的最大利润"><span class="toc-number">1.1.3.7.</span> <span class="toc-text">剑指 Offer 63. 股票的最大利润</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#面试题-17-16-按摩师"><span class="toc-number">1.1.3.8.</span> <span class="toc-text">面试题 17.16. 按摩师</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#丑数系列"><span class="toc-number">1.1.4.</span> <span class="toc-text">丑数系列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#264-丑数-II"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">264. 丑数 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#313-超级丑数"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">313. 超级丑数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#343-整数拆分"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">343. 整数拆分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#面试题14-I-剪绳子"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">面试题14- I. 剪绳子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#面试题14-II-剪绳子-II"><span class="toc-number">1.1.4.5.</span> <span class="toc-text">面试题14- II. 剪绳子 II</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优化DP"><span class="toc-number">1.1.5.</span> <span class="toc-text">优化DP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5631-跳跃游戏-VI"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">5631. 跳跃游戏 VI</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他"><span class="toc-number">1.1.6.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#279-完全平方数"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">279. 完全平方数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#338-比特位计数"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">338. 比特位计数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#357-计算各个位数不同的数字个数"><span class="toc-number">1.1.6.3.</span> <span class="toc-text">357. 计算各个位数不同的数字个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#368-最大整除子集"><span class="toc-number">1.1.6.4.</span> <span class="toc-text">368. 最大整除子集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#376-摆动序列"><span class="toc-number">1.1.6.5.</span> <span class="toc-text">376. 摆动序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#413-等差数列划分"><span class="toc-number">1.1.6.6.</span> <span class="toc-text">413. 等差数列划分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#523-连续的子数组和"><span class="toc-number">1.1.6.7.</span> <span class="toc-text">523. 连续的子数组和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#646-最长数对链"><span class="toc-number">1.1.6.8.</span> <span class="toc-text">646. 最长数对链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#718-最长重复子数组"><span class="toc-number">1.1.6.9.</span> <span class="toc-text">718. 最长重复子数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#740-删除与获得点数"><span class="toc-number">1.1.6.10.</span> <span class="toc-text">740. 删除与获得点数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#790-多米诺和托米诺平铺"><span class="toc-number">1.1.6.11.</span> <span class="toc-text">790. 多米诺和托米诺平铺</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#801-使序列递增的最小交换次数"><span class="toc-number">1.1.6.12.</span> <span class="toc-text">801. 使序列递增的最小交换次数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#813-最大平均值和的分组"><span class="toc-number">1.1.6.13.</span> <span class="toc-text">813. 最大平均值和的分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#845-数组中的最长山脉"><span class="toc-number">1.1.6.14.</span> <span class="toc-text">845. 数组中的最长山脉</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#935-骑士拨号器"><span class="toc-number">1.1.6.15.</span> <span class="toc-text">935. 骑士拨号器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#978-最长湍流子数组"><span class="toc-number">1.1.6.16.</span> <span class="toc-text">978. 最长湍流子数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1191-K-次串联后最大子数组之和"><span class="toc-number">1.1.6.17.</span> <span class="toc-text">1191. K 次串联后最大子数组之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1218-最长定差子序列"><span class="toc-number">1.1.6.18.</span> <span class="toc-text">1218. 最长定差子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1269-停在原地的方案数"><span class="toc-number">1.1.6.19.</span> <span class="toc-text">1269. 停在原地的方案数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#面试题-08-02-迷路的机器人"><span class="toc-number">1.1.6.20.</span> <span class="toc-text">面试题 08.02. 迷路的机器人</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LCP-13-寻宝"><span class="toc-number">1.1.6.21.</span> <span class="toc-text">LCP 13. 寻宝</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#前缀和系列"><span class="toc-number">1.2.</span> <span class="toc-text">前缀和系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#410-分割数组的最大值"><span class="toc-number">1.2.1.</span> <span class="toc-text">410. 分割数组的最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1477-找两个和为目标值且不重叠的子数组"><span class="toc-number">1.2.2.</span> <span class="toc-text">1477. 找两个和为目标值且不重叠的子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1664-生成平衡数组的方案数"><span class="toc-number">1.2.3.</span> <span class="toc-text">1664. 生成平衡数组的方案数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5471-和为目标值的最大数目不重叠非空子数组数目"><span class="toc-number">1.2.4.</span> <span class="toc-text">5471. 和为目标值的最大数目不重叠非空子数组数目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#区间DP"><span class="toc-number">1.3.</span> <span class="toc-text">区间DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-最长回文子串"><span class="toc-number">1.3.1.</span> <span class="toc-text">5. 最长回文子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#303-区域和检索-数组不可变"><span class="toc-number">1.3.2.</span> <span class="toc-text">303. 区域和检索 - 数组不可变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#304-二维区域和检索-矩阵不可变"><span class="toc-number">1.3.3.</span> <span class="toc-text">304. 二维区域和检索 - 矩阵不可变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#375-猜数字大小-II"><span class="toc-number">1.3.4.</span> <span class="toc-text">375. 猜数字大小 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#516-最长回文子序列"><span class="toc-number">1.3.5.</span> <span class="toc-text">516. 最长回文子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#647-回文子串"><span class="toc-number">1.3.6.</span> <span class="toc-text">647. 回文子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#764-最大加号标志"><span class="toc-number">1.3.7.</span> <span class="toc-text">764. 最大加号标志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1024-视频拼接"><span class="toc-number">1.3.8.</span> <span class="toc-text">1024. 视频拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1039-多边形三角剖分的最低得分"><span class="toc-number">1.3.9.</span> <span class="toc-text">1039. 多边形三角剖分的最低得分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1105-填充书架"><span class="toc-number">1.3.10.</span> <span class="toc-text">1105. 填充书架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1139-最大的以-1-为边界的正方形"><span class="toc-number">1.3.11.</span> <span class="toc-text">1139. 最大的以 1 为边界的正方形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1240-铺瓷砖"><span class="toc-number">1.3.12.</span> <span class="toc-text">1240. 铺瓷砖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题-08-14-布尔运算"><span class="toc-number">1.3.13.</span> <span class="toc-text">面试题 08.14. 布尔运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题-17-23-最大黑方阵"><span class="toc-number">1.3.14.</span> <span class="toc-text">面试题 17.23. 最大黑方阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1277-统计全为-1-的正方形子矩阵"><span class="toc-number">1.3.15.</span> <span class="toc-text">1277. 统计全为 1 的正方形子矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1314-矩阵区域和"><span class="toc-number">1.3.16.</span> <span class="toc-text">1314. 矩阵区域和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1504-统计全-1-子矩形"><span class="toc-number">1.3.17.</span> <span class="toc-text">1504. 统计全 1 子矩形</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计数DP"><span class="toc-number">1.4.</span> <span class="toc-text">计数DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#62-不同路径"><span class="toc-number">1.4.1.</span> <span class="toc-text">62. 不同路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-不同路径-II"><span class="toc-number">1.4.2.</span> <span class="toc-text">63. 不同路径 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#96-不同的二叉搜索树"><span class="toc-number">1.4.3.</span> <span class="toc-text">96. 不同的二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#377-组合总和-Ⅳ"><span class="toc-number">1.4.4.</span> <span class="toc-text">377. 组合总和 Ⅳ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#576-出界的路径数"><span class="toc-number">1.4.5.</span> <span class="toc-text">576. 出界的路径数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#673-最长递增子序列的个数"><span class="toc-number">1.4.6.</span> <span class="toc-text">673. 最长递增子序列的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1155-掷骰子的N种方法"><span class="toc-number">1.4.7.</span> <span class="toc-text">1155. 掷骰子的N种方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1223-掷骰子模拟"><span class="toc-number">1.4.8.</span> <span class="toc-text">1223. 掷骰子模拟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题-17-06-2出现的次数"><span class="toc-number">1.4.9.</span> <span class="toc-text">面试题 17.06. 2出现的次数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递推DP"><span class="toc-number">1.5.</span> <span class="toc-text">递推DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#64-最小路径和"><span class="toc-number">1.5.1.</span> <span class="toc-text">64. 最小路径和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70-爬楼梯"><span class="toc-number">1.5.2.</span> <span class="toc-text">70. 爬楼梯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1423-可获得的最大点数"><span class="toc-number">1.5.3.</span> <span class="toc-text">1423. 可获得的最大点数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1621-大小为-K-的不重叠线段的数目"><span class="toc-number">1.5.4.</span> <span class="toc-text">1621. 大小为 K 的不重叠线段的数目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#背包DP"><span class="toc-number">1.6.</span> <span class="toc-text">背包DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#322-零钱兑换"><span class="toc-number">1.6.1.</span> <span class="toc-text">322. 零钱兑换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#416-分割等和子集"><span class="toc-number">1.6.2.</span> <span class="toc-text">416. 分割等和子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#474-一和零"><span class="toc-number">1.6.3.</span> <span class="toc-text">474. 一和零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#494-目标和"><span class="toc-number">1.6.4.</span> <span class="toc-text">494. 目标和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题-08-11-硬币"><span class="toc-number">1.6.5.</span> <span class="toc-text">面试题 08.11. 硬币</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1049-最后一块石头的重量-II"><span class="toc-number">1.6.6.</span> <span class="toc-text">1049. 最后一块石头的重量 II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#博弈DP"><span class="toc-number">1.7.</span> <span class="toc-text">博弈DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#464-我能赢吗"><span class="toc-number">1.7.1.</span> <span class="toc-text">464. 我能赢吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#486-预测赢家"><span class="toc-number">1.7.2.</span> <span class="toc-text">486. 预测赢家</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1140-石子游戏-II"><span class="toc-number">1.7.3.</span> <span class="toc-text">1140. 石子游戏 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#292-Nim-游戏"><span class="toc-number">1.7.4.</span> <span class="toc-text">292. Nim 游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1025-除数博弈"><span class="toc-number">1.7.5.</span> <span class="toc-text">1025. 除数博弈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#877-石子游戏"><span class="toc-number">1.7.6.</span> <span class="toc-text">877. 石子游戏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dfs-记忆化搜索"><span class="toc-number">1.8.</span> <span class="toc-text">dfs&#x2F;记忆化搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#638-大礼包"><span class="toc-number">1.8.1.</span> <span class="toc-text">638. 大礼包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#650-只有两个键的键盘"><span class="toc-number">1.8.2.</span> <span class="toc-text">650. 只有两个键的键盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#698-划分为k个相等的子集"><span class="toc-number">1.8.3.</span> <span class="toc-text">698. 划分为k个相等的子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#983-最低票价"><span class="toc-number">1.8.4.</span> <span class="toc-text">983. 最低票价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1339-分裂二叉树的最大乘积"><span class="toc-number">1.8.5.</span> <span class="toc-text">1339. 分裂二叉树的最大乘积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1367-二叉树中的列表"><span class="toc-number">1.8.6.</span> <span class="toc-text">1367. 二叉树中的列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#967-连续差相同的数字"><span class="toc-number">1.8.7.</span> <span class="toc-text">967. 连续差相同的数字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#概率DP"><span class="toc-number">1.9.</span> <span class="toc-text">概率DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#688-“马”在棋盘上的概率"><span class="toc-number">1.9.1.</span> <span class="toc-text">688. “马”在棋盘上的概率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#808-分汤"><span class="toc-number">1.9.2.</span> <span class="toc-text">808. 分汤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#837-新21点"><span class="toc-number">1.9.3.</span> <span class="toc-text">837. 新21点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1227-飞机座位分配概率"><span class="toc-number">1.9.4.</span> <span class="toc-text">1227. 飞机座位分配概率</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#位DP"><span class="toc-number">1.10.</span> <span class="toc-text">位DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#898-子数组按位或操作"><span class="toc-number">1.10.1.</span> <span class="toc-text">898. 子数组按位或操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树形DP"><span class="toc-number">1.11.</span> <span class="toc-text">树形DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#337-打家劫舍-III"><span class="toc-number">1.11.1.</span> <span class="toc-text">337. 打家劫舍 III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#834-树中距离之和"><span class="toc-number">1.11.2.</span> <span class="toc-text">834. 树中距离之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1130-叶值的最小代价生成树"><span class="toc-number">1.11.3.</span> <span class="toc-text">1130. 叶值的最小代价生成树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1372-二叉树中的最长交错路径"><span class="toc-number">1.11.4.</span> <span class="toc-text">1372. 二叉树中的最长交错路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#环状DP"><span class="toc-number">1.12.</span> <span class="toc-text">环状DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#873-最长的斐波那契子序列的长度"><span class="toc-number">1.12.1.</span> <span class="toc-text">873. 最长的斐波那契子序列的长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#446-等差数列划分-II-子序列"><span class="toc-number">1.12.2.</span> <span class="toc-text">446. 等差数列划分 II - 子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1027-最长等差数列"><span class="toc-number">1.12.3.</span> <span class="toc-text">1027. 最长等差数列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多DP递推"><span class="toc-number">1.13.</span> <span class="toc-text">多DP递推</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1186-删除一次得到子数组最大和"><span class="toc-number">1.13.1.</span> <span class="toc-text">1186. 删除一次得到子数组最大和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1262-可被三整除的最大和"><span class="toc-number">1.13.2.</span> <span class="toc-text">1262. 可被三整除的最大和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特殊DP"><span class="toc-number">1.14.</span> <span class="toc-text">特殊DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#312-戳气球"><span class="toc-number">1.14.1.</span> <span class="toc-text">312. 戳气球</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#403-青蛙过河"><span class="toc-number">1.14.2.</span> <span class="toc-text">403. 青蛙过河</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#514-自由之路"><span class="toc-number">1.14.3.</span> <span class="toc-text">514. 自由之路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#546-移除盒子"><span class="toc-number">1.14.4.</span> <span class="toc-text">546. 移除盒子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#956-最高的广告牌"><span class="toc-number">1.14.5.</span> <span class="toc-text">956. 最高的广告牌</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1631-最小体力消耗路径"><span class="toc-number">1.14.6.</span> <span class="toc-text">1631. 最小体力消耗路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#状态压缩DP"><span class="toc-number">1.15.</span> <span class="toc-text">状态压缩DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#464-我能赢吗-1"><span class="toc-number">1.15.1.</span> <span class="toc-text">464. 我能赢吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#526-优美的排列"><span class="toc-number">1.15.2.</span> <span class="toc-text">526. 优美的排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#698-划分为k个相等的子集-1"><span class="toc-number">1.15.3.</span> <span class="toc-text">698. 划分为k个相等的子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1723-完成所有工作的最短时间"><span class="toc-number">1.15.4.</span> <span class="toc-text">1723. 完成所有工作的最短时间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关联DP"><span class="toc-number">1.16.</span> <span class="toc-text">关联DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1473-粉刷房子-III"><span class="toc-number">1.16.1.</span> <span class="toc-text">1473. 粉刷房子 III</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#POJ"><span class="toc-number">2.</span> <span class="toc-text">POJ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3616-Milking-Time"><span class="toc-number">2.1.</span> <span class="toc-text">3616 Milking Time</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#经典DP题"><span class="toc-number">2.2.</span> <span class="toc-text">经典DP题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#885-螺旋矩阵-III"><span class="toc-number">2.3.</span> <span class="toc-text">885. 螺旋矩阵 III</span></a></li></ol></li></ol></div></span></div></div></div></aside></div></div></div><footer id="footer"><div class="outer"><div id="footer-info"><div class="footer-left"> &copy; 2025 Louris <span style="font-size:smaller">Hosted by <a href="https://coding.net/" target="_blank" rel="noopener" style="font-weight:700">Coding Pages</a>/ <a href="https://gitee.com/" target="_blank" rel="noopener" style="font-weight:700">Gitee Pages</a>/ <a href="https://github.com/" target="_blank" rel="noopener" style="font-weight:700">Github Pages</a></span></div><div class="footer-right"> <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten</div></div></div></footer></div><script>var yiliaConfig={mathjax:!0,isHome:!1,isPost:!0,isArchive:!1,isTag:!1,isCategory:!1,open_in_new:!1,toc_hide_index:!1,root:"/",innerArchive:!0,showTags:!1}</script><script>!function(r){function e(t){if(i[t])return i[t].exports;var n=i[t]={exports:{},id:t,loaded:!1};return r[t].call(n.exports,n,n.exports,e),n.loaded=!0,n.exports}var i={};e.m=r,e.c=i,e.p="./",e(0)}([function(t,n,r){r(203),t.exports=r(199)},function(t,n,r){var d=r(3),y=r(49),g=r(26),m=r(27),b=r(46),x="prototype",S=function(t,n,r){var e,i,o,u,c=t&S.F,f=t&S.G,a=t&S.S,s=t&S.P,l=t&S.B,h=f?d:a?d[n]||(d[n]={}):(d[n]||{})[x],v=f?y:y[n]||(y[n]={}),p=v[x]||(v[x]={});for(e in f&&(r=n),r)o=((i=!c&&h&&void 0!==h[e])?h:r)[e],u=l&&i?b(o,d):s&&"function"==typeof o?b(Function.call,o):o,h&&m(h,e,o,t&S.U),v[e]!=o&&g(v,e,u),s&&p[e]!=o&&(p[e]=o)};d.core=y,S.F=1,S.G=2,S.S=4,S.P=8,S.B=16,S.W=32,S.U=64,S.R=128,t.exports=S},function(t,n,r){var e=r(5);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n,r){var e=r(128)("wks"),i=r(78),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(170),o=r(53),u=Object.defineProperty;n.f=r(9)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(52),i=Math.min;t.exports=function(t){return 0<t?i(e(t),9007199254740991):0}},function(t,n,r){t.exports=!r(18)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(22);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(20),i=r(59),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(95),i=r(33);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(40)("wks"),i=r(23),o=r(6).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(50);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(21);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n){var r=t.exports={version:"2.5.1"};"number"==typeof __e&&(__e=r)},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(10),i=r(74);t.exports=r(9)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var o=r(3),u=r(26),c=r(25),f=r(78)("src"),e="toString",i=Function[e],a=(""+i).split(e);r(49).inspectSource=function(t){return i.call(t)},(t.exports=function(t,n,r,e){var i="function"==typeof r;i&&(c(r,"name")||u(r,"name",n)),t[n]!==r&&(i&&(c(r,f)||u(r,f,t[n]?""+t[n]:a.join(String(n)))),t===o?t[n]=r:e?t[n]?t[n]=r:u(t,n,r):(delete t[n],u(t,n,r)))})(Function.prototype,e,function(){return"function"==typeof this&&this[f]||i.call(this)})},function(t,n,r){var e=r(1),i=r(4),u=r(50),c=/"/g,o=function(t,n,r,e){var i=String(u(t)),o="<"+n;return""!==r&&(o+=" "+r+'="'+String(e).replace(c,"&quot;")+'"'),o+">"+i+"</"+n+">"};t.exports=function(n,t){var r={};r[n]=t(o),e(e.P+e.F*i(function(){var t=""[n]('"');return t!==t.toLowerCase()||3<t.split('"').length}),"String",r)}},function(t,n,r){var e=r(64),i=r(34);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(116),i=r(74),o=r(32),u=r(53),c=r(25),f=r(170),a=Object.getOwnPropertyDescriptor;n.f=r(9)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(25),i=r(17),o=r(149)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(115),i=r(50);t.exports=function(t){return e(i(t))}},function(t,n){t.exports=function(t){if(null==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(8),o=r(16)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(23);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(6),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(0<t?e:r)(t)}},function(t,n,r){var i=r(21);t.exports=function(t,n){if(!i(t))return t;var r,e;if(n&&"function"==typeof(r=t.toString)&&!i(e=r.call(t)))return e;if("function"==typeof(r=t.valueOf)&&!i(e=r.call(t)))return e;if(!n&&"function"==typeof(r=t.toString)&&!i(e=r.call(t)))return e;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(6),i=r(24),o=r(36),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(16)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var o=r(19);t.exports=function(e,i,t){if(o(e),void 0===i)return e;switch(t){case 1:return function(t){return e.call(i,t)};case 2:return function(t,n){return e.call(i,t,n)};case 3:return function(t,n,r){return e.call(i,t,n,r)}}return function(){return e.apply(i,arguments)}}},function(t,n,r){"use strict";var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n,r){var b=r(46),x=r(115),S=r(17),w=r(11),e=r(134);t.exports=function(l,t){var h=1==l,v=2==l,p=3==l,d=4==l,y=6==l,g=5==l||y,m=t||e;return function(t,n,r){for(var e,i,o=S(t),u=x(o),c=b(n,r,3),f=w(u.length),a=0,s=h?m(t,f):v?m(t,0):void 0;a<f;a++)if((g||a in u)&&(i=c(e=u[a],a,o),l))if(h)s[a]=i;else if(i)switch(l){case 3:return!0;case 5:return e;case 6:return a;case 2:s.push(e)}else if(d)return!1;return y?-1:p||d?d:s}}},function(t,n){var r=t.exports={version:"2.5.1"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){if(null==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var i=r(1),o=r(49),u=r(4);t.exports=function(t,n){var r=(o.Object||{})[t]||Object[t],e={};e[t]=n(r),i(i.S+i.F*u(function(){r(1)}),"Object",e)}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(0<t?e:r)(t)}},function(t,n,r){var i=r(5);t.exports=function(t,n){if(!i(t))return t;var r,e;if(n&&"function"==typeof(r=t.toString)&&!i(e=r.call(t)))return e;if("function"==typeof(r=t.valueOf)&&!i(e=r.call(t)))return e;if(!n&&"function"==typeof(r=t.toString)&&!i(e=r.call(t)))return e;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var d=r(6),y=r(24),g=r(92),m=r(13),b="prototype",x=function(t,n,r){var e,i,o,u=t&x.F,c=t&x.G,f=t&x.S,a=t&x.P,s=t&x.B,l=t&x.W,h=c?y:y[n]||(y[n]={}),v=h[b],p=c?d:f?d[n]:(d[n]||{})[b];for(e in c&&(r=n),r)(i=!u&&p&&void 0!==p[e])&&e in h||(o=i?p[e]:r[e],h[e]=c&&"function"!=typeof p[e]?r[e]:s&&i?g(o,d):l&&p[e]==o?function(e){var t=function(t,n,r){if(this instanceof e){switch(arguments.length){case 0:return new e;case 1:return new e(t);case 2:return new e(t,n)}return new e(t,n,r)}return e.apply(this,arguments)};return t[b]=e[b],t}(o):a&&"function"==typeof o?g(Function.call,o):o,a&&((h.virtual||(h.virtual={}))[e]=o,t&x.R&&v&&!v[e]&&m(v,e,o)))};x.F=1,x.G=2,x.S=4,x.P=8,x.B=16,x.W=32,x.U=64,x.R=128,t.exports=x},function(t,n,r){var o=r(191),e=r(1),i=r(128)("metadata"),u=i.store||(i.store=new(r(194))),c=function(t,n,r){var e=u.get(t);if(!e){if(!r)return;u.set(t,e=new o)}var i=e.get(n);if(!i){if(!r)return;e.set(n,i=new o)}return i};t.exports={store:u,map:c,has:function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},get:function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},set:function(t,n,r,e){c(r,e,!0).set(t,n)},keys:function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},key:function(t){return void 0===t||"symbol"==typeof t?t:String(t)},exp:function(t){e(e.S,"Reflect",t)}}},function(t,n,r){"use strict";if(r(9)){var g=r(70),m=r(3),b=r(4),x=r(1),S=r(130),e=r(155),h=r(46),w=r(68),i=r(74),_=r(26),o=r(75),u=r(52),O=r(11),E=r(189),c=r(77),f=r(53),a=r(25),M=r(114),P=r(5),v=r(17),p=r(141),j=r(71),F=r(31),A=r(72).f,d=r(157),s=r(78),l=r(7),y=r(48),L=r(117),N=r(129),T=r(158),I=r(80),k=r(123),R=r(76),C=r(133),D=r(162),G=r(10),W=r(30),U=G.f,V=W.f,B=m.RangeError,q=m.TypeError,z=m.Uint8Array,H="ArrayBuffer",K="Shared"+H,J="BYTES_PER_ELEMENT",Y="prototype",$=Array[Y],X=e.ArrayBuffer,Q=e.DataView,Z=y(0),tt=y(2),nt=y(3),rt=y(4),et=y(5),it=y(6),ot=L(!0),ut=L(!1),ct=T.values,ft=T.keys,at=T.entries,st=$.lastIndexOf,lt=$.reduce,ht=$.reduceRight,vt=$.join,pt=$.sort,dt=$.slice,yt=$.toString,gt=$.toLocaleString,mt=l("iterator"),bt=l("toStringTag"),xt=s("typed_constructor"),St=s("def_constructor"),wt=S.CONSTR,_t=S.TYPED,Ot=S.VIEW,Et="Wrong length!",Mt=y(1,function(t,n){return Lt(N(t,t[St]),n)}),Pt=b(function(){return 1===new z(new Uint16Array([1]).buffer)[0]}),jt=!!z&&!!z[Y].set&&b(function(){new z(1).set({})}),Ft=function(t,n){var r=u(t);if(r<0||r%n)throw B("Wrong offset!");return r},At=function(t){if(P(t)&&_t in t)return t;throw q(t+" is not a typed array!")},Lt=function(t,n){if(!(P(t)&&xt in t))throw q("It is not a typed array constructor!");return new t(n)},Nt=function(t,n){return Tt(N(t,t[St]),n)},Tt=function(t,n){for(var r=0,e=n.length,i=Lt(t,e);r<e;)i[r]=n[r++];return i},It=function(t,n,r){U(t,n,{get:function(){return this._d[r]}})},kt=function(t){var n,r,e,i,o,u,c=v(t),f=arguments.length,a=1<f?arguments[1]:void 0,s=void 0!==a,l=d(c);if(null!=l&&!p(l)){for(u=l.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(s&&2<f&&(a=h(a,arguments[2],2)),n=0,r=O(c.length),i=Lt(this,r);n<r;n++)i[n]=s?a(c[n],n):c[n];return i},Rt=function(){for(var t=0,n=arguments.length,r=Lt(this,n);t<n;)r[t]=arguments[t++];return r},Ct=!!z&&b(function(){gt.call(new z(1))}),Dt=function(){return gt.apply(Ct?dt.call(At(this)):At(this),arguments)},Gt={copyWithin:function(t,n){return D.call(At(this),t,n,2<arguments.length?arguments[2]:void 0)},every:function(t){return rt(At(this),t,1<arguments.length?arguments[1]:void 0)},fill:function(t){return C.apply(At(this),arguments)},filter:function(t){return Nt(this,tt(At(this),t,1<arguments.length?arguments[1]:void 0))},find:function(t){return et(At(this),t,1<arguments.length?arguments[1]:void 0)},findIndex:function(t){return it(At(this),t,1<arguments.length?arguments[1]:void 0)},forEach:function(t){Z(At(this),t,1<arguments.length?arguments[1]:void 0)},indexOf:function(t){return ut(At(this),t,1<arguments.length?arguments[1]:void 0)},includes:function(t){return ot(At(this),t,1<arguments.length?arguments[1]:void 0)},join:function(t){return vt.apply(At(this),arguments)},lastIndexOf:function(t){return st.apply(At(this),arguments)},map:function(t){return Mt(At(this),t,1<arguments.length?arguments[1]:void 0)},reduce:function(t){return lt.apply(At(this),arguments)},reduceRight:function(t){return ht.apply(At(this),arguments)},reverse:function(){for(var t,n=this,r=At(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(At(this),t,1<arguments.length?arguments[1]:void 0)},sort:function(t){return pt.call(At(this),t)},subarray:function(t,n){var r=At(this),e=r.length,i=c(t,e);return new(N(r,r[St]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,O((void 0===n?e:c(n,e))-i))}},Wt=function(t,n){return Nt(this,dt.call(At(this),t,n))},Ut=function(t){At(this);var n=Ft(arguments[1],1),r=this.length,e=v(t),i=O(e.length),o=0;if(r<i+n)throw B(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(At(this))},keys:function(){return ft.call(At(this))},values:function(){return ct.call(At(this))}},Bt=function(t,n){return P(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return Bt(t,n=f(n,!0))?i(2,t[n]):V(t,n)},zt=function(t,n,r){return!(Bt(t,n=f(n,!0))&&P(r)&&a(r,"value"))||a(r,"get")||a(r,"set")||r.configurable||a(r,"writable")&&!r.writable||a(r,"enumerable")&&!r.enumerable?U(t,n,r):(t[n]=r.value,t)};wt||(W.f=qt,G.f=zt),x(x.S+x.F*!wt,"Object",{getOwnPropertyDescriptor:qt,defineProperty:zt}),b(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Ht=o({},Gt);o(Ht,Vt),_(Ht,mt,Vt.values),o(Ht,{slice:Wt,set:Ut,constructor:function(){},toString:yt,toLocaleString:Dt}),It(Ht,"buffer","b"),It(Ht,"byteOffset","o"),It(Ht,"byteLength","l"),It(Ht,"length","e"),U(Ht,bt,{get:function(){return this[_t]}}),t.exports=function(t,l,n,o){var h=t+((o=!!o)?"Clamped":"")+"Array",r="get"+t,u="set"+t,v=m[h],c=v||{},e=v&&F(v),i=!v||!S.ABV,f={},a=v&&v[Y],p=function(t,i){U(t,i,{get:function(){return t=i,(n=this._d).v[r](t*l+n.o,Pt);var t,n},set:function(t){return n=i,r=t,e=this._d,o&&(r=(r=Math.round(r))<0?0:255<r?255:255&r),void e.v[u](n*l+e.o,r,Pt);var n,r,e},enumerable:!0})};i?(v=n(function(t,n,r,e){w(t,v,h,"_d");var i,o,u,c,f=0,a=0;if(P(n)){if(!(n instanceof X||(c=M(n))==H||c==K))return _t in n?Tt(v,n):kt.call(v,n);i=n,a=Ft(r,l);var s=n.byteLength;if(void 0===e){if(s%l)throw B(Et);if((o=s-a)<0)throw B(Et)}else if((o=O(e)*l)+a>s)throw B(Et);u=o/l}else u=E(n),i=new X(o=u*l);for(_(t,"_d",{b:i,o:a,l:o,e:u,v:new Q(i)});f<u;)p(t,f++)}),a=v[Y]=j(Ht),_(a,"constructor",v)):b(function(){v(1)})&&b(function(){new v(-1)})&&k(function(t){new v,new v(null),new v(1.5),new v(t)},!0)||(v=n(function(t,n,r,e){var i;return w(t,v,h),P(n)?n instanceof X||(i=M(n))==H||i==K?void 0!==e?new c(n,Ft(r,l),e):void 0!==r?new c(n,Ft(r,l)):new c(n):_t in n?Tt(v,n):kt.call(v,n):new c(E(n))}),Z(e!==Function.prototype?A(c).concat(A(e)):A(c),function(t){t in v||_(v,t,c[t])}),v[Y]=a,g||(a.constructor=v));var s=a[mt],d=!!s&&("values"==s.name||null==s.name),y=Vt.values;_(v,xt,!0),_(a,_t,h),_(a,Ot,!0),_(a,St,v),(o?new v(1)[bt]==h:bt in a)||U(a,bt,{get:function(){return h}}),f[h]=v,x(x.G+x.W+x.F*(v!=c),f),x(x.S,h,{BYTES_PER_ELEMENT:l}),x(x.S+x.F*b(function(){c.of.call(v,1)}),h,{from:kt,of:Rt}),J in a||_(a,J,l),x(x.P,h,Gt),R(h),x(x.P+x.F*jt,h,{set:Ut}),x(x.P+x.F*!d,h,Vt),g||a.toString==yt||(a.toString=yt),x(x.P+x.F*b(function(){new v(1).slice()}),h,{slice:Wt}),x(x.P+x.F*(b(function(){return[1,2].toLocaleString()!=new v([1,2]).toLocaleString()})||!b(function(){a.toLocaleString.call([1,2])})),h,{toLocaleString:Dt}),I[h]=d?s:y,g||d||_(a,mt,y)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(21),i=r(6).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(18)(function(){return 7!=Object.defineProperty(r(58)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var b=r(36),x=r(54),S=r(65),w=r(13),_=r(8),O=r(35),E=r(97),M=r(38),P=r(103),j=r(16)("iterator"),F=!([].keys&&"next"in[].keys()),A="values",L=function(){return this};t.exports=function(t,n,r,e,i,o,u){E(r,n,e);var c,f,a,s=function(t){if(!F&&t in p)return p[t];switch(t){case"keys":case A:return function(){return new r(this,t)}}return function(){return new r(this,t)}},l=n+" Iterator",h=i==A,v=!1,p=t.prototype,d=p[j]||p["@@iterator"]||i&&p[i],y=d||s(i),g=i?h?s("entries"):y:void 0,m="Array"==n&&p.entries||d;if(m&&(a=P(m.call(new t)))!==Object.prototype&&a.next&&(M(a,l,!0),b||_(a,j)||w(a,j,L)),h&&d&&d.name!==A&&(v=!0,y=function(){return d.call(this)}),b&&!u||!F&&!v&&p[j]||w(p,j,y),O[n]=y,O[l]=L,i)if(c={values:h?y:s(A),keys:o?y:s("keys"),entries:g},u)for(f in c)f in p||S(p,f,c[f]);else x(x.P+x.F*(F||v),n,c);return c}},function(t,n,e){var i=e(20),o=e(100),u=e(34),c=e(39)("IE_PROTO"),f=function(){},a="prototype",s=function(){var t,n=e(58)("iframe"),r=u.length;for(n.style.display="none",e(94).appendChild(n),n.src="javascript:",(t=n.contentWindow.document).open(),t.write("<script>document.F=Object<\/script>"),t.close(),s=t.F;r--;)delete s[a][u[r]];return s()};t.exports=Object.create||function(t,n){var r;return null!==t?(f[a]=i(t),r=new f,f[a]=null,r[c]=t):r=s(),void 0===n?r:o(r,n)}},function(t,n,r){var e=r(64),i=r(34).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var u=r(8),c=r(15),f=r(91)(!1),a=r(39)("IE_PROTO");t.exports=function(t,n){var r,e=c(t),i=0,o=[];for(r in e)r!=a&&u(e,r)&&o.push(r);for(;n.length>i;)u(e,r=n[i++])&&(~f(o,r)||o.push(r));return o}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;null==i[e]&&r(26)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n,r){var e=r(78)("meta"),i=r(5),o=r(25),u=r(10).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=t.exports={KEY:e,NEED:!1,fastKey:function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},getWeak:function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},onFreeze:function(t){return a&&l.NEED&&f(t)&&!o(t,e)&&s(t),t}}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n,r){var h=r(46),v=r(173),p=r(141),d=r(2),y=r(11),g=r(157),m={},b={};(n=t.exports=function(t,n,r,e,i){var o,u,c,f,a=i?function(){return t}:g(t),s=h(r,e,n?2:1),l=0;if("function"!=typeof a)throw TypeError(t+" is not iterable!");if(p(a)){for(o=y(t.length);l<o;l++)if((f=n?s(d(u=t[l])[0],u[1]):s(t[l]))===m||f===b)return f}else for(c=a.call(t);!(u=c.next()).done;)if((f=v(c,s,u.value,n))===m||f===b)return f}).BREAK=m,n.RETURN=b},function(t,n){t.exports=!1},function(t,n,e){var i=e(2),o=e(179),u=e(137),c=e(149)("IE_PROTO"),f=function(){},a="prototype",s=function(){var t,n=e(136)("iframe"),r=u.length;for(n.style.display="none",e(139).appendChild(n),n.src="javascript:",(t=n.contentWindow.document).open(),t.write("<script>document.F=Object<\/script>"),t.close(),s=t.F;r--;)delete s[a][u[r]];return s()};t.exports=Object.create||function(t,n){var r;return null!==t?(f[a]=i(t),r=new f,f[a]=null,r[c]=t):r=s(),void 0===n?r:o(r,n)}},function(t,n,r){var e=r(181),i=r(137).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(181),i=r(137);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n,r){var i=r(27);t.exports=function(t,n,r){for(var e in n)i(t,e,n[e],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(10),o=r(9),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(52),i=Math.max,o=Math.min;t.exports=function(t,n){return(t=e(t))<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(33);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports={}},function(t,n,r){var e=r(10).f,i=r(25),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var u=r(1),e=r(50),c=r(4),f=r(153),i="["+f+"]",o=RegExp("^"+i+i+"*"),a=RegExp(i+i+"*$"),s=function(t,n,r){var e={},i=c(function(){return!!f[t]()||"​"!="​"[t]()}),o=e[t]=i?n(l):f[t];r&&(e[r]=o),u(u.P+u.F*i,"String",e)},l=s.trim=function(t,n){return t=String(e(t)),1&n&&(t=t.replace(o,"")),2&n&&(t=t.replace(a,"")),t};t.exports=s},function(t,n,r){var e=r(5);t.exports=function(t,n){if(!e(t)||t._t!==n)throw TypeError("Incompatible receiver, "+n+" required!");return t}},function(t,n,r){t.exports={default:r(87),__esModule:!0}},function(t,n,r){t.exports={default:r(88),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=e(r(85)),o=e(r(84)),u="function"==typeof o.default&&"symbol"==typeof i.default?function(t){return typeof t}:function(t){return t&&"function"==typeof o.default&&t.constructor===o.default&&t!==o.default.prototype?"symbol":typeof t};n.default="function"==typeof o.default&&"symbol"===u(i.default)?function(t){return void 0===t?"undefined":u(t)}:function(t){return t&&"function"==typeof o.default&&t.constructor===o.default&&t!==o.default.prototype?"symbol":void 0===t?"undefined":u(t)}},function(t,n,r){r(110),r(108),r(111),r(112),t.exports=r(24).Symbol},function(t,n,r){r(109),r(113),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var f=r(15),a=r(106),s=r(105);t.exports=function(c){return function(t,n,r){var e,i=f(t),o=a(i.length),u=s(r,o);if(c&&n!=n){for(;u<o;)if((e=i[u++])!=e)return!0}else for(;u<o;u++)if((c||u in i)&&i[u]===n)return c||u||0;return!c&&-1}}},function(t,n,r){var o=r(89);t.exports=function(e,i,t){if(o(e),void 0===i)return e;switch(t){case 1:return function(t){return e.call(i,t)};case 2:return function(t,n){return e.call(i,t,n)};case 3:return function(t,n,r){return e.call(i,t,n,r)}}return function(){return e.apply(i,arguments)}}},function(t,n,r){var c=r(29),f=r(63),a=r(37);t.exports=function(t){var n=c(t),r=f.f;if(r)for(var e,i=r(t),o=a.f,u=0;i.length>u;)o.call(t,e=i[u++])&&n.push(e);return n}},function(t,n,r){var e=r(6).document;t.exports=e&&e.documentElement},function(t,n,r){var e=r(57);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(57);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(61),i=r(22),o=r(38),u={};r(13)(u,r(16)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(23)("meta"),i=r(21),o=r(8),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(18)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=t.exports={KEY:e,NEED:!1,fastKey:function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},getWeak:function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},onFreeze:function(t){return a&&l.NEED&&f(t)&&!o(t,e)&&s(t),t}}},function(t,n,r){var u=r(14),c=r(20),f=r(29);t.exports=r(12)?Object.defineProperties:function(t,n){c(t);for(var r,e=f(n),i=e.length,o=0;o<i;)u.f(t,r=e[o++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(22),o=r(15),u=r(42),c=r(8),f=r(59),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(15),i=r(62).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?function(t){try{return i(t)}catch(t){return u.slice()}}(t):i(e(t))}},function(t,n,r){var e=r(8),i=r(79),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var f=r(41),a=r(33);t.exports=function(c){return function(t,n){var r,e,i=String(a(t)),o=f(n),u=i.length;return o<0||u<=o?c?"":void 0:(r=i.charCodeAt(o))<55296||56319<r||o+1===u||(e=i.charCodeAt(o+1))<56320||57343<e?c?i.charAt(o):r:c?i.slice(o,o+2):e-56320+(r-55296<<10)+65536}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return(t=e(t))<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return 0<t?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(90),i=r(98),o=r(35),u=r(15);t.exports=r(60)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):i(0,"keys"==n?r:"values"==n?t[r]:[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(104)(!0);r(60)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(6),u=r(8),i=r(12),o=r(54),c=r(65),f=r(99).KEY,a=r(18),s=r(40),l=r(38),h=r(23),v=r(16),p=r(44),d=r(43),y=r(93),g=r(96),m=r(20),b=r(15),x=r(42),S=r(22),w=r(61),_=r(102),O=r(101),E=r(14),M=r(29),P=O.f,j=E.f,F=_.f,A=e.Symbol,L=e.JSON,N=L&&L.stringify,T="prototype",I=v("_hidden"),k=v("toPrimitive"),R={}.propertyIsEnumerable,C=s("symbol-registry"),D=s("symbols"),G=s("op-symbols"),W=Object[T],U="function"==typeof A,V=e.QObject,B=!V||!V[T]||!V[T].findChild,q=i&&a(function(){return 7!=w(j({},"a",{get:function(){return j(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=P(W,n);e&&delete W[n],j(t,n,r),e&&t!==W&&j(W,n,e)}:j,z=function(t){var n=D[t]=w(A[T]);return n._k=t,n},H=U&&"symbol"==typeof A.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof A},K=function(t,n,r){return t===W&&K(G,n,r),m(t),n=x(n,!0),m(r),u(D,n)?(r.enumerable?(u(t,I)&&t[I][n]&&(t[I][n]=!1),r=w(r,{enumerable:S(0,!1)})):(u(t,I)||j(t,I,S(1,{})),t[I][n]=!0),q(t,n,r)):j(t,n,r)},J=function(t,n){m(t);for(var r,e=y(n=b(n)),i=0,o=e.length;i<o;)K(t,r=e[i++],n[r]);return t},Y=function(t){var n=R.call(this,t=x(t,!0));return!(this===W&&u(D,t)&&!u(G,t))&&(!(n||!u(this,t)||!u(D,t)||u(this,I)&&this[I][t])||n)},$=function(t,n){if(t=b(t),n=x(n,!0),t!==W||!u(D,n)||u(G,n)){var r=P(t,n);return!r||!u(D,n)||u(t,I)&&t[I][n]||(r.enumerable=!0),r}},X=function(t){for(var n,r=F(b(t)),e=[],i=0;r.length>i;)u(D,n=r[i++])||n==I||n==f||e.push(n);return e},Q=function(t){for(var n,r=t===W,e=F(r?G:b(t)),i=[],o=0;e.length>o;)!u(D,n=e[o++])||r&&!u(W,n)||i.push(D[n]);return i};U||(c((A=function(){if(this instanceof A)throw TypeError("Symbol is not a constructor!");var n=h(0<arguments.length?arguments[0]:void 0),r=function(t){this===W&&r.call(G,t),u(this,I)&&u(this[I],n)&&(this[I][n]=!1),q(this,n,S(1,t))};return i&&B&&q(W,n,{configurable:!0,set:r}),z(n)})[T],"toString",function(){return this._k}),O.f=$,E.f=K,r(62).f=_.f=X,r(37).f=Y,r(63).f=Q,i&&!r(36)&&c(W,"propertyIsEnumerable",Y,!0),p.f=function(t){return z(v(t))}),o(o.G+o.W+o.F*!U,{Symbol:A});for(var Z="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),tt=0;Z.length>tt;)v(Z[tt++]);for(var nt=M(v.store),rt=0;nt.length>rt;)d(nt[rt++]);o(o.S+o.F*!U,"Symbol",{for:function(t){return u(C,t+="")?C[t]:C[t]=A(t)},keyFor:function(t){if(!H(t))throw TypeError(t+" is not a symbol!");for(var n in C)if(C[n]===t)return n},useSetter:function(){B=!0},useSimple:function(){B=!1}}),o(o.S+o.F*!U,"Object",{create:function(t,n){return void 0===n?w(t):J(w(t),n)},defineProperty:K,defineProperties:J,getOwnPropertyDescriptor:$,getOwnPropertyNames:X,getOwnPropertySymbols:Q}),L&&o(o.S+o.F*(!U||a(function(){var t=A();return"[null]"!=N([t])||"{}"!=N({a:t})||"{}"!=N(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!H(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return"function"==typeof(n=e[1])&&(r=n),!r&&g(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!H(n))return n}),e[1]=n,N.apply(L,e)}}}),A[T][k]||r(13)(A[T],k,A[T].valueOf),l(A,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(107);for(var e=r(6),i=r(13),o=r(35),u=r(16)("toStringTag"),c="CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","),f=0;f<c.length;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){var i=r(45),o=r(7)("toStringTag"),u="Arguments"==i(function(){return arguments}());t.exports=function(t){var n,r,e;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=function(t,n){try{return t[n]}catch(t){}}(n=Object(t),o))?r:u?i(n):"Object"==(e=i(n))&&"function"==typeof n.callee?"Arguments":e}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var f=r(32),a=r(11),s=r(77);t.exports=function(c){return function(t,n,r){var e,i=f(t),o=a(i.length),u=s(r,o);if(c&&n!=n){for(;u<o;)if((e=i[u++])!=e)return!0}else for(;u<o;u++)if((c||u in i)&&i[u]===n)return c||u||0;return!c&&-1}}},function(t,n,r){"use strict";var g=r(3),m=r(1),b=r(27),x=r(75),S=r(67),w=r(69),_=r(68),O=r(5),E=r(4),M=r(123),P=r(81),j=r(140);t.exports=function(e,t,n,r,i,o){var u=g[e],c=u,f=i?"set":"add",a=c&&c.prototype,s={},l=function(t){var r=a[t];b(a,t,"delete"==t?function(t){return!(o&&!O(t))&&r.call(this,0===t?0:t)}:"has"==t?function(t){return!(o&&!O(t))&&r.call(this,0===t?0:t)}:"get"==t?function(t){return o&&!O(t)?void 0:r.call(this,0===t?0:t)}:"add"==t?function(t){return r.call(this,0===t?0:t),this}:function(t,n){return r.call(this,0===t?0:t,n),this})};if("function"==typeof c&&(o||a.forEach&&!E(function(){(new c).entries().next()}))){var h=new c,v=h[f](o?{}:-0,1)!=h,p=E(function(){h.has(1)}),d=M(function(t){new c(t)}),y=!o&&E(function(){for(var t=new c,n=5;n--;)t[f](n,n);return!t.has(-0)});d||(((c=t(function(t,n){_(t,c,e);var r=j(new u,t,c);return null!=n&&w(n,i,r[f],r),r})).prototype=a).constructor=c),(p||y)&&(l("delete"),l("has"),i&&l("get")),(y||v)&&l(f),o&&a.clear&&delete a.clear}else c=r.getConstructor(t,e,i,f),x(c.prototype,n),S.NEED=!0;return P(c,e),s[e]=c,m(m.G+m.W+m.F*(c!=u),s),o||r.setStrong(c,e,i),c}},function(t,n,r){"use strict";var c=r(26),f=r(27),a=r(4),s=r(50),l=r(7);t.exports=function(n,t,r){var e=l(n),i=r(s,e,""[n]),o=i[0],u=i[1];a(function(){var t={};return t[e]=function(){return 7},7!=""[n](t)})&&(f(String.prototype,n,o),c(RegExp.prototype,e,2==t?function(t,n){return u.call(t,this,n)}:function(t){return u.call(t,this)}))}},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){var e=r(5),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var o=r(7)("iterator"),u=!1;try{var e=[7][o]();e.return=function(){u=!0},Array.from(e,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!u)return!1;var r=!1;try{var e=[7],i=e[o]();i.next=function(){return{done:r=!0}},e[o]=function(){return i},t(e)}catch(t){}return r}},function(t,n,r){"use strict";t.exports=r(70)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){"use strict";var e=r(1),u=r(19),c=r(46),f=r(69);t.exports=function(t){e(e.S,t,{from:function(t){var n,r,e,i,o=arguments[1];return u(this),(n=void 0!==o)&&u(o),null==t?new this:(r=[],n?(e=0,i=c(o,arguments[2],2),f(t,!1,function(t){r.push(i(t,e++))})):f(t,!1,r.push,r),new this(r))}})}},function(t,n,r){"use strict";var e=r(1);t.exports=function(t){e(e.S,t,{of:function(){for(var t=arguments.length,n=Array(t);t--;)n[t]=arguments[t];return new this(n)}})}},function(t,n,r){var e=r(3),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n,r){var i=r(2),o=r(19),u=r(7)("species");t.exports=function(t,n){var r,e=i(t).constructor;return void 0===e||null==(r=i(e)[u])?n:o(r)}},function(t,n,r){for(var e,i=r(3),o=r(26),u=r(78),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n){"use strict";var r,e={versions:(r=window.navigator.userAgent,{trident:-1<r.indexOf("Trident"),presto:-1<r.indexOf("Presto"),webKit:-1<r.indexOf("AppleWebKit"),gecko:-1<r.indexOf("Gecko")&&-1==r.indexOf("KHTML"),mobile:!!r.match(/AppleWebKit.*Mobile.*/),ios:!!r.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:-1<r.indexOf("Android")||-1<r.indexOf("Linux"),iPhone:-1<r.indexOf("iPhone")||-1<r.indexOf("Mac"),iPad:-1<r.indexOf("iPad"),webApp:-1==r.indexOf("Safari"),weixin:-1==r.indexOf("MicroMessenger")})};t.exports=e},function(t,n,r){"use strict";var e,l=(e=r(86))&&e.__esModule?e:{default:e},h=function(){function n(t,n,r){return n||r?String.fromCharCode(n||r):o[t]||t}function r(t){return s[t]}var e=/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,i=/['<> "&]/g,o={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},u=/\u00a0/g,c=/<br\s*\/?>/gi,f=/\r?\n/g,a=/\s/g,s={};for(var t in o)s[o[t]]=t;return o["&apos;"]="'",s["'"]="&#39;",{encode:function(t){return t?(""+t).replace(i,r).replace(f,"<br/>").replace(a,"&nbsp;"):""},decode:function(t){return t?(""+t).replace(c,"\n").replace(e,n).replace(u," "):""},encodeBase16:function(t){if(!t)return t;for(var n=[],r=0,e=(t+="").length;r<e;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;for(var n=[],r=0,e=(t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")})).length;r<e;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;for(var n=[],r=0,e=(t+="").length;r<e;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;n<r;n++)t[n]=h.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,l.default)(t)))for(var e in t)t[e]=h.encodeObject(t[e]);else if("string"==typeof t)return h.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=h},function(t,n,r){"use strict";var c=r(17),f=r(77),a=r(11);t.exports=function(t){for(var n=c(this),r=a(n.length),e=arguments.length,i=f(1<e?arguments[1]:void 0,r),o=2<e?arguments[2]:void 0,u=void 0===o?r:f(o,r);i<u;)n[i++]=t;return n}},function(t,n,r){var e=r(211);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(10),i=r(74);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(5),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(n){var r=/./;try{"/./"[n](r)}catch(t){try{return r[e]=!1,!"/./"[n](r)}catch(n){}}return!0}},function(t,n,r){var e=r(3).document;t.exports=e&&e.documentElement},function(t,n,r){var o=r(5),u=r(148).set;t.exports=function(t,n,r){var e,i=n.constructor;return i!==r&&"function"==typeof i&&(e=i.prototype)!==r.prototype&&o(e)&&u&&u(t,e),t}},function(t,n,r){var e=r(80),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){"use strict";var e=r(71),i=r(74),o=r(81),u={};r(26)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var b=r(70),x=r(1),S=r(27),w=r(26),_=r(25),O=r(80),E=r(142),M=r(81),P=r(31),j=r(7)("iterator"),F=!([].keys&&"next"in[].keys()),A="values",L=function(){return this};t.exports=function(t,n,r,e,i,o,u){E(r,n,e);var c,f,a,s=function(t){if(!F&&t in p)return p[t];switch(t){case"keys":case A:return function(){return new r(this,t)}}return function(){return new r(this,t)}},l=n+" Iterator",h=i==A,v=!1,p=t.prototype,d=p[j]||p["@@iterator"]||i&&p[i],y=d||s(i),g=i?h?s("entries"):y:void 0,m="Array"==n&&p.entries||d;if(m&&(a=P(m.call(new t)))!==Object.prototype&&a.next&&(M(a,l,!0),b||_(a,j)||w(a,j,L)),h&&d&&d.name!==A&&(v=!0,y=function(){return d.call(this)}),b&&!u||!F&&!v&&p[j]||w(p,j,y),O[n]=y,O[l]=L,i)if(c={values:h?y:s(A),keys:o?y:s("keys"),entries:g},u)for(f in c)f in p||S(p,f,c[f]);else x(x.P+x.F*(F||v),n,c);return c}},function(t,n){var r=Math.expm1;t.exports=!r||22025.465794806718<r(10)||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:-1e-6<t&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var c=r(3),f=r(154).set,a=c.MutationObserver||c.WebKitMutationObserver,s=c.process,l=c.Promise,h="process"==r(45)(s);t.exports=function(){var r,e,i,t=function(){var t,n;for(h&&(t=s.domain)&&t.exit();r;){n=r.fn,r=r.next;try{n()}catch(t){throw r?i():e=void 0,t}}e=void 0,t&&t.enter()};if(h)i=function(){s.nextTick(t)};else if(a){var n=!0,o=document.createTextNode("");new a(t).observe(o,{characterData:!0}),i=function(){o.data=n=!n}}else if(l&&l.resolve){var u=l.resolve();i=function(){u.then(t)}}else i=function(){f.call(c,t)};return function(t){var n={fn:t,next:void 0};e&&(e.next=n),r||(r=n,i()),e=n}}},function(t,n,r){"use strict";function e(t){var r,e;this.promise=new t(function(t,n){if(void 0!==r||void 0!==e)throw TypeError("Bad Promise constructor");r=t,e=n}),this.resolve=i(r),this.reject=i(e)}var i=r(19);t.exports.f=function(t){return new e(t)}},function(t,n,i){var r=i(5),e=i(2),o=function(t,n){if(e(t),!r(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,r,e){try{(e=i(46)(Function.call,i(30).f(Object.prototype,"__proto__").set,2))(t,[]),r=!(t instanceof Array)}catch(t){r=!0}return function(t,n){return o(t,n),r?t.__proto__=n:e(t,n),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(128)("keys"),i=r(78);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var f=r(52),a=r(50);t.exports=function(c){return function(t,n){var r,e,i=String(a(t)),o=f(n),u=i.length;return o<0||u<=o?c?"":void 0:(r=i.charCodeAt(o))<55296||56319<r||o+1===u||(e=i.charCodeAt(o+1))<56320||57343<e?c?i.charAt(o):r:c?i.slice(o,o+2):e-56320+(r-55296<<10)+65536}}},function(t,n,r){var e=r(122),i=r(50);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var i=r(52),o=r(50);t.exports=function(t){var n=String(o(this)),r="",e=i(t);if(e<0||e==1/0)throw RangeError("Count can't be negative");for(;0<e;(e>>>=1)&&(n+=n))1&e&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(46),c=r(171),f=r(139),a=r(136),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=s.Dispatch,y=0,g={},m="onreadystatechange",b=function(){var t=+this;if(g.hasOwnProperty(t)){var n=g[t];delete g[t],n()}},x=function(t){b.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return g[++y]=function(){c("function"==typeof t?t:Function(t),n)},e(y),y},v=function(t){delete g[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(b,t,1))}:d&&d.now?e=function(t){d.now(u(b,t,1))}:p?(o=(i=new p).port2,i.port1.onmessage=x,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",x,!1)):e=m in a("script")?function(t){f.appendChild(a("script"))[m]=function(){f.removeChild(this),b.call(t)}}:function(t){setTimeout(u(b,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";function e(t,n,r){var e,i,o,u=Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?W(2,-24)-W(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for((t=G(t))!=t||t===C?(i=t!=t?1:0,e=f):(e=U(V(t)/B),t*(o=W(2,-e))<1&&(e--,o*=2),2<=(t+=1<=e+a?s/o:s*W(2,1-a))*o&&(e++,o/=2),f<=e+a?(i=0,e=f):1<=e+a?(i=(t*o-1)*W(2,n),e+=a):(i=t*W(2,a-1)*W(2,n),e=0));8<=n;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;0<c;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u}function i(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;0<c;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;0<c;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-C:C;e+=W(2,n),s-=u}return(a?-1:1)*e*W(2,s-n)}function o(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]}function u(t){return[255&t]}function c(t){return[255&t,t>>8&255]}function f(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]}function a(t){return e(t,52,8)}function s(t){return e(t,23,4)}function l(t,n,r){M(t[L],n,{get:function(){return this[r]}})}function h(t,n,r,e){var i=O(+r);if(i+n>t[K])throw R(N);var o=t[H]._b,u=i+t[J],c=o.slice(u,u+n);return e?c:c.reverse()}function v(t,n,r,e,i,o){var u=O(+r);if(u+n>t[K])throw R(N);for(var c=t[H]._b,f=u+t[J],a=e(+i),s=0;s<n;s++)c[f+s]=a[o?s:n-s-1]}var p=r(3),d=r(9),y=r(70),g=r(130),m=r(26),b=r(75),x=r(4),S=r(68),w=r(52),_=r(11),O=r(189),E=r(72).f,M=r(10).f,P=r(133),j=r(81),F="ArrayBuffer",A="DataView",L="prototype",N="Wrong index!",T=p[F],I=p[A],k=p.Math,R=p.RangeError,C=p.Infinity,D=T,G=k.abs,W=k.pow,U=k.floor,V=k.log,B=k.LN2,q="byteLength",z="byteOffset",H=d?"_b":"buffer",K=d?"_l":q,J=d?"_o":z;if(g.ABV){if(!x(function(){T(1)})||!x(function(){new T(-1)})||x(function(){return new T,new T(1.5),new T(NaN),T.name!=F})){for(var Y,$=(T=function(t){return S(this,T),new D(O(t))})[L]=D[L],X=E(D),Q=0;X.length>Q;)(Y=X[Q++])in T||m(T,Y,D[Y]);y||($.constructor=T)}var Z=new I(new T(2)),tt=I[L].setInt8;Z.setInt8(0,2147483648),Z.setInt8(1,2147483649),!Z.getInt8(0)&&Z.getInt8(1)||b(I[L],{setInt8:function(t,n){tt.call(this,t,n<<24>>24)},setUint8:function(t,n){tt.call(this,t,n<<24>>24)}},!0)}else T=function(t){S(this,T,F);var n=O(t);this._b=P.call(Array(n),0),this[K]=n},I=function(t,n,r){S(this,I,A),S(t,T,A);var e=t[K],i=w(n);if(i<0||e<i)throw R("Wrong offset!");if(e<i+(r=void 0===r?e-i:_(r)))throw R("Wrong length!");this[H]=t,this[J]=i,this[K]=r},d&&(l(T,q,"_l"),l(I,"buffer","_b"),l(I,q,"_l"),l(I,z,"_o")),b(I[L],{getInt8:function(t){return h(this,1,t)[0]<<24>>24},getUint8:function(t){return h(this,1,t)[0]},getInt16:function(t){var n=h(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=h(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return o(h(this,4,t,arguments[1]))},getUint32:function(t){return o(h(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return i(h(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return i(h(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){v(this,1,t,u,n)},setUint8:function(t,n){v(this,1,t,u,n)},setInt16:function(t,n){v(this,2,t,c,n,arguments[2])},setUint16:function(t,n){v(this,2,t,c,n,arguments[2])},setInt32:function(t,n){v(this,4,t,f,n,arguments[2])},setUint32:function(t,n){v(this,4,t,f,n,arguments[2])},setFloat32:function(t,n){v(this,4,t,s,n,arguments[2])},setFloat64:function(t,n){v(this,8,t,a,n,arguments[2])}});j(T,F),j(I,A),m(I[L],g.VIEW,!0),n[F]=T,n[A]=I},function(t,n,r){var e=r(3),i=r(49),o=r(70),u=r(190),c=r(10).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(114),i=r(7)("iterator"),o=r(80);t.exports=r(49).getIteratorMethod=function(t){if(null!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(66),i=r(174),o=r(80),u=r(32);t.exports=r(143)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):i(0,"keys"==n?r:"values"==n?t[r]:[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){t.exports=function(t,n){t.classList?t.classList.add(n):t.className+=" "+n}},function(t,n){t.exports=function(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var a=r(17),s=r(77),l=r(11);t.exports=[].copyWithin||function(t,n){var r=a(this),e=l(r.length),i=s(t,e),o=s(n,e),u=2<arguments.length?arguments[2]:void 0,c=Math.min((void 0===u?e:s(u,e))-o,e-i),f=1;for(o<i&&i<o+c&&(f=-1,o+=c-1,i+=c-1);0<c--;)o in r?r[i]=r[o]:delete r[i],i+=f,o+=f;return r}},function(t,n,r){var e=r(69);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var s=r(19),l=r(17),h=r(115),v=r(11);t.exports=function(t,n,r,e,i){s(n);var o=l(t),u=h(o),c=v(o.length),f=i?c-1:0,a=i?-1:1;if(r<2)for(;;){if(f in u){e=u[f],f+=a;break}if(f+=a,i?f<0:c<=f)throw TypeError("Reduce of empty array with no initial value")}for(;i?0<=f:f<c;f+=a)f in u&&(e=n(e,u[f],f,o));return e}},function(t,n,r){"use strict";var o=r(19),u=r(5),c=r(171),f=[].slice,a={};t.exports=Function.bind||function(n){var r=o(this),e=f.call(arguments,1),i=function(){var t=e.concat(f.call(arguments));return this instanceof i?function(t,n,r){if(!(n in a)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";a[n]=Function("F,a","return new F("+e.join(",")+")")}return a[n](t,r)}(r,t.length,t):c(r,t,n)};return u(r.prototype)&&(i.prototype=r.prototype),i}},function(t,n,r){"use strict";var u=r(10).f,c=r(71),f=r(75),a=r(46),s=r(68),l=r(69),e=r(143),i=r(174),o=r(76),h=r(9),v=r(67).fastKey,p=r(83),d=h?"_s":"size",y=function(t,n){var r,e=v(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,o,r,e){var i=t(function(t,n){s(t,i,o,"_i"),t._t=o,t._i=c(null),t._f=void 0,t._l=void 0,t[d]=0,null!=n&&l(n,r,t[e],t)});return f(i.prototype,{clear:function(){for(var t=p(this,o),n=t._i,r=t._f;r;r=r.n)r.r=!0,r.p&&(r.p=r.p.n=void 0),delete n[r.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var n=p(this,o),r=y(n,t);if(r){var e=r.n,i=r.p;delete n._i[r.i],r.r=!0,i&&(i.n=e),e&&(e.p=i),n._f==r&&(n._f=e),n._l==r&&(n._l=i),n[d]--}return!!r},forEach:function(t){p(this,o);for(var n,r=a(t,1<arguments.length?arguments[1]:void 0,3);n=n?n.n:this._f;)for(r(n.v,n.k,this);n&&n.r;)n=n.p},has:function(t){return!!y(p(this,o),t)}}),h&&u(i.prototype,"size",{get:function(){return p(this,o)[d]}}),i},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=v(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,r,n){e(t,r,function(t,n){this._t=p(t,r),this._k=n,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?i(0,"keys"==n?r.k:"values"==n?r.v:[r.k,r.v]):(t._t=void 0,i(1))},n?"entries":"values",!n,!0),o(r)}}},function(t,n,r){var e=r(114),i=r(163);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var u=r(75),c=r(67).getWeak,i=r(2),f=r(5),a=r(68),s=r(69),e=r(48),l=r(25),h=r(83),o=e(5),v=e(6),p=0,d=function(t){return t._l||(t._l=new y)},y=function(){this.a=[]},g=function(t,n){return o(t.a,function(t){return t[0]===n})};y.prototype={get:function(t){var n=g(this,t);if(n)return n[1]},has:function(t){return!!g(this,t)},set:function(t,n){var r=g(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(n){var t=v(this.a,function(t){return t[0]===n});return~t&&this.a.splice(t,1),!!~t}},t.exports={getConstructor:function(t,r,e,i){var o=t(function(t,n){a(t,o,r,"_i"),t._t=r,t._i=p++,t._l=void 0,null!=n&&s(n,e,t[i],t)});return u(o.prototype,{delete:function(t){if(!f(t))return!1;var n=c(t);return!0===n?d(h(this,r)).delete(t):n&&l(n,this._i)&&delete n[this._i]},has:function(t){if(!f(t))return!1;var n=c(t);return!0===n?d(h(this,r)).has(t):n&&l(n,this._i)}}),o},def:function(t,n,r){var e=c(i(n),!0);return!0===e?d(t).set(n,r):e[t._i]=r,t},ufstore:d}},function(t,n,r){"use strict";var p=r(121),d=r(5),y=r(11),g=r(46),m=r(7)("isConcatSpreadable");t.exports=function t(n,r,e,i,o,u,c,f){for(var a,s,l=o,h=0,v=!!c&&g(c,f,3);h<i;){if(h in e){if(a=v?v(e[h],h,r):e[h],s=!1,d(a)&&(s=void 0!==(s=a[m])?!!s:p(a)),s&&0<u)l=t(n,r,a,y(a.length),l,u-1)-1;else{if(9007199254740991<=l)throw TypeError();n[l]=a}l++}h++}return l}},function(t,n,r){t.exports=!r(9)&&!r(4)(function(){return 7!=Object.defineProperty(r(136)("div"),"a",{get:function(){return 7}}).a})},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(5),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var o=r(2);t.exports=function(t,n,r,e){try{return e?n(o(r)[0],r[1]):n(r)}catch(n){var i=t.return;throw void 0!==i&&o(i.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var o=r(145),e=Math.pow,u=e(2,-52),c=e(2,-23),f=e(2,127)*(2-c),a=e(2,-126);t.exports=Math.fround||function(t){var n,r,e=Math.abs(t),i=o(t);return e<a?i*(e/a/c+1/u-1/u)*a*c:(r=(n=(1+c/u)*e)-(n-e))>f||r!=r?i*(1/0):i*r}},function(t,n){t.exports=Math.log1p||function(t){return-1e-8<(t=+t)&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n){t.exports=Math.scale||function(t,n,r,e,i){return 0===arguments.length||t!=t||n!=n||r!=r||e!=e||i!=i?NaN:t===1/0||t===-1/0?t:(t-n)*(i-e)/(r-n)+e}},function(t,n,r){"use strict";var h=r(73),v=r(125),p=r(116),d=r(17),y=r(115),i=Object.assign;t.exports=!i||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=i({},t)[r]||Object.keys(i({},n)).join("")!=e})?function(t,n){for(var r=d(t),e=arguments.length,i=1,o=v.f,u=p.f;i<e;)for(var c,f=y(arguments[i++]),a=o?h(f).concat(o(f)):h(f),s=a.length,l=0;l<s;)u.call(f,c=a[l++])&&(r[c]=f[c]);return r}:i},function(t,n,r){var u=r(10),c=r(2),f=r(73);t.exports=r(9)?Object.defineProperties:function(t,n){c(t);for(var r,e=f(n),i=e.length,o=0;o<i;)u.f(t,r=e[o++],n[r]);return t}},function(t,n,r){var e=r(32),i=r(72).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?function(t){try{return i(t)}catch(t){return u.slice()}}(t):i(e(t))}},function(t,n,r){var u=r(25),c=r(32),f=r(117)(!1),a=r(149)("IE_PROTO");t.exports=function(t,n){var r,e=c(t),i=0,o=[];for(r in e)r!=a&&u(e,r)&&o.push(r);for(;n.length>i;)u(e,r=n[i++])&&(~f(o,r)||o.push(r));return o}},function(t,n,r){var f=r(73),a=r(32),s=r(116).f;t.exports=function(c){return function(t){for(var n,r=a(t),e=f(r),i=e.length,o=0,u=[];o<i;)s.call(r,n=e[o++])&&u.push(c?[n,r[n]]:r[n]);return u}}},function(t,n,r){var e=r(72),i=r(125),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(82).trim;t.exports=1/e(r(153)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(82).trim,o=r(153),u=/^[-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=function(t){try{return{e:!1,v:t()}}catch(t){return{e:!0,v:t}}}},function(t,n,r){var e=r(2),i=r(5),o=r(147);t.exports=function(t,n){if(e(t),i(n)&&n.constructor===t)return n;var r=o.f(t);return(0,r.resolve)(n),r.promise}},function(t,n,r){var s=r(11),l=r(152),h=r(50);t.exports=function(t,n,r,e){var i=String(h(t)),o=i.length,u=void 0===r?" ":String(r),c=s(n);if(c<=o||""==u)return i;var f=c-o,a=l.call(u,Math.ceil(f/u.length));return a.length>f&&(a=a.slice(0,f)),e?a+i:i+a}},function(t,n,r){var e=r(52),i=r(11);t.exports=function(t){if(void 0===t)return 0;var n=e(t),r=i(n);if(n!==r)throw RangeError("Wrong length!");return r}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(166),i=r(83);t.exports=r(118)("Map",function(t){return function(){return t(this,0<arguments.length?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(i(this,"Map"),t);return n&&n.v},set:function(t,n){return e.def(i(this,"Map"),0===t?0:t,n)}},e,!0)},function(t,n,r){r(9)&&"g"!=/./g.flags&&r(10).f(RegExp.prototype,"flags",{configurable:!0,get:r(120)})},function(t,n,r){"use strict";var e=r(166),i=r(83);t.exports=r(118)("Set",function(t){return function(){return t(this,0<arguments.length?arguments[0]:void 0)}},{add:function(t){return e.def(i(this,"Set"),t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var o,e=r(48)(0),u=r(27),i=r(67),c=r(178),f=r(168),a=r(5),s=r(4),l=r(83),h="WeakMap",v=i.getWeak,p=Object.isExtensible,d=f.ufstore,y={},g=function(t){return function(){return t(this,0<arguments.length?arguments[0]:void 0)}},m={get:function(t){if(a(t)){var n=v(t);return!0===n?d(l(this,h)).get(t):n?n[this._i]:void 0}},set:function(t,n){return f.def(l(this,h),t,n)}},b=t.exports=r(118)(h,g,m,f,!0,!0);s(function(){return 7!=(new b).set((Object.freeze||Object)(y),7).get(y)})&&(c((o=f.getConstructor(g,h)).prototype,m),i.NEED=!0,e(["delete","has","get","set"],function(e){var t=b.prototype,i=t[e];u(t,e,function(t,n){if(!a(t)||p(t))return i.call(this,t,n);this._f||(this._f=new o);var r=this._f[e](t,n);return"set"==e?this:r})}))},,,,function(t,n){"use strict";t.exports={init:function(){var t=document.querySelector("#page-nav");t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&lt; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &gt;</a>'),yiliaConfig&&yiliaConfig.open_in_new&&document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")}),yiliaConfig&&yiliaConfig.toc_hide_index&&document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"});var n=document.querySelector("#js-aboutme");n&&0!==n.length&&(n.innerHTML=n.innerText)}}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n,r,e,i){var o=function(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}(t),u=function(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}(t)-n;if(u-r<=i){var c=t.$newDom;c||(c=t.cloneNode(!0),(0,a.default)(t,c),(t.$newDom=c).style.position="fixed",c.style.top=(r||u)+"px",c.style.left=o+"px",c.style.zIndex=e||2,c.style.width="100%",c.style.color="#fff"),c.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var f=t.$newDom;f&&(f.style.visibility="hidden")}}function o(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");i(t,document.body.scrollTop,-63,2,0),i(n,document.body.scrollTop,1,3,0)}var f=e(r(159)),a=e((e(r(160)),r(410))),u=e(r(131)),c=e(r(198)),s=r(132);u.default.versions.mobile&&window.screen.width<800&&(function(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var i=t[r];o=n,u=i.getAttribute("href"),c=/\/|index.html/g,o.replace(c,"")===u.replace(c,"")&&(0,f.default)(i,"active")}var o,u,c}(),document.querySelector("#container").addEventListener("scroll",function(t){o()}),window.addEventListener("scroll",function(t){o()}),o()),(0,s.addLoadEvent)(function(){c.default.init()}),t.exports={}},,,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object.defineProperty(t,n,{writable:!0,configurable:!0,value:r})}if(r(409),r(204),r(207),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},function(N,t){(function(t){!function(t){"use strict";function o(t,n,r,e){var o,u,c,f,i=n&&n.prototype instanceof h?n:h,a=Object.create(i.prototype),s=new p(e||[]);return a._invoke=(o=t,u=r,c=s,f=_,function(t,n){if(f===E)throw new Error("Generator is already running");if(f===M){if("throw"===t)throw n;return d()}for(c.method=t,c.arg=n;;){var r=c.delegate;if(r){var e=v(r,c);if(e){if(e===P)continue;return e}}if("next"===c.method)c.sent=c._sent=c.arg;else if("throw"===c.method){if(f===_)throw f=M,c.arg;c.dispatchException(c.arg)}else"return"===c.method&&c.abrupt("return",c.arg);f=E;var i=l(o,u,c);if("normal"===i.type){if(f=c.done?M:O,i.arg===P)continue;return{value:i.arg,done:c.done}}"throw"===i.type&&(f=M,c.method="throw",c.arg=i.arg)}}),a}function l(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function h(){}function r(){}function n(){}function e(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function u(c){function f(t,n,r,e){var i=l(c[t],c,n);if("throw"!==i.type){var o=i.arg,u=o.value;return u&&"object"==typeof u&&y.call(u,"__await")?Promise.resolve(u.__await).then(function(t){f("next",t,r,e)},function(t){f("throw",t,r,e)}):Promise.resolve(u).then(function(t){o.value=t,r(o)},e)}e(i.arg)}var n;"object"==typeof t.process&&t.process.domain&&(f=t.process.domain.bind(f)),this._invoke=function(r,e){function t(){return new Promise(function(t,n){f(r,e,t,n)})}return n=n?n.then(t,t):t()}}function v(t,n){var r=t.iterator[n.method];if(r===a){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=a,v(t,n),"throw"===n.method))return P;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return P}var e=l(r,t.iterator,n.arg);if("throw"===e.type)return n.method="throw",n.arg=e.arg,n.delegate=null,P;var i=e.arg;return i?i.done?(n[t.resultName]=i.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=a),n.delegate=null,P):i:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,P)}function i(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function c(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function p(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(i,this),this.reset(!0)}function f(n){if(n){var t=n[m];if(t)return t.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var r=-1,e=function t(){for(;++r<n.length;)if(y.call(n,r))return t.value=n[r],t.done=!1,t;return t.value=a,t.done=!0,t};return e.next=e}}return{next:d}}function d(){return{value:a,done:!0}}var a,s=Object.prototype,y=s.hasOwnProperty,g="function"==typeof Symbol?Symbol:{},m=g.iterator||"@@iterator",b=g.asyncIterator||"@@asyncIterator",x=g.toStringTag||"@@toStringTag",S="object"==typeof N,w=t.regeneratorRuntime;if(w)S&&(N.exports=w);else{(w=t.regeneratorRuntime=S?N.exports:{}).wrap=o;var _="suspendedStart",O="suspendedYield",E="executing",M="completed",P={},j={};j[m]=function(){return this};var F=Object.getPrototypeOf,A=F&&F(F(f([])));A&&A!==s&&y.call(A,m)&&(j=A);var L=n.prototype=h.prototype=Object.create(j);r.prototype=L.constructor=n,n.constructor=r,n[x]=r.displayName="GeneratorFunction",w.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===r||"GeneratorFunction"===(n.displayName||n.name))},w.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,n):(t.__proto__=n,x in t||(t[x]="GeneratorFunction")),t.prototype=Object.create(L),t},w.awrap=function(t){return{__await:t}},e(u.prototype),u.prototype[b]=function(){return this},w.AsyncIterator=u,w.async=function(t,n,r,e){var i=new u(o(t,n,r,e));return w.isGeneratorFunction(n)?i:i.next().then(function(t){return t.done?t.value:i.next()})},e(L),L[x]="Generator",L[m]=function(){return this},L.toString=function(){return"[object Generator]"},w.keys=function(r){var e=[];for(var t in r)e.push(t);return e.reverse(),function t(){for(;e.length;){var n=e.pop();if(n in r)return t.value=n,t.done=!1,t}return t.done=!0,t}},w.values=f,p.prototype={constructor:p,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=a,this.done=!1,this.delegate=null,this.method="next",this.arg=a,this.tryEntries.forEach(c),!t)for(var n in this)"t"===n.charAt(0)&&y.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=a)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(r){function t(t,n){return o.type="throw",o.arg=r,e.next=t,n&&(e.method="next",e.arg=a),!!n}if(this.done)throw r;for(var e=this,n=this.tryEntries.length-1;0<=n;--n){var i=this.tryEntries[n],o=i.completion;if("root"===i.tryLoc)return t("end");if(i.tryLoc<=this.prev){var u=y.call(i,"catchLoc"),c=y.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return t(i.catchLoc,!0);if(this.prev<i.finallyLoc)return t(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return t(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return t(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;0<=r;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&y.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,P):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),P},finish:function(t){for(var n=this.tryEntries.length-1;0<=n;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),c(r),P}},catch:function(t){for(var n=this.tryEntries.length-1;0<=n;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;c(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:f(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=a),P}}}}("object"==typeof t?t:"object"==typeof window?window:"object"==typeof self?self:this)}).call(t,function(){return this}())},,,function(t,n,r){r(217),t.exports=r(49).RegExp.escape},,,,function(t,n,r){var e=r(5),i=r(121),o=r(7)("species");t.exports=function(t){var n;return i(t)&&("function"!=typeof(n=t.constructor)||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&null===(n=n[o])&&(n=void 0)),void 0===n?Array:n}},function(t,n,r){"use strict";var e=r(4),i=Date.prototype.getTime,o=Date.prototype.toISOString,u=function(t){return 9<t?t:"0"+t};t.exports=e(function(){return"0385-07-25T07:06:39.999Z"!=o.call(new Date(-5e13-1))})||!e(function(){o.call(new Date(NaN))})?function(){if(!isFinite(i.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":9999<n?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(99<r?r:"0"+u(r))+"Z"}:o},function(t,n,r){"use strict";var e=r(2),i=r(53);t.exports=function(t){if("string"!==t&&"number"!==t&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),"number"!=t)}},function(t,n,r){var c=r(73),f=r(125),a=r(116);t.exports=function(t){var n=c(t),r=f.f;if(r)for(var e,i=r(t),o=a.f,u=0;i.length>u;)o.call(t,e=i[u++])&&n.push(e);return n}},function(t,n){t.exports=function(n,r){var e=r===Object(r)?function(t){return r[t]}:r;return function(t){return String(t).replace(n,e)}}},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var e=r(1),i=r(215)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(162)}),r(66)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(48)(4);e(e.P+e.F*!r(47)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(133)}),r(66)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(48)(2);e(e.P+e.F*!r(47)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,1<arguments.length?arguments[1]:void 0)}}),r(66)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,1<arguments.length?arguments[1]:void 0)}}),r(66)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(0),o=r(47)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var h=r(46),e=r(1),v=r(17),p=r(173),d=r(141),y=r(11),g=r(135),m=r(157);e(e.S+e.F*!r(123)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,e,i,o=v(t),u="function"==typeof this?this:Array,c=arguments.length,f=1<c?arguments[1]:void 0,a=void 0!==f,s=0,l=m(o);if(a&&(f=h(f,2<c?arguments[2]:void 0,2)),null==l||u==Array&&d(l))for(r=new u(n=y(o.length));s<n;s++)g(r,s,a?f(o[s],s):o[s]);else for(i=l.call(o),r=new u;!(e=i.next()).done;s++)g(r,s,a?p(i,f,[e.value,s],!0):e.value);return r.length=s,r}})},function(t,n,r){"use strict";var e=r(1),i=r(117)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(47)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(121)})},function(t,n,r){"use strict";var e=r(1),i=r(32),o=[].join;e(e.P+e.F*(r(115)!=Object||!r(47)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(32),o=r(52),u=r(11),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(47)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(1<arguments.length&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);0<=e;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(1);e(e.P+e.F*!r(47)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(135);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);t<n;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(164);e(e.P+e.F*!r(47)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(164);e(e.P+e.F*!r(47)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(139),a=r(45),s=r(77),l=r(11),h=[].slice;e(e.P+e.F*r(4)(function(){i&&h.call(i)}),"Array",{slice:function(t,n){var r=l(this.length),e=a(this);if(n=void 0===n?r:n,"Array"==e)return h.call(this,t,n);for(var i=s(t,r),o=s(n,r),u=l(o-i),c=Array(u),f=0;f<u;f++)c[f]="String"==e?this.charAt(i+f):this[i+f];return c}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(3);e(e.P+e.F*!r(47)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(19),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(47)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(76)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){var e=r(1),i=r(212);e(e.P+e.F*(Date.prototype.toISOString!==i),"Date",{toISOString:i})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(53);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(26)(i,e,r(213))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(27)(e,o,function(){var t=c.call(this);return t==t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(165)})},function(t,n,r){"use strict";var e=r(5),i=r(31),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(10).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(10).f,i=Function.prototype,o=/^\s*function ([^ (]*)/;"name"in i||r(9)&&e(i,"name",{configurable:!0,get:function(){try{return(""+this).match(o)[1]}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(176),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:94906265.62425156<t?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){var e=r(1),i=Math.asinh;e(e.S+e.F*!(i&&0<1/i(0)),"Math",{asinh:function t(n){return isFinite(n=+n)&&0!=n?n<0?-t(-n):Math.log(n+Math.sqrt(n*n+1)):n}})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(145);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(144);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1);e(e.S,"Math",{fround:r(175)})},function(t,n,r){var e=r(1),f=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,i=0,o=0,u=arguments.length,c=0;o<u;)c<(r=f(arguments[o++]))?(i=i*(e=c/r)*e+1,c=r):0<r?i+=(e=r/c)*e:i+=r;return c===1/0?1/0:c*Math.sqrt(i)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)*Math.LOG10E}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(176)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(145)})},function(t,n,r){var e=r(1),i=r(144),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(144),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(0<t?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(25),o=r(45),u=r(140),s=r(53),c=r(4),f=r(72).f,a=r(30).f,l=r(10).f,h=r(82).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(71)(y))==v,m="trim"in String.prototype,b=function(t){var n=s(t,!1);if("string"==typeof n&&2<n.length){var r,e,i,o=(n=m?n.trim():h(n,3)).charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,c=n.slice(2),f=0,a=c.length;f<a;f++)if((u=c.charCodeAt(f))<48||i<u)return NaN;return parseInt(c,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?c(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(b(n)),r,p):b(n)};for(var x,S=r(9)?f(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),w=0;S.length>w;w++)i(d,x=S[w])&&!i(p,x)&&l(p,x,a(d,x));(p.prototype=y).constructor=p,r(27)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(172)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(172),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(184);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(185);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),a=r(52),s=r(161),l=r(152),i=1..toFixed,o=Math.floor,u=[0,0,0,0,0,0],h="Number.toFixed: incorrect invocation!",v=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*u[r],u[r]=e%1e7,e=o(e/1e7)},p=function(t){for(var n=6,r=0;0<=--n;)r+=u[n],u[n]=o(r/t),r=r%t*1e7},d=function(){for(var t=6,n="";0<=--t;)if(""!==n||0===t||0!==u[t]){var r=String(u[t]);n=""===n?r:n+l.call("0",7-r.length)+r}return n},y=function(t,n,r){return 0===n?r:n%2==1?y(t,n-1,r*t):y(t*t,n/2,r)};e(e.P+e.F*(!!i&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){i.call({})})),"Number",{toFixed:function(t){var n,r,e,i,o=s(this,h),u=a(t),c="",f="0";if(u<0||20<u)throw RangeError(h);if(o!=o)return"NaN";if(o<=-1e21||1e21<=o)return String(o);if(o<0&&(c="-",o=-o),1e-21<o)if(r=(n=function(t){for(var n=0,r=t;4096<=r;)n+=12,r/=4096;for(;2<=r;)n+=1,r/=2;return n}(o*y(2,69,1))-69)<0?o*y(2,-n,1):o/y(2,n,1),r*=4503599627370496,0<(n=52-n)){for(v(0,r),e=u;7<=e;)v(1e7,0),e-=7;for(v(y(10,e,1),0),e=n-1;23<=e;)p(1<<23),e-=23;p(1<<e),v(1,1),p(2),f=d()}else v(0,r),v(1<<-n,0),f=d()+l.call("0",u);return f=0<u?c+((i=f.length)<=u?"0."+l.call("0",u-i)+f:f.slice(0,i-u)+"."+f.slice(i-u)):c+f}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(161),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(178)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(71)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(9),"Object",{defineProperties:r(179)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(9),"Object",{defineProperty:r(10).f})},function(t,n,r){var e=r(5),i=r(67).onFreeze;r(51)("freeze",function(n){return function(t){return n&&e(t)?n(i(t)):t}})},function(t,n,r){var e=r(32),i=r(30).f;r(51)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(51)("getOwnPropertyNames",function(){return r(180).f})},function(t,n,r){var e=r(17),i=r(31);r(51)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(5);r(51)("isExtensible",function(n){return function(t){return!!e(t)&&(!n||n(t))}})},function(t,n,r){var e=r(5);r(51)("isFrozen",function(n){return function(t){return!e(t)||!!n&&n(t)}})},function(t,n,r){var e=r(5);r(51)("isSealed",function(n){return function(t){return!e(t)||!!n&&n(t)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(216)})},function(t,n,r){var e=r(17),i=r(73);r(51)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(5),i=r(67).onFreeze;r(51)("preventExtensions",function(n){return function(t){return n&&e(t)?n(i(t)):t}})},function(t,n,r){var e=r(5),i=r(67).onFreeze;r(51)("seal",function(n){return function(t){return n&&e(t)?n(i(t)):t}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(148).set})},function(t,n,r){"use strict";var e=r(114),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(27)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(184);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(185);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u,c=r(70),f=r(3),a=r(46),s=r(114),l=r(1),h=r(5),v=r(19),p=r(68),d=r(69),y=r(129),g=r(154).set,m=r(146)(),b=r(147),x=r(186),S=r(187),w="Promise",_=f.TypeError,O=f.process,E=f[w],M="process"==s(O),P=function(){},j=i=b.f,F=!!function(){try{var t=E.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(P,P)};return(M||"function"==typeof PromiseRejectionEvent)&&t.then(P)instanceof n}catch(t){}}(),A=function(t){var n;return!(!h(t)||"function"!=typeof(n=t.then))&&n},L=function(a,n){if(!a._n){a._n=!0;var r=a._c;m(function(){for(var c=a._v,f=1==a._s,t=0;r.length>t;)!function(t){var n,r,e=f?t.ok:t.fail,i=t.resolve,o=t.reject,u=t.domain;try{e?(f||(2==a._h&&I(a),a._h=1),!0===e?n=c:(u&&u.enter(),n=e(c),u&&u.exit()),n===t.promise?o(_("Promise-chain cycle")):(r=A(n))?r.call(n,i,o):i(n)):o(c)}catch(t){o(t)}}(r[t++]);a._c=[],a._n=!1,n&&!a._h&&N(a)})}},N=function(o){g.call(f,function(){var t,n,r,e=o._v,i=T(o);if(i&&(t=x(function(){M?O.emit("unhandledRejection",e,o):(n=f.onunhandledrejection)?n({promise:o,reason:e}):(r=f.console)&&r.error&&r.error("Unhandled promise rejection",e)}),o._h=M||T(o)?2:1),o._a=void 0,i&&t.e)throw t.v})},T=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if((n=r[e++]).fail||!T(n.promise))return!1;return!0},I=function(n){g.call(f,function(){var t;M?O.emit("rejectionHandled",n):(t=f.onrejectionhandled)&&t({promise:n,reason:n._v})})},k=function(t){var n=this;n._d||(n._d=!0,(n=n._w||n)._v=t,n._s=2,n._a||(n._a=n._c.slice()),L(n,!0))},R=function(t){var r,e=this;if(!e._d){e._d=!0,e=e._w||e;try{if(e===t)throw _("Promise can't be resolved itself");(r=A(t))?m(function(){var n={_w:e,_d:!1};try{r.call(t,a(R,n,1),a(k,n,1))}catch(t){k.call(n,t)}}):(e._v=t,e._s=1,L(e,!1))}catch(t){k.call({_w:e,_d:!1},t)}}};F||(E=function(t){p(this,E,w,"_h"),v(t),e.call(this);try{t(a(R,this,1),a(k,this,1))}catch(t){k.call(this,t)}},(e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1}).prototype=r(75)(E.prototype,{then:function(t,n){var r=j(y(this,E));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=M?O.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&L(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),o=function(){var t=new e;this.promise=t,this.resolve=a(R,t,1),this.reject=a(k,t,1)},b.f=j=function(t){return t===E||t===u?new o(t):i(t)}),l(l.G+l.W+l.F*!F,{Promise:E}),r(81)(E,w),r(76)(w),u=r(49)[w],l(l.S+l.F*!F,w,{reject:function(t){var n=j(this);return(0,n.reject)(t),n.promise}}),l(l.S+l.F*(c||!F),w,{resolve:function(t){return S(c&&this===u?E:this,t)}}),l(l.S+l.F*!(F&&r(123)(function(t){E.all(t).catch(P)})),w,{all:function(t){var u=this,n=j(u),c=n.resolve,f=n.reject,r=x(function(){var e=[],i=0,o=1;d(t,!1,function(t){var n=i++,r=!1;e.push(void 0),o++,u.resolve(t).then(function(t){r||(r=!0,e[n]=t,--o||c(e))},f)}),--o||c(e)});return r.e&&f(r.v),n.promise},race:function(t){var n=this,r=j(n),e=r.reject,i=x(function(){d(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i.e&&e(i.v),r.promise}})},function(t,n,r){var e=r(1),o=r(19),u=r(2),c=(r(3).Reflect||{}).apply,f=Function.apply;e(e.S+e.F*!r(4)(function(){c(function(){})}),"Reflect",{apply:function(t,n,r){var e=o(t),i=u(r);return c?c(e,n,i):f.call(e,n,i)}})},function(t,n,r){var e=r(1),c=r(71),f=r(19),a=r(2),s=r(5),i=r(4),l=r(165),h=(r(3).Reflect||{}).construct,v=i(function(){function t(){}return!(h(function(){},[],t)instanceof t)}),p=!i(function(){h(function(){})});e(e.S+e.F*(v||p),"Reflect",{construct:function(t,n){f(t),a(n);var r=arguments.length<3?t:f(arguments[2]);if(p&&!v)return h(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(l.apply(t,e))}var i=r.prototype,o=c(s(i)?i:Object.prototype),u=Function.apply.call(t,o,n);return s(u)?u:o}})},function(t,n,r){var e=r(10),i=r(1),o=r(2),u=r(53);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(30).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(142)(o,"Object",function(){var t,n=this._k;do{if(this._i>=n.length)return{value:void 0,done:!0}}while(!((t=n[this._i++])in this._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(30),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(31),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){var u=r(30),c=r(31),f=r(25),e=r(1),a=r(5),s=r(2);e(e.S,"Reflect",{get:function t(n,r){var e,i,o=arguments.length<3?n:arguments[2];return s(n)===o?n[r]:(e=u.f(n,r))?f(e,"value")?e.value:void 0!==e.get?e.get.call(o):void 0:a(i=c(n))?t(i,r,o):void 0}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(183)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(148);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){var f=r(10),a=r(30),s=r(31),l=r(25),e=r(1),h=r(74),v=r(2),p=r(5);e(e.S,"Reflect",{set:function t(n,r,e){var i,o,u=arguments.length<4?n:arguments[3],c=a.f(v(n),r);if(!c){if(p(o=s(n)))return t(o,r,e,u);c=h(0)}return l(c,"value")?!(!1===c.writable||!p(u)||((i=a.f(u,r)||h(0)).value=e,f.f(u,r,i),0)):void 0!==c.set&&(c.set.call(u,e),!0)}})},function(t,n,r){var e=r(3),o=r(140),i=r(10).f,u=r(72).f,c=r(122),f=r(120),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(9)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),i=void 0===n;return!r&&e&&t.constructor===a&&i?t:o(p?new s(e&&!i?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&i?f.call(t):n),r?this:l,a)};for(var d=u(s),y=0;d.length>y;)!function(n){n in a||i(a,n,{configurable:!0,get:function(){return s[n]},set:function(t){s[n]=t}})}(d[y++]);(l.constructor=a).prototype=l,r(27)(e,"RegExp",a)}r(76)("RegExp")},function(t,n,r){r(119)("match",1,function(e,i,t){return[function(t){"use strict";var n=e(this),r=null==t?void 0:t[i];return void 0!==r?r.call(t,n):new RegExp(t)[i](String(n))},t]})},function(t,n,r){r(119)("replace",2,function(i,o,u){return[function(t,n){"use strict";var r=i(this),e=null==t?void 0:t[o];return void 0!==e?e.call(t,r,n):u.call(String(r),t,n)},u]})},function(t,n,r){r(119)("search",1,function(e,i,t){return[function(t){"use strict";var n=e(this),r=null==t?void 0:t[i];return void 0!==r?r.call(t,n):new RegExp(t)[i](String(n))},t]})},function(t,n,r){r(119)("split",2,function(i,o,u){"use strict";var v=r(122),p=u,d=[].push,t="split",y="length",g="lastIndex";if("c"=="abbc"[t](/(b)*/)[1]||4!="test"[t](/(?:)/,-1)[y]||2!="ab"[t](/(?:ab)*/)[y]||4!="."[t](/(.?)(.?)/)[y]||1<"."[t](/()()/)[y]||""[t](/.?/)[y]){var m=void 0===/()??/.exec("")[1];u=function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!v(t))return p.call(r,t,n);var e,i,o,u,c,f=[],a=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),s=0,l=void 0===n?4294967295:n>>>0,h=new RegExp(t.source,a+"g");for(m||(e=new RegExp("^"+h.source+"$(?!\\s)",a));(i=h.exec(r))&&!((o=i.index+i[0][y])>s&&(f.push(r.slice(s,i.index)),!m&&1<i[y]&&i[0].replace(e,function(){for(c=1;c<arguments[y]-2;c++)void 0===arguments[c]&&(i[c]=void 0)}),1<i[y]&&i.index<r[y]&&d.apply(f,i.slice(1)),u=i[0][y],s=o,f[y]>=l));)h[g]===i.index&&h[g]++;return s===r[y]?!u&&h.test("")||f.push(""):f.push(r.slice(s)),f[y]>l?f.slice(0,l):f}}else"0"[t](void 0,0)[y]&&(u=function(t,n){return void 0===t&&0===n?[]:p.call(this,t,n)});return[function(t,n){var r=i(this),e=null==t?void 0:t[o];return void 0!==e?e.call(t,r,n):u.call(String(r),t,n)},u]})},function(t,n,r){"use strict";r(192);var e=r(2),i=r(120),o=r(9),u="toString",c=/./[u],f=function(t){r(27)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(28)("anchor",function(n){return function(t){return n(this,"a","name",t)}})},function(t,n,r){"use strict";r(28)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(28)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(28)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(150)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),u=r(11),c=r(151),f="endsWith",a=""[f];e(e.P+e.F*r(138)(f),"String",{endsWith:function(t){var n=c(this,t,f),r=1<arguments.length?arguments[1]:void 0,e=u(n.length),i=void 0===r?e:Math.min(u(r),e),o=String(t);return a?a.call(n,o,i):n.slice(i-o.length,i)===o}})},function(t,n,r){"use strict";r(28)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(28)("fontcolor",function(n){return function(t){return n(this,"font","color",t)}})},function(t,n,r){"use strict";r(28)("fontsize",function(n){return function(t){return n(this,"font","size",t)}})},function(t,n,r){var e=r(1),o=r(77),u=String.fromCharCode,i=String.fromCodePoint;e(e.S+e.F*(!!i&&1!=i.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,i=0;i<e;){if(n=+arguments[i++],o(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?u(n):u(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(151);e(e.P+e.F*r(138)("includes"),"String",{includes:function(t){return!!~i(this,t,"includes").indexOf(t,1<arguments.length?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(28)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(150)(!0);r(143)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(28)("link",function(n){return function(t){return n(this,"a","href",t)}})},function(t,n,r){var e=r(1),u=r(32),c=r(11);e(e.S,"String",{raw:function(t){for(var n=u(t.raw),r=c(n.length),e=arguments.length,i=[],o=0;o<r;)i.push(String(n[o++])),o<e&&i.push(String(arguments[o]));return i.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(152)})},function(t,n,r){"use strict";r(28)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(11),o=r(151),u="startsWith",c=""[u];e(e.P+e.F*r(138)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(1<arguments.length?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(28)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(28)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(28)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(82)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),u=r(25),i=r(9),o=r(1),c=r(27),f=r(67).KEY,a=r(4),s=r(128),l=r(81),h=r(78),v=r(7),p=r(190),d=r(156),y=r(214),g=r(121),m=r(2),b=r(32),x=r(53),S=r(74),w=r(71),_=r(180),O=r(30),E=r(10),M=r(73),P=O.f,j=E.f,F=_.f,A=e.Symbol,L=e.JSON,N=L&&L.stringify,T="prototype",I=v("_hidden"),k=v("toPrimitive"),R={}.propertyIsEnumerable,C=s("symbol-registry"),D=s("symbols"),G=s("op-symbols"),W=Object[T],U="function"==typeof A,V=e.QObject,B=!V||!V[T]||!V[T].findChild,q=i&&a(function(){return 7!=w(j({},"a",{get:function(){return j(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=P(W,n);e&&delete W[n],j(t,n,r),e&&t!==W&&j(W,n,e)}:j,z=function(t){var n=D[t]=w(A[T]);return n._k=t,n},H=U&&"symbol"==typeof A.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof A},K=function(t,n,r){return t===W&&K(G,n,r),m(t),n=x(n,!0),m(r),u(D,n)?(r.enumerable?(u(t,I)&&t[I][n]&&(t[I][n]=!1),r=w(r,{enumerable:S(0,!1)})):(u(t,I)||j(t,I,S(1,{})),t[I][n]=!0),q(t,n,r)):j(t,n,r)},J=function(t,n){m(t);for(var r,e=y(n=b(n)),i=0,o=e.length;i<o;)K(t,r=e[i++],n[r]);return t},Y=function(t){var n=R.call(this,t=x(t,!0));return!(this===W&&u(D,t)&&!u(G,t))&&(!(n||!u(this,t)||!u(D,t)||u(this,I)&&this[I][t])||n)},$=function(t,n){if(t=b(t),n=x(n,!0),t!==W||!u(D,n)||u(G,n)){var r=P(t,n);return!r||!u(D,n)||u(t,I)&&t[I][n]||(r.enumerable=!0),r}},X=function(t){for(var n,r=F(b(t)),e=[],i=0;r.length>i;)u(D,n=r[i++])||n==I||n==f||e.push(n);return e},Q=function(t){for(var n,r=t===W,e=F(r?G:b(t)),i=[],o=0;e.length>o;)!u(D,n=e[o++])||r&&!u(W,n)||i.push(D[n]);return i};U||(c((A=function(){if(this instanceof A)throw TypeError("Symbol is not a constructor!");var n=h(0<arguments.length?arguments[0]:void 0),r=function(t){this===W&&r.call(G,t),u(this,I)&&u(this[I],n)&&(this[I][n]=!1),q(this,n,S(1,t))};return i&&B&&q(W,n,{configurable:!0,set:r}),z(n)})[T],"toString",function(){return this._k}),O.f=$,E.f=K,r(72).f=_.f=X,r(116).f=Y,r(125).f=Q,i&&!r(70)&&c(W,"propertyIsEnumerable",Y,!0),p.f=function(t){return z(v(t))}),o(o.G+o.W+o.F*!U,{Symbol:A});for(var Z="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),tt=0;Z.length>tt;)v(Z[tt++]);for(var nt=M(v.store),rt=0;nt.length>rt;)d(nt[rt++]);o(o.S+o.F*!U,"Symbol",{for:function(t){return u(C,t+="")?C[t]:C[t]=A(t)},keyFor:function(t){if(!H(t))throw TypeError(t+" is not a symbol!");for(var n in C)if(C[n]===t)return n},useSetter:function(){B=!0},useSimple:function(){B=!1}}),o(o.S+o.F*!U,"Object",{create:function(t,n){return void 0===n?w(t):J(w(t),n)},defineProperty:K,defineProperties:J,getOwnPropertyDescriptor:$,getOwnPropertyNames:X,getOwnPropertySymbols:Q}),L&&o(o.S+o.F*(!U||a(function(){var t=A();return"[null]"!=N([t])||"{}"!=N({a:t})||"{}"!=N(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!H(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return"function"==typeof(n=e[1])&&(r=n),!r&&g(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!H(n))return n}),e[1]=n,N.apply(L,e)}}}),A[T][k]||r(26)(A[T],k,A[T].valueOf),l(A,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(130),o=r(155),a=r(2),s=r(77),l=r(11),u=r(5),c=r(3).ArrayBuffer,h=r(129),v=o.ArrayBuffer,p=o.DataView,f=i.ABV&&c.isView,d=v.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(c!==v),{ArrayBuffer:v}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return f&&f(t)||u(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new v(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(a(this),t);for(var r=a(this).byteLength,e=s(t,r),i=s(void 0===n?r:n,r),o=new(h(this,v))(l(i-e)),u=new p(this),c=new p(o),f=0;e<i;)c.setUint8(f++,u.getUint8(e++));return o}}),r(76)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(130).ABV,{DataView:r(155).DataView})},function(t,n,r){r(56)("Float32",4,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(56)("Float64",8,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(56)("Int16",2,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(56)("Int32",4,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(56)("Int8",1,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(56)("Uint16",2,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(56)("Uint32",4,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(56)("Uint8",1,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(56)("Uint8",1,function(e){return function(t,n,r){return e(this,t,n,r)}},!0)},function(t,n,r){"use strict";var e=r(168),i=r(83);r(118)("WeakSet",function(t){return function(){return t(this,0<arguments.length?arguments[0]:void 0)}},{add:function(t){return e.def(i(this,"WeakSet"),t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(169),o=r(17),u=r(11),c=r(19),f=r(134);e(e.P,"Array",{flatMap:function(t){var n,r,e=o(this);return c(t),n=u(e.length),r=f(e,0),i(r,e,e,n,0,1,t,arguments[1]),r}}),r(66)("flatMap")},function(t,n,r){"use strict";var e=r(1),i=r(169),o=r(17),u=r(11),c=r(52),f=r(134);e(e.P,"Array",{flatten:function(){var t=arguments[0],n=o(this),r=u(n.length),e=f(n,0);return i(e,n,n,r,0,void 0===t?1:c(t)),e}}),r(66)("flatten")},function(t,n,r){"use strict";var e=r(1),i=r(117)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,1<arguments.length?arguments[1]:void 0)}}),r(66)("includes")},function(t,n,r){var e=r(1),i=r(146)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.G,{global:r(3)})},function(t,n,r){r(126)("Map")},function(t,n,r){r(127)("Map")},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(167)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{clamp:function(t,n,r){return Math.min(r,Math.max(n,t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{DEG_PER_RAD:Math.PI/180})},function(t,n,r){var e=r(1),i=180/Math.PI;e(e.S,"Math",{degrees:function(t){return t*i}})},function(t,n,r){var e=r(1),o=r(177),u=r(175);e(e.S,"Math",{fscale:function(t,n,r,e,i){return u(o(t,n,r,e,i))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=r>>>0;return(n>>>0)+(e>>>0)+((i&o|(i|o)&~(i+o>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=+t,e=+n,i=65535&r,o=65535&e,u=r>>16,c=e>>16,f=(u*o>>>0)+(i*o>>>16);return u*c+(f>>16)+((i*c>>>0)+(65535&f)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=r>>>0;return(n>>>0)-(e>>>0)-((~i&o|~(i^o)&i-o>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{RAD_PER_DEG:180/Math.PI})},function(t,n,r){var e=r(1),i=Math.PI/180;e(e.S,"Math",{radians:function(t){return t*i}})},function(t,n,r){var e=r(1);e(e.S,"Math",{scale:r(177)})},function(t,n,r){var e=r(1);e(e.S,"Math",{signbit:function(t){return(t=+t)!=t?t:0==t?1/t==1/0:0<t}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=+t,e=+n,i=65535&r,o=65535&e,u=r>>>16,c=e>>>16,f=(u*o>>>0)+(i*o>>>16);return u*c+(f>>>16)+((i*c>>>0)+(65535&f)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(19),u=r(10);r(9)&&e(e.P+r(124),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(19),u=r(10);r(9)&&e(e.P+r(124),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(182)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),f=r(183),a=r(32),s=r(30),l=r(135);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r,e=a(t),i=s.f,o=f(e),u={},c=0;o.length>c;)void 0!==(r=i(e,n=o[c++]))&&l(u,n,r);return u}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(53),u=r(31),c=r(30).f;r(9)&&e(e.P+r(124),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(53),u=r(31),c=r(30).f;r(9)&&e(e.P+r(124),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(182)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),o=r(3),u=r(49),i=r(146)(),c=r(7)("observable"),f=r(19),a=r(2),s=r(68),l=r(75),h=r(26),v=r(69),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},m=function(t){g(t)||(t._o=void 0,y(t))},b=function(t,n){a(t),this._c=void 0,this._o=t,t=new x(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};b.prototype=l({},{unsubscribe:function(){m(this)}});var x=function(t){this._s=t};x.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{m(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var S=function(t){s(this,S,"Observable","_f")._f=f(t)};l(S.prototype,{subscribe:function(t){return new b(t,this._f)},forEach:function(e){var i=this;return new(u.Promise||o.Promise)(function(t,n){f(e);var r=i.subscribe({next:function(t){try{return e(t)}catch(t){n(t),r.unsubscribe()}},error:n,complete:t})})}}),l(S,{from:function(t){var n="function"==typeof this?this:S,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return i(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,e=Array(n);t<n;)e[t]=arguments[t++];return new("function"==typeof this?this:S)(function(n){var r=!1;return i(function(){if(!r){for(var t=0;t<e.length;++t)if(n.next(e[t]),r)return;n.complete()}}),function(){r=!0}})}}),h(S.prototype,c,function(){return this}),e(e.G,{Observable:S}),r(76)("Observable")},function(t,n,r){"use strict";var e=r(1),i=r(49),o=r(3),u=r(129),c=r(187);e(e.P+e.R,"Promise",{finally:function(n){var r=u(this,i.Promise||o.Promise),t="function"==typeof n;return this.then(t?function(t){return c(r,n()).then(function(){return t})}:n,t?function(t){return c(r,n()).then(function(){throw t})}:n)}})},function(t,n,r){"use strict";var e=r(1),i=r(147),o=r(186);e(e.S,"Promise",{try:function(t){var n=i.f(this),r=o(t);return(r.e?n.reject:n.resolve)(r.v),n.promise}})},function(t,n,r){var e=r(55),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(55),o=r(2),u=e.key,c=e.map,f=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:u(arguments[2]),e=c(o(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var i=f.get(n);return i.delete(r),!!i.size||f.delete(n)}})},function(t,n,r){var o=r(193),u=r(163),e=r(55),i=r(2),c=r(31),f=e.keys,a=e.key,s=function(t,n){var r=f(t,n),e=c(t);if(null===e)return r;var i=s(e,n);return i.length?r.length?u(new o(r.concat(i))):i:r};e.exp({getMetadataKeys:function(t){return s(i(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(55),i=r(2),o=r(31),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(55),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(55),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(55),i=r(2),o=r(31),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(55),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(55),i=r(2),o=r(19),u=e.key,c=e.set;e.exp({metadata:function(r,e){return function(t,n){c(r,e,(void 0!==n?i:o)(t),u(n))}}})},function(t,n,r){r(126)("Set")},function(t,n,r){r(127)("Set")},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(167)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(150)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(50),o=r(11),u=r(122),c=r(120),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(142)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(188);e(e.P,"String",{padEnd:function(t){return i(this,t,1<arguments.length?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(188);e(e.P,"String",{padStart:function(t){return i(this,t,1<arguments.length?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(82)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(82)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(156)("asyncIterator")},function(t,n,r){r(156)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){r(126)("WeakMap")},function(t,n,r){r(127)("WeakMap")},function(t,n,r){r(126)("WeakSet")},function(t,n,r){r(127)("WeakSet")},function(t,n,r){for(var e=r(158),i=r(73),o=r(27),u=r(3),c=r(26),f=r(80),a=r(7),s=a("iterator"),l=a("toStringTag"),h=f.Array,v={CSSRuleList:!0,CSSStyleDeclaration:!1,CSSValueList:!1,ClientRectList:!1,DOMRectList:!1,DOMStringList:!1,DOMTokenList:!0,DataTransferItemList:!1,FileList:!1,HTMLAllCollection:!1,HTMLCollection:!1,HTMLFormElement:!1,HTMLSelectElement:!1,MediaList:!0,MimeTypeArray:!1,NamedNodeMap:!1,NodeList:!0,PaintRequestList:!1,Plugin:!1,PluginArray:!1,SVGLengthList:!1,SVGNumberList:!1,SVGPathSegList:!1,SVGPointList:!1,SVGStringList:!1,SVGTransformList:!1,SourceBufferList:!1,StyleSheetList:!0,TextTrackCueList:!1,TextTrackList:!1,TouchList:!1},p=i(v),d=0;d<p.length;d++){var y,g=p[d],m=v[g],b=u[g],x=b&&b.prototype;if(x&&(x[s]||c(x,s,h),x[l]||c(x,l,g),f[g]=h,m))for(y in e)x[y]||o(x,y,e[y],!0)}},function(t,n,r){var e=r(1),i=r(154);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=e.navigator,u=[].slice,c=!!o&&/MSIE .\./.test(o.userAgent),f=function(i){return function(t,n){var r=2<arguments.length,e=!!r&&u.call(arguments,2);return i(r?function(){("function"==typeof t?t:Function(t)).apply(this,e)}:t,n)}};i(i.G+i.B+i.F*c,{setTimeout:f(e.setTimeout),setInterval:f(e.setInterval)})},function(t,n,r){r(337),r(276),r(278),r(277),r(280),r(282),r(287),r(281),r(279),r(289),r(288),r(284),r(285),r(283),r(275),r(286),r(290),r(291),r(243),r(245),r(244),r(293),r(292),r(263),r(273),r(274),r(264),r(265),r(266),r(267),r(268),r(269),r(270),r(271),r(272),r(246),r(247),r(248),r(249),r(250),r(251),r(252),r(253),r(254),r(255),r(256),r(257),r(258),r(259),r(260),r(261),r(262),r(324),r(329),r(336),r(327),r(319),r(320),r(325),r(330),r(332),r(315),r(316),r(317),r(318),r(321),r(322),r(323),r(326),r(328),r(331),r(333),r(334),r(335),r(238),r(240),r(239),r(242),r(241),r(227),r(225),r(231),r(228),r(234),r(236),r(224),r(230),r(221),r(235),r(219),r(233),r(232),r(226),r(229),r(218),r(220),r(223),r(222),r(237),r(158),r(309),r(314),r(192),r(310),r(311),r(312),r(313),r(294),r(191),r(193),r(194),r(349),r(338),r(339),r(344),r(347),r(348),r(342),r(345),r(343),r(346),r(340),r(341),r(295),r(296),r(297),r(298),r(299),r(302),r(300),r(301),r(303),r(304),r(305),r(306),r(308),r(307),r(352),r(350),r(351),r(393),r(396),r(395),r(397),r(398),r(394),r(399),r(400),r(374),r(377),r(373),r(371),r(372),r(375),r(376),r(358),r(392),r(357),r(391),r(403),r(405),r(356),r(390),r(402),r(404),r(355),r(401),r(354),r(359),r(360),r(361),r(362),r(363),r(365),r(364),r(366),r(367),r(368),r(370),r(369),r(379),r(380),r(381),r(382),r(384),r(383),r(386),r(385),r(387),r(388),r(389),r(353),r(378),r(408),r(407),r(406),t.exports=r(49)},function(t,n){t.exports=function(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}}])</script><script src="/./main.e8862b.js"></script><script>!function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src","/slider.5b7e29.js")}()</script><script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script><script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)"><div class="tools-nav header-menu"><ul style="width:70%"><li style="width:33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">All articles</a></li><li style="width:33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">Friends</a></li><li style="width:33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">About me</a></li></ul></div><div class="tools-wrap"><section class="tools-section tools-section-all" q-show="innerArchive"><div class="search-wrap"> <input class="search-ipt" q-model="search" type="text" placeholder="find something…"><i class="icon-search icon" q-show="search|isEmptyStr"></i><i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i></div><div class="widget tagcloud search-tag"><p class="search-tag-wording">tag:</p> <label class="search-switch"><input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags"></label><ul class="article-tag-list" q-show="showTags"><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color5">Algorithm</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color4">C++</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color3">DS</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color3">Android</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color5">Tech</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color3">ML</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color3">DL</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color1">Essay</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color4">git</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color5">hexo</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color2">golang</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color5">HTML</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color1">Javascript</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color4">CSS</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color3">js</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color5">html</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color5">Java</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color1">Redis</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color1">MYSQL</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color2">Spring</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color1">linux</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color2">papers</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color3">RL</a></li><li class="article-tag-list-item"> <a href="javascript:void(0)" class="js-tag color4">k8s</a></li><div class="clearfix"></div></ul></div><ul class="search-ul"><p q-show="jsonFail" style="padding:20px;font-size:12px"> 缺失模块。<br>1、请确保node版本大于6.2<br>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br> npm i hexo-generator-json-content --save<br><br> 3、在根目录_config.yml里添加配置：<pre style="font-size:12px" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre></p><li class="search-li" q-repeat="items" q-show="isShow"><a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a><p class="search-time"><i class="icon-calendar icon"></i><span q-text="date|dateformat"></span></p><p class="search-tag"><i class="icon-price-tags icon"></i><span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span></p></li></ul></section><section class="tools-section tools-section-friends" q-show="friends"><ul class="search-ul"><li class="search-li"><a href="https://leetcode-cn.com/u/louris/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i> 我的力扣</a></li><li class="search-li"><a href="https://www.six1110.top/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i> 饭勺</a></li><li class="search-li"><a href="https://www.zjcheng.site/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i> 中建</a></li></ul></section><section class="tools-section tools-section-me" q-show="aboutme"><div class="aboutme-wrap" id="js-aboutme">做一个安静细微的人，&lt;br&gt; 于角落里自在开放，&lt;br&gt; 默默悦人，&lt;br&gt; 却始终不引起过分热闹的关注，&lt;br&gt; 保有独立而随意的品格，&lt;br&gt; 这就很好。&lt;br&gt;&lt;br&gt; Stick to what you insist on,&lt;br&gt; believe what you believe!&lt;br&gt; Life hastily for decades,&lt;br&gt; do what I can!</div></section></div></div><div class="pswp" tabindex="-1" role="dialog" aria-hidden="true"><div class="pswp__bg"></div><div class="pswp__scroll-wrap"><div class="pswp__container"><div class="pswp__item"></div><div class="pswp__item"></div><div class="pswp__item"></div></div><div class="pswp__ui pswp__ui--hidden"><div class="pswp__top-bar"><div class="pswp__counter"></div> <button class="pswp__button pswp__button--close" title="Close (Esc)"></button> <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button> <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button> <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class="pswp__preloader"><div class="pswp__preloader__icn"><div class="pswp__preloader__cut"><div class="pswp__preloader__donut"></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class="pswp__share-tooltip"></div></div> <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button> <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class="pswp__caption"><div class="pswp__caption__center"></div></div></div></div></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!1},react:{opacity:1},log:!1})</script></body></html>