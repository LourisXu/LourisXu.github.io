<!DOCTYPE html>
<html>
<head>

  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="https://lourisxu.github.io">
  <title>算法进阶 | Louris&#39; Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="第一章 二分查找 二分查找函数①写一个函数BinarySearch，在包含size个元素的、从小到大排序的int数组a里查找元素p，如果找到，则返回元素下标，如果找不到，则返回-1。要求时间复杂度$O\left(\log n \right)$ 1234567891011121314151617181920212223int BinarySearch(int a[],int size,int p)">
<meta property="og:type" content="article">
<meta property="og:title" content="算法进阶">
<meta property="og:url" content="https://lourisxu.github.io/2017/09/12/advanced-algorithm.html/index.html">
<meta property="og:site_name" content="Louris&#39; Blog">
<meta property="og:description" content="第一章 二分查找 二分查找函数①写一个函数BinarySearch，在包含size个元素的、从小到大排序的int数组a里查找元素p，如果找到，则返回元素下标，如果找不到，则返回-1。要求时间复杂度$O\left(\log n \right)$ 1234567891011121314151617181920212223int BinarySearch(int a[],int size,int p)">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/1f31d.png?v8">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B3%95%E6%B1%82%E5%AD%90%E9%9B%86.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/A-Star-01.jpg">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/A-Star-02.jpg">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/A-Star-03.jpg">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/A-Star-04.jpg">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/A-Star-05.jpg">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/A-Star-06.jpg">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/A-Star-07.jpg">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/%E7%BA%BF%E6%AE%B5%E6%A0%91.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%8601.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%8602.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%8603.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%8604.png">
<meta property="og:image" content="https://lourisxu.github.io/assets/img/algorithm/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.gif">
<meta property="og:image" content="https://dn-coding-net-production-file.codehub.cn/1a6b87b0-0863-11e9-bec5-e1ca741700a6.png?e=1545827553&amp;token=goE9CtaiT5YaIP6ZQ1nAafd_C1Z_H2gVP8AwuC-5:hASfxODm5Go0AhAtsqH_EPancZk=">
<meta property="article:published_time" content="2017-09-12T03:31:31.000Z">
<meta property="article:modified_time" content="2024-01-19T02:20:51.960Z">
<meta property="article:author" content="Louris">
<meta property="article:tag" content="Algorithm">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.githubassets.com/images/icons/emoji/unicode/1f31d.png?v8">
  
    <link rel="alternative" href="/atom.xml" title="Louris&#39; Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/assets/img/blog/favicon.png">
  
  <link rel="stylesheet" type="text/css" href="/./main.e8862b.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

<meta name="generator" content="Hexo 4.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #00BFFF"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/assets/img/blog/userpic.jpg" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">Louris</a></h1>
		</hgroup>
		
		<p class="header-subtitle">Do what I can</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">Home</a></li>
	        
				<li><a href="/categories/DS/">DS</a></li>
	        
				<li><a href="/tags/ML/">ML&amp;DL</a></li>
	        
				<li><a href="/tags/Tech/">Tech</a></li>
	        
				<li><a href="/tags/Algorithm/">Algorithm</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">All articles</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">Friends</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">About me</a>
    			
            
		</nav>
		<nav>
		 <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=230 height=86 src="//music.163.com/outchain/player?type=2&id=2080322&auto=1&height=66"></iframe>
		 <!--<div id="aplayer_home" class="aplayer" style="margin-bottom: 20px;width:100%;"></div>
		 <script type="text/javascript" src="\assets\js\APlayer.min.js"> </script>
 			<script>
   			new APlayer({
     		element: document.getElementById("aplayer_home"),
     		narrow: false,
     		autoplay: false,
     		showlrc: 0,
     		music: {
       		title: "What Are Words",
       		author: "Chris Media",
       		url: "https://coding.net/u/LourisXu/p/LourisXu/attachment/4532287/preview/4533847",
       		pic: "http://ov4otygyd.bkt.clouddn.com/What_Are_Words.jpg",
   			}
 			});
			</script>-->
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/LourisXu" title="github"><i class="icon-github"></i></a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/5634881238/profile?rightmod=1&wvr=6&mod=personinfo" title="weibo"><i class="icon-weibo"></i></a>
		        
					<a class="mail" target="_blank" href="mailto:louris@csu.edu.cn" title="mail"><i class="icon-mail"></i></a>
		        
			</div>
		</nav>
	</header>
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #00BFFF"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/assets/img/blog/userpic.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">Louris</h1>
			</hgroup>
			
			<p class="header-subtitle"><i class="icon icon-quo-left"></i>Do what I can<i class="icon icon-quo-right"></i></p>
			
			
			
				
			
				
			
				
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/LourisXu" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/5634881238/profile?rightmod=1&wvr=6&mod=personinfo" title="weibo"><i class="icon-weibo"></i></a>
			        
						<a class="mail" target="_blank" href="mailto:louris@csu.edu.cn" title="mail"><i class="icon-mail"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 70%">
				
				
					<li style="width: 20%"><a href="/">Home</a></li>
		        
					<li style="width: 20%"><a href="/categories/DS/">DS</a></li>
		        
					<li style="width: 20%"><a href="/tags/ML/">ML&amp;DL</a></li>
		        
					<li style="width: 20%"><a href="/tags/Tech/">Tech</a></li>
		        
					<li style="width: 20%"><a href="/tags/Algorithm/">Algorithm</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            <article id="post-Algorithm/算法进阶" class="article article-type-post " itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      算法进阶
    </h1>
  


        
        <a href="/2017/09/12/advanced-algorithm.html/" class="archive-article-date">
  	<time datetime="2017-09-12T03:31:31.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-09-12</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<h1 id="第一章-二分查找"><a href="#第一章-二分查找" class="headerlink" title="第一章 二分查找"></a>第一章 二分查找</h1></blockquote>
<h2 id="二分查找函数"><a href="#二分查找函数" class="headerlink" title="二分查找函数"></a>二分查找函数</h2><p>①写一个函数BinarySearch，在包含size个元素的、从小到大排序的int数组a里查找元素p，如果找到，则返回元素下标，如果找不到，则返回-1。要求时间复杂度$O\left(\log n \right)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> size,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">int</span> Left=<span class="number">0</span>;<span class="comment">//查找区间的左端点</span></span><br><span class="line">  <span class="keyword">int</span> Right=size<span class="number">-1</span>;<span class="comment">//查找区间的右端点</span></span><br><span class="line">  <span class="keyword">while</span>(Left&lt;=Right)</span><br><span class="line">  {</span><br><span class="line">    <span class="comment">//int mid=(Left+Right)/2;</span></span><br><span class="line">    <span class="keyword">int</span> mid=Left+(Right-Left)/<span class="number">2</span>;<span class="comment">//防止L+R过大溢出</span></span><br><span class="line">    <span class="keyword">if</span>(p==a[mid])</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p&gt;a[mid])</span><br><span class="line">    {</span><br><span class="line">      Left=mid+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">      Right=mid<span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}<span class="comment">//复杂度O(log n)</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>②写一个函数LowerBound，在包含size个元素的、从小到大排序的int数组a里查找比给定整数p小的，下标最大的元素，找到则返回其下标，找不到则返回-1。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LowerBound</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> size,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">int</span> Left=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> Right=size<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> lastPos=<span class="number">-1</span>;<span class="comment">//到目前为止找到的最优解</span></span><br><span class="line">  <span class="keyword">while</span>(Left&lt;=Right)</span><br><span class="line">  {</span><br><span class="line">    <span class="comment">//int mid=(Left+Right)/2;</span></span><br><span class="line">    <span class="keyword">int</span> mid=Left+(Right-Left)/<span class="number">2</span>;<span class="comment">//防止L+R过大溢出</span></span><br><span class="line">    <span class="keyword">if</span>(a[mid]&gt;=p)</span><br><span class="line">    {</span><br><span class="line">      Right=mid<span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">      lastPos=mid;</span><br><span class="line">      Left=mid+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> lastPos;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="二分法求方程的根"><a href="#二分法求方程的根" class="headerlink" title="二分法求方程的根"></a>二分法求方程的根</h2><p>求下面方程的一个根：$f(x)=x^3-5x^2+10x-80=0$，若求出的根是a，则要求$|f(a)|&lt;=10^{-6}$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：二分法求方程的根.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">对f(x)求导，得f'(x)=3x^2-10x+10。由一元二次方程求根公式知方程无解，</span></span><br><span class="line"><span class="comment">因此f'(x)恒大于0,。故f(x)事单调递增的。易知f(0)&lt;0且f(100)&gt;0，所以</span></span><br><span class="line"><span class="comment">区间[0,100]内必然有且只有一个根。由于f(x)在[0,100]内是单调的，所以</span></span><br><span class="line"><span class="comment">可以用二分的办法在区间[0.100]中寻找根。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.09.12</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-6</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">equation</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> x*x*x - <span class="number">5</span> * x*x + <span class="number">10</span> * x - <span class="number">80</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">double</span> root, x1 = <span class="number">0</span>, x2 = <span class="number">100</span>, y;</span><br><span class="line">	root = x1 + (x2 - x1) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> triedTimes = <span class="number">1</span>;</span><br><span class="line">	y = equation(root);</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">fabs</span>(y) &gt; EPS)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (y &gt; <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			x2 = root;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			x1 = root;</span><br><span class="line">		}</span><br><span class="line">		root = x1 + (x2 - x1) / <span class="number">2</span>;</span><br><span class="line">		y = equation(root);</span><br><span class="line">		triedTimes++;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.8f\n"</span>, root);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, triedTimes);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="整数和"><a href="#整数和" class="headerlink" title="整数和"></a>整数和</h2><p>输入n(n&lt;=100,000)个整数，找出其中的两个数，它们之和等于整数m(假定肯定有解)。体重所有整数都能用int表示。<br><strong>解法1</strong><br>用两重循环，枚举所有的取数方法，复杂度是$O\left(n^2\right)$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">     <span class="keyword">if</span>(a[i]+a[j]==m)</span><br><span class="line">       <span class="keyword">break</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>$100,1000^2=100亿$，在各种OJ伤提交或参加各种程序设计竞赛，这种复杂度都会超时！<br><strong>解法2</strong><br>1)将数组排序，复杂度是$O\left(n\log n\right)$<br>2)对数组中的每个元素a[i]，在数组中二分查找m-a[i]，看能否找到。<br>复杂度$\log n$，最坏要查找n-2，所以查找这部分的复杂度也是$O\left(n\log n\right)$。<br>这种解法总的复杂度是$O\left(n \log n\right)$。<br><strong>解法3</strong><br>1)将数组排序，复杂度是$O\left(n \log n\right)$<br>2)查找的时候，设置两个变量i和j，i初值是0，j初值是n-1.<br>看a[i]+a[j]，如果大于m，就让j减1，如果小于m，就让i加1，直至a[i]+a[j]=m。<br>这种解法总的复杂度是$O\left(n \log n\right)$。</p>
<h2 id="Aggressive-cows"><a href="#Aggressive-cows" class="headerlink" title="Aggressive cows"></a>Aggressive cows</h2><p><strong>描述</strong><br>Farmer John has built a new long barn, with N (2 &lt;= N &lt;= 100,000) stalls. The stalls are located along a straight line at positions x1,…,xN (0 &lt;= xi &lt;= 1,000,000,000).<br>His C (2 &lt;= C &lt;= N) cows don’t like this barn layout and become aggressive towards each other once put into a stall. To prevent the cows from hurting each other, FJ want to assign the cows to the stalls, such that the minimum distance between any two of them is as large as possible. What is the largest minimum distance?<br><strong>输入</strong><br>Line 1: Two space-separated integers: N and C<br>Lines 2..N+1: Line i+1 contains an integer stall location, xi<br><strong>输出</strong><br>Line 1: One integer: the largest minimum distance<br><strong>样例输入</strong><br>5 3<br>1<br>2<br>8<br>4<br>9<br><strong>样例输出</strong><br>3<br><strong>程序</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：Aggressive_cows.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">解法1：</span></span><br><span class="line"><span class="comment">先得到排序后的间隔坐标x0,...,xN-1</span></span><br><span class="line"><span class="comment">从1,000,000,000/C到1依次尝试这个“最大的最近距离”D，找到的第一个可行的就是答案。</span></span><br><span class="line"><span class="comment">尝试方法：</span></span><br><span class="line"><span class="comment">1)第1头牛放在x0</span></span><br><span class="line"><span class="comment">2)第2头牛放在xi，则找到xi+1到xN-1中第一个位于[xi+D,1,000,000,000]中的xj第k+1头牛放在xj。找不到这样的xj，则D=D-1，转1)再试</span></span><br><span class="line"><span class="comment">若所有牛都能放下，则D即答案。</span></span><br><span class="line"><span class="comment">复杂度 1,000,000,000/C*N，即1,000,000,000，超时！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解法2：</span></span><br><span class="line"><span class="comment">先得到排序后的间隔坐标x0,...,xN-1</span></span><br><span class="line"><span class="comment">在[L,R]内用二分法尝试“最大最近距离”D=(L+R)/2  (L,R初值为[1,1000000000/C]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">若D可行，则记住该D，然后在新[L,R]中继续尝试(L=D+1)</span></span><br><span class="line"><span class="comment">若D不可行，则在新[L,R]中继续尝试(R=D-1)</span></span><br><span class="line"><span class="comment">复杂度 log(1000000000/C)*N</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.09.13</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> C, n, num;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; C)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">int</span>* x = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x[i];</span><br><span class="line">		}</span><br><span class="line">		sort(x, x + n);</span><br><span class="line">		<span class="comment">//解法一</span></span><br><span class="line">		<span class="comment">/*int D;</span></span><br><span class="line"><span class="comment">		for (D = 1000000000 / C; D &gt;= 1;)</span></span><br><span class="line"><span class="comment">		{</span></span><br><span class="line"><span class="comment">			int temp = x[0];</span></span><br><span class="line"><span class="comment">			num = 1;</span></span><br><span class="line"><span class="comment">			for (int j = 1; j &lt; n; j++)</span></span><br><span class="line"><span class="comment">			{</span></span><br><span class="line"><span class="comment">				if (temp + D &gt; 1000000000)</span></span><br><span class="line"><span class="comment">				{</span></span><br><span class="line"><span class="comment">					break;</span></span><br><span class="line"><span class="comment">				}</span></span><br><span class="line"><span class="comment">				if (temp + D &lt;= x[j])</span></span><br><span class="line"><span class="comment">				{</span></span><br><span class="line"><span class="comment">					num++;</span></span><br><span class="line"><span class="comment">					temp = x[j];</span></span><br><span class="line"><span class="comment">				}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">				if(num==C)</span></span><br><span class="line"><span class="comment">				{</span></span><br><span class="line"><span class="comment">					break;</span></span><br><span class="line"><span class="comment">				}</span></span><br><span class="line"><span class="comment">			}</span></span><br><span class="line"><span class="comment">			if (num != C)</span></span><br><span class="line"><span class="comment">			{</span></span><br><span class="line"><span class="comment">			D--;</span></span><br><span class="line"><span class="comment">			}</span></span><br><span class="line"><span class="comment">		}*/</span></span><br><span class="line">		<span class="comment">//解法二</span></span><br><span class="line">		<span class="keyword">int</span> Left = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> Right = <span class="number">1000000000</span> / C;</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (Left &lt;= Right)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">int</span> D = Left + (Right - Left) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">int</span> temp = x[<span class="number">0</span>];</span><br><span class="line">			num = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">if</span> (temp + D &gt; <span class="number">1000000000</span>)</span><br><span class="line">				{</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">if</span> (temp + D &lt;= x[j])</span><br><span class="line">				{</span><br><span class="line">					num++;</span><br><span class="line">					temp = x[j];</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">if</span> (num == C)</span><br><span class="line">				{</span><br><span class="line">					Left = D + <span class="number">1</span>;</span><br><span class="line">					result = D;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (num != C)</span><br><span class="line">			{</span><br><span class="line">				Right = D - <span class="number">1</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="第二章-动态规划之背包专题"><a href="#第二章-动态规划之背包专题" class="headerlink" title="第二章 动态规划之背包专题"></a>第二章 动态规划之背包专题</h1></blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h3><p>一个背包总容量为V，现在有N个物品，第i个 物品体积为weight[i]，价值为value[i]，现在往背包里面装东西，怎么装能使背包的内物品价值最大？<br><strong>状态转移方程</strong><br>取或不取第i件物品，j表示当前剩余容量<br>d[i][j]=max(d[i-1][j],d[i-1][j-w[i]]+v[i]) (j&gt;w[i]才有第二项)<br>伪代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N</span><br><span class="line"><span class="keyword">for</span> v=V.<span class="number">.0</span></span><br><span class="line">d[j]=max(d[j],d[j-w[i]]+v[i])</span><br></pre></td></tr></tbody></table></figure>
<p><strong>这里已经是空间优化的结果</strong><br>求第i行j列的元素，按照状态转移方程可知，必须用到其上一行正上方的元素和该元素左侧的一个元素<br><strong>①行分析</strong><br>那么按照行从小到大的顺序进行，当前行各元素计算完成则其上一行元素失去作用，不再参与计算，<br>故可以将下一行的各元素的计算结果保存到上一行，已达到空间优化的目的。<br><strong>②列分析</strong><br>由于当前元素的计算需要其正上方及其左边的某个元素，那么，<br>如果从左到右进行枚举，当前元素的计算结果保存到其正上方元素，则进行右边的其他元素时<br>可能会用到这个已经被保存计算结果的元素，所以不可以。<br>如果从右到左进行枚举，当前元素的计算结果保存到其正上方元素，对当行左边其他元素的计算不产生任何影响，故达到了空间优化的目的。<br>综上：采用从上到下，从右到左的顺序进行枚举。</p>
<h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><p>一个背包总容量为V，现在有N种物品，第i个 物品体积为weight[i]，价值为value[i]，每个物品都有无限多件，现在往背包里面装东西，怎么装能使背包的内物品价值最大？<br><strong>状态转移方程</strong><br>i表示选第i种物品，j表示剩余空间<br>d[i][j]=max\left(d[i-1][j],d[i-1][j-k×w[i]]+k×v[i]\right)  (j&gt;k×w[i]才有第二项，0&lt;=k×w[i]&lt;=V)<br>伪代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N</span><br><span class="line"><span class="keyword">for</span> j=c..V</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1.</span>..j/w[i]</span><br><span class="line">d[i][j]=max(d[i<span class="number">-1</span>][j],d[i<span class="number">-1</span>][j-k*w[i]]+k*v[i])</span><br></pre></td></tr></tbody></table></figure>
<p>同样采用空间优化的思路：<br>在d[i][j]与d[i-1][j]以及d[i-1][j]左边k个元素比较的过程中，取最大值，<br>由于i、w[i]在k循环中为定量，考虑j和k是变量，进行逆序循环k：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N</span><br><span class="line"><span class="keyword">for</span> j=c..V</span><br><span class="line"><span class="keyword">for</span> k=j/w[i]..<span class="number">.1</span></span><br><span class="line">d[i][j]=max(d[i<span class="number">-1</span>][j],d[i<span class="number">-1</span>][j-k*w[i]]+k*v[i])</span><br></pre></td></tr></tbody></table></figure>
<p>那么在j增加的情况下，递推公式可以简化：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">假设j_1,...,j_4都恰好整除w[i]：</span><br><span class="line">j_1/w[i]=<span class="number">3</span></span><br><span class="line">j_2/w[i]=<span class="number">2</span></span><br><span class="line">j_3/w[i]=<span class="number">1</span></span><br><span class="line">j_4/w[i]=<span class="number">0</span></span><br><span class="line">d[j_4]</span><br><span class="line">=max(d[j_4])</span><br><span class="line">d[j_3]</span><br><span class="line">=max(d[j_3],d[j_3<span class="number">-1</span>*w[i]]+v[i])</span><br><span class="line">=max(d[j_3],d[j_4]+v[i])</span><br><span class="line">d[j_2]</span><br><span class="line">=max(d[j_2],d[j_2<span class="number">-2</span>*w[i]]+<span class="number">2</span>*v[i],d[j_2<span class="number">-1</span>*w[i]]+v[i])</span><br><span class="line">=max(d[j_2],d[j_4]+<span class="number">2</span>*v[i],d[j_3]+v[i])</span><br><span class="line">=max(d[j_2],max(d[j_3],d[j_4]+v[i])+v[i])</span><br><span class="line">=max(d[j_2],d[j_3]+v[i])</span><br><span class="line">d[j_1]</span><br><span class="line">=max(d[j_1],d[j_1<span class="number">-3</span>*w[i]]+<span class="number">3</span>*v[i],d[j_1<span class="number">-2</span>*w[i]]+<span class="number">2</span>*v[i],d[j_1<span class="number">-1</span>*w[i]]+v[i])</span><br><span class="line">=max(d[j_1],d[j_4]+<span class="number">3</span>*w[i],d[j_3]+<span class="number">2</span>*w[i],d[j_2]+v[i])</span><br><span class="line">=max(d[j_1],max(d[j_4]+<span class="number">2</span>*v[i],d[j_3]+v[i],d[j_2])+v[i])</span><br><span class="line">=max(d[j_1],d[j_2]+v[i])</span><br><span class="line">上述推导可以用二维数组简化图推导，也许更加明了。</span><br><span class="line">至此规律已出：</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N</span><br><span class="line"><span class="keyword">for</span> j=c..V</span><br><span class="line">d[j]=max(d[j],d[j-w[i]]+v[i])</span><br></pre></td></tr></tbody></table></figure>
<p>综上，完全背包在当前j剩余空间最优结果可以由前者递推实现，也就是说j增大的过程中，较大的j的k个取法的最优结果是由上一个较小的j的k个取法最优结果和i当前不取时两者取最优。<br><strong>二者区别</strong><br>前者物品有限件，后者物品无限件<br>完全背包问题和01背包问题唯一不同的是j是从1到M。01背包问题是在前一个子问题（i-1种物品）的基础上来解决当前问题（i种物品），向i-1种物品时的背包添加第i种物品；而完全背包问题是在解决当前问题（i种物品），向i种物品时的背包添加第i种物品。<br>从矩阵来看，<br><strong>0-1背包</strong><br>第二层循环必须逆序进行，因为当前f[i][j]需要用到f[i-1][j]和f[i-1][j-w[i]]，即前一个i-1件商品的结果，并且不重复<br><strong>完全背包</strong><br>第二层循环必须顺序进行，因为当前f[i][j]表示取第i件，这第i件可以和前i-1件重复<br><strong>分析优化后的伪代码</strong><br>你会发现，这个伪代码与01背包的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？<br>首先想想为什么01背包中要按照v=V..0的逆序来循环。这是因为要保证第i次循环中的状态f[v]是由状态f[v-c]递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个没有已经选入第i件物品的子结果f[v-c]。<br>而当前完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[v-c]，所以就可以并且必须采用v=0..V的顺序循环。这就是这个简单的程序为何成立的道理。</p>
<h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>与完全背包类似，不同的是，多重背包每种物品的个数有限,假设为m_i，那么可以转化成0-1背包求解<br>d[i][j]=max(d[i-1][j],d[i-1][j-k×w[i]]+k×v[i])  (j&gt;k×w[i]才有第二项，0&lt;=k&lt;=m_i)<br><strong>二进制优化</strong><br>这m个同种物品可以用二进制表示，因为每个整数m都可以用二进制表示，那么<br>比如说$10=2^0+2^1+2^2+3$<br>那么也就是把同一件物品10件拆成1,2,4,3份，每一份看成新的一种物品，那么就是0-1背包问题，<br>这里每新的一种都有取或不取，或句话说，也就是这些新的堆可以在取或不取中组成10以内的各个数，也就是说<br>如果10件商品最优为取7件，那么1+2+4或者4+3，虽然会有重复，但是也在计算内。<br>再言之，如果单纯将同种物品的每一件看成不同的，那么无奈枚举的情况太多，时间复杂度太高，这种二进制的优化能在很大程度上减少枚举的数量。<br><strong>参考</strong><br><a href="http://www.cnblogs.com/jbelial/articles/2116074.html" target="_blank" rel="noopener">背包九讲</a></p>
<h2 id="神奇的口袋"><a href="#神奇的口袋" class="headerlink" title="神奇的口袋"></a>神奇的口袋</h2><p><strong>描述</strong><br>有一个神奇的口袋，总的容积是40，用这个口袋可以变出一些物品，这些物品的总体积必须是40。John现在有n个想要得到的物品，每个物品的体积分别是a1，a2……an。John可以从这些物品中选择一些，如果选出的物体的总体积是40，那么利用这个神奇的口袋，John就可以得到这些物品。现在的问题是，John有多少种不同的选择物品的方式。<br><strong>输入</strong><br>输入的第一行是正整数n (1 &lt;= n &lt;= 20)，表示不同的物品的数目。接下来的n行，每行有一个1到40之间的正整数，分别给出a1，a2……an的值。<br><strong>输出</strong><br>输出不同的选择物品的方式的数目。<br><strong>样例输入</strong><br>3<br>20<br>20<br>20<br><strong>样例输出</strong><br>3<br><strong>程序</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：神奇的口袋.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">设w体积，k种物品，则：</span></span><br><span class="line"><span class="comment">边界条件：</span></span><br><span class="line"><span class="comment">if(w==0) return 1;</span></span><br><span class="line"><span class="comment">if(k&lt;=0) return 0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">总数=选第k种物品+不选第k中物品</span></span><br><span class="line"><span class="comment">Ways(w,k)=Ways(w,k-1)+Ways(w-a[k],k-1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">AC时间：50ms</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.08.31</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Ways</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (w == <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (k &lt;= <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> Ways(w, k - <span class="number">1</span>) + Ways(w - a[k], k - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Ways(<span class="number">40</span>, N);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：神奇的口袋_动规版.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">设w体积，k种物品，则：</span></span><br><span class="line"><span class="comment">边界条件：</span></span><br><span class="line"><span class="comment">if(w==0) return 1;</span></span><br><span class="line"><span class="comment">if(k&lt;=0) return 0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">总数=选第k种物品+不选第k中物品</span></span><br><span class="line"><span class="comment">Ways(w,k)=Ways(w,k-1)+Ways(w-a[k],k-1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">AC时间:0ms</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.08.31</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">21</span>];</span><br><span class="line"><span class="keyword">int</span> Ways[<span class="number">41</span>][<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">			Ways[<span class="number">0</span>][i] = <span class="number">1</span>; <span class="comment">//边界条件</span></span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//边界条件</span></span><br><span class="line">		Ways[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++)</span><br><span class="line">		{</span><br><span class="line">			Ways[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//动规</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">if</span> (i - a[j] &lt; <span class="number">0</span>)</span><br><span class="line">				{</span><br><span class="line">					Ways[i][j] = Ways[i][j - <span class="number">1</span>];</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				{</span><br><span class="line">					Ways[i][j] = Ways[i][j - <span class="number">1</span>] + Ways[i - a[j]][j - <span class="number">1</span>];</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; Ways[<span class="number">40</span>][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Charm-Bracelet"><a href="#Charm-Bracelet" class="headerlink" title="Charm Bracelet"></a>Charm Bracelet</h2><p><strong>描述</strong><br>Bessie has gone to the mall’s jewelry store and spies a charm bracelet. Of course, she’d like to fill it with the best charms possible from the N(1 ≤ N≤ 3,402) available charms. Each charm iin the supplied list has a weight Wi(1 ≤ Wi≤ 400), a ‘desirability’ factor Di(1 ≤ Di≤ 100), and can be used at most once. Bessie can only support a charm bracelet whose weight is no more than M(1 ≤ M≤ 12,880).</p>
<p>Given that weight limit as a constraint and a list of the charms with their weights and desirability rating, deduce the maximum possible sum of ratings.<br><strong>输入</strong><br>Line 1: Two space-separated integers: N and M<br>Lines 2..N+1: Line i+1 describes charm i with two space-separated integers: Wi and Di<br><strong>输出</strong><br>Line 1: A single integer that is the greatest sum of charm desirabilities that can be achieved given the weight constraints<br><strong>样例输入</strong><br>4 6<br>1 4<br>2 6<br>3 12<br>2 7<br><strong>样例输出</strong><br>23<br><strong>程序</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：0-1背包问题.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">与上一题不同，此题背包未必装满。</span></span><br><span class="line"><span class="comment">用F[i][j]表示取前i种物品，使它们总体积不超过j的最优取法取得的价值总和。</span></span><br><span class="line"><span class="comment">要求F[N][M]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">边界：</span></span><br><span class="line"><span class="comment">if(w[1]&lt;=j)</span></span><br><span class="line"><span class="comment">  F[1][j]=d[1];</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">  F[1][j]=0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">递推：</span></span><br><span class="line"><span class="comment">f[i][j]=max(F[i-1][j],f[i-1][j-w[i]]+d[i])</span></span><br><span class="line"><span class="comment">取或不取第i种物品，两者选优</span></span><br><span class="line"><span class="comment">(j-w[i]&gt;=0才有第二项)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">本题如用记忆性递归，需要一个很大的二维数组，会超内存。注意到这个二维数组的下一行的值，</span></span><br><span class="line"><span class="comment">只用到了上一行的正上方及左边的值，因此可用滚动数组的思想，只要一行即可。即可以用一位数组，</span></span><br><span class="line"><span class="comment">用“人人为我”递推型动规实现。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">空间优化分析：</span></span><br><span class="line"><span class="comment">求第i行j列的元素，按照状态转移方程可知，必须用到其上一行正上方的元素和该元素左侧的一个元素</span></span><br><span class="line"><span class="comment">①行分析：</span></span><br><span class="line"><span class="comment">那么按照行从小到大的顺序进行，当前行各元素计算完成则其上一行元素失去作用，不再参与计算，</span></span><br><span class="line"><span class="comment">故可以将下一行的各元素的计算结果保存到上一行，已达到空间优化的目的。</span></span><br><span class="line"><span class="comment">②列分析：</span></span><br><span class="line"><span class="comment">由于当前元素的计算需要其正上方及其左边的某个元素，那么，</span></span><br><span class="line"><span class="comment">如果从左到右进行枚举，当前元素的计算结果保存到其正上方元素，则进行右边的其他元素时</span></span><br><span class="line"><span class="comment">可能会用到这个已经被保存计算结果的元素，所以不可以。</span></span><br><span class="line"><span class="comment">如果从右到左进行枚举，当前元素的计算结果保存到其正上方元素，对当行左边其他元素的计算不产生任何影响</span></span><br><span class="line"><span class="comment">故达到了空间优化的目的。</span></span><br><span class="line"><span class="comment">综上：采用从上到下，从右到左的顺序进行枚举。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.08.31</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Goods</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> Value;</span><br><span class="line">	<span class="keyword">int</span> Volume;</span><br><span class="line">}goods[<span class="number">3501</span>];</span><br><span class="line"><span class="keyword">int</span> Gross[<span class="number">13001</span>];</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; goods[i].Volume &gt;&gt; goods[i].Value;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//边界条件</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (goods[<span class="number">1</span>].Volume &lt;= j)</span><br><span class="line">			{</span><br><span class="line">				Gross[j] = goods[<span class="number">1</span>].Value;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			{</span><br><span class="line">				Gross[j] = <span class="number">0</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		Gross[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//动规 f[i][j]=max(F[i-1][j],f[i-1][j-w[i]]+d[i])</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = M; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">if</span> (j &gt;= goods[i].Volume)</span><br><span class="line">				{</span><br><span class="line">					Gross[j] = max(Gross[j], Gross[j-goods[i].Volume] + goods[i].Value);</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; Gross[M] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">与上者比较：</span></span><br><span class="line"><span class="comment">可发现边界初始化和选择恰到好处！</span></span><br><span class="line"><span class="comment">第一：</span></span><br><span class="line"><span class="comment">边界条件在i=1时，装得下则去value，装不下取0</span></span><br><span class="line"><span class="comment">同DP刚开始</span></span><br><span class="line"><span class="comment">第二：</span></span><br><span class="line"><span class="comment">选择条件j&gt;=w[i]刚好在循环控制内，所以不需要选择条件，换句话说，j&lt;w[i]，取dp[j]自身，不需要</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3500</span>;</span><br><span class="line"><span class="keyword">int</span> w[maxn], d[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">12881</span>];		<span class="comment">//体积不超过j</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; d[i];</span><br><span class="line">	fill(dp, dp+<span class="number">12881</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= w[i]; --j)</span><br><span class="line">			dp[j] = max(dp[j], dp[j - w[i]] + d[i]);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; dp[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="HDOJ-1114-Piggy-Bank"><a href="#HDOJ-1114-Piggy-Bank" class="headerlink" title="HDOJ 1114 Piggy-Bank"></a>HDOJ 1114 Piggy-Bank</h2><p><strong>Problem Description</strong><br>Before ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig. After a sufficiently long time, there should be enough cash in the piggy-bank to pay everything that needs to be paid.<br>But there is a big problem with piggy-banks. It is not possible to determine how much money is inside. So we might break the pig into pieces only to find out that there is not enough money. Clearly, we want to avoid this unpleasant situation. The only possibility is to weigh the piggy-bank and try to guess how many coins are inside. Assume that we are able to determine the weight of the pig exactly and that we know the weights of all coins of a given currency. Then there is some minimum amount of money in the piggy-bank that we can guarantee. Your task is to find out this worst case and determine the minimum amount of cash inside the piggy-bank. We need your help. No more prematurely broken pigs!<br><strong>Input</strong><br>The input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers E and F. They indicate the weight of an empty pig and of the pig filled with coins. Both weights are given in grams. No pig will weigh more than 10 kg, that means 1 &lt;= E &lt;= F &lt;= 10000. On the second line of each test case, there is an integer number N (1 &lt;= N &lt;= 500) that gives the number of various coins used in the given currency. Following this are exactly N lines, each specifying one coin type. These lines contain two integers each, Pand W (1 &lt;= P &lt;= 50000, 1 &lt;= W &lt;=10000). P is the value of the coin in monetary units, W is it’s weight in grams.<br><strong>Output</strong><br>Print exactly one line of output for each test case. The line must contain the sentence “The minimum amount of money in the piggy-bank is X.” where X is the minimum amount of money that can be achieved using coins with the given total weight. If the weight cannot be reached exactly, print a line “This is impossible.”.<br><strong>Sample Input</strong><br>3<br>10 110<br>2<br>1 1<br>30 50<br>10 110<br>2<br>1 1<br>50 30<br>1 6<br>2<br>10 3<br>20 4<br><strong>Sample Output</strong><br>The minimum amount of money in the piggy-bank is 60.<br>The minimum amount of money in the piggy-bank is 100.<br>This is impossible.<br><strong>Procedure</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：Piggy-Bank.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">完全背包问题</span></span><br><span class="line"><span class="comment">题目意思为给出空包重量，装了coin后的重量，给出若干种包含的货币，</span></span><br><span class="line"><span class="comment">给出每种货币的价值和重量，求最小价值是多少。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">for i=1..N</span></span><br><span class="line"><span class="comment">for j=c..V</span></span><br><span class="line"><span class="comment">d[j]=max(d[j],d[j-w[i]]+v[i])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">边界条件：</span></span><br><span class="line"><span class="comment">d[0]=0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.09.17</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> val[MAXN],wei[MAXN];</span><br><span class="line"><span class="keyword">int</span> d[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> t, e, f, n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	{</span><br><span class="line">		fill(d, d + MAXN, inf);</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; e &gt;&gt; f;</span><br><span class="line">		<span class="keyword">int</span> left = f - e;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; val[i] &gt;&gt; wei[i];</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//边界</span></span><br><span class="line">		d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//DP</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = wei[i]; j &lt;= left; j++)</span><br><span class="line">			{</span><br><span class="line">				d[j] = min(d[j], d[j - wei[i]] + val[i]);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (d[left] == inf)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"This is impossible."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"The minimum amount of money in the piggy-bank is "</span> &lt;&lt; d[left] &lt;&lt; <span class="string">"."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="HDOJ-1203-I-NEED-A-OFFER"><a href="#HDOJ-1203-I-NEED-A-OFFER" class="headerlink" title="HDOJ 1203 I NEED A OFFER!"></a>HDOJ 1203 I NEED A OFFER!</h2><p><strong>Problem Description</strong><br>Speakless很早就想出国，现在他已经考完了所有需要的考试，准备了所有要准备的材料，于是，便需要去申请学校了。要申请国外的任何大学，你都要交纳一定的申请费用，这可是很惊人的。Speakless没有多少钱，总共只攒了n万美元。他将在m个学校中选择若干的（当然要在他的经济承受范围内）。每个学校都有不同的申请费用a（万美元），并且Speakless估计了他得到这个学校offer的可能性b。不同学校之间是否得到offer不会互相影响。“I NEED A OFFER”，他大叫一声。帮帮这个可怜的人吧，帮助他计算一下，他可以收到至少一份offer的最大概率。（如果Speakless选择了多个学校，得到任意一个学校的offer都可以）。<br><strong>Input</strong><br>输入有若干组数据，每组数据的第一行有两个正整数n,m(0&lt;=n&lt;=10000,0&lt;=m&lt;=10000)<br>后面的m行，每行都有两个数据ai(整型),bi(实型)分别表示第i个学校的申请费用和可能拿到offer的概率。<br>输入的最后有两个0。<br><strong>Output</strong><br>每组数据都对应一个输出，表示Speakless可能得到至少一份offer的最大概率。用百分数表示，精确到小数点后一位。<br><strong>Sample Input</strong><br>10 3<br>4 0.1<br>4 0.2<br>5 0.3<br>0 0<br><strong>Sample Output</strong><br>44.0%<br><strong>Hint</strong><br>You should use printf(“%%”) to print a ‘%’.<br><strong>Procedure</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：I_NEED_OFFER.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">至少得到一份的最大概率=!(一份都得不到的最小概率)</span></span><br><span class="line"><span class="comment">一个学校不能申请两次，0-1背包问题</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">套路模板：</span></span><br><span class="line"><span class="comment">for i=1..N</span></span><br><span class="line"><span class="comment">for v=V..0</span></span><br><span class="line"><span class="comment">d[j]=min(d[j],d[j-w[i]]*(1-v[i]))</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">边界条件：</span></span><br><span class="line"><span class="comment">不申请等于100%得不到</span></span><br><span class="line"><span class="comment">所以初始化</span></span><br><span class="line"><span class="comment">d[j]=1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意观察与神奇的口袋代码的区别</span></span><br><span class="line"><span class="comment">精简如此程序：</span></span><br><span class="line"><span class="comment">一些边界条件可以舍去，直接DP代码段进行，</span></span><br><span class="line"><span class="comment">将j&lt;w[i]的部分直接在初始化的时候进行，边界的另一部分则在DP中进行</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.09.18</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> val[MAXN];</span><br><span class="line"><span class="keyword">double</span> pro[MAXN];</span><br><span class="line"><span class="keyword">double</span> d[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; (m != <span class="number">0</span> || n != <span class="number">0</span>))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; val[i] &gt;&gt; pro[i];</span><br><span class="line">		}</span><br><span class="line">		fill(d, d + MAXN, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= val[i]; j--)</span><br><span class="line">			{</span><br><span class="line">				d[j] = min(d[j], d[j - val[i]] * (<span class="number">1</span> - pro[i]));</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(<span class="number">1</span>) &lt;&lt; (<span class="number">1</span> - d[n]) * <span class="number">100</span> &lt;&lt; <span class="string">"%"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="HDOJ-1171-Big-Event-in-HDU"><a href="#HDOJ-1171-Big-Event-in-HDU" class="headerlink" title="HDOJ 1171 Big Event in HDU"></a>HDOJ 1171 Big Event in HDU</h2><p><strong>Problem Description</strong><br>Nowadays, we all know that Computer College is the biggest department in HDU. But, maybe you don’t know that Computer College had ever been split into Computer College and Software College in 2002.<br>The splitting is absolutely a big event in HDU! At the same time, it is a trouble thing too. All facilities must go halves. First, all facilities are assessed, and two facilities are thought to be same if they have the same value. It is assumed that there is N (0&lt;N&lt;1000) kinds of facilities (different value, different kinds).<br><strong>Input</strong><br>Input contains multiple test cases. Each test case starts with a number N (0 &lt; N &lt;= 50 – the total number of different facilities). The next N lines contain an integer V (0&lt;V&lt;=50 –value of facility) and an integer M (0&lt;M&lt;=100 –corresponding number of the facilities) each. You can assume that all V are different.<br>A test case starting with a negative integer terminates input and this test case is not to be processed.<br><strong>Output</strong><br>For each case, print one line containing two integers A and B which denote the value of Computer College and Software College will get respectively. A and B should be as equal as possible. At the same time, you should guarantee that A is not less than B.<br><strong>Sample Input</strong><br>2<br>10 1<br>20 1<br>3<br>10 1<br>20 2<br>30 1<br>-1<br><strong>Sample Output</strong><br>20 10<br>40 40<br><strong>Procedure</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：Big_Event_in_HDU.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">尽可能将总价值一定的设备均分给两个学院，A_Value&gt;=B_Value</span></span><br><span class="line"><span class="comment">价值不同，设备种类不同</span></span><br><span class="line"><span class="comment">那么典型多重背包问题，可以转换成典型0-1背包问题，即每种背包数量一定，可以把每种的每一个背包看成不同的背包转成0-1背包问题</span></span><br><span class="line"><span class="comment">背包容量总价值total_value/2</span></span><br><span class="line"><span class="comment">尽可能装下最大价值的东西</span></span><br><span class="line"><span class="comment">取或不取第i件设备，价值容量为j</span></span><br><span class="line"><span class="comment">d[i][j]=max(d[i-1][j],d[i-1][j-v[i]]+v[i])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.09.18</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> val[<span class="number">5010</span>];</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">250010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n&amp;&amp;n &gt; <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">		<span class="built_in">memset</span>(val, <span class="number">0</span>, <span class="keyword">sizeof</span>(val));</span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">0</span>, total_value = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (n--)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">int</span> temp, m;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; temp &gt;&gt; m;</span><br><span class="line">			<span class="keyword">while</span> (m--)</span><br><span class="line">			{</span><br><span class="line">				val[num++] = temp;</span><br><span class="line">				total_value += temp;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//DP</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = total_value / <span class="number">2</span>; j &gt;= val[i]; j--)</span><br><span class="line">			{</span><br><span class="line">				d[j] = max(d[j], d[j - val[i]] + val[i]);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; total_value - d[total_value / <span class="number">2</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; d[total_value / <span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="HDOJ-1059-Dividing"><a href="#HDOJ-1059-Dividing" class="headerlink" title="HDOJ 1059 Dividing"></a>HDOJ 1059 Dividing</h2><p><strong>Problem Description</strong><br>Marsha and Bill own a collection of marbles. They want to split the collection among themselves so that both receive an equal share of the marbles. This would be easy if all the marbles had the same value, because then they could just split the collection in half. But unfortunately, some of the marbles are larger, or more beautiful than others. So, Marsha and Bill start by assigning a value, a natural number between one and six, to each marble. Now they want to divide the marbles so that each of them gets the same total value.<br>Unfortunately, they realize that it might be impossible to divide the marbles in this way (even if the total value of all marbles is even). For example, if there are one marble of value 1, one of value 3 and two of value 4, then they cannot be split into sets of equal value. So, they ask you to write a program that checks whether there is a fair partition of the marbles.<br><strong>Input</strong><br>Each line in the input describes one collection of marbles to be divided. The lines consist of six non-negative integers n1, n2, …, n6, where ni is the number of marbles of value i. So, the example from above would be described by the input-line 1 0 1 2 0 0. The maximum total number of marbles will be 20000.<br>The last line of the input file will be 0 0 0 0 0 0; do not process this line.<br><strong>Output</strong><br>For each colletcion, output Collection #k:, where k is the number of the test case, and then either Can be divided. or Can’t be divided..<br>Output a blank line after each test case.<br><strong>Sample Input</strong><br>1 0 1 2 0 0<br>1 0 0 0 1 1<br>0 0 0 0 0 0<br><strong>Sample Output</strong><br>Collection #1:<br>Can’t be divided.</p>
<p>Collection #2:<br>Can be divided.<br><strong>Procedure</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：Dviding.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">转成0-1背包问题:</span></span><br><span class="line"><span class="comment">每种价值有多件，那么全部转换成只有六种，</span></span><br><span class="line"><span class="comment">为了均分，那么每种价值最多取一半！！！也就是说每种价值可以取或不取一半及以下</span></span><br><span class="line"><span class="comment">d[j]=d[j]||d[j-v[i]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">参见多重背包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.09.18</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> d[<span class="number">60010</span>];</span><br><span class="line"><span class="keyword">int</span> total_value;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> num[<span class="number">7</span>];</span><br><span class="line">	<span class="keyword">int</span> Case = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; num[<span class="number">1</span>] &gt;&gt; num[<span class="number">2</span>] &gt;&gt; num[<span class="number">3</span>] &gt;&gt; num[<span class="number">4</span>] &gt;&gt; num[<span class="number">5</span>] &gt;&gt; num[<span class="number">6</span>])</span><br><span class="line">	{</span><br><span class="line">		Case++;</span><br><span class="line">		<span class="keyword">if</span> (!num[<span class="number">1</span>] &amp;&amp; !num[<span class="number">2</span>] &amp;&amp; !num[<span class="number">3</span>] &amp;&amp; !num[<span class="number">4</span>] &amp;&amp; !num[<span class="number">5</span>] &amp;&amp; !num[<span class="number">6</span>])</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">		d[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">		total_value = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++)</span><br><span class="line">		{</span><br><span class="line">			total_value += i*num[i];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (total_value &amp; <span class="number">1</span>)<span class="comment">//奇数</span></span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"Collection #"</span> &lt;&lt; Case &lt;&lt; <span class="string">":\nCan't be divided.\n\n"</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (k &lt; num[i]) <span class="comment">//二进制优化</span></span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = total_value &gt;&gt; <span class="number">1</span>; j &gt;= k*i; j--)</span><br><span class="line">				{</span><br><span class="line">					d[j] = d[j] || d[j - k*i];</span><br><span class="line">				}</span><br><span class="line">				num[i] -= k;</span><br><span class="line">				k *= <span class="number">2</span>;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = total_value &gt;&gt; <span class="number">1</span>; j &gt;= num[i] * i; j--)</span><br><span class="line">			{</span><br><span class="line">				d[j] = d[j] || d[j - num[i] * i];</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (d[total_value &gt;&gt; <span class="number">1</span>])</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"Collection #"</span> &lt;&lt; Case &lt;&lt; <span class="string">":\nCan be divided.\n\n"</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"Collection #"</span> &lt;&lt; Case &lt;&lt; <span class="string">":\nCan't be divided.\n\n"</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="第三章-子集生成算法"><a href="#第三章-子集生成算法" class="headerlink" title="第三章 子集生成算法"></a>第三章 子集生成算法</h1></blockquote>
<h2 id="增量构造法"><a href="#增量构造法" class="headerlink" title="增量构造法"></a>增量构造法</h2><p>每次只选择一个元素进入集合，同时规定集合A中所有元素的编号从小到大排列，不会出现重复输出。<br>程序的关键在于cur的处理上，很巧妙。<br>总体思路明了，程序设计上需要多加理解：<br>①每个元素遍历一次<br>②打印子集<br>③剩余元素遍历一次<br>④打印子集<br>⑤…<br>总的来说，就是取完当个元素（顺序取），剩余元素重复之前顺序取的步骤，直至所有遍历次数达到数组大小n<br>和取或不取当个元素相当，但是巧妙地控制了输出。（难想！我还是喜欢位向量的排列组合思维！<span class="github-emoji"><span>🌝</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f31d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>）<br>程序演示结果：<br>5</p>
<p>0<br>0 1<br>0 1 2<br>0 1 2 3<br>0 1 2 3 4<br>0 1 2 4<br>0 1 3<br>0 1 3 4<br>0 1 4<br>0 2<br>0 2 3<br>0 2 3 4<br>0 2 4<br>0 3<br>0 3 4<br>0 4<br>1<br>1 2<br>1 2 3<br>1 2 3 4<br>1 2 4<br>1 3<br>1 3 4<br>1 4<br>2<br>2 3<br>2 3 4<br>2 4<br>3<br>3 4<br>4</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_subset</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span>* a,<span class="keyword">int</span> cur)</span></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cur;i++) <span class="comment">//打印上一个子集</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minElem = cur?a[cur<span class="number">-1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找出上一个子集中最大的数将其+1</span></span><br><span class="line">    <span class="comment">// if(0 == cur)</span></span><br><span class="line">        <span class="comment">//minElem = 0;</span></span><br><span class="line">    <span class="comment">//else</span></span><br><span class="line">        <span class="comment">//minElem = a[cur - 1];</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=minElem;i&lt;n;i++) {</span><br><span class="line">        a[cur]=i; <span class="comment">//这个数成为下一个循环中最大的数将排在下一个子集的最后  （按字典顺序输出）</span></span><br><span class="line">        print_subset(n,a,cur+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;n,n){</span><br><span class="line">        print_subset(n,a,<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="位向量法"><a href="#位向量法" class="headerlink" title="位向量法"></a>位向量法</h2><p>每种元素都有取或不取两种情况，故递归，当所有元素都判断了一遍就输出。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_subset</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* B, <span class="keyword">int</span> cur)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span>(cur == n) {</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur; i++)</span><br><span class="line">			<span class="keyword">if</span>(B[i]) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i); <span class="comment">// 打印当前集合</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	B[cur] = <span class="number">1</span>; <span class="comment">// 选第cur个元素</span></span><br><span class="line">	print_subset(n, B, cur+<span class="number">1</span>);</span><br><span class="line">	B[cur] = <span class="number">0</span>; <span class="comment">// 不选第cur个元素</span></span><br><span class="line">	print_subset(n, B, cur+<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> B[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	print_subset(<span class="number">5</span>, B, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="二进制法"><a href="#二进制法" class="headerlink" title="二进制法"></a>二进制法</h2><p>1、A&amp;B、A|B和A^B分别对应集合的交、并和对称差<br>2、如果是n那就一般都是0~n-1的子集，而且对应的二进制位是从右往左<br>其中从右往左第i位(从0开始编号)表示元素i是否在集合中（1表示在，0表示不在）<br>s={0,1,…,n-1}中n个1，对应十进制2^n-1<br>那么全集为(1&lt;&lt;n)-1<br><img src="/assets/img/algorithm/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B3%95%E6%B1%82%E5%AD%90%E9%9B%86.png" alt="二进制求子集图示"></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_subset</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	{</span><br><span class="line">	 	<span class="keyword">if</span>(s&amp;(<span class="number">1</span>&lt;&lt;i))</span><br><span class="line">	 	{</span><br><span class="line">	 		<span class="built_in">cout</span>&lt;&lt;i;</span><br><span class="line">		}</span><br><span class="line">	}  </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)</span><br><span class="line">    {</span><br><span class="line">    	print_subset(n,i); <span class="comment">//枚举各子集所对应的编码0,1,2,...2^n-1,</span></span><br><span class="line">	  }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="第四章-双向广度优先搜索-DBFS"><a href="#第四章-双向广度优先搜索-DBFS" class="headerlink" title="第四章 双向广度优先搜索(DBFS)"></a>第四章 双向广度优先搜索(DBFS)</h1></blockquote>
<h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><h3 id="DBFS算法是对BFS算法的一种扩展"><a href="#DBFS算法是对BFS算法的一种扩展" class="headerlink" title="DBFS算法是对BFS算法的一种扩展"></a>DBFS算法是对BFS算法的一种扩展</h3><p>①BFS算法从起始节点以广度优先的顺序不断扩展，直到遇到目标节点。<br>②DBFS算法从两个方向以广度优先的顺序同时扩展，一个是从起始节点开始扩展，另一个从目标节点扩展，直到一个扩展队列中出现另外一个队列中已经扩展的节点，也就是相当于两个扩展方向出现了交点，那么可以认为我们找到了一条路径。</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>①DBFS算法相对于BFS算法来说，由于采用了双向扩展的方式，搜索树的宽度得到了明显的减少，所以在算法的时间复杂度和空间复杂度上都有较大的优势！<br>②假设一个节点能扩展出n个节点，单向搜索要m层能找到答案，那么扩展出来的节点数目就是:$\frac{\left(1-n^m\right)}{\left(1-n\right)}$<br>③双向广搜，同样是一共扩展m层，假定两边各扩展出m/2层，则总节点数目$2\cdot\frac{\left(1-n^{\frac{m}{2}}\right)}{\left(1-n\right)}$</p>
<h3 id="DBFS框架"><a href="#DBFS框架" class="headerlink" title="DBFS框架"></a>DBFS框架</h3><p><strong>1.双向广搜函数</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dbfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="number">1.</span>将起始节点放入队列q_0,将目标节点放入队列q_1;</span><br><span class="line">  <span class="number">2.</span>当两个队列都未空时，作如下循环：</span><br><span class="line">    <span class="number">1</span>)如果队列q_0里的节点比q_1中的少，则扩展队列q_0;</span><br><span class="line">    <span class="number">2</span>)否则扩展队列q_1;</span><br><span class="line">  <span class="number">3.</span>如果队列q_0未空，不断扩展q_0直到为空;</span><br><span class="line">  <span class="number">4.</span>如果队列q_1未空，不断扩展q_1直到为空;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>2.扩展函数</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(i)</span><span class="comment">//其中i为队列的编号，0或1</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  取队列q_i的头结点H;</span><br><span class="line">  对H的每一个相邻节点adj:</span><br><span class="line">    <span class="number">1.</span>如果adj已经在队列q_i之中出现过，则抛弃adj;</span><br><span class="line">    <span class="number">2.</span>如果adj在队列q_i中未出现过，则:</span><br><span class="line">      <span class="number">1</span>)将adj放入队列q_i;</span><br><span class="line">      <span class="number">2</span>)如果adj曾在队列q_1-i中出现过，则:输出找到的路径。</span><br><span class="line">  <span class="comment">//需要两个标志序列，分别记录节点是否出现在两个队列中</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Eight"><a href="#Eight" class="headerlink" title="Eight"></a>Eight</h2><p><strong>Problem Description</strong><br>The 15-puzzle has been around for over 100 years; even if you don’t know it by that name, you’ve seen it. It is constructed with 15 sliding tiles, each with a number from 1 to 15 on it, and all packed into a 4 by 4 frame with one tile missing. Let’s call the missing tile ‘x’; the object of the puzzle is to arrange the tiles so that they are ordered as:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 1  2  3  4</span><br><span class="line"> 5  6  7  8</span><br><span class="line"> 9 10 11 12</span><br><span class="line">13 14 15  x</span><br></pre></td></tr></tbody></table></figure>
<p>where the only legal operation is to exchange ‘x’ with one of the tiles with which it shares an edge. As an example, the following sequence of moves solves a slightly scrambled puzzle:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 1  2  3  4     1  2  3  4     1  2  3  4     1  2  3  4</span><br><span class="line"> 5  6  7  8     5  6  7  8     5  6  7  8     5  6  7  8</span><br><span class="line"> 9  x 10 12     9 10  x 12     9 10 11 12     9 10 11 12</span><br><span class="line">13 14 11 15    13 14 11 15    13 14  x 15    13 14 15  x</span><br><span class="line">            r-&gt;            d-&gt;            r-&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>The letters in the previous row indicate which neighbor of the ‘x’ tile is swapped with the ‘x’ tile at each step; legal values are ‘r’,’l’,’u’ and ‘d’, for right, left, up, and down, respectively.</p>
<p>Not all puzzles can be solved; in 1870, a man named Sam Loyd was famous for distributing an unsolvable version of the puzzle, and<br>frustrating many people. In fact, all you have to do to make a regular puzzle into an unsolvable one is to swap two tiles (not counting the missing ‘x’ tile, of course).</p>
<p>In this problem, you will write a program for solving the less well-known 8-puzzle, composed of tiles on a three by three<br>arrangement.<br><strong>Input</strong><br>You will receive, several descriptions of configuration of the 8 puzzle. One description is just a list of the tiles in their initial positions, with the rows listed from top to bottom, and the tiles listed from left to right within a row, where the tiles are represented by numbers 1 to 8, plus ‘x’. For example, this puzzle<br>1 2 3<br>x 4 6<br>7 5 8<br>is described by this list:<br>1 2 3 x 4 6 7 5 8<br><strong>Output</strong><br>You will print to standard output either the word “unsolvable”, if the puzzle has no solution, or a string consisting entirely of the letters ‘r’, ‘l’, ‘u’ and ‘d’ that describes a series of moves that produce a solution. The string should include no spaces and start at the beginning of the line. Do not print a blank line between cases.<br><strong>Sample Input</strong><br>2  3  4  1  5  x  7  6  8<br><strong>Sample Output</strong><br>ullddrurdllurdruldr<br><strong>Procedure</strong></p>
<hr>
<p>最近懒，不想看新算法，所以来仔细研究研究这道题….偶都尅<del>~</del><br><strong>方案一</strong><br>每个状态用一个字符串存储，要9个字节，太浪费！</p>
<p><strong>方案二</strong><br>①每个状态对应于一个9位数，则该9位数最大为876543210，小于$2^{31}$，则int就能表示一个状态。<br>②判重需要一个标志位序列，每个状态对应于标志位序列中的1位，标志位为0表示该状态尚未扩展，为1则说明已经扩展过了<br>③标志位序列可以用字符数组a存放。a的每个元素存放8个状态的标志位。最多需要876543210位，因此a数组需要876543210/8+1个元素，即109,567,902字节<br>④如果某个状态对应于x，则其标志位就是a[x/8]的第x%8位<br>⑤空间要求还是太大！</p>
<p><strong>方案三</strong><br>①状态数目义工只有9！个，即$362880_{\left(10\right)}$个，怎么会需要$876543210_{\left(9\right)}$即$381367044_{\left(10\right)}$个标志位呢？<br>②如果某个状态对应于数x，则其标志位就是a[x/8]的第x%8位<br>③因为有浪费！例如，$666666666_{\left(9\right)}$根本不对应于任何状态！</p>
<p><strong>方案四</strong><br>①把每个状态都看做0-8的一个排列，以此排列在全部排列中的位置作为其序号。状态用其排列序号来表示<br>②012345678是第0个排列，876543210是第9!-1个<br>③状态总数即排列总数：9!=362880比特即可。<br>④如果某个状态的序号是x，则其标志位就是a[x/8]的第x%8位<br>⑤在进行状态间转移，即一个状态通过某个移动变化到另一个状态时，需要先把int形式的状态（排列序号），转变成字符串形式的状态，然后在字符串形式的状态上进行移动，得到字符串形式的新状态，再把新状态转换成int形式（排列序号）<br>⑥需要编写给定排列（字符串型是）求序号的函数<br>⑦需要编写给定序号，求该序号的排列（字符串型是）的函数</p>
<p><strong>给定排列求序号</strong><br>整数1,2,…,k的一个排列<br>$a_1,a_2,a_3,…,a_k$<br>求其序号<br>基本思想：算出有多少个排列比给定排列小。<br>先算1到$a_1-1$放在第1位，会有多少个排列：$\left(a_1-1\right)\cdot\left(\left(k-1\right)!\right)$<br>再算$a_1$不变，1到$a_2-1$放在第2位（左边出现过的不能再用），会有多少个排列：$\left(a_2-1\right)\cdot\left(\left(k-2\right)!\right)$<br>再算$a_1,a_2$不变，1到$a_3-1$放在第3位，会有多少个排列<br>…全加起来。时间复杂度:$O\left(n^2\right)$</p>
<p><strong>给定序号n求排列</strong><br>1234的排列的第9号<br>第一位假定是1，共有3!种，没有到达9，所以第一位至少是2<br>第一位是2，一共能数到3!+3!&gt;=9，所以第一位是2<br>第二位是1,21??，一共能数到3!+2!=8&lt;9，所以第二位至少是3<br>第二位是3,23??，一共能数到3!+2!+2!&gt;=9，因此第二位是3<br>第三位是1，一共能数到3!+2!+1=9，所以第三位是1，第四位是4<br>答案2314<br>时间复杂度：$O\left(n^2\right)$</p>
<p><strong>八数码问题有解性的判定</strong><br>①八数码问题的一个状态实际上是0<del>8的一个排列，对于任意给定的初始状态和目标，不一定有解，即从初始状态不一定能到达目标状态。因为排列有奇排列和偶排列两类，从奇排列不能转化成偶排列或相反。<br>②如果一个数字0</del>8的随机排列，用F(X)(X!=0)表示数字X前面比它小的数（不包括0）的个数，全部数字的F(X)之和为Y=∑(F(X))，如果Y为奇数则称该排列是奇排列，如果Y为偶数则称该排列是偶排列。<br>871526340排列的Y=0+0+0+1+1+3+2+3=10，10是偶数，所以是偶排列<br>871625340排列的Y=0+0+0+1+1+2+2+3=9，9是奇数，所以是奇排列<br>因此，可以在运行程序前检查初始状态和目标状态的奇偶性是否相同，相同则问题可解，应当能搜索到路径，否则无解。</p>
<p>证明：移动0的位置，不改变排列的奇偶性<br>$a_1,a_2,a_3,a_4,a_5,a_6,a_7,a_8,a_9$<br>0向上移动<br>$a_1,0,a_3,a_4,a_2,a_5,a_6,a_7,a_8,a_9$</p>
<p>0的位置无非上下左右，<br><strong>①左右移动时，由于0不参与计算，所以奇偶性不变</strong><br><strong>②上下移动时，由于变化仅2位，那么假设连续4位为ABC0，变化后为0BCA</strong><br>这4位之后的序列F(X)不变，那么不妨设这4位序列后的F(X)之和为$Y_{Later}$<br>这4位之前的序列F(X)不变，那么不妨设这4位之前的序列的F(X)之和为$Y_{Before}$<br>仅在这4位的序列F(X)改变，那么不妨设这4位的序列的F(X)之和为$Y_{Mid}$<br>所以$Y=Y_{Before}+Y_{Mid}+Y_{Later}$<br>那么可知<br>$F(A)=F_0(A)+(A&gt;B)+(A&gt;C)$<br>$F(B)=F_0(B)-(B&gt;A)$<br>$F(C)=F_0(C)-(C&gt;A)$<br>$(F_0(*)表示变化前，其他同理)$<br>$Y_{Mid}$<br>$=F(A)+F(B)+F(A)$<br>$=F_0(A)+(A&gt;B)+(A&gt;C)$<br>$+F_0(B)-(B&gt;A)$<br>$+F_0(C)-(C&gt;A)$<br>$=F_0(A)+F_0(B)+F_0(C)$<br>$+(A&gt;B)-(B&gt;A)$<br>$+(A&gt;C)-(C&gt;A)$<br>$=F_0(A)+F_0(B)+F_0(C)$或$=F_0(A)+F_0(B)+F_0(C)±2$<br>$=Y_{Mid0}$或$=Y_{Mid0}±2$<br>$∴Y=Y_0或Y=Y_0±2$<br>$∴排列的奇偶性不变！$<br>证毕！</p>
<hr>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//八数码问题 单向广搜 用set判重</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> goalStatus = <span class="number">123456780</span>; <span class="comment">//目标状态</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXS = <span class="number">400000</span>;</span><br><span class="line"><span class="keyword">char</span> result[MAXS]; <span class="comment">//要输出的移动方案</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> status;<span class="comment">//状态</span></span><br><span class="line">	<span class="keyword">int</span> father;<span class="comment">//父节点指针，即myQuere的下标</span></span><br><span class="line">	<span class="keyword">char</span> move;<span class="comment">//父节点到本节点的移动方式 u d r l</span></span><br><span class="line">	Node(<span class="keyword">int</span> s, <span class="keyword">int</span> f, <span class="keyword">char</span> m) :status(s), father(f), move(m) {}</span><br><span class="line">	Node() {}</span><br><span class="line">};</span><br><span class="line">Node myQueue[MAXS];<span class="comment">//状态队列，状态总数362880</span></span><br><span class="line"><span class="keyword">int</span> qHead = <span class="number">0</span>;<span class="comment">//队头指针</span></span><br><span class="line"><span class="keyword">int</span> qTail = <span class="number">1</span>;<span class="comment">//队尾指针</span></span><br><span class="line"><span class="keyword">char</span> moves[] = <span class="string">"udrl"</span>;<span class="comment">//四种移动</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NewStatus</span><span class="params">(<span class="keyword">int</span> status, <span class="keyword">char</span> move)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//求从status经过move移动后得到的新状态，若移动不可行则返回-1</span></span><br><span class="line">	<span class="keyword">char</span> temp[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> zeroPos;<span class="comment">//字符'0'的位置</span></span><br><span class="line">	<span class="built_in">sprintf</span>(temp, <span class="string">"%09d"</span>, status);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (temp[i] == <span class="string">'0'</span>)</span><br><span class="line">		{</span><br><span class="line">			zeroPos = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">switch</span> (move)</span><br><span class="line">	{</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">		<span class="keyword">if</span> (zeroPos - <span class="number">3</span> &lt; <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//空格在第一行</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			temp[zeroPos] = temp[zeroPos - <span class="number">3</span>];</span><br><span class="line">			temp[zeroPos - <span class="number">3</span>] = <span class="string">'0'</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">		<span class="keyword">if</span> (zeroPos + <span class="number">3</span> &gt; <span class="number">8</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//空格在第三行</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			temp[zeroPos] = temp[zeroPos + <span class="number">3</span>];</span><br><span class="line">			temp[zeroPos + <span class="number">3</span>] = <span class="string">'0'</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'l'</span>:</span><br><span class="line">		<span class="keyword">if</span> (zeroPos % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//空格在第一列</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			temp[zeroPos] = temp[zeroPos - <span class="number">1</span>];</span><br><span class="line">			temp[zeroPos - <span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'r'</span>:</span><br><span class="line">		<span class="keyword">if</span> (zeroPos % <span class="number">3</span> == <span class="number">2</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//空格在第三列</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			temp[zeroPos] = temp[zeroPos + <span class="number">1</span>];</span><br><span class="line">			temp[zeroPos + <span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> atoi(temp);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bfs</span><span class="params">(<span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//寻找从初始状态status到目标的路径，找不到则返回false</span></span><br><span class="line">	<span class="keyword">int</span> newStatus;</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;expanded;</span><br><span class="line">	myQueue[qHead] = Node(status, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">	expanded.insert(status);</span><br><span class="line">	<span class="keyword">while</span> (qHead != qTail)</span><br><span class="line">	{</span><br><span class="line">		status = myQueue[qHead].status;</span><br><span class="line">		<span class="keyword">if</span> (status == goalStatus)<span class="comment">//找到目标状态</span></span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)<span class="comment">//尝试4种移动</span></span><br><span class="line">		{</span><br><span class="line">			newStatus = NewStatus(status, moves[i]);</span><br><span class="line">			<span class="keyword">if</span> (newStatus == <span class="number">-1</span>)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">continue</span>;<span class="comment">//不可移动，试下一种</span></span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (expanded.find(newStatus) != expanded.end())</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">continue</span>;<span class="comment">//已扩展过，试下一种</span></span><br><span class="line">			}</span><br><span class="line">			expanded.insert(newStatus);</span><br><span class="line">			myQueue[qTail++] = Node(newStatus, qHead, moves[i]);<span class="comment">//新节点入队列</span></span><br><span class="line">		}</span><br><span class="line">		qHead++;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">char</span> line1[<span class="number">50</span>];</span><br><span class="line">	<span class="keyword">char</span> line2[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span>.getline(line1, <span class="number">48</span>))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">int</span> i, j;</span><br><span class="line">		<span class="comment">//将输入的原始字符串变为数字字符串</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; line1[i]; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (line1[i] != <span class="string">' '</span>)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">if</span> (line1[i] == <span class="string">'x'</span>)</span><br><span class="line">				{</span><br><span class="line">					line2[j++] = <span class="string">'0'</span>;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				{</span><br><span class="line">					line2[j++] = line1[i];</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		line2[j] = <span class="number">0</span>;<span class="comment">//字符串形式的初始状态</span></span><br><span class="line">		<span class="keyword">if</span> (Bfs(atoi(line2)))</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">int</span> moves = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> pos = qHead;</span><br><span class="line">			<span class="keyword">do</span> {<span class="comment">//通过father找到成功的状态序列，输出相应步骤</span></span><br><span class="line">				result[moves++] = myQueue[pos].move;</span><br><span class="line">				pos = myQueue[pos].father;</span><br><span class="line">			} <span class="keyword">while</span> (pos);<span class="comment">//pos=0说明已经回退到初始状态了</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = moves - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">			{</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; result[i];</span><br><span class="line">			}</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"unsolvable"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//八数码 双向广搜</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> goalStatus; <span class="comment">//目标状态</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXS = <span class="number">400000</span>;</span><br><span class="line"><span class="keyword">char</span> result[MAXS]; <span class="comment">//要输出的移动方案</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> status; <span class="comment">//状态</span></span><br><span class="line">	<span class="keyword">int</span> father; <span class="comment">//父节点指针，即myQueue的下标</span></span><br><span class="line">	<span class="keyword">char</span> move; <span class="comment">//父节点到本节点的移动方式 u/d/r/l</span></span><br><span class="line">	Node(<span class="keyword">int</span> s, <span class="keyword">int</span> f, <span class="keyword">char</span> m) :status(s), father(f), move(m) { }</span><br><span class="line">	Node() { }</span><br><span class="line">};</span><br><span class="line">Node myQueue[<span class="number">2</span>][MAXS]; <span class="comment">//两个方向的状态队列，状态总数362880</span></span><br><span class="line"><span class="keyword">int</span> matchingStatus; <span class="comment">//双向碰到的那个状态</span></span><br><span class="line"><span class="keyword">int</span> matchingQ; <span class="comment">// 队列matchingQ的队头元素是双向碰到的那个状态</span></span><br><span class="line"><span class="keyword">int</span> qHead[<span class="number">2</span>]; <span class="comment">//队头指针</span></span><br><span class="line"><span class="keyword">int</span> qTail[<span class="number">2</span>]; <span class="comment">//队尾指针</span></span><br><span class="line"><span class="keyword">char</span> sz4Moves[] = <span class="string">"udrl"</span>; <span class="comment">//四种移动</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IntStatusToStrStatus</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> * strStatus)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">sprintf</span>(strStatus, <span class="string">"%09d"</span>, n); <span class="comment">//需要保留前导0</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NewStatus</span><span class="params">(<span class="keyword">int</span> status, <span class="keyword">char</span> cMove)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//求从status经过 cMove 移动后得到的新状态。若移动不可行则返回-1</span></span><br><span class="line">	<span class="keyword">char</span> szTmp[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> zeroPos; <span class="comment">//字符'0'的位置</span></span><br><span class="line">	IntStatusToStrStatus(status, szTmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">		<span class="keyword">if</span> (szTmp[i] == <span class="string">'0'</span>)</span><br><span class="line">		{</span><br><span class="line">			zeroPos = i; <span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	<span class="comment">//返回空格的位置</span></span><br><span class="line">	<span class="keyword">switch</span> (cMove)</span><br><span class="line">	{</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">		<span class="keyword">if</span> (zeroPos - <span class="number">3</span> &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//空格在第一行</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			szTmp[zeroPos] = szTmp[zeroPos - <span class="number">3</span>];</span><br><span class="line">			szTmp[zeroPos - <span class="number">3</span>] = <span class="string">'0'</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">		<span class="keyword">if</span> (zeroPos + <span class="number">3</span> &gt; <span class="number">8</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//空格在第三行</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			szTmp[zeroPos] = szTmp[zeroPos + <span class="number">3</span>];</span><br><span class="line">			szTmp[zeroPos + <span class="number">3</span>] = <span class="string">'0'</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">break</span>; <span class="keyword">case</span> <span class="string">'l'</span>:<span class="keyword">if</span> (zeroPos % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//空格在第一列</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			szTmp[zeroPos] = szTmp[zeroPos - <span class="number">1</span>];</span><br><span class="line">			szTmp[zeroPos - <span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'r'</span>:</span><br><span class="line">			<span class="keyword">if</span> (zeroPos % <span class="number">3</span> == <span class="number">2</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//空格在第三列</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			{</span><br><span class="line">				szTmp[zeroPos] = szTmp[zeroPos + <span class="number">1</span>];</span><br><span class="line">				szTmp[zeroPos + <span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> atoi(szTmp);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">ReverseMove</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">switch</span> (c)</span><br><span class="line">	{</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'d'</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'l'</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'r'</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'r'</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'l'</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'u'</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DBfs</span><span class="params">(<span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//寻找从初始状态status到目标的路径，找不到则返回false</span></span><br><span class="line">	<span class="keyword">int</span> newStatus;</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; expanded[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">	{</span><br><span class="line">		qHead[i] = <span class="number">0</span>;</span><br><span class="line">		qTail[i] = <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	myQueue[<span class="number">0</span>][<span class="number">0</span>] = Node(status, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">	expanded[<span class="number">0</span>].insert(status);</span><br><span class="line">	myQueue[<span class="number">1</span>][<span class="number">0</span>] = Node(goalStatus, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">	expanded[<span class="number">1</span>].insert(goalStatus);</span><br><span class="line">	<span class="keyword">while</span> (qHead[<span class="number">0</span>] != qTail[<span class="number">0</span>] &amp;&amp; qHead[<span class="number">1</span>] != qTail[<span class="number">1</span>])</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//两个队列不都为空</span></span><br><span class="line">		<span class="keyword">int</span> qNo; <span class="comment">//本次要扩展的队列</span></span><br><span class="line">		<span class="keyword">if</span> (qHead[<span class="number">0</span>] == qTail[<span class="number">0</span>])</span><br><span class="line">			qNo = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (qHead[<span class="number">1</span>] == qTail[<span class="number">1</span>])</span><br><span class="line">			qNo = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (qTail[<span class="number">0</span>] - qHead[<span class="number">0</span>] &lt; qTail[<span class="number">1</span>] - qHead[<span class="number">1</span>]) <span class="comment">//比较两个队列元素个数</span></span><br><span class="line">				qNo = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				qNo = <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">int</span> vqNo = <span class="number">1</span> - qNo; <span class="comment">//另一队列</span></span><br><span class="line">		status = myQueue[qNo][qHead[qNo]].status;</span><br><span class="line">		<span class="keyword">if</span> (expanded[vqNo].find(status) != expanded[vqNo].end())</span><br><span class="line">		{</span><br><span class="line">			<span class="comment">//status在另一队列扩展过，路径找到</span></span><br><span class="line">			matchingStatus = status;</span><br><span class="line">			matchingQ = qNo;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">			{</span><br><span class="line">				<span class="comment">//尝试4种移动</span></span><br><span class="line">				newStatus = NewStatus(status, sz4Moves[i]);</span><br><span class="line">				<span class="keyword">if</span> (newStatus == <span class="number">-1</span>)</span><br><span class="line">					<span class="keyword">continue</span>; <span class="comment">//不可移，试下一种</span></span><br><span class="line">				<span class="keyword">if</span> (expanded[qNo].find(newStatus) != expanded[qNo].end())</span><br><span class="line">					<span class="keyword">continue</span>; <span class="comment">//如果已经扩展过，则不能入队</span></span><br><span class="line">				expanded[qNo].insert(newStatus);</span><br><span class="line">				myQueue[qNo][qTail[qNo]] = Node(newStatus, qHead[qNo], sz4Moves[i]);</span><br><span class="line">				qTail[qNo] ++;</span><br><span class="line">			}qHead[qNo] ++;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">char</span> line1[<span class="number">50</span>];</span><br><span class="line">	<span class="keyword">char</span> line2[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span>.getline(line1, <span class="number">48</span>))</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//将输入的原始字符串变为数字字符串</span></span><br><span class="line">		<span class="keyword">int</span> i, j;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; line1[i]; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (line1[i] != <span class="string">' '</span>)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">if</span> (line1[i] == <span class="string">'x'</span>)</span><br><span class="line">					line2[j++] = <span class="string">'0'</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					line2[j++] = line1[i];</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		line2[j] = <span class="number">0</span>;<span class="comment">//字符串形式的初始状态</span></span><br><span class="line">					 <span class="comment">//用奇偶性判定是否有解</span></span><br><span class="line">		<span class="keyword">int</span> sumGoal = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">			sumGoal += i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> sumStart = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (line2[i] == <span class="string">'0'</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">if</span> (line2[j] &lt; line2[i] &amp;&amp; line2[j] != <span class="string">'0'</span>)</span><br><span class="line">					sumStart++;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (sumStart % <span class="number">2</span> != sumGoal % <span class="number">2</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"unsolvable"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		}</span><br><span class="line">		goalStatus = atoi(<span class="string">"123456780"</span>);</span><br><span class="line">		<span class="keyword">if</span> (DBfs(atoi(line2)))</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">int</span> moves = <span class="number">0</span>; <span class="keyword">int</span> pos;</span><br><span class="line">			<span class="keyword">if</span> (matchingQ == <span class="number">0</span>)</span><br><span class="line">				pos = qHead[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qTail[<span class="number">0</span>]; ++i)</span><br><span class="line">					<span class="keyword">if</span> (myQueue[<span class="number">0</span>][i].status == matchingStatus)</span><br><span class="line">					{</span><br><span class="line">						pos = i;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					}</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">do</span></span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">if</span> (pos)</span><br><span class="line">				{</span><br><span class="line">					result[moves++] = myQueue[<span class="number">0</span>][pos].move;</span><br><span class="line">					pos = myQueue[<span class="number">0</span>][pos].father;</span><br><span class="line">				}</span><br><span class="line">			} <span class="keyword">while</span> (pos);</span><br><span class="line">			reverse(result, result + moves);</span><br><span class="line">			<span class="keyword">if</span> (matchingQ == <span class="number">0</span>)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qTail[<span class="number">1</span>]; ++i)</span><br><span class="line">					<span class="keyword">if</span> (myQueue[<span class="number">1</span>][i].status == matchingStatus)</span><br><span class="line">					{</span><br><span class="line">						pos = i;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					}</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				pos = qHead[<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">do</span></span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">if</span> (pos)</span><br><span class="line">				{</span><br><span class="line">					result[moves++] = ReverseMove(myQueue[<span class="number">1</span>][pos].move);</span><br><span class="line">					pos = myQueue[<span class="number">1</span>][pos].father;</span><br><span class="line">				}</span><br><span class="line">			} <span class="keyword">while</span> (pos);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; moves; ++i)</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; result[i];</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"unsolvable"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="迷宫问题（DBFS版）"><a href="#迷宫问题（DBFS版）" class="headerlink" title="迷宫问题（DBFS版）"></a>迷宫问题（DBFS版）</h2><p><strong>描述</strong><br>定义一个二维数组，它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。<br><strong>输入</strong><br>一个5 × 5的二维数组，表示一个迷宫。数据保证有唯一解。<br><strong>输出</strong><br>左上角到右下角的最短路径，格式如样例所示。<br><strong>样例输入</strong><br>0 1 0 0 0<br>0 1 0 1 0<br>0 0 0 0 0<br>0 1 1 1 0<br>0 0 0 1 0<br><strong>样例输出</strong><br>(0, 0)<br>(1, 0)<br>(2, 0)<br>(2, 1)<br>(2, 2)<br>(2, 3)<br>(2, 4)<br>(3, 4)<br>(4, 4)<br><strong>程序</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：迷宫问题_DBFS.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">双向广搜</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.09.20</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> x;  <span class="comment">//纵坐标</span></span><br><span class="line">	<span class="keyword">int</span> y;  <span class="comment">//横坐标</span></span><br><span class="line">	<span class="keyword">int</span> father;</span><br><span class="line">	Node(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> df) :x(dx), y(dy), father(df) {}<span class="comment">//默认构造函数</span></span><br><span class="line">	Node() {}<span class="comment">//默认构造函数</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;Node&gt; Q[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; V[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> Step[<span class="number">4</span>][<span class="number">2</span>]</span><br><span class="line">{</span><br><span class="line">	 <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">	<span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">	 <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">	 <span class="number">0</span>,<span class="number">-1</span>,</span><br><span class="line">};</span><br><span class="line"><span class="keyword">bool</span> Visited[<span class="number">2</span>][<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line"><span class="function">Status <span class="title">expand</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Node s = Q[i].front();</span><br><span class="line">	Q[i].pop();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">int</span> tempx = s.x + Step[j][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> tempy = s.y + Step[j][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (tempx &gt;= <span class="number">0</span> &amp;&amp; tempx &lt; <span class="number">5</span> &amp;&amp; tempy &gt;= <span class="number">0</span> &amp;&amp; tempy &lt; <span class="number">5</span> &amp;&amp; !Visited[i][tempx][tempy] &amp;&amp; <span class="built_in">map</span>[tempx][tempy] != <span class="number">1</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (!Visited[<span class="number">1</span> - i][tempx][tempy])</span><br><span class="line">			{</span><br><span class="line">				Q[i].push(Node(tempx, tempy, num[i]));</span><br><span class="line">				V[i].push_back(Node(tempx, tempy, num[i]));</span><br><span class="line">				Visited[i][tempx][tempy] = <span class="literal">true</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			{</span><br><span class="line">				Node t, rt; <span class="comment">//分别指向正向队列和逆向队列的最后一个节点</span></span><br><span class="line">				Node opposite;</span><br><span class="line">				<span class="comment">//正向找到，则找到逆向队列的对应元素</span></span><br><span class="line">				<span class="comment">//反向找到，则找到正向队列的对应元素</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Node&gt;::iterator it = V[<span class="number">1</span> - i].begin(); it != V[<span class="number">1</span> - i].end(); it++)</span><br><span class="line">				{</span><br><span class="line">					<span class="keyword">if</span> (it-&gt;x == tempx&amp;&amp;it-&gt;y == tempy)</span><br><span class="line">					{</span><br><span class="line">						opposite = *it;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">				{</span><br><span class="line">					t = s;</span><br><span class="line">					rt = opposite;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				{</span><br><span class="line">					t = opposite;</span><br><span class="line">					rt = s;</span><br><span class="line">				}</span><br><span class="line">				<span class="built_in">deque</span>&lt;Node&gt; temp;</span><br><span class="line">				temp.push_front(t);</span><br><span class="line">				<span class="keyword">while</span> (t.father != <span class="number">-1</span>)</span><br><span class="line">				{</span><br><span class="line">					temp.push_front(V[<span class="number">0</span>][t.father]);</span><br><span class="line">					t = V[<span class="number">0</span>][t.father];</span><br><span class="line">				}</span><br><span class="line">				temp.push_back(rt);</span><br><span class="line">				<span class="keyword">while</span> (rt.father != <span class="number">-1</span>)</span><br><span class="line">				{</span><br><span class="line">					temp.push_back(V[<span class="number">1</span>][rt.father]);</span><br><span class="line">					rt = V[<span class="number">1</span>][rt.father];</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">for</span> (<span class="built_in">deque</span>&lt;Node&gt;::iterator it = temp.begin(); it != temp.end(); it++)</span><br><span class="line">				{</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; it-&gt;x &lt;&lt; <span class="string">", "</span> &lt;&lt; it-&gt;y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				}</span><br><span class="line">				result = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">return</span> OK;</span><br><span class="line">				<span class="comment">//精简前冗杂代码段</span></span><br><span class="line">				<span class="comment">/*vector&lt;Node&gt;temp;</span></span><br><span class="line"><span class="comment">				Node t = s;</span></span><br><span class="line"><span class="comment">				if (i == 0)</span></span><br><span class="line"><span class="comment">				{</span></span><br><span class="line"><span class="comment">					//正向找到路径重合点</span></span><br><span class="line"><span class="comment">					//输出正向序列路径</span></span><br><span class="line"><span class="comment">					temp.push_back(t);</span></span><br><span class="line"><span class="comment">					while (t.father != -1)</span></span><br><span class="line"><span class="comment">					{</span></span><br><span class="line"><span class="comment">						temp.push_back(V[0][t.father]);</span></span><br><span class="line"><span class="comment">						t = V[0][t.father];</span></span><br><span class="line"><span class="comment">					}</span></span><br><span class="line"><span class="comment">					for (vector&lt;Node&gt;::reverse_iterator rit = temp.rbegin(); rit != temp.rend(); rit++)</span></span><br><span class="line"><span class="comment">					{</span></span><br><span class="line"><span class="comment">						cout &lt;&lt; "(" &lt;&lt; rit-&gt;x &lt;&lt; ", " &lt;&lt; rit-&gt;y &lt;&lt; ")" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">					}</span></span><br><span class="line"><span class="comment">					temp.clear();</span></span><br><span class="line"><span class="comment">					//输出逆向序列路径</span></span><br><span class="line"><span class="comment">					for (vector&lt;Node&gt;::iterator it = V[1].begin(); it != V[1].end(); it++)</span></span><br><span class="line"><span class="comment">					{</span></span><br><span class="line"><span class="comment">						if (it-&gt;x == tempx&amp;&amp;it-&gt;y == tempy)</span></span><br><span class="line"><span class="comment">						{</span></span><br><span class="line"><span class="comment">							temp.push_back(*it);</span></span><br><span class="line"><span class="comment">							t = *it;</span></span><br><span class="line"><span class="comment">							break;</span></span><br><span class="line"><span class="comment">						}</span></span><br><span class="line"><span class="comment">					}</span></span><br><span class="line"><span class="comment">					while (t.father != -1)</span></span><br><span class="line"><span class="comment">					{</span></span><br><span class="line"><span class="comment">						temp.push_back(V[1][t.father]);</span></span><br><span class="line"><span class="comment">						t = V[1][t.father];</span></span><br><span class="line"><span class="comment">					}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">					for (vector&lt;Node&gt;::iterator it = temp.begin(); it != temp.end(); it++)</span></span><br><span class="line"><span class="comment">					{</span></span><br><span class="line"><span class="comment">						cout &lt;&lt; "(" &lt;&lt; it-&gt;x &lt;&lt; ", " &lt;&lt; it-&gt;y &lt;&lt; ")" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">					}</span></span><br><span class="line"><span class="comment">					result = true;</span></span><br><span class="line"><span class="comment">					return OK;</span></span><br><span class="line"><span class="comment">				}</span></span><br><span class="line"><span class="comment">				else</span></span><br><span class="line"><span class="comment">				{</span></span><br><span class="line"><span class="comment">					//逆向找到路径重合点</span></span><br><span class="line"><span class="comment">					//输出正向序列路径</span></span><br><span class="line"><span class="comment">					for (vector&lt;Node&gt;::iterator it = V[0].begin(); it != V[0].end(); it++)</span></span><br><span class="line"><span class="comment">					{</span></span><br><span class="line"><span class="comment">						if (it-&gt;x == tempx&amp;&amp;it-&gt;y == tempy)</span></span><br><span class="line"><span class="comment">						{</span></span><br><span class="line"><span class="comment">							temp.push_back(*it);</span></span><br><span class="line"><span class="comment">							t = *it;</span></span><br><span class="line"><span class="comment">							break;</span></span><br><span class="line"><span class="comment">						}</span></span><br><span class="line"><span class="comment">					}</span></span><br><span class="line"><span class="comment">					while (t.father != -1)</span></span><br><span class="line"><span class="comment">					{</span></span><br><span class="line"><span class="comment">						temp.push_back(V[0][t.father]);</span></span><br><span class="line"><span class="comment">						t = V[0][t.father];</span></span><br><span class="line"><span class="comment">					}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">					for (vector&lt;Node&gt;::reverse_iterator rit = temp.rbegin(); rit != temp.rend(); rit++)</span></span><br><span class="line"><span class="comment">					{</span></span><br><span class="line"><span class="comment">						cout &lt;&lt; "(" &lt;&lt; rit-&gt;x &lt;&lt; ", " &lt;&lt; rit-&gt;y &lt;&lt; ")" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">					}</span></span><br><span class="line"><span class="comment">					temp.clear();</span></span><br><span class="line"><span class="comment">					//输出逆向序列路径</span></span><br><span class="line"><span class="comment">					t = s;</span></span><br><span class="line"><span class="comment">					temp.push_back(t);</span></span><br><span class="line"><span class="comment">					while (t.father != -1)</span></span><br><span class="line"><span class="comment">					{</span></span><br><span class="line"><span class="comment">						temp.push_back(V[1][t.father]);</span></span><br><span class="line"><span class="comment">						t = V[1][t.father];</span></span><br><span class="line"><span class="comment">					}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">					for (vector&lt;Node&gt;::iterator it = temp.begin(); it != temp.end(); it++)</span></span><br><span class="line"><span class="comment">					{</span></span><br><span class="line"><span class="comment">						cout &lt;&lt; "(" &lt;&lt; it-&gt;x &lt;&lt; ", " &lt;&lt; it-&gt;y &lt;&lt; ")" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">					}</span></span><br><span class="line"><span class="comment">					result = true;</span></span><br><span class="line"><span class="comment">					return OK;</span></span><br><span class="line"><span class="comment">				}*/</span></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	num[i]++;</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; <span class="built_in">map</span>[i][j];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//DBFS</span></span><br><span class="line">	Q[<span class="number">0</span>].push(Node(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>));</span><br><span class="line">	Q[<span class="number">1</span>].push(Node(<span class="number">4</span>, <span class="number">4</span>, <span class="number">-1</span>));</span><br><span class="line">	V[<span class="number">0</span>].push_back(Node(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>));</span><br><span class="line">	V[<span class="number">1</span>].push_back(Node(<span class="number">4</span>, <span class="number">4</span>, <span class="number">-1</span>));</span><br><span class="line">	<span class="built_in">memset</span>(Visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(Visited));</span><br><span class="line">	Visited[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">	Visited[<span class="number">1</span>][<span class="number">4</span>][<span class="number">4</span>] = <span class="literal">true</span>;</span><br><span class="line">	num[<span class="number">1</span>] = num[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!Q[<span class="number">0</span>].empty() &amp;&amp; !Q[<span class="number">1</span>].empty() &amp;&amp; !result)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (Q[<span class="number">0</span>].size() &lt; Q[<span class="number">1</span>].size())</span><br><span class="line">		{</span><br><span class="line">			expand(<span class="number">0</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			expand(<span class="number">1</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//省略</span></span><br><span class="line">	<span class="comment">/*while (!Q[0].empty() &amp;&amp; !result)</span></span><br><span class="line"><span class="comment">	{</span></span><br><span class="line"><span class="comment">		expand(0);</span></span><br><span class="line"><span class="comment">	}</span></span><br><span class="line"><span class="comment">	while (!Q[1].empty() &amp;&amp; !result)</span></span><br><span class="line"><span class="comment">	{</span></span><br><span class="line"><span class="comment">		expand(1);</span></span><br><span class="line"><span class="comment">	}*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Jack-and-Jill"><a href="#Jack-and-Jill" class="headerlink" title="Jack and Jill"></a>Jack and Jill</h2><p><strong>Description</strong><br>Ever since the incident on the hill, Jack and Jill dislike each other and wish to remain as distant as possible. Jack and Jill must attend school each day; Jack attends a boys’ school while Jill attends a girls’ school. Both schools start at the same time. You have been retained by their lawyers to arrange routes and a schedule that Jack and Jill will adhere to so as to maximize the closest straight-line distance between them at any time during their trip to school.<br>Jack and Jill live in a town laid out as an n by n square grid (n &lt;= 30). It takes 1 minute to walk from one location to an adjacent location. In maximizing the distance between Jack and Jill you need consider only the distance between the locations they visit (i.e. you need not consider any intermediate points on the path they take from grid location to grid location). Some locations are impassable due to being occupied by rivers, buildings, etc. Jack must start at his house and walk continuously until he gets to school. Jill must start at her house at the same time as Jack and walk continuously until she arrives at her school. Jack’s house and school are impassable to Jill while Jill’s house and school are impassable to Jack. Other grid locations that are impassable to both Jack and Jill are given in the input.</p>
<p><strong>Input</strong><br>Input will consist of several test cases. Each test case will consist of n, followed by n lines with n characters representing a map of the town. In the map, Jack’s house is represented by ‘H’, Jack’s school is represented by ‘S’, Jill’s house is represented by ‘h’, Jill’s school is represented by ‘s’, impassable locations are represented by ‘*‘, and all other locations are represented by ‘.’ You may assume the normal cartographic convention that North is at the top of the page and West is to the left. A line containing 0 follows the last case.</p>
<p><strong>Output</strong><br>For each input case you should give three lines of output containing:<br>the closest that Jack and Jill come during the schedule (to 2 decimal places)<br>Jack’s route<br>Jill’s route.<br>Each route is a sequence of directions that Jack or Jill should follow for each minute from the start time until arriving at school. Each direction is one of ‘N’, ‘S’, ‘E’, or ‘W’. If several pairs of routes are possible, any one will do. You may assume there is at least one solution. Leave a blank line between the output for successive cases.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">..........</span><br><span class="line">...H......</span><br><span class="line">.**...s...</span><br><span class="line">.**.......</span><br><span class="line">.**.......</span><br><span class="line">.**.......</span><br><span class="line">.**.......</span><br><span class="line">.**.......</span><br><span class="line">...S..h..*</span><br><span class="line">..........</span><br><span class="line">0</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Sample Out</strong><br>6.71<br>WWWSSSSSSSEEE<br>NEEENNNNNWWW<br><strong>Procedure</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：Jack and Jill.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这题有点坑，两个人走的步数可以不一样，还能来回走？？！！冤家路窄啊？</span></span><br><span class="line"><span class="comment">  两个非要隔着老远走？还要让各自的行程规划师协调使得最近直线距离最大，服！</span></span><br><span class="line"><span class="comment">  也就是说尽可能保证两人之间距离最大，然后输出最近距离！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  一个结构体保存两个人的状态，优先队列优化，其中一个人先到达目的地就原地停止。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.09.21</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> hx, hy;</span><br><span class="line">	<span class="keyword">int</span> Hx, Hy;</span><br><span class="line">	<span class="keyword">int</span> dist;</span><br><span class="line">	<span class="keyword">char</span> moveh, moveH; <span class="comment">//记录上一个节点的移动方向</span></span><br><span class="line">	<span class="keyword">int</span> father;</span><br><span class="line">	<span class="keyword">int</span> index; <span class="comment">//注意优先队列的top序列</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;a)<span class="keyword">const</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> dist &lt; a.dist; <span class="comment">//保证top最大，降序排列</span></span><br><span class="line">	}</span><br><span class="line">	Node(<span class="keyword">int</span> dhx, <span class="keyword">int</span> dhy, <span class="keyword">int</span> dHx, <span class="keyword">int</span> dHy, <span class="keyword">int</span> ddist, <span class="keyword">char</span> dmoveh, <span class="keyword">char</span> dmoveH, <span class="keyword">int</span> dfather, <span class="keyword">int</span> dindex)</span><br><span class="line">		:hx(dhx), hy(dhy), Hx(dHx), Hy(dHy), dist(ddist), moveh(dmoveh), moveH(dmoveH), father(dfather), index(dindex) {}</span><br><span class="line">	Node() {}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">int</span> Step[<span class="number">4</span>][<span class="number">2</span>] =</span><br><span class="line">{</span><br><span class="line">	<span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">   <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">	<span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">	<span class="number">0</span>,<span class="number">-1</span>,</span><br><span class="line">};<span class="comment">//下上右左</span></span><br><span class="line"><span class="keyword">char</span> moves[] = <span class="string">"SNEW"</span>;</span><br><span class="line"><span class="keyword">int</span> visited[<span class="number">31</span>][<span class="number">31</span>][<span class="number">31</span>][<span class="number">31</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[<span class="number">31</span>][<span class="number">31</span>];</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; v;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">distance</span><span class="params">(<span class="keyword">int</span> hx, <span class="keyword">int</span> hy, <span class="keyword">int</span> Hx, <span class="keyword">int</span> Hy)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> (hx - Hx)*(hx - Hx) + (hy - Hy)*(hy - Hy);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> hx, <span class="keyword">int</span> hy, <span class="keyword">int</span> Hx, <span class="keyword">int</span> Hy)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	q.push(Node(hx, hy, Hx, Hy, distance(hx, hy, Hx, Hy), <span class="string">'o'</span>, <span class="string">'o'</span>, <span class="number">-1</span>, num));</span><br><span class="line">	v.push_back(Node(hx, hy, Hx, Hy, distance(hx, hy, Hx, Hy), <span class="string">'o'</span>, <span class="string">'o'</span>, <span class="number">-1</span>, num++));</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())</span><br><span class="line">	{</span><br><span class="line">		Node s = q.top();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">map</span>[s.hx][s.hy] == <span class="string">'s'</span>&amp;&amp;<span class="built_in">map</span>[s.Hx][s.Hy] == <span class="string">'S'</span>)<span class="comment">//双方都到达学校</span></span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; <span class="built_in">sqrt</span>(s.dist) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="built_in">deque</span>&lt;<span class="keyword">char</span>&gt; temp[<span class="number">2</span>];</span><br><span class="line">			<span class="keyword">while</span> (s.father != <span class="number">-1</span>)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">if</span> (s.moveH != <span class="string">'o'</span>)</span><br><span class="line">				{</span><br><span class="line">					temp[<span class="number">0</span>].push_front(s.moveH);</span><br><span class="line">				}</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (s.moveh != <span class="string">'o'</span>)</span><br><span class="line">				{</span><br><span class="line">					temp[<span class="number">1</span>].push_front(s.moveh);</span><br><span class="line">				}</span><br><span class="line">				s = v[s.father];</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">char</span>&gt;::iterator it = temp[i].begin(); it != temp[i].end(); it++)</span><br><span class="line">				{</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line">				}</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">return</span> OK;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">int</span> temp_hx = s.hx + Step[i][<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">int</span> temp_hy = s.hy + Step[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">char</span> temp_moveh = moves[i];</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">map</span>[s.hx][s.hy] == <span class="string">'s'</span>)<span class="comment">//站在终点不动，因为另一个人还没走到终点</span></span><br><span class="line">			{</span><br><span class="line">				temp_hx = s.hx;</span><br><span class="line">				temp_hy = s.hy;</span><br><span class="line">				temp_moveh = <span class="string">'o'</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (temp_hx &gt;= <span class="number">0</span> &amp;&amp; temp_hx &lt; n&amp;&amp;temp_hy &gt;= <span class="number">0</span> &amp;&amp; temp_hy &lt; n&amp;&amp;<span class="built_in">map</span>[temp_hx][temp_hy] != <span class="string">'S'</span>&amp;&amp;<span class="built_in">map</span>[temp_hx][temp_hy] != <span class="string">'H'</span>&amp;&amp;<span class="built_in">map</span>[temp_hx][temp_hy] != <span class="string">'*'</span>)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">				{</span><br><span class="line">					<span class="keyword">int</span> temp_Hx = s.Hx + Step[j][<span class="number">0</span>];</span><br><span class="line">					<span class="keyword">int</span> temp_Hy = s.Hy + Step[j][<span class="number">1</span>];</span><br><span class="line">					<span class="keyword">char</span> temp_moveH = moves[j];</span><br><span class="line">					<span class="keyword">if</span> (<span class="built_in">map</span>[s.Hx][s.Hy] == <span class="string">'S'</span>)<span class="comment">//站在原地不动，因为另一个人还没走到终点</span></span><br><span class="line">					{</span><br><span class="line">						temp_Hx = s.Hx;</span><br><span class="line">						temp_Hy = s.Hy;</span><br><span class="line">						temp_moveH = <span class="string">'o'</span>;</span><br><span class="line">					}</span><br><span class="line">					<span class="keyword">if</span> (temp_Hx &gt;= <span class="number">0</span> &amp;&amp; temp_Hx &lt; n&amp;&amp;temp_Hy &gt;= <span class="number">0</span> &amp;&amp; temp_Hy &lt; n&amp;&amp;<span class="built_in">map</span>[temp_Hx][temp_Hy] != <span class="string">'s'</span>&amp;&amp;<span class="built_in">map</span>[temp_Hx][temp_Hy] != <span class="string">'h'</span>&amp;&amp;<span class="built_in">map</span>[temp_Hx][temp_Hy] != <span class="string">'*'</span>)</span><br><span class="line">					{</span><br><span class="line">						<span class="keyword">int</span> dis = distance(temp_hx, temp_hy, temp_Hx, temp_Hy);</span><br><span class="line">						dis = min(dis, s.dist);<span class="comment">//关键代码</span></span><br><span class="line">						<span class="keyword">if</span> (!visited[temp_hx][temp_hy][temp_Hx][temp_Hy])</span><br><span class="line">						{</span><br><span class="line">							q.push(Node(temp_hx, temp_hy, temp_Hx, temp_Hy, dis, temp_moveh, temp_moveH, s.index, num));</span><br><span class="line">							v.push_back(Node(temp_hx, temp_hy, temp_Hx, temp_Hy, dis, temp_moveh, temp_moveH, s.index, num++));</span><br><span class="line">							visited[temp_hx][temp_hy][temp_Hx][temp_Hy] = <span class="number">1</span>;</span><br><span class="line">						}</span><br><span class="line">					}</span><br><span class="line">					<span class="keyword">if</span> (<span class="built_in">map</span>[s.Hx][s.Hy] == <span class="string">'S'</span>) <span class="comment">//循环一次</span></span><br><span class="line">					{</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">map</span>[s.hx][s.hy] == <span class="string">'s'</span>)<span class="comment">//循环一次</span></span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> hx, hy, Hx, Hy;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n&amp;&amp;n != <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			{</span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; <span class="built_in">map</span>[i][j];</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="string">'H'</span>)</span><br><span class="line">				{</span><br><span class="line">					Hx = i;</span><br><span class="line">					Hy = j;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="string">'h'</span>)</span><br><span class="line">				{</span><br><span class="line">					hx = i;</span><br><span class="line">					hy = j;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">		num = <span class="number">0</span>;</span><br><span class="line">		BFS(hx, hy, Hx, Hy);</span><br><span class="line">		<span class="keyword">while</span> (!q.empty()) <span class="comment">//清空，queue没有clear方法，很无奈！</span></span><br><span class="line">		{</span><br><span class="line">			q.pop();</span><br><span class="line">		}</span><br><span class="line">		v.clear();</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="第五章-素数筛选法"><a href="#第五章-素数筛选法" class="headerlink" title="第五章 素数筛选法"></a>第五章 素数筛选法</h1></blockquote>
<h2 id="素数筛选函数"><a href="#素数筛选函数" class="headerlink" title="素数筛选函数"></a>素数筛选函数</h2><p>当一个数不算大的时候，可以用普通的求素数的方法去求，但是如果一个数过大的话，就像让求1-十亿之间素数的个数，普通方法就不行了，这事就需要用到素数筛选法，他的时间复杂度是O(n),尽管不算很好，但是，也算是目前为止比较快的一种方法了，它是以空间换取时间，现在的计算机，空间有的是，但是时间是非常珍贵的。效率问题特别重要。他的原理就是标记，防止重复判断，这样提高了效率。就像2是素数，所有是2的倍数的肯定都不是素数，这时候标记上，接着判断3是素数，所有是3的倍数的都肯定不是素数，这时就要标记上，以此下去，执行到根下(总数)，这样就会得到一个素数表，所有没有被标记的都是素数，下面是具体的代码实现，代码里面有注释。写的很清楚。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1000000000<span class="comment">//定义一个数组长度</span></span></span><br><span class="line"><span class="keyword">bool</span> prime[MAX + <span class="number">1</span>];<span class="comment">//素数表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i, j, count = <span class="number">0</span>;<span class="comment">//count为计数器</span></span><br><span class="line">    <span class="built_in">memset</span>(prime, <span class="literal">true</span>, <span class="keyword">sizeof</span>(prime));<span class="comment">//初始化，将prime数组全部都初始化为true</span></span><br><span class="line">    prime[<span class="number">0</span>] = prime[<span class="number">1</span>] = <span class="literal">false</span>; prime[<span class="number">2</span>] = <span class="literal">true</span>;<span class="comment">//0，1都不是素数，所以为false，2是素数，所以为true</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i * i &lt;= MAX; i ++)<span class="comment">/*从2开始进行遍历， i * i &lt;= MAX 就等价于 i &lt; sqrt(MAX);但是前者更不容易出错</span></span><br><span class="line"><span class="comment">     具体为什么是sqrt就不用说了吧，普通的方法中也有这个*/</span>   </span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(prime[i])<span class="comment">//如果没有被标记的话将它的倍数的数标记(标记就是将它赋值为false)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(j = i + i; j &lt;= MAX; j += i)<span class="comment">//因为是从2开始的，所以j = i + i 就行了，最小的一个他的倍数的就是i + i了，不可能有比这个更小的了</span></span><br><span class="line">                prime[j] = <span class="literal">false</span>;<span class="comment">//标记为false</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= MAX; i ++)<span class="comment">//遍历一下，找出所有的素数来</span></span><br><span class="line">        <span class="keyword">if</span>(prime[i])</span><br><span class="line">                count ++;<span class="comment">//如果没有被标记，计数器++</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"count is :%d\n"</span>, count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="素数判断函数"><a href="#素数判断函数" class="headerlink" title="素数判断函数"></a>素数判断函数</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Is_prime</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;x;i++)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">return</span> ERROR;<span class="comment">//不是质数</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Calling-Extraterrestrial-Intelligence-Again"><a href="#Calling-Extraterrestrial-Intelligence-Again" class="headerlink" title="Calling Extraterrestrial Intelligence Again"></a>Calling Extraterrestrial Intelligence Again</h2><p><strong>描述</strong><br>A message from humans to extraterrestrial intelligence was sent through the Arecibo radio telescope in Puerto Rico on the afternoon of Saturday November 16, 1974. The message consisted of 1679 bits and was meant to be translated to a rectangular picture with 23 x 73 pixels. Since both 23 and 73 are prime numbers, 23 x 73 is the unique possible size of the translated rectangular picture each edge of which is longer than 1 pixel. Of course, there was no guarantee that the receivers would try to translate the message to a rectangular picture. Even if they would, they might put the pixels into the rectangle incorrectly. The senders of the Arecibo message were optimistic.<br>We are planning a similar project. Your task in the project is to find the most suitable width and height of the translated rectangular picture. The term “most suitable” is defined as follows. An integer m greater than 4 is given. A positive fraction a/b less than or equal to 1 is also given. The area of the picture should not be greater than m. Both of the width and the height of the translated picture should be prime numbers. The ratio of the width to the height should not be less than a/b nor greater than 1. You should maximize the area of the picture under these constraints.<br>In other words, you will receive an integer m and a fraction a/b. It holds that m &gt; 4 and 0 &lt; a/b &lt;= 1. You should find the pair of prime numbers p, q such that pq &lt;= m and a/b &lt;= p/q &lt;= 1, and furthermore, the product pq takes the maximum value among such pairs of two prime numbers. You should report p and q as the “most suitable” width and height of the translated picture.<br>输入<br>The input is a sequence of at most 2000 triplets of positive integers, delimited by a space character in between. Each line contains a single triplet. The sequence is followed by a triplet of zeros, 0 0 0, which indicates the end of the input and should not be treated as data to be processed.<br>The integers of each input triplet are the integer m, the numerator a, and the denominator b described above, in this order. You may assume 4 &lt; m &lt;= 100000 and 1 &lt;= a &lt;= b &lt;= 1000.<br><strong>输出</strong><br>The output is a sequence of pairs of positive integers. The i-th output pair corresponds to the i-th input triplet. The integers of each output pair are the width p and the height q described above, in this order.<br>Each output line contains a single pair. A space character is put between the integers as a delimiter. No other characters should appear in the output.<br><strong>样例输入</strong><br>5 1 2<br>99999 999 999<br>1680 5 16<br>1970 1 1<br>2002 4 11<br>0 0 0<br><strong>样例输出</strong><br>2 2<br>313 313<br>23 73<br>43 43<br>37 53<br><strong>程序</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：Calling_Extraterrestrial_Intelligence_Again.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">题目前一段描述废话略过！</span></span><br><span class="line"><span class="comment">两个素数 p, q 并且 pq &lt;= m and a / b &lt;= p / q &lt;= 1,</span></span><br><span class="line"><span class="comment">4 &lt; m &lt;= 100000 and 1 &lt;= a &lt;= b &lt;= 1000.求最大的q,p值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：请用DEV，VS报错，傻逼一样！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.09.24</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">1300</span>];</span><br><span class="line"><span class="keyword">bool</span> x[MAXN];</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function">Status <span class="title">C_Prime</span><span class="params">()</span><span class="comment">//素数筛选法</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">memset</span>(x, <span class="literal">true</span>, <span class="keyword">sizeof</span>(x));</span><br><span class="line">	x[<span class="number">0</span>] = x[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAXN; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (x[i])</span><br><span class="line">		{</span><br><span class="line">			prime[num++] = i;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i &lt;&lt; <span class="number">1</span>; j &lt;= MAXN; j += i)</span><br><span class="line">			{</span><br><span class="line">				x[j] = <span class="literal">false</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/*for (int i = 0; i &lt; num; i++)</span></span><br><span class="line"><span class="comment">	{</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; prime[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	}*/</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> m, a, b, p, q;</span><br><span class="line">	C_Prime();</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; a &gt;&gt; b&amp;&amp;(a!=<span class="number">0</span>||b!=<span class="number">0</span>||m!=<span class="number">0</span>))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> temp;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = num - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (prime[i] &gt;= m)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; num; j++)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">if</span> (prime[i] * prime[j] &gt; m || (<span class="keyword">double</span>)prime[i] / prime[j] &lt; (<span class="keyword">double</span>)a / b)</span><br><span class="line">				{</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">				temp = prime[i] * prime[j];</span><br><span class="line">				<span class="keyword">if</span> (temp &gt; max)</span><br><span class="line">				{</span><br><span class="line">					max = temp;</span><br><span class="line">					p = prime[i];</span><br><span class="line">					q = prime[j];</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="string">" "</span> &lt;&lt; q &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="第六章-博弈论及其算法实现"><a href="#第六章-博弈论及其算法实现" class="headerlink" title="第六章 博弈论及其算法实现"></a>第六章 博弈论及其算法实现</h1></blockquote>
<h2 id="何为博弈论"><a href="#何为博弈论" class="headerlink" title="何为博弈论"></a>何为博弈论</h2><p>　　那就是若有多个人进行博弈，假设他们都足够聪明（能力已经相当于计算机了），在他们都没有失误并采取最优策略后，一定有一个人胜出，在知道初状态及规则的情况下，求解最终必胜的初状态（即何人胜出）的一类问题的理论及方法。</p>
<h2 id="理论铺垫"><a href="#理论铺垫" class="headerlink" title="理论铺垫"></a>理论铺垫</h2><p><strong>1、定义P-position和N-position</strong><br>　　其中P代表Previous，N代表Next。直观的说，上一次move的人有必败策略的局面是P-position，也就是“先手必败”（奇异局势），现在轮到move的人有必胜策略的局面是N-position，也就是“先手可保证必胜”（非奇异局势）。<br> （1）.无法进行任何移动的局面（也就是terminal position）是P-position；<br> （2）.可以移动到P-position的局面是N-position；<br> （3）.所有移动都导致N-position的局面是P-position。<br><strong>2、P/N状态有如下性质</strong><br>（1）、若面临末状态者为获胜则末状态为胜态否则末状态为必败态。<br>（2）、一个局面是胜态的充要条件是该局面进行某种决策后会成为必败态。<br>（3）、一个局面是必败态的充要条件是该局面无论进行何种决策均会成为胜态</p>
<h2 id="公平组合博弈（ICG）"><a href="#公平组合博弈（ICG）" class="headerlink" title="公平组合博弈（ICG）"></a>公平组合博弈（ICG）</h2><p><strong>1.定义</strong><br>（1）只有两人参与。<br>（2）游戏局面的状态集合是有限。<br>（3）对于同一个局面，两个游戏者的可操作集合完全相同<br>（4）游戏者轮流进行游戏。<br>（5）当无法进行操作时游戏结束，此时不能进行操作的一方算输。<br>（6）无论游戏如何进行，总可以在有限步数之内结束。<br><strong>2.模型</strong><br>　　给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿有向边进行移动，无法移动者判负。这个游戏可以认为是所有公平组合游戏的抽象模型。其实，任何一个ICG都可以通过把每个局势看成一个顶点，对每个局势和它的子局势连一条有向边来抽象成这个“有向图游戏”。<br><strong>3.解决思路</strong><br>　　现在，假定我们给出两个游戏G1 和 G2甚至多个游戏。如果我们只知道单个游戏的P-状态和N-状态我们能够正确地玩好游戏和G1 + G2吗？答案是否定的。不难看出两个P-状态的和总是P-状态，P-状态和N-状态的和总是N-状态。但是两个N-状态的和既可能是P-状态也可能是N-状态。因此，只知道单个游戏的P-状态和N-状态是不够的。<br>  为了了解到几个状态叠加后是N还是P状态，我们需首先了解Sprague-Grudy函数。<br><strong>4.Sprague-Grudy定理</strong><br>令N = {0, 1, 2, 3, …} 为自然数的集合。Sprague-Grundy 函数给游戏中的每个状态分配了一个自然数。结点v的Grundy值等于没有在v的后继的Grundy值中出现的最小自然数.<br>形式上：给定一个有限子集 S ⊂ N,令mex S为没有出现在S中的最小自然数。定义的mex(minimal excludant)运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。<br>对于一个给定的有向无环图，定义关于图的每个顶点的Sprague-Garundy函数g如下：g(x)=mex{ g(y) | y是x的后继 }。<br><strong>5.Sprague-Grudy函数性质</strong><br>（1）所有的终结点所对应的顶点，其SG值为0，因为它的后继集合是空集——所有终结点是必败点（P点）。<br>（2）对于一个SG(x)=0的顶点x，它的所有后继y都满足g(y)!=0——无论如何操作，从必败点（P点）都只能进入必胜点（N点）//对手走完又能把N留给我们。<br>（3）对于一个SG(x)!=0的顶点，必定存在一个后继点y满足g(y)=0——从任何必胜点（N点）操作，至少有一种方法可以进入必败点（P点）<br>//就是那种我们要走的方法。<br>综上：必须判断先手是否为P状态，如果是，则必败，如果不是则必赢，因为按照上述性质，先手N状态必然可以移动到P状态使后者必输。</p>
<h2 id="巴什博奕-Bash-Game"><a href="#巴什博奕-Bash-Game" class="headerlink" title="巴什博奕(Bash Game)"></a>巴什博奕(Bash Game)</h2><p><strong>1.QUESTION</strong><br> 　　只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。<br> <strong>2.分析</strong><br> 　　游戏中为两人取一堆，干脆扩展到取n堆，由于取物数量有限制，因此正好是综合内第一个情况。<br>　　求SG值总能发现SG值为该值%(m+1) 后的结果，因此不加证明就能给出每一堆%（m+1)后再抑或一遍就为答案，下面是一堆贪心算法原理：<br>显然，如果n=m+1，那么由于一次最多只能取m个，所以，无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，后者取胜。因此我们发现了如何取胜的法则：如果n=（m+1）r+s，（r为任意自然数，s≤m),那么先取者要拿走s个物品，如果后取者拿走k（≤m)个，那么先取者再拿走m+1-k个，结果剩下（m+1）（r-1）个，以后保持这样的取法，那么先取者肯定获胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。<br>即，若n=k×(m+1)，则后取着胜，反之，存在先取者获胜的取法。n%(m+1)==0. 先取者必败，即此时为P状态。<br>　　多堆类似。<br><strong>3.算法实现</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bash_Game</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> <span class="comment">//先手是否有必赢策略</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">if</span>(n%(m+<span class="number">1</span>)==<span class="number">0</span>)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="尼姆博弈-Nimm-Game"><a href="#尼姆博弈-Nimm-Game" class="headerlink" title="尼姆博弈(Nimm Game)"></a>尼姆博弈(Nimm Game)</h2><p><strong>1.简单情况</strong><br>　　有3堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，最后取光者获胜胜。<br>　　这是nim博弈最简单的情况，我们用（a，b，c）表示某种局势，首先（0，0，0）显然是奇异局势，无论谁面对奇异局势，都必然失败。第二种奇异局势是（0，n，n），只要与对手拿走一样多的物品，最后都将导致（0，0，0）。仔细分析一下，（1，2，3）也是奇异局势，无论对手如何拿，接下来都可以变为（0，n，n）的情形。<br>　　那么怎么才能判断一个局势是否为奇异局势呢？答案就是抑或运算。这也算是公平组合博弈的一个原理之一，由于是尼姆博弈的基础于是放到此部分。<br><strong>2.异或运算对尼姆博弈的处理以及原理</strong><br>对于P/N状态，有以下三个定义：（即前面理论铺垫的三个定义）<br>（1）无法进行任何移动的局面（也就是terminal position）是P-position；<br>（2）可以移动到P-position的局面是N-position；<br>（3）所有移动都导致N-position的局面是P-position。</p>
<p>假设各堆石子数为$a_1,a_2,a_3,…,a_n$，首先P状态对应$a_1;xor;a_2;xor;a_3;xor;…;xor;a_n = 0$,N状态对应$a_1;xor;a_2;xor;a_3;xor;…;xor;a_n !=0 $;<br>对于（1），无法操作的局面对应$a_i$全为0的情况，抑或为0，得证。<br>对于（2），对于任何$a_1;xor;a_2;xor;a_3;xor;…;xor;a_n！=0$的情况，如果能够转移成P-position，则必存在一个数$a_i$使得$a_1;xor;a_2;xor;a_3;xor;…;xor;a_n=0$，证明如下：<br>将$a_i$减少为$a_i’$($a_i’\lt a_i$,因为$a_i$只能减小不能增加),令$A=a_1;xor;a_2;xor;a_3;xor;…;xor;a_{i-1};xor;a_{i+1};xor;a_n$，则$a_i’;xor;A=0$,<br>$又∵A;xor;a_i=X&gt;0$，<br>$∴a_i’;xor;A=a_i’;xor;a_i;xor;a_i;xor;A=X;xor;a_i;xor;a_i’=0$<br>$∴a_i’=X;xor;a_i$<br>$又∵a_i’\lt a_i$<br>$∴X;xor;a_i\lt a_i$<br>故满足此式的$a_i$必能转移成P-position,<br>进一步，如果X与$a_i$最高位同时为1，那么必定满足上式，而由于X&gt;0,且X由其他各元素异或得到，必定存在奇数个与X最高位同为1的$a_i$<br>证毕。<br>对于（3），证明P状态转移后必定不为P状态，也就能证明（3）了。<br>对于$a_1;xor;a_2;xor;a_3;xor;…;xor;a_i;xor;…;xor;a_n=0$的P状态 将其中$a_i$取走一堆，即减去一个数字变为$a_i’$,仍为P状态，即$a_1;xor;a_2;xor;a_3;xor;…;xor;a_i’;xor;…;xor;a_n=0=a_1;xor;a_2;xor;a_3;xor;…;xor;a_i;xor;…;xor;a_n$,由于抑或运算满足削去率，所以得到最后结果为$a_i’=a_i$，所以P状态不可能经过任何转移使得其仍未P状态，(3)成立。<br>因此nim简单博弈中，把3堆石子数量抑或一遍，判断是否为零就能得出是否为必胜态。</p>
<p>推广到n堆，原理相似。</p>
<p><strong>3.算法实现</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Nimm_Game</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> size)</span> <span class="comment">//判断先手是否有必赢策略</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">  {</span><br><span class="line">    flag^=a[i];</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span>(flag!=<span class="number">0</span>)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//非奇异局势</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//奇异局势</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="ICG，NIM博弈及-SG函数综合"><a href="#ICG，NIM博弈及-SG函数综合" class="headerlink" title="ICG，NIM博弈及 SG函数综合"></a>ICG，NIM博弈及 SG函数综合</h2><p>　　对于能化为n堆取石子的问题，若取石子的数量是有限制的（给出n个能取得石子数量），因此先求出每堆数量的SG值（也就是单个游戏对应的状态），再进行抑或，得出的答案按是否为0判断是否为必胜或者必败态。<br>　　而对于一次取后会变为多状态的问题，由于按照最优策略最后一定有一个人胜出，所以取后各个状态得出的结果是一致的，只需要把该次取后的所有状态抑或一遍，得出的答案就是取前状态，可递归计算。</p>
<h2 id="威佐夫博弈（Wythoff-Game"><a href="#威佐夫博弈（Wythoff-Game" class="headerlink" title="威佐夫博弈（Wythoff Game)"></a>威佐夫博弈（Wythoff Game)</h2><p><strong>1.QUESTION</strong><br>有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。<br><strong>2.分析</strong><br>这种情况下是颇为复杂的。我们用$(a_k，b_k)(a_k ≤ b_k ,k=0，1，2，…,n)$表示两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。<br>    可以看出,$a_0=b_0=0,a_k$是未在前面出现过的最小自然数,而$b_k=a_k + k$，奇异局势有<br>如下三条性质：<br><strong>a.任何自然数都包含在一个且仅有一个奇异局势中</strong><br>由于ak是未在前面出现过的最小自然数，所以有：<br>$a_k&gt;a_{k-1}，而b_k=a_k+k&gt;a_{k-1}+k-1=b_{k-1}&gt;a_{k-1}$<br>所以性质1。成立。<br><strong>b.任意操作都可将奇异局势变为非奇异局势</strong><br>事实上，若只改变奇异局势$(a_k，b_k)$的某一个分量，那么另一个分量不可能在其他奇异局势中，所以必然是非奇异局势。如果使$(a_k，b_k)$的两个分量同时减少，则由于其差不变，且不可能是其他奇异局势的差，因此也是非奇异局势。<br><strong>c.采用适当的方法，可以将非奇异局势变为奇异局势</strong><br>假设面对的局势是(a,b)，<br>1.如果 b = a，则同时从两堆中取走 a 个物体，就变为了奇异局势（0，0）；<br>2.如果$a = a_k ，b &gt; b_k$，那么，取走$b - b_k$个物体，即变为奇异局势；<br>3.如果 $a = a_k，a_k &lt; b &lt; b_k$ ,则令$m=b-a_k &lt; k$,同时从两堆中拿走$a_k-a_m$个物体,变为奇异局势$(a_m, a_m + m)$；<br>4.如果$a = a_k，b &lt; a_k$ ,则令$m=a_k - b$,<br>①m &lt; k，则两边同时拿走$b-a_m$，变为奇异局势$(m+a_m,a_m)$<br>②m &gt; k，则b必在前面的局势中出现过，因为$a_k$是之前没出现过的最小的数，且$b &lt; a_k$,所以：<br>a. $b=a_j(j &lt; k)$,则从左边拿走$a_k-b_j$，变成奇异局势$(b_j,a_j)$<br>b. $b=b_j(j &lt; k)$,则从左边拿走$a_k-a_j$，变成奇异局势$(a_j,b_j)$<br>5.如果$a &gt; a_k，b= a_k + k$,则从第一堆中拿走多余的数量$a - a_k$ 即可；<br>6.如果$a &lt; a_k，b= a_k + k$<br>① $a=a_j (j &lt; k)$,从第二堆里面拿走$b - b_j$ 即可；<br>② $a=b_j (j &lt; k)$,从第二堆里面拿走$b - a_j$ 即可。</p>
<p>那么任给一个局势(a,b)，怎样判断它是不是奇异局势呢？公式如下：<br>$a_k=\left[k\cdot\frac{\left(1+\sqrt 5\right)}{2}\right]$<br>$b_k=a_k+k(k=0,1,2,…,n,[]代表取整函数)$<br><strong>3.算法实现</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Wythoff_Game</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">  {</span><br><span class="line">    swap(a,b);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">floor</span>((b - a)* (<span class="number">1</span> + <span class="built_in">sqrt</span>(<span class="number">5</span>)) / <span class="number">2</span>) == a)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">return</span> fasle; <span class="comment">//奇异局势</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//非奇异局势</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="斐波那契博弈（Fibonacci-Game）"><a href="#斐波那契博弈（Fibonacci-Game）" class="headerlink" title="斐波那契博弈（Fibonacci Game）"></a>斐波那契博弈（Fibonacci Game）</h2><p><strong>1.QUESTION</strong><br>有一堆个数为n的石子，游戏双方轮流取石子，满足：<br>（1）先手不能第一次把所有的石子取完；<br>（2）之后每次可以取的石子数介于1到对手刚取的石子数的2倍之间（包含1和对手刚取的石子数的2倍）。约定取走最后一个石子的人为赢家。<br><strong>2.解题思路</strong><br>当n为Fibonacci(0、1、1、2、3、5、8、13、21)数时，先手必败。即存在先手的必败态当且仅当石头个数为Fibonacci数。<br>证明：<br>根据“Zeckendorf定理”（齐肯多夫定理）：任何正整数可以表示为若干个不连续的Fibonacci数之和。如n=83 = 55+21+5+2，我们看看这个分解有什么指导意义：假如先手取2颗，那么后手无法取5颗或更多，而5是一个Fibonacci数，那么一定是先手取走这5颗石子中的最后一颗，同理，接下去先手取走接下来的后21颗中的最后一颗，再取走后55颗中的最后一颗，那么先手赢。<br><strong>3.算法实现</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  a[<span class="number">0</span>]=<span class="number">0</span>,a[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">  {</span><br><span class="line">    a[i]=a[i<span class="number">-1</span>]+a[i<span class="number">-2</span>];</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Fibonacci_Game</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span>(a[i]==n)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//奇异局势</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>参考</strong><br><a href="http://www.cnblogs.com/wujiechao/p/5365039.html" target="_blank" rel="noopener">博弈论的总结</a></p>
<h2 id="Good-Luck-in-CET-4-Everybody"><a href="#Good-Luck-in-CET-4-Everybody" class="headerlink" title="Good Luck in CET-4 Everybody!"></a>Good Luck in CET-4 Everybody!</h2><p><strong>Problem Description</strong><br>大学英语四级考试就要来临了，你是不是在紧张的复习？也许紧张得连短学期的ACM都没工夫练习了，反正我知道的Kiki和Cici都是如此。当然，作为在考场浸润了十几载的当代大学生，Kiki和Cici更懂得考前的放松，所谓“张弛有道”就是这个意思。这不，Kiki和Cici在每天晚上休息之前都要玩一会儿扑克牌以放松神经。<br>“升级”？“双扣”？“红五”？还是“斗地主”？<br>当然都不是！那多俗啊~<br>作为计算机学院的学生，Kiki和Cici打牌的时候可没忘记专业，她们打牌的规则是这样的：<br>1.总共n张牌;<br>2.双方轮流抓牌；<br>3.每人每次抓牌的个数只能是2的幂次（即：1，2，4，8，16…）<br>4.抓完牌，胜负结果也出来了：最后抓完牌的人为胜者；<br>假设Kiki和Cici都是足够聪明（其实不用假设，哪有不聪明的学生~），并且每次都是Kiki先抓牌，请问谁能赢呢？<br>当然，打牌无论谁赢都问题不大，重要的是马上到来的CET-4能有好的状态。<br>Good luck in CET-4 everybody!<br><strong>Input</strong><br>输入数据包含多个测试用例，每个测试用例占一行，包含一个整数n(1&lt;=n&lt;=1000)。<br><strong>Output</strong><br>如果Kiki能赢的话，晴输出“Kiki”，否则请输出“Cici”，每个实例的输出占一行。<br><strong>Sample Input</strong><br>1<br>3<br><strong>Sample Output</strong><br>Kiki<br>Cici<br><strong>Procedure</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：Good Luck in CET-4 Everybody!.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">博弈论，找规律</span></span><br><span class="line"><span class="comment">n为3的倍数时，后手必胜</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.09.26</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Judge</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">//判断是否先手胜</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (n%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (Judge(n))</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"Kiki"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cici"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Stone"><a href="#Stone" class="headerlink" title="Stone"></a>Stone</h2><p><strong>Problem Description</strong><br>Tang and Jiang are good friends. To decide whose treat it is for dinner, they are playing a game. Specifically, Tang and Jiang will alternatively write numbers (integers) on a white board. Tang writes first, then Jiang, then again Tang, etc… Moreover, assuming that the number written in the previous round is X, the next person who plays should write a number Y such that 1 &lt;= Y - X &lt;= k. The person who writes a number no smaller than N first will lose the game. Note that in the first round, Tang can write a number only within range [1, k] (both inclusive). You can assume that Tang and Jiang will always be playing optimally, as they are both very smart students.<br><strong>Input</strong><br>There are multiple test cases. For each test case, there will be one line of input having two integers N (0 &lt; N &lt;= 10^8) and k (0 &lt; k &lt;= 100). Input terminates when both N and k are zero.<br><strong>Output</strong><br>For each case, print the winner’s name in a single line.<br><strong>Sample Input</strong><br>1 1<br>30 3<br>10 2<br>0 0<br><strong>Sample Output</strong><br>Jiang<br>Tang<br>Jiang<br><strong>Procedure</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：Stone.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">巴什博奕：</span></span><br><span class="line"><span class="comment">两人分别报数，先报到不小于N的人输</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.09.26</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &amp;&amp; (n != <span class="number">0</span> || k != <span class="number">0</span>))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> ((n - <span class="number">1</span>) % (k + <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"Jiang"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"Tang"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="取石子游戏"><a href="#取石子游戏" class="headerlink" title="取石子游戏"></a>取石子游戏</h2><p><strong>Problem Description</strong><br>有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。<br><strong>Input</strong><br>输入包含若干行，表示若干种石子的初始情况，其中每一行包含两个非负整数a和b，表示两堆石子的数目，a和b都不大于1,000,000,000。<br><strong>Output</strong><br>输出对应也有若干行，每行包含一个数字1或0，如果最后你是胜者，则为1，反之，则为0。<br><strong>Sample Input</strong><br>2 1<br>8 4<br>4 7<br><strong>Sample Output</strong><br>0<br>1<br>0<br><strong>Procedure</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：取石子游戏.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">威佐夫博弈</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.09.26</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (a &gt; b)</span><br><span class="line">		{</span><br><span class="line">			swap(a, b);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">floor</span>((b - a)* (<span class="number">1</span> + <span class="built_in">sqrt</span>(<span class="number">5</span>)) / <span class="number">2</span>) == a)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Being-a-Good-Boy-in-Spring-Festival"><a href="#Being-a-Good-Boy-in-Spring-Festival" class="headerlink" title="Being a Good Boy in Spring Festival"></a>Being a Good Boy in Spring Festival</h2><p><strong>Problem Description</strong><br>下面是一个二人小游戏：桌子上有M堆扑克牌；每堆牌的数量分别为Ni(i=1…M)；两人轮流进行；每走一步可以任意选择一堆并取走其中的任意张牌；桌子上的扑克全部取光，则游戏结束；最后一次取牌的人为胜者。<br>现在我们不想研究到底先手为胜还是为负，我只想问大家：<br>——“先手的人如果想赢，第一步有几种选择呢？”<br><strong>Input</strong><br>输入数据包含多个测试用例，每个测试用例占2行，首先一行包含一个整数M(1&lt;M&lt;=100)，表示扑克牌的堆数，紧接着一行包含M个整数Ni(1&lt;=Ni&lt;=1000000，i=1…M)，分别表示M堆扑克的数量。M为0则表示输入数据的结束。<br><strong>Output</strong><br>如果先手的人能赢，请输出他第一步可行的方案数，否则请输出0，每个实例的输出占一行。<br><strong>Sample Input</strong><br>3<br>5 7 9<br>0<br><strong>Sample Output</strong><br>1<br><strong>Procedure</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：Being a Good Boy in Spring Festival.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">威佐夫博弈</span></span><br><span class="line"><span class="comment">先手如果想赢，可行的几种方案，即从N状态进入P状态的方案数。</span></span><br><span class="line"><span class="comment">根据三条基本性质：必然能从N走到P</span></span><br><span class="line"><span class="comment">那么flag^=a[1]^...a[n]</span></span><br><span class="line"><span class="comment">只需找到a[i]中与flag最高位同为1，并且a[i]&gt;flag^a[i],因为有可能有flag值的最高位并不是在ai中，譬如flag=1,10^flag&gt;10.</span></span><br><span class="line"><span class="comment">当flag==0,a[i]≯flag^a[i]，a[i]==0,flag^a[i]==0,a[i]!=0,flag^a[i]==1</span></span><br><span class="line"><span class="comment">当flag==1,a[i]＞flag^a[i]，才有可能的方案</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">即找出与k最高位同位1的a[i]的个数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.09.26</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> m, a[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; m&amp;&amp;m != <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">			flag ^= a[i];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">		{</span><br><span class="line">			num += (a[i] &gt; (flag^a[i]));</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2012-蓝桥杯-取球博弈"><a href="#2012-蓝桥杯-取球博弈" class="headerlink" title="2012 蓝桥杯 取球博弈"></a>2012 蓝桥杯 取球博弈</h2><p>取球博弈<br>今盒子里有n个小球，A、B两人轮流从盒中取球，每个人都可以看到另一个人取了多少个，也可以看到盒中还剩下多少个，并且两人都很聪明，不会做出错误的判断。<br>我们约定：<br>每个人从盒子中取出的球的数目必须是：1，3，7或者8个。<br>轮到某一方取球时不能弃权！<br>A先取球，然后双方交替取球，直到取完。<br>被迫拿到最后一个球的一方为负方（输方）<br>请编程确定出在双方都不判断失误的情况下，对于特定的初始球数，A是否能赢？<br>程序运行时，从标准输入获得数据，其格式如下：<br>先是一个整数n(n&lt;100)，表示接下来有n个整数。然后是n个整数，每个占一行（整数&lt;10000），表示初始球数。<br>程序则输出n行，表示A的输赢情况（输为0，赢为1）。<br>例如，用户输入：<br>４<br>１<br>２<br>10<br>18<br>则程序应该输出：<br>0<br>1<br>1<br>0<br><strong>程序</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">逆推，最后一次能够拿完为负</span></span><br><span class="line"><span class="comment">那么，对应于1 3 7 8四种取法</span></span><br><span class="line"><span class="comment">1.逻辑推导结论：</span></span><br><span class="line"><span class="comment">最后那个人取走了球，那么他取球的时候，盒子里面有几个球呢？</span></span><br><span class="line"><span class="comment">如果盒子里面是1个球，必然输掉</span></span><br><span class="line"><span class="comment">2个，拿1个，赢</span></span><br><span class="line"><span class="comment">如果盒子里面是3个球，必然输掉</span></span><br><span class="line"><span class="comment">4个，拿3个，赢</span></span><br><span class="line"><span class="comment">如果盒子里面是5个球，必然输掉</span></span><br><span class="line"><span class="comment">6个，拿3，赢</span></span><br><span class="line"><span class="comment">如果盒子里面是7个球，必然输掉</span></span><br><span class="line"><span class="comment">如果盒子里面是8个球，必然赢(可以拿7个)</span></span><br><span class="line"><span class="comment">如果盒子里面是9个球，必然赢（可以拿8个）</span></span><br><span class="line"><span class="comment">如果盒子里面是10个，必然赢(可以拿7个)</span></span><br><span class="line"><span class="comment">如果盒子里面是11个，必然赢(可以拿8个)</span></span><br><span class="line"><span class="comment">如果盒子里面是12个，必然赢(可以拿7个)</span></span><br><span class="line"><span class="comment">如果盒子里面是13个，必然赢(可以拿8个)</span></span><br><span class="line"><span class="comment">如果盒子里面是14个，必然赢(可以拿7个)</span></span><br><span class="line"><span class="comment">如果盒子里面是15个，必然赢(可以拿8个)</span></span><br><span class="line"><span class="comment">如果盒子里面是16个，必然输(拿1,3,7,8都陷入到对方必然赢的情况)</span></span><br><span class="line"><span class="comment">如果盒子里面是17个，拿1个,必然赢</span></span><br><span class="line"><span class="comment">如果盒子里面是18个，必然输(拿1,3,7,8都陷入到对方必然赢的情况）。</span></span><br><span class="line"><span class="comment">如果盒子里面是19个，拿1个必然赢。</span></span><br><span class="line"><span class="comment">如果盒子里面是20个，必然输(拿1,3,7,8都陷入到对方必然赢的情况）。</span></span><br><span class="line"><span class="comment">…</span></span><br><span class="line"><span class="comment">后面继续陷入上述讨论情况</span></span><br><span class="line"><span class="comment">这就变成了一个以15为周期的扩展！</span></span><br><span class="line"><span class="comment">结论：球的个数对 15 取余，若余数为 1、3、5、7，则先手必输</span></span><br><span class="line"><span class="comment">通过前趋图求解更加直观，也就是从N-Position能找到后继P-Position的话就是必赢，否则必输。</span></span><br><span class="line"><span class="comment">但是，你妈，巴仕博弈用前趋图好推，毕竟连续区间，这种离散的取法规律太难找了吧？还是我太蠢，还是没找到</span></span><br><span class="line"><span class="comment">根本的规律？！！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Judge</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> temp = x % <span class="number">15</span>;</span><br><span class="line">	<span class="keyword">if</span> (temp == <span class="number">1</span> || temp == <span class="number">3</span> || temp == <span class="number">5</span> || temp == <span class="number">7</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>{  </span><br><span class="line">    <span class="keyword">int</span> n;  </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;  </span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;n; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; Judge(x) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="第七章-高级搜索算法"><a href="#第七章-高级搜索算法" class="headerlink" title="第七章 高级搜索算法"></a>第七章 高级搜索算法</h1></blockquote>
<h2 id="A算法"><a href="#A算法" class="headerlink" title="A算法"></a>A算法</h2><p><strong>启发式搜索</strong><br>启发式搜索就是在状态空间中的搜索对每一个搜索的位置进行评估，得到最好的位置，再从这个位置进行搜索直到目标。这样可以省略大量无畏的搜索路径，提到了效率。在启发式搜索中，对位置的估价是十分重要的。采用了不同的估价可以有不同的效果。<br><strong>估价函数</strong><br>从当前节点移动到目标节点的预估费用；这个估计就是启发式的。在寻路问题和迷宫问题中，我们通常用曼哈顿（manhattan）估价函数（下文有介绍）预估费用。<br><strong>A算法与BFS</strong><br>可以这样说，BFS是A*算法的一个特例。对于一个BFS算法，从当前节点扩展出来的每一个节点（如果没有被访问过的话）都要放进队列进行进一步扩展。也就是说BFS的估计函数h永远等于0，没有一点启发式的信息，可以认为BFS是“最烂的”A*算法。<br><strong>选取最小估价</strong><br>如果学过数据结构的话，应该可以知道，对于每次都要选取最小估价的节点，应该用到最小优先级队列（也叫最小二叉堆）。在C++的STL里有现成的数据结构priority_queue，可以直接使用。当然不要忘了重载自定义节点的比较操作符。<br><strong>A算法的特点</strong><br>A算法在理论上是时间最优的，但是也有缺点：它的空间增长是指数级别的。<br><strong>搜索区域</strong><br>假设有人想从A点移动到一墙之隔的B点，如下图，绿色的是起点A，红色是终点B，蓝色方块是中间的墙。<br><img src="/assets/img/algorithm/A-Star-01.jpg" alt="A-Star01图示"><br>你应该注意到了，我们把要搜寻的区域划分成了正方形的格子。这是寻路的第一步，简化搜索区域，就像我们这里做的一样。这个特殊的方法把我们的搜索区域简化为了 2 维数组。数组的每一项代表一个格子，它的状态就是可走 (walkalbe) 和不可走 (unwalkable) 。通过计算出从 A 到 B需要走过哪些方格，就找到了路径。一旦路径找到了，人物便从一个方格的中心移动到另一个方格的中心，直至到达目的地。</p>
<p>方格的中心点我们成为“节点 (nodes) ”。如果你读过其他关于 A* 寻路算法的文章，你会发现人们常常都在讨论节点。为什么不直接描述为方格呢？因为我们有可能把搜索区域划为为其他多变形而不是正方形，例如可以是六边形，矩形，甚至可以是任意多变形。而节点可以放在任意多边形里面，可以放在多变形的中心，也可以放在多边形的边上。我们使用这个系统，因为它最简单。<br><strong>开始搜索</strong><br>方格的中心点我们成为“节点 (nodes) ”。如果你读过其他关于 A* 寻路算法的文章，你会发现人们常常都在讨论节点。为什么不直接描述为方格呢？因为我们有可能把搜索区域划为为其他多变形而不是正方形，例如可以是六边形，矩形，甚至可以是任意多变形。而节点可以放在任意多边形里面，可以放在多变形的中心，也可以放在多边形的边上。我们使用这个系统，因为它最简单。<br>我们这样开始我们的寻路旅途：<br>1.从起点 A 开始，并把它就加入到一个由方格组成的 open list( 开放列表 ) 中。这个 open list 有点像是一个购物单。当然现在 open list 里只有一项，它就是起点 A ，后面会慢慢加入更多的项。 Open list 里的格子是路径可能会是沿途经过的，也有可能不经过。基本上 open list 是一个待检查的方格列表。</p>
<p>2.查看与起点 A 相邻的方格 ( 忽略其中墙壁所占领的方格，河流所占领的方格及其他非法地形占领的方格 ) ，把其中可走的 (walkable) 或可到达的 (reachable) 方格也加入到 open list 中。把起点 A 设置为这些方格的父亲 (parent node 或 parent square) 。当我们在追踪路径时，这些父节点的内容是很重要的。稍后解释。</p>
<p>3.把 A 从 open list 中移除，加入到 close list( 封闭列表 ) 中， close list 中的每个方格都是现在不需要再关注的。</p>
<p>如下图所示，深绿色的方格为起点，它的外框是亮蓝色，表示该方格被加入到了 close list 。与它相邻的黑色方格是需要被检查的，他们的外框是亮绿色。每个黑方格都有一个灰色的指针指向他们的父节点，这里是起点 A 。<br><img src="/assets/img/algorithm/A-Star-02.jpg" alt="A-Star02图示"></p>
<p>接着，我们选择开启列表中的临近方格，大致重复前面的过程，如下。但是，哪个方格是我们要选择的呢？是那个F值最低的。</p>
<p><strong>路径排序</strong><br>计算出组成路径的方格的关键是下面这个等式：<br>F = G + H<br>这里，<br>G = 从起点 A 移动到指定方格的移动代价，沿着到达该方格而生成的路径。<br>H = 从指定的方格移动到终点 B 的估算成本。这经常被称为启发式的，可能会让你有点迷惑。这样叫的原因是因为它只是个猜测。我们没办法事先知道路径的长度，因为路上可能存在各种障碍(墙，水，等等)。虽然本文只提供了一种计算H的方法，但是你可以在网上找到很多其他的方法。</p>
<p>这个通常被称为试探法，有点让人混淆。为什么这么叫呢，因为这是个猜测。直到我们找到了路径我们才会知道真正的距离，因为途中有各种各样的东西 ( 比如墙壁，水等 ) 。本教程将教你一种计算 H 的方法，你也可以在网上找到其他方法。</p>
<p>我们的路径是这么产生的：反复遍历 open list ，选择 F 值最小的方格。这个过程稍后详细描述。我们还是先看看怎么去计算上面的等式。</p>
<p>如上所述， G 是从起点Ａ移动到指定方格的移动代价。在本例中，横向和纵向的移动代价为 10 ，对角线的移动代价为 14 。之所以使用这些数据，是因为实际的对角移动距离是 2 的平方根，或者是近似的 1.414 倍的横向或纵向移动代价。使用 10 和 14 就是为了简单起见。比例是对的，我们避免了开放和小数的计算。这并不是我们没有这个能力或是不喜欢数学。使用这些数字也可以使计算机更快。稍后你便会发现，如果不使用这些技巧，寻路算法将很慢。</p>
<p>既然我们是沿着到达指定方格的路径来计算 G 值，那么计算出该方格的 G 值的方法就是找出其父亲的 G 值，然后按父亲是直线方向还是斜线方向加上 10 或 14 。随着我们离开起点而得到更多的方格，这个方法会变得更加明朗。</p>
<p>有很多方法可以估算 H 值。这里我们使用 Manhattan 方法，计算从当前方格横向或纵向移动到达目标所经过的方格数，忽略对角移动，然后把总数乘以 10 。之所以叫做 Manhattan 方法，是因为这很像统计从一个地点到另一个地点所穿过的街区数，而你不能斜向穿过街区。重要的是，计算 H 是，要忽略路径中的障碍物。这是对剩余距离的估算值，而不是实际值，因此才称为试探法。</p>
<p>把 G 和 H 相加便得到 F 。我们第一步的结果如下图所示。每个方格都标上了 F ， G ， H 的值，就像起点右边的方格那样，左上角是 F ，左下角是 G ，右下角是 H 。</p>
<p>好，现在让我们看看其中的一些方格。在标有字母的方格， G = 10 。这是因为水平方向从起点到那里只有一个方格的距离。与起点直接相邻的上方，下方，左方的方格的 G 值都是 10 ，对角线的方格 G 值都是 14 。</p>
<p>H 值通过估算起点于终点 ( 红色方格 ) 的 Manhattan 距离得到，仅作横向和纵向移动，并且忽略沿途的墙壁。使用这种方式，起点右边的方格到终点有 3 个方格的距离，因此 H = 30 。这个方格上方的方格到终点有 4 个方格的距离 ( 注意只计算横向和纵向距离 ) ，因此 H = 40 。对于其他的方格，你可以用同样的方法知道 H 值是如何得来的。</p>
<p>每个方格的 F 值，再说一次，直接把 G 值和 H 值相加就可以了。<br><img src="/assets/img/algorithm/A-Star-03.jpg" alt="A-Star03图示"><br><strong>继续搜索</strong><br>为了继续搜索，我们从 open list 中选择 F 值最小的 ( 方格 ) 节点，然后对所选择的方格作如下操作：</p>
<p>4.把它从 open list 里取出，放到 close list 中。<br>5.检查所有与它相邻的方格，忽略其中在 close list 中或是不可走 (unwalkable) 的方格 ( 比如墙，水，或是其他非法地形 ) ，如果方格不在open lsit 中，则把它们加入到 open list 中。把我们选定的方格设置为这些新加入的方格的父亲。<br>6.如果某个相邻的方格已经在 open list 中，则检查这条路径是否更优，也就是说经由当前方格 ( 我们选中的方格 ) 到达那个方格是否具有更小的 G 值。如果没有，不做任何操作。<br>相反，如果 G 值更小，则把那个方格的父亲设为当前方格 ( 我们选中的方格 ) ，然后重新计算那个方格的 F 值和 G 值。如果你还是很混淆，请参考下图。<br><img src="/assets/img/algorithm/A-Star-04.jpg" alt="A-Star04图示"><br>Ok ，让我们看看它是怎么工作的。在我们最初的 9 个方格中，还有 8 个在 open list 中，起点被放入了 close list 中。在这些方格中，起点右边的格子的 F 值 40 最小，因此我们选择这个方格作为下一个要处理的方格。它的外框用蓝线打亮。</p>
<p>首先，我们把它从 open list 移到 close list 中 ( 这就是为什么用蓝线打亮的原因了 ) 。然后我们检查与它相邻的方格。它右边的方格是墙壁，我们忽略。它左边的方格是起点，在 close list 中，我们也忽略。其他 4 个相邻的方格均在 open list 中，我们需要检查经由这个方格到达那里的路径是否更好，使用 G 值来判定。让我们看看上面的方格。它现在的 G 值为 14 。如果我们经由当前方格到达那里， G 值将会为 20(其中 10 为到达当前方格的 G 值，此外还要加上从当前方格纵向移动到上面方格的 G 值 10) 。显然 20 比 14 大，因此这不是最优的路径。如果你看图你就会明白。直接从起点沿对角线移动到那个方格比先横向移动再纵向移动要好。</p>
<p>当把 4 个已经在 open list 中的相邻方格都检查后，没有发现经由当前方格的更好路径，因此我们不做任何改变。现在我们已经检查了当前方格的所有相邻的方格，并也对他们作了处理，是时候选择下一个待处理的方格了。</p>
<p>因此再次遍历我们的 open list ，现在它只有 7 个方格了，我们需要选择 F 值最小的那个。有趣的是，这次有两个方格的 F 值都 54 ，选哪个呢？没什么关系。从速度上考虑，选择最后加入 open list 的方格更快。这导致了在寻路过程中，当靠近目标时，优先使用新找到的方格的偏好。但是这并不重要。 ( 对相同数据的不同对待，导致两中版本的 A* 找到等长的不同路径 ) 。</p>
<p>我们选择起点右下方的方格，如下图所示。<br><img src="/assets/img/algorithm/A-Star-05.jpg" alt="A-Star05图示"><br>这次，当我们检查相邻的方格时，我们发现它右边的方格是墙，忽略之。上面的也一样。</p>
<p>我们把墙下面的一格也忽略掉。为什么？因为如果不穿越墙角的话，你不能直接从当前方格移动到那个方格。你需要先往下走，然后再移动到那个方格，这样来绕过墙角。 ( 注意：穿越墙角的规则是可选的，依赖于你的节点是怎么放置的 )</p>
<p>这样还剩下 5 个相邻的方格。当前方格下面的 2 个方格还没有加入 open list ，所以把它们加入，同时把当前方格设为他们的父亲。在剩下的3 个方格中，有 2 个已经在 close list 中 ( 一个是起点，一个是当前方格上面的方格，外框被加亮的 ) ，我们忽略它们。最后一个方格，也就是当前方格左边的方格，我们检查经由当前方格到达那里是否具有更小的 G 值。没有。因此我们准备从 open list 中选择下一个待处理的方格。</p>
<p>不断重复这个过程，直到把终点也加入到了 open list 中，此时如下图所示。<br><img src="/assets/img/algorithm/A-Star-06.jpg" alt="A-Star06图示"><br>注意，在起点下面 2 格的方格的父亲已经与前面不同了。之前它的 G 值是 28 并且指向它右上方的方格。现在它的 G 值为 20 ，并且指向它正上方的方格。这在寻路过程中的某处发生，使用新路径时 G 值经过检查并且变得更低，因此父节点被重新设置， G 和 F 值被重新计算。尽管这一变化在本例中并不重要，但是在很多场合中，这种变化会导致寻路结果的巨大变化。</p>
<p>那么我们怎么样去确定实际路径呢？很简单，从终点开始，按着箭头向父节点移动，这样你就被带回到了起点，这就是你的路径。如下图所示。从起点 A 移动到终点 B 就是简单从路径上的一个方格的中心移动到另一个方格的中心，直至目标。就是这么简单！<br><img src="/assets/img/algorithm/A-Star-07.jpg" alt="A-Star07图示"><br><strong>A方法总结</strong><br>好，现在你已经看完了整个说明，让我们把每一步的操作写在一起：<br>1.把起始格添加到开启列表。<br>2.重复如下的工作：<br> a)寻找开启列表中F值最低的格子。我们称它为当前格。<br> b)把它切换到关闭列表。<br> c)对相邻的格中的每一个？</p>
<ul>
<li>如果它不可通过或者已经在关闭列表中，略过它。反之如下。</li>
<li>如果它不在开启列表中，把它添加进去。把当前格作为这一格的父节点。记录这一格的F,G,和H值。</li>
<li>如果它已经在开启列表中，用G值为参考检查新的路径是否更好。更低的G值意味着更好的路径。如果是这样，就把这一格的父节点改成当前格，并且重新计算这一格的G和F值。如果你保持你的开启列表按F值排序，改变之后你可能需要重新对开启列表排序。<br>d)停止，当你</li>
<li>把目标格添加进了关闭列表(注解)，这时候路径被找到，或者</li>
<li>没有找到目标格，开启列表已经空了。这时候，路径不存在。<br>3.保存路径。从目标格开始，沿着每一格的父节点移动直到回到起始格。这就是你的路径。<br><strong>参考</strong><br><a href="http://www.cppblog.com/mythit/archive/2009/04/19/80492.aspx" target="_blank" rel="noopener">A*算法入门</a><h2 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h2><ul>
<li>最近又对A算法有了更深理解，来补充补充</li>
<li>在BFS算法中，若对每个状态n都设定估价函数f(n)=g(n)+h(n)，并且每次从Open表中选节点进行扩展时，都选取f值最小的节点，则该搜索算法为启发式搜索算法，又称A算法。</li>
<li>g(n)：从起始状态到当前状态n的代价</li>
<li>h(n)：从当前状态n到目标状态的估价代价</li>
</ul>
<strong>A*算法</strong><ul>
<li>A算法中的估价函数若选取不当，则可能找不到解，或者找到的解也不是最优解。因此，需要对估价函数做一些限制，使得算法确保找到最优解（步数，即状态转移次数最少的解）。A*算法即为对估价函数做了特定限制，且确保找到最优解的A算法。</li>
<li>$f^*(n)=g^*(n)+h^*(n)$<br>$f^*(n)$：从初始节点$S_0$出发，经过节点n到达目标节点的最小步数（真实值）<br>$g^*(n)$：从$S_0$出发，到达n的最小步数（真实值）<br>$h^*(n)$：从n出发，到达目标节点的最小步数（真实值）<br>估价函数$f(n)$是$f^*(n)$的估计值。</li>
<li>$f(n)=g(n)+h(n)$，且满足以下限制：</li>
<li>$g(n)$是从$s_0$到n的真实步数（未必是最优的），因此：$g(n)&gt;0且g(n)&gt;=g*(n)$</li>
<li>$h(n)$是从n到目标的估计步数。估计总是过于乐观的，即$h(n)&lt;=h*(n)$，且$h(n)$相容，则A算法转变为A*算法。证明暂无。</li>
<li>$h(n)$的相容：<br>如果h函数对任意状态s_1和s_2还满足：<br>$h(s_1)&lt;=h(s_2)+c(s_1,s_2)$<br>$c(s_1,s_2)$是$s_1$转移到$s_2$的步数，则称h是相容的。<br>h相容能确保随着一步步往前组，f递增，这样A*能更高效找到最优解。<br>h相容$\Rightarrow g(s_1)+h(s_1)&lt;=g(s_1)+h(s_2)+c(s_1,s_2)=g(s_2)+h(s_2)\Rightarrow f(s_1)&lt;=f(s_2)$ 即f是递增的。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>A*算法的搜索效率很大程度上取决于估价函数h(n)。一般来说，在满足h(n)&lt;=h^*(n)的前提下，h(n)越大越好</strong></li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">open=[Start]</span><br><span class="line">closed=[]</span><br><span class="line"><span class="keyword">while</span> open 不为空</span><br><span class="line">{</span><br><span class="line">  从open中取出估价f最小的节点n</span><br><span class="line">  <span class="keyword">if</span> n== Target Then</span><br><span class="line">    <span class="keyword">return</span> 从Start到n的路径找到了</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">for</span> n的每个子节点x</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span> x in open</span><br><span class="line">      {</span><br><span class="line">        计算新的f(x)</span><br><span class="line">        比较open表中的旧的f(x)和新的f(x)</span><br><span class="line">        <span class="keyword">if</span> 新f(x)&lt;旧f(x)</span><br><span class="line">        {</span><br><span class="line">          删掉open表里的旧f(x)，加入新f(x)</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> x in closed</span><br><span class="line">      {</span><br><span class="line">        计算新的f(x)</span><br><span class="line">        比较closed表中的旧f(x)和新f(x)</span><br><span class="line">        <span class="keyword">if</span> 新f(x)&lt;旧f(x)</span><br><span class="line">        {</span><br><span class="line">           remove x from closed</span><br><span class="line">           add x to open</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      {</span><br><span class="line">        <span class="comment">//不在open 也不再closed，遇到的是新节点</span></span><br><span class="line">        计算f(x)</span><br><span class="line">        add x to open</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    add n to closed</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//open表尾空表示搜索结束，那就意味无解！</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="Knight-Moves"><a href="#Knight-Moves" class="headerlink" title="Knight Moves"></a>Knight Moves</h2><p><strong>Description</strong><br>A friend of you is doing research on the Traveling Knight Problem (TKP) where you are to find the shortest closed tour of knight moves that visits each square of a given set of n squares on a chessboard exactly once. He thinks that the most difficult part of the problem is determining the smallest number of knight moves between two given squares and that, once you have accomplished this, finding the tour would be easy.<br>Of course you know that it is vice versa. So you offer him to write a program that solves the “difficult” part.<br>Your job is to write a program that takes two squares a and b as input and then determines the number of knight moves on a shortest route from a to b.<br><strong>Input</strong><br>The input will contain one or more test cases. Each test case consists of one line containing two squares separated by one space. A square is a string consisting of a letter (a-h) representing the column and a digit (1-8) representing the row on the chessboard.<br><strong>Output</strong><br>For each test case, print one line saying “To get from xx to yy takes n knight moves.”.<br><strong>Sample Input</strong><br>e2 e4<br>a1 b2<br>b2 c3<br>a1 h8<br>a1 h7<br>h8 a1<br>b1 c3<br>f6 f6<br><strong>Sample Output</strong><br>To get from e2 to e4 takes 2 knight moves.<br>To get from a1 to b2 takes 4 knight moves.<br>To get from b2 to c3 takes 2 knight moves.<br>To get from a1 to h8 takes 6 knight moves.<br>To get from a1 to h7 takes 5 knight moves.<br>To get from h8 to a1 takes 6 knight moves.<br>To get from b1 to c3 takes 1 knight moves.<br>To get from f6 to f6 takes 0 knight moves.<br><strong>Procedure</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：Knight_Moves.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">A*算法模板题</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">关于本题似乎没有更新或比较值钱加入open list里的节点的G值：</span></span><br><span class="line"><span class="comment">每次当前节点检查子节点的时候，都会重新计算,而且采用了优先队列，那么原先节点的g值减少的，f值也减少，因为h值不变，</span></span><br><span class="line"><span class="comment">加入优先队列后，按f值升序排练，f值越小越优先，虽然也加入了重复节点，但是没关系，之后先pop的是f值更小的一个，pop后随即加入close list</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这题没必要记录父节点，如果结果输出的是路径，那么必须记录，这和之前的广搜题目很类似，不再累述。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意这里选择的估价不是用步数而是距离</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">因为A*的搜索效率取决于h，并且要求h比h*小且尽可能大</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果选用步骤递增g，那么h采用曼哈顿距离的时候h不满足比h*小了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">所以采用距离估价的时候，满足A*对A的限制条件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.09.26</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Knight</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">	<span class="keyword">int</span> step;</span><br><span class="line">	<span class="keyword">int</span> g, h, f;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Knight &amp;k)<span class="keyword">const</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> f &gt; k.f;</span><br><span class="line">	}</span><br><span class="line">	Knight() {};</span><br><span class="line">	Knight(<span class="keyword">int</span> xx, <span class="keyword">int</span> yy, <span class="keyword">int</span> st, <span class="keyword">int</span> gg, <span class="keyword">int</span> hh, <span class="keyword">int</span> ff)</span><br><span class="line">		:x(xx), y(yy), step(st), g(gg), h(hh), f(ff) {}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">bool</span> visited[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> Knight_x1, Knight_y1, Knight_x2, Knight_y2, ans;<span class="comment">//起点(x1,y1),终点(x2,y2)，最少移动次数ans</span></span><br><span class="line"><span class="keyword">int</span> Step[<span class="number">8</span>][<span class="number">2</span>] =</span><br><span class="line">{</span><br><span class="line">	<span class="number">-2</span>,<span class="number">-1</span>,</span><br><span class="line">	<span class="number">-2</span>, <span class="number">1</span>,</span><br><span class="line">	<span class="number">-1</span>,<span class="number">-2</span>,</span><br><span class="line">	<span class="number">-1</span>, <span class="number">2</span>,</span><br><span class="line">	 <span class="number">1</span>,<span class="number">-2</span>,</span><br><span class="line">	 <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">	 <span class="number">2</span>,<span class="number">-1</span>,</span><br><span class="line">	 <span class="number">2</span>, <span class="number">1</span>,</span><br><span class="line">};</span><br><span class="line">priority_queue&lt;Knight&gt; que;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Judge</span><span class="params">(<span class="keyword">const</span> Knight &amp;a)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (a.x &lt; <span class="number">0</span> || a.y &lt; <span class="number">0</span> || a.x &gt;= <span class="number">8</span> || a.y &gt;= <span class="number">8</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Heuristic</span><span class="params">(<span class="keyword">const</span> Knight &amp;a)</span> <span class="comment">//Manhattan估价函数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">int</span>)(<span class="built_in">abs</span>(a.x - Knight_x2) + <span class="built_in">abs</span>(a.y - Knight_y2)) * <span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function">Status <span class="title">A_Star</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span> (!que.empty())</span><br><span class="line">	{</span><br><span class="line">		Knight t = que.top();</span><br><span class="line">		que.pop();</span><br><span class="line">		visited[t.x][t.y] = <span class="literal">true</span>; <span class="comment">//关键！！！取出来后才加入close list</span></span><br><span class="line">		<span class="keyword">if</span> (t.x == Knight_x2&amp;&amp;t.y == Knight_y2)</span><br><span class="line">		{</span><br><span class="line">			ans = t.step;</span><br><span class="line">			<span class="keyword">return</span> OK;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">		{</span><br><span class="line">			Knight s;</span><br><span class="line">			s.x = t.x + Step[i][<span class="number">0</span>];</span><br><span class="line">			s.y = t.y + Step[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (Judge(s) &amp;&amp; !visited[s.x][s.y])</span><br><span class="line">			{</span><br><span class="line">				s.g = t.g + <span class="number">23</span>;<span class="comment">//23表示根号5乘以10再取ceil</span></span><br><span class="line">				s.h = Heuristic(s);</span><br><span class="line">				s.step = t.step + <span class="number">1</span>;</span><br><span class="line">				s.f = s.g + s.h;</span><br><span class="line">				que.push(s);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">char</span> line[<span class="number">6</span>];</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span>.getline(line, <span class="number">6</span>))</span><br><span class="line">	{</span><br><span class="line">		Knight_x1 = line[<span class="number">0</span>] - <span class="string">'a'</span>;</span><br><span class="line">		Knight_y1 = line[<span class="number">1</span>] - <span class="string">'1'</span>;</span><br><span class="line">		Knight_x2 = line[<span class="number">3</span>] - <span class="string">'a'</span>;</span><br><span class="line">		Knight_y2 = line[<span class="number">4</span>] - <span class="string">'1'</span>;</span><br><span class="line">		<span class="built_in">memset</span>(visited, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">		Knight k;</span><br><span class="line">		k.x = Knight_x1;</span><br><span class="line">		k.y = Knight_y1;</span><br><span class="line">		k.g = k.step = <span class="number">0</span>;</span><br><span class="line">		k.h = Heuristic(k);</span><br><span class="line">		k.f = k.g + k.h;</span><br><span class="line">		que.push(k);</span><br><span class="line">		A_Star();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"To get from "</span> &lt;&lt; line[<span class="number">0</span>] &lt;&lt; line[<span class="number">1</span>] &lt;&lt; <span class="string">" to "</span>&lt;&lt;line[<span class="number">3</span>]&lt;&lt;line[<span class="number">4</span>]&lt;&lt;<span class="string">" takes "</span></span><br><span class="line">			&lt;&lt; ans &lt;&lt; <span class="string">" knight moves."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">while</span> (!que.empty())<span class="comment">//清空队列</span></span><br><span class="line">		{</span><br><span class="line">			que.pop();</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Knight</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">	<span class="keyword">int</span> step;</span><br><span class="line">	<span class="comment">//int g, h, f;</span></span><br><span class="line">	<span class="keyword">int</span> h;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Knight &amp;k)<span class="keyword">const</span></span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//return f &gt; k.f;</span></span><br><span class="line">		<span class="keyword">if</span>(step!=k.step)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> step&gt;k.step;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> h&gt;k.h;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	Knight() {};</span><br><span class="line">	Knight(<span class="keyword">int</span> xx, <span class="keyword">int</span> yy, <span class="keyword">int</span> st, <span class="keyword">int</span> hh)</span><br><span class="line">		:x(xx), y(yy), step(st),h(hh) {}</span><br><span class="line">	<span class="comment">/*Knight(int xx, int yy, int st, int gg, int hh, int ff)</span></span><br><span class="line"><span class="comment">		:x(xx), y(yy), step(st), g(gg), h(hh), f(ff) {}*/</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">bool</span> visited[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> Knight_x1, Knight_y1, Knight_x2, Knight_y2, ans;<span class="comment">//起点(x1,y1),终点(x2,y2)，最少移动次数ans</span></span><br><span class="line"><span class="keyword">int</span> Step[<span class="number">8</span>][<span class="number">2</span>] =</span><br><span class="line">{</span><br><span class="line">	<span class="number">-2</span>,<span class="number">-1</span>,</span><br><span class="line">	<span class="number">-2</span>, <span class="number">1</span>,</span><br><span class="line">	<span class="number">-1</span>,<span class="number">-2</span>,</span><br><span class="line">	<span class="number">-1</span>, <span class="number">2</span>,</span><br><span class="line">	 <span class="number">1</span>,<span class="number">-2</span>,</span><br><span class="line">	 <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">	 <span class="number">2</span>,<span class="number">-1</span>,</span><br><span class="line">	 <span class="number">2</span>, <span class="number">1</span>,</span><br><span class="line">};</span><br><span class="line">priority_queue&lt;Knight&gt; que;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Judge</span><span class="params">(<span class="keyword">const</span> Knight &amp;a)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (a.x &lt; <span class="number">0</span> || a.y &lt; <span class="number">0</span> || a.x &gt;= <span class="number">8</span> || a.y &gt;= <span class="number">8</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Heuristic</span><span class="params">(<span class="keyword">const</span> Knight &amp;a)</span> <span class="comment">//Manhattan估价函数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">int</span>)(<span class="built_in">abs</span>(a.x - Knight_x2) + <span class="built_in">abs</span>(a.y - Knight_y2));</span><br><span class="line">}</span><br><span class="line"><span class="function">Status <span class="title">A_Star</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span> (!que.empty())</span><br><span class="line">	{</span><br><span class="line">		Knight t = que.top();</span><br><span class="line">		que.pop();</span><br><span class="line">		visited[t.x][t.y] = <span class="literal">true</span>; <span class="comment">//关键！！！取出来后才加入close list</span></span><br><span class="line">		<span class="keyword">if</span> (t.x == Knight_x2&amp;&amp;t.y == Knight_y2)</span><br><span class="line">		{</span><br><span class="line">			ans = t.step;</span><br><span class="line">			<span class="keyword">return</span> OK;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">		{</span><br><span class="line">			Knight s;</span><br><span class="line">			s.x = t.x + Step[i][<span class="number">0</span>];</span><br><span class="line">			s.y = t.y + Step[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (Judge(s) &amp;&amp; !visited[s.x][s.y])</span><br><span class="line">			{</span><br><span class="line">				<span class="comment">//s.g = t.g + 23;//23表示根号5乘以10再取ceil</span></span><br><span class="line">				s.h = Heuristic(s);</span><br><span class="line">				s.step = t.step + <span class="number">1</span>;</span><br><span class="line">				<span class="comment">//s.f = s.g + s.h;</span></span><br><span class="line">				que.push(s);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">char</span> line[<span class="number">6</span>];</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span>.getline(line, <span class="number">6</span>))</span><br><span class="line">	{</span><br><span class="line">		Knight_x1 = line[<span class="number">0</span>] - <span class="string">'a'</span>;</span><br><span class="line">		Knight_y1 = line[<span class="number">1</span>] - <span class="string">'1'</span>;</span><br><span class="line">		Knight_x2 = line[<span class="number">3</span>] - <span class="string">'a'</span>;</span><br><span class="line">		Knight_y2 = line[<span class="number">4</span>] - <span class="string">'1'</span>;</span><br><span class="line">		<span class="built_in">memset</span>(visited, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">		Knight k;</span><br><span class="line">		k.x = Knight_x1;</span><br><span class="line">		k.y = Knight_y1;</span><br><span class="line">		k.step=<span class="number">0</span>;</span><br><span class="line">		<span class="comment">//k.g = k.step = 0;</span></span><br><span class="line">		k.h = Heuristic(k);</span><br><span class="line">		<span class="comment">//k.f = k.g + k.h;</span></span><br><span class="line">		que.push(k);</span><br><span class="line">		A_Star();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"To get from "</span> &lt;&lt; line[<span class="number">0</span>] &lt;&lt; line[<span class="number">1</span>] &lt;&lt; <span class="string">" to "</span>&lt;&lt;line[<span class="number">3</span>]&lt;&lt;line[<span class="number">4</span>]&lt;&lt;<span class="string">" takes "</span></span><br><span class="line">			&lt;&lt; ans &lt;&lt; <span class="string">" knight moves."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">while</span> (!que.empty())<span class="comment">//清空队列</span></span><br><span class="line">		{</span><br><span class="line">			que.pop();</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="D-Olya-and-Energy-Drinks"><a href="#D-Olya-and-Energy-Drinks" class="headerlink" title="D. Olya and Energy Drinks"></a>D. Olya and Energy Drinks</h2><p><strong>Description</strong><br>Olya loves energy drinks. She loves them so much that her room is full of empty cans from energy drinks.<br>Formally, her room can be represented as a field of n × m cells, each cell of which is empty or littered with cans.<br>Olya drank a lot of energy drink, so now she can run k meters per second. Each second she chooses one of the four directions (up, down, left or right) and runs from 1 to k meters in this direction. Of course, she can only run through empty cells.<br>Now Olya needs to get from cell (x1, y1) to cell (x2, y2). How many seconds will it take her if she moves optimally?<br>It’s guaranteed that cells (x1, y1) and (x2, y2) are empty. These cells can coincide.<br><strong>Input</strong><br>The first line contains three integers n, m and k (1 ≤ n, m, k ≤ 1000) — the sizes of the room and Olya’s speed.<br>Then n lines follow containing m characters each, the i-th of them contains on j-th position “#”, if the cell (i, j) is littered with cans, and “.” otherwise.<br>The last line contains four integers x1, y1, x2, y2 (1 ≤ x1, x2 ≤ n, 1 ≤ y1, y2 ≤ m) — the coordinates of the first and the last cells.<br><strong>Output</strong><br>Print a single integer — the minimum time it will take Olya to get from (x1, y1) to (x2, y2).<br>If it’s impossible to get from (x1, y1) to (x2, y2), print -1.<br><strong>Examples</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">input</span><br><span class="line">3 4 4</span><br><span class="line">....</span><br><span class="line">###.</span><br><span class="line">....</span><br><span class="line">1 1 3 1</span><br><span class="line">output</span><br><span class="line">3</span><br><span class="line">input</span><br><span class="line">3 4 1</span><br><span class="line">....</span><br><span class="line">###.</span><br><span class="line">....</span><br><span class="line">1 1 3 1</span><br><span class="line">output</span><br><span class="line">8</span><br><span class="line">input</span><br><span class="line">2 2 1</span><br><span class="line">.#</span><br><span class="line">#.</span><br><span class="line">1 1 2 2</span><br><span class="line">output</span><br><span class="line">-1</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Procedue</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：Energy_Drinks.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">两层循环再加k步数，队列，貌似数据量太大</span></span><br><span class="line"><span class="comment">还是队友的A*算法思路很正确，</span></span><br><span class="line"><span class="comment">现在就来敲一敲熟悉一下。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.11.20</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="keyword">int</span> time;</span><br><span class="line">	<span class="keyword">int</span> h;<span class="comment">//估价函数</span></span><br><span class="line">	Node(<span class="keyword">int</span> x_, <span class="keyword">int</span> y_, <span class="keyword">int</span> t_, <span class="keyword">int</span> h_) :x(x_), y(y_), time(t_), h(h_) {}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Node &amp;s)<span class="keyword">const</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (time != s.time)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> time &gt; s.time;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> h &gt; s.h;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">int</span> steps[<span class="number">4</span>][<span class="number">2</span>] =</span><br><span class="line">{</span><br><span class="line">	<span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">	 <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">	 <span class="number">0</span>,<span class="number">-1</span>,</span><br><span class="line">	 <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">};<span class="comment">//上下左右</span></span><br><span class="line"><span class="keyword">int</span> N, M, K;</span><br><span class="line"><span class="keyword">int</span> startX, startY;</span><br><span class="line"><span class="keyword">int</span> endX, endY;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[MAXN][MAXN];</span><br><span class="line"><span class="keyword">bool</span> bUsed[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getH</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">abs</span>(x - endX) + <span class="built_in">abs</span>(y - endY);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= N || y &lt; <span class="number">0</span> || y &gt;= M)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">map</span>[x][y] == <span class="string">'#'</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="comment">//while (scanf("%d%d%d", &amp;N, &amp;M, &amp;K))</span></span><br><span class="line">	<span class="comment">//{</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;N, &amp;M, &amp;K);</span><br><span class="line">	<span class="built_in">memset</span>(bUsed, <span class="literal">false</span>, <span class="keyword">sizeof</span>(bUsed));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, <span class="built_in">map</span>[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;startX, &amp;startY, &amp;endX, &amp;endY);</span><br><span class="line">	startX--;</span><br><span class="line">	startY--;</span><br><span class="line">	endX--;</span><br><span class="line">	endY--;</span><br><span class="line">	priority_queue&lt;Node&gt; pq;</span><br><span class="line">	pq.push(Node(startX, startY, <span class="number">0</span>, getH(startX, startY)));</span><br><span class="line">	bUsed[startX][startY] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (!pq.empty())</span><br><span class="line">	{</span><br><span class="line">		Node tmp = pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		<span class="keyword">if</span> (tmp.x == endX&amp;&amp;tmp.y == endY)</span><br><span class="line">		{</span><br><span class="line">			result = <span class="literal">true</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tmp.time);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; j++)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">int</span> row = tmp.x + j*steps[i][<span class="number">0</span>];</span><br><span class="line">				<span class="keyword">int</span> col = tmp.y + j*steps[i][<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">if</span> (judge(row, col))</span><br><span class="line">				{</span><br><span class="line">					<span class="keyword">if</span> (!bUsed[row][col])<span class="comment">//注意不能放在judge里面判断</span></span><br><span class="line">						<span class="comment">//此题隐含条件是落脚点不能重复，但是可以穿过，跟障碍的理解不同</span></span><br><span class="line">					{</span><br><span class="line">						pq.push(Node(row, col, tmp.time + <span class="number">1</span>, getH(row, col)));</span><br><span class="line">						bUsed[row][col] = <span class="literal">true</span>;</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				{</span><br><span class="line">					<span class="keyword">break</span>;<span class="comment">//有障碍,此路不通</span></span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (pq.empty() &amp;&amp; !result)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//}</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="第八章-线段树和树状数组"><a href="#第八章-线段树和树状数组" class="headerlink" title="第八章 线段树和树状数组"></a>第八章 线段树和树状数组</h1></blockquote>
<h2 id="线段树-Interval-Tree"><a href="#线段树-Interval-Tree" class="headerlink" title="线段树(Interval Tree)"></a>线段树(Interval Tree)</h2><ul>
<li>实际上还是称为区间树更好理解一些</li>
<li>树：一棵二叉树</li>
<li>线段：树上的每个节点对应于一个线段（还是叫“区间”更容易理解，区间的起点和终点通常为整数）</li>
<li>同一层的节点所代表的区间，相互不会重叠。同一层节点所代表的区间，加起来十个连续的区间。</li>
<li>叶子节点的区间是单位长度，不能再分了。</li>
<li>线段树是一棵二叉树，树中的每一个节点表示了一个区间[a,b]。a,b通常是正数。每一个叶子节点表示了一个单位区间（长度为1）。对于每一个非叶子节点所表示的节点[a,b]，其左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2+1,b]（除法去尾取整）。<br><img src="/assets/img/algorithm/%E7%BA%BF%E6%AE%B5%E6%A0%91.png" alt="线段树图示"></li>
<li>每个区间的长度是区间内正数的个数</li>
<li>叶子节点长度为1，不能再往下分</li>
<li>若一个节点对应的区间是[a,b]，则其子节点对应的区间分别是[a,(a+b)/2]和[(a+b)/2+1,b]（除法去尾取整）</li>
</ul>
<p>$n$<br>$\frac{n}{2}\cdot2$<br>$\frac{n}{4}\cdot4$<br>…<br>$1\cdot n$<br>$\iff$<br>$n$<br>$\frac{n}{2}\cdot2$<br>$\frac{n}{2^2}\cdot2^2$<br>…<br>$1\cdot2^x$<br>$2^x=n$<br>$x=\log_2 n$</p>
<ul>
<li>线段树的平分构造，实际上是用了二分的方法。若根节点对应的区间是[a,b]，那么它的深度为$\log_2 {\left(b-a+1\right)}$（向上取整）</li>
<li>叶子节点的数目和根节点表示区间的长度相同。</li>
<li>线段树节点要么0度，要么2度，因此若叶子节点数目为N，则线段树总节点数目为2N-1。</li>
<li>若叶子节点为N，要想用连续的数组表示一棵线段树，则数组的大小应该为4N。<br> 因为，根据性质3，线段树总节点数目为2<em>N-1，又由于线段树不是完全二叉树，因此其最低的叶子一层并不是紧靠最左边，这样在其倒数第二层上的索引号接近2N的位置，按照2</em>index+1和2<em>index+2的方式来访问其左右子节点，这就导致整个数组的大小要约为 4</em>N.<h3 id="线段树的特征"><a href="#线段树的特征" class="headerlink" title="线段树的特征"></a>线段树的特征</h3></li>
</ul>
<p>1.线段树的深度不超过$\log_2 {n}+1$（向上取整，n是根节点对应区间的长度）。<br>2.线段树上，任意一个区间被分解后得到的“终止节点”数目都是$\log_2 n$量级。<br>3.线段树上更新叶子节点和进行区间分解时间复杂度都是$O\left(\log_2 {n}\right)$<br>这些结论为线段树能在$O\left(\log_2 {n}\right)$的时间内完成插入、更新、查找、统计等工作，提供了理论依据。</p>
<h3 id="线段树的构建"><a href="#线段树的构建" class="headerlink" title="线段树的构建"></a>线段树的构建</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function 以节点v为根建树、v对应区间为[l.r]</span><br><span class="line">{</span><br><span class="line">  对节点v初始化</span><br><span class="line">  <span class="keyword">if</span>(l!=r)</span><br><span class="line">  {</span><br><span class="line">    以v的左孩子为根建树，区间为[l.(l+r)/<span class="number">2</span>]</span><br><span class="line">    以v的右孩子为根建树，区间为[(l+r)/<span class="number">2</span>+<span class="number">1</span>,r]</span><br><span class="line">  }</span><br><span class="line">}<span class="comment">//时间复杂度O(n)，这一点可以运用算法导论的递归式主方法或者递归树得出，此处略，待我未来不知道哪时候觉得学得还可以了再来总结论述。</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="线段树的基本用途"><a href="#线段树的基本用途" class="headerlink" title="线段树的基本用途"></a>线段树的基本用途</h3><ul>
<li>线段树适用于和区间统计有关的问题。比如某些数据可以按区间进行划分，按区间动态进行修改，而且还需要按区间多次进行查询，那么使用线段树可以达到较快查询速度。</li>
</ul>
<h3 id="线段树应用举例"><a href="#线段树应用举例" class="headerlink" title="线段树应用举例"></a>线段树应用举例</h3><p>给你一个数的序列$A_1A_2…A_n$，并且可能多次进行下列两个操作：<br>1.对序列里面的某个数进行加减<br>2.询问这个序列里面任意一个连续的子序列的和是多少</p>
<ul>
<li>希望第2个操作每次能在$\log_2 n$</li>
<li>显然，[1,n]就是根节点对应的区间</li>
<li>可以在每个节点记录该节点对应的区间里面的数和Sum</li>
<li>对于操作1：因为序列里面$A_i$最多只会被线段树的$\log_2 n$个节点覆盖。只要求对线段树覆盖$A_i$的节点Sum进行加操作，因此复杂度是$\log_2 n$</li>
<li>对于操作2：同样只需要找到区间所覆盖的“终止”接地单，然后把所找到“终止”节点的Sum累加起来。因为这些节点的数量是$O\left(\log_2 {n}\right)$的，负责度也是$O\left(\log_2 {n}\right)$</li>
<li>如果走到节点[L,R]时，如果要查询的区间就是[L,R]，那么直接返回该节点的Sum，并累加到总的和尚</li>
<li>如果不是，则对于区间[L,R]，去mid=(L+R)/2</li>
<li>然后看要查询的区间与[L,mid]或[mid+1,R]哪个有交集，就进入哪个区间进行进一步查询</li>
<li>因为这个线段树的深度最深的LogN，所以每次遍历操作都在LogN内完成。但是常数可能很大。</li>
<li>如果是对区间所对应的一些数据进行修改，过程和查询类似。</li>
<li>用线段树解题，关键是要想清楚每个节点要存哪些信息（当然区间起终点，以及左右子节点指针是必须的），以及这些信息如何搞笑更新，维护，查询。不要一更新到叶子节点，那样更新效率最坏可能变成O(n)的了。</li>
<li>先建树，然后插入数据、更新、查询。</li>
</ul>
<h3 id="动态建树与静态建树"><a href="#动态建树与静态建树" class="headerlink" title="动态建树与静态建树"></a>动态建树与静态建树</h3><p>做A_Simple_Problem_with_Integers的时候，强迫症，想改成动态建树，测试发现居然更耗时间，而且内存反而开销更大？！！更耗时间可能了解，动态的话每次申请都得时间，内存更大就搞不懂了…</p>
<p>做了些测试，发现应该不是左右指针的问题，但是测试发现几乎内存增加了一倍，这应该不是偶然啊，但是没找到具体原因，先不管了，以后会顿悟的。</p>
<p>暂且先记住用静态建树的方法分配开始就分配内存，采用动态建树分配就比较好。<br>结合了动态建树的节点少的问题，又结合了静态建树节省时间的问题。</p>
<p>还是强迫症啊！！！！！！什么鬼！！！！</p>
<h3 id="Balanced-Lineup"><a href="#Balanced-Lineup" class="headerlink" title="Balanced Lineup"></a>Balanced Lineup</h3><p><strong>Description</strong><br>For the daily milking, Farmer John’s N cows (1 ≤ N ≤ 50,000) always line up in the same order. One day Farmer John decides to organize a game of Ultimate Frisbee with some of the cows. To keep things simple, he will take a contiguous range of cows from the milking lineup to play the game. However, for all the cows to have fun they should not differ too much in height.<br>Farmer John has made a list of Q (1 ≤ Q ≤ 200,000) potential groups of cows and their heights (1 ≤ height ≤ 1,000,000). For each group, he wants your help to determine the difference in height between the shortest and the tallest cow in the group.<br><strong>Input</strong><br>Line 1: Two space-separated integers, N and Q.<br>Lines 2..N+1: Line i+1 contains a single integer that is the height of cow i<br>Lines N+2..N+Q+1: Two integers A and B (1 ≤ A ≤ B ≤ N), representing the range of cows from A to B inclusive.<br><strong>Output</strong><br>Lines 1..Q: Each line contains a single integer that is a response to a reply and indicates the difference in height between the tallest and shortest cow in the range.<br><strong>Sample Input</strong><br>6 3<br>1<br>7<br>3<br>4<br>2<br>5<br>1 5<br>4 6<br>2 2<br><strong>Sample Output</strong><br>6<br>3<br>0<br><strong>Procedrue</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：Balanced Lineup.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">本题的树节点结构：</span></span><br><span class="line"><span class="comment">struct CNode</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">  int Left,Right;//区间起点和终点</span></span><br><span class="line"><span class="comment">  int min,max;//本区间里的最大最小值</span></span><br><span class="line"><span class="comment">  CNode* pLeft,pRight;</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">也可以不要左右节点指针，用一个数组存放线段树。</span></span><br><span class="line"><span class="comment">根节点下标为0，假设线段树仧某节点下标为i，则</span></span><br><span class="line"><span class="comment">左子节点下标为i*2+1</span></span><br><span class="line"><span class="comment">右子节点下标为i*2+1</span></span><br><span class="line"><span class="comment">如果用一位数组存放线段树，且根结点区间[1,n]</span></span><br><span class="line"><span class="comment">- 使用左右节点指针，则数组需要有2n-1个元素</span></span><br><span class="line"><span class="comment">- 不适用左右节点指针，则数组需要：</span></span><br><span class="line"><span class="comment">  2*2^ceil(log_2 n)-1&lt;=4n-1个元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.10.04</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0xffffff</span>;</span><br><span class="line"><span class="keyword">int</span> MAX, MIN;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LTNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> Left, Right;</span><br><span class="line">	<span class="keyword">int</span> Min, Max;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Mid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> (Left + Right) / <span class="number">2</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//LTNode(int L,int R,int min,int max):Left(L),Right(R),Min(min),Max(max){}</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//LTNode *pLeft, *pRight;</span></span><br><span class="line">}Tree[<span class="number">800010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CreateLTree</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Tree[root].Left = L;</span><br><span class="line">	Tree[root].Right = R;</span><br><span class="line">	Tree[root].Min = INF;</span><br><span class="line">	Tree[root].Max = -INF;</span><br><span class="line">	<span class="keyword">if</span> (L != R)</span><br><span class="line">	{</span><br><span class="line">		CreateLTree(<span class="number">2</span> * root + <span class="number">1</span>, L, (L + R) / <span class="number">2</span>);</span><br><span class="line">		CreateLTree(<span class="number">2</span> * root + <span class="number">2</span>, (L + R) / <span class="number">2</span> + <span class="number">1</span>, R);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"><span class="function">Status <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> i, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (Tree[root].Left == Tree[root].Right)</span><br><span class="line">	{</span><br><span class="line">		Tree[root].Min = Tree[root].Max = v;</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	Tree[root].Min = min(Tree[root].Min, v);</span><br><span class="line">	Tree[root].Max = max(Tree[root].Max, v);</span><br><span class="line">	<span class="keyword">if</span> (i &lt;= Tree[root].Mid())</span><br><span class="line">	{</span><br><span class="line">		Insert(<span class="number">2</span> * root + <span class="number">1</span>, i, v);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		Insert(<span class="number">2</span> * root + <span class="number">2</span>, i, v);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"><span class="function">Status <span class="title">Query</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (Tree[root].Min &gt;= MIN&amp;&amp;Tree[root].Max &lt;= MAX)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (Tree[root].Left == s&amp;&amp;Tree[root].Right == e)</span><br><span class="line">	{</span><br><span class="line">		MIN = min(MIN, Tree[root].Min);</span><br><span class="line">		MAX = max(MAX, Tree[root].Max);</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (e &lt;= Tree[root].Mid())</span><br><span class="line">	{</span><br><span class="line">		Query(<span class="number">2</span> * root + <span class="number">1</span>, s, e);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (s &gt; Tree[root].Mid())</span><br><span class="line">	{</span><br><span class="line">		Query(<span class="number">2</span> * root + <span class="number">2</span>, s, e);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		Query(<span class="number">2</span> * root + <span class="number">1</span>, s, Tree[root].Mid());</span><br><span class="line">		Query(<span class="number">2</span> * root + <span class="number">2</span>, Tree[root].Mid() + <span class="number">1</span>, e);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> N, Q;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;Q);</span><br><span class="line">	CreateLTree(<span class="number">0</span>, <span class="number">1</span>, N);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		<span class="comment">//cin &gt;&gt; x;</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">		Insert(<span class="number">0</span>, i, x);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">int</span> s, e;</span><br><span class="line">		<span class="comment">//cin &gt;&gt; s &gt;&gt; e;</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;s, &amp;e);</span><br><span class="line">		MIN = INF;</span><br><span class="line">		MAX = -INF;</span><br><span class="line">		Query(<span class="number">0</span>, s, e);</span><br><span class="line">		<span class="comment">//cout &lt;&lt; MAX - MIN &lt;&lt; endl;</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, MAX - MIN);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默写了一遍，改用指针，坐等26号POJ维护完成测试，看看能不能一次AC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ERROR = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0xffffff</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> Left;</span><br><span class="line">	<span class="keyword">int</span> Right;</span><br><span class="line">	<span class="keyword">int</span> MIN,MAX;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Mid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> (Left + Right) / <span class="number">2</span>;</span><br><span class="line">	}</span><br><span class="line">	CNode *pLeft, *pRight;</span><br><span class="line">}Tree[<span class="number">2</span>*MAXN];</span><br><span class="line"><span class="keyword">int</span> nNodeCount=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> MAX, MIN;</span><br><span class="line"><span class="function">Status <span class="title">BuildTree</span><span class="params">(CNode *pRoot, <span class="keyword">int</span> Left, <span class="keyword">int</span> Right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	pRoot-&gt;Left = Left;</span><br><span class="line">	pRoot-&gt;Right = Right;</span><br><span class="line">	pRoot-&gt;MAX= -inf;</span><br><span class="line">	pRoot-&gt;MIN = inf;</span><br><span class="line">	<span class="keyword">if</span> (Left == Right)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	nNodeCount++;</span><br><span class="line">	pRoot-&gt;pLeft = Tree + nNodeCount;</span><br><span class="line">	nNodeCount++;</span><br><span class="line">	pRoot-&gt;pRight = Tree + nNodeCount;</span><br><span class="line">	BuildTree(pRoot-&gt;pLeft, Left, pRoot-&gt;Mid());</span><br><span class="line">	BuildTree(pRoot-&gt;pRight, pRoot-&gt;Mid() + <span class="number">1</span>, Right);</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"><span class="function">Status <span class="title">Insert</span><span class="params">(CNode *pRoot, <span class="keyword">int</span> i, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Left == pRoot-&gt;Right)</span><br><span class="line">	{</span><br><span class="line">		pRoot-&gt;MAX = pRoot-&gt;MIN = x;</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	pRoot-&gt;MIN = min(pRoot-&gt;MIN, x);</span><br><span class="line">	pRoot-&gt;MAX = max(pRoot-&gt;MAX, x);</span><br><span class="line">	<span class="keyword">if</span> (i &lt;= pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Insert(pRoot-&gt;pLeft, i, x);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		Insert(pRoot-&gt;pRight, i, x);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"><span class="function">Status <span class="title">Query</span><span class="params">(CNode *pRoot, <span class="keyword">int</span> Left, <span class="keyword">int</span> Right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Left == Left&amp;&amp;pRoot-&gt;Right == Right)</span><br><span class="line">	{</span><br><span class="line">		MAX = max(MAX,pRoot-&gt;MAX);</span><br><span class="line">		MIN = min(MIN,pRoot-&gt;MIN);</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (Right &lt;= pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Query(pRoot-&gt;pLeft, Left, pRoot-&gt;Mid());</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Left &gt; pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Query(pRoot-&gt;pRight, pRoot-&gt;Mid() + <span class="number">1</span>, Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		Query(pRoot-&gt;pLeft, Left, pRoot-&gt;Mid());</span><br><span class="line">		Query(pRoot-&gt;pRight, pRoot-&gt;Mid() + <span class="number">1</span>, Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> N, Q;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; Q;</span><br><span class="line">	BuildTree(Tree, <span class="number">1</span>, N);</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		Insert(Tree, i, x);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">int</span> l, r;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		MIN = inf;</span><br><span class="line">		MAX = -inf;</span><br><span class="line">		Query(Tree, l, r);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; MAX - MIN &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对比下，就会发现问题，坐等26号POJ维护完成，爆了这么多天了...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ERROR =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">50000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> Left;</span><br><span class="line">	<span class="keyword">int</span> Right;</span><br><span class="line">	<span class="keyword">int</span> Max;</span><br><span class="line">	<span class="keyword">int</span> Min;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Mid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> (Left+Right)/<span class="number">2</span>;</span><br><span class="line">	}</span><br><span class="line">	CNode *pLeft,*pRight;</span><br><span class="line">}Tree[<span class="number">2</span>*MAXN+<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> nNodeCount=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> MAX,MIN;</span><br><span class="line"><span class="function">Status <span class="title">BuildTree</span><span class="params">(CNode *pRoot,<span class="keyword">int</span> Left,<span class="keyword">int</span> Right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	pRoot-&gt;Left=Left;</span><br><span class="line">	pRoot-&gt;Right=Right;</span><br><span class="line">	pRoot-&gt;Max=-INF;</span><br><span class="line">	pRoot-&gt;Min=INF;</span><br><span class="line">	<span class="keyword">if</span>(Left==Right)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	nNodeCount++;</span><br><span class="line">	pRoot-&gt;pLeft=Tree+nNodeCount;</span><br><span class="line">	nNodeCount++;</span><br><span class="line">	pRoot-&gt;pRight=Tree+nNodeCount;</span><br><span class="line">	BuildTree(pRoot-&gt;pLeft,Left,pRoot-&gt;Mid());</span><br><span class="line">	BuildTree(pRoot-&gt;pRight,pRoot-&gt;Mid()+<span class="number">1</span>,Right);</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"><span class="function">Status <span class="title">Insert</span><span class="params">(CNode *pRoot,<span class="keyword">int</span> i,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	pRoot-&gt;Max=max(val,pRoot-&gt;Max);</span><br><span class="line">	pRoot-&gt;Min=min(val,pRoot-&gt;Min);</span><br><span class="line">	<span class="keyword">if</span>(pRoot-&gt;Left==pRoot-&gt;Right)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(i&lt;=pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Insert(pRoot-&gt;pLeft,i,val);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		Insert(pRoot-&gt;pRight,i,val);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"><span class="function">Status <span class="title">Query</span><span class="params">(CNode *pRoot,<span class="keyword">int</span> Left,<span class="keyword">int</span> Right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span>(pRoot-&gt;Left==Left&amp;&amp;pRoot-&gt;Right==Right)</span><br><span class="line">	{</span><br><span class="line">		MAX=max(MAX,pRoot-&gt;Max);</span><br><span class="line">		MIN=min(MIN,pRoot-&gt;Min);</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(Right&lt;=pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Query(pRoot-&gt;pLeft,Left,Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(Left&gt;pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Query(pRoot-&gt;pRight,Left,Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		Query(pRoot-&gt;pLeft,Left,pRoot-&gt;Mid());</span><br><span class="line">		Query(pRoot-&gt;pRight,pRoot-&gt;Mid()+<span class="number">1</span>,Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> N,Q;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;N&gt;&gt;Q;</span><br><span class="line">	BuildTree(Tree,<span class="number">1</span>,N);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">int</span> temp;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">		Insert(Tree,i+<span class="number">1</span>,temp);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Q;i++)</span><br><span class="line">	{</span><br><span class="line">		MAX=-INF;</span><br><span class="line">		MIN=INF;</span><br><span class="line">		<span class="keyword">int</span> l,r;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">		Query(Tree,l,r);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;MAX-MIN&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="A-Simple-Problem-with-Integers"><a href="#A-Simple-Problem-with-Integers" class="headerlink" title="A Simple Problem with Integers"></a>A Simple Problem with Integers</h3><p><strong>Description</strong><br>You have N integers, A1, A2, … , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval.<br><strong>Input</strong><br>The first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000.<br>The second line contains N numbers, the initial values of A1, A2, … , AN. -1000000000 ≤ Ai ≤ 1000000000.<br>Each of the next Q lines represents an operation.<br>“C a b c” means adding c to each of Aa, Aa+1, … , Ab. -10000 ≤ c ≤ 10000.<br>“Q a b” means querying the sum of Aa, Aa+1, … , Ab.<br><strong>Output</strong><br>You need to answer all Q commands in order. One answer in a line.<br><strong>Sample Input</strong><br>10 5<br>1 2 3 4 5 6 7 8 9 10<br>Q 4 4<br>Q 1 10<br>Q 2 4<br>C 3 6 3<br>Q 2 4<br><strong>Sample Output</strong><br>4<br>55<br>9<br>15<br><strong>Procedure</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：A_Simple_Problem_with_Integers.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">本题树节点要存哪些信息？只存该区间的数的和，行不行？</span></span><br><span class="line"><span class="comment">只存和，会导致每次加数的时候都要更新到叶子节点，速度太慢(O(nlogn)，这是必须要避免的。</span></span><br><span class="line"><span class="comment">本题树节点结构：</span></span><br><span class="line"><span class="comment">struct CNode</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">  int L,R;</span></span><br><span class="line"><span class="comment">  CNode *pLeft,*pRight;</span></span><br><span class="line"><span class="comment">  long long nSum;//原来的和</span></span><br><span class="line"><span class="comment">  long long inc;//增量c的累加</span></span><br><span class="line"><span class="comment">};//本节点区间的和实际上是nSum+inc*(R-L+1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在增加时，如果要加的区间正好覆盖一个节点，则增加其节点的inc值，不再往下走，</span></span><br><span class="line"><span class="comment">否则要更新nSum(加上本次增量)，在将增量往下传。这样更新的复杂度就是O(logn)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在查询时，如果待查区间不是正好覆盖一个节点，就将节点的inc往下带，然后将inc代表的</span></span><br><span class="line"><span class="comment">所有增量累加到nSum上后将inc清0，接下来再往下查询。一边查询，一边inc往下带的过程也是区间分解的过程，</span></span><br><span class="line"><span class="comment">复杂度也是O(logn)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.10.06</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> Left, Right;</span><br><span class="line">	CNode *pLeft, *pRight;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> nSum;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> inc;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Mid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> (Left + Right) / <span class="number">2</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line">CNode Tree[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> nCount = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="function">Status <span class="title">BuildTree</span><span class="params">(CNode* pRoot, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	pRoot-&gt;Left = L;</span><br><span class="line">	pRoot-&gt;Right = R;</span><br><span class="line">	pRoot-&gt;nSum = <span class="number">0</span>;</span><br><span class="line">	pRoot-&gt;inc = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (L == R)<span class="comment">//叶子节点，更新至叶子节点结束</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	nCount++;</span><br><span class="line">	pRoot-&gt;pLeft = Tree + nCount;</span><br><span class="line">	nCount++;</span><br><span class="line">	pRoot-&gt;pRight = Tree + nCount;</span><br><span class="line">	BuildTree(pRoot-&gt;pLeft, L, (L + R) / <span class="number">2</span>);</span><br><span class="line">	BuildTree(pRoot-&gt;pRight, (L + R) / <span class="number">2</span>+<span class="number">1</span>, R);</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Insert</span><span class="params">(CNode *pRoot, <span class="keyword">int</span> i, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Left==pRoot-&gt;Right<span class="comment">/*pRoot-&gt;Left == i&amp;&amp;pRoot-&gt;Right == i*/</span>)<span class="comment">//叶子节点，更新至叶子节点结束</span></span><br><span class="line">	{</span><br><span class="line">		pRoot-&gt;nSum = v;</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	pRoot-&gt;nSum += v;</span><br><span class="line">	<span class="keyword">if</span> (i &lt;= pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Insert(pRoot-&gt;pLeft, i, v);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		Insert(pRoot-&gt;pRight, i, v);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Add</span><span class="params">(CNode* pRoot, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">long</span> <span class="keyword">long</span> c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Left == a&amp;&amp;pRoot-&gt;Right == b)<span class="comment">//不一次性更新到叶子节点，若区间恰好符合，则停住，保存增量，不下传</span></span><br><span class="line">	{</span><br><span class="line">		pRoot-&gt;inc += c;</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	pRoot-&gt;nSum += c*(b - a + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (b &lt;= pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Add(pRoot-&gt;pLeft, a, b, c);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (a &gt;= pRoot-&gt;Mid()+<span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		Add(pRoot-&gt;pRight, a, b, c);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		Add(pRoot-&gt;pLeft, a, pRoot-&gt;Mid(),c);</span><br><span class="line">		Add(pRoot-&gt;pRight, pRoot-&gt;Mid() + <span class="number">1</span>, b, c);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">QuerynSum</span><span class="params">(CNode * pRoot, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Left == a&amp;&amp;pRoot-&gt;Right == b)<span class="comment">//不一次性查询到叶子节点</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> pRoot-&gt;nSum + (pRoot-&gt;Right - pRoot-&gt;Left + <span class="number">1</span>)*pRoot-&gt;inc;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//区间不符合，则往下传递inc</span></span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;inc != <span class="number">0</span>)<span class="comment">//条件控制</span></span><br><span class="line">	{</span><br><span class="line">		pRoot-&gt;nSum += (pRoot-&gt;Right - pRoot-&gt;Left + <span class="number">1</span>)*pRoot-&gt;inc;</span><br><span class="line">		Add(pRoot-&gt;pLeft, pRoot-&gt;Left, pRoot-&gt;Mid(), pRoot-&gt;inc);</span><br><span class="line">		Add(pRoot-&gt;pRight, pRoot-&gt;Mid() + <span class="number">1</span>, pRoot-&gt;Right, pRoot-&gt;inc);</span><br><span class="line">		pRoot-&gt;inc = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (b &lt;= pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> QuerynSum(pRoot-&gt;pLeft, a, b);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (a &gt;= pRoot-&gt;Mid() + <span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> QuerynSum(pRoot-&gt;pRight, a, b);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> QuerynSum(pRoot-&gt;pLeft, a, pRoot-&gt;Mid()) + QuerynSum(pRoot-&gt;pRight, pRoot-&gt;Mid() + <span class="number">1</span>, b);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> n, q, a, b, c;</span><br><span class="line">	<span class="keyword">char</span> cmd[<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">	nCount = <span class="number">0</span>;</span><br><span class="line">	BuildTree(Tree, <span class="number">1</span>, n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">		Insert(Tree, i, a);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmd);</span><br><span class="line">		<span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'C'</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">			Add(Tree, a, b, c);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, QuerynSum(Tree, a, b));</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">强迫症，非要动态申请内存，测试发现，反而内存占用大，时间慢了！！！！</span></span><br><span class="line"><span class="comment">申请内存耗时间，然后为什么内存反而大了呢？...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：A_Simple_Problem_with_Integers.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">本题树节点要存哪些信息？只存该区间的数的和，行不行？</span></span><br><span class="line"><span class="comment">只存和，会导致每次加数的时候都要更新到叶子节点，速度太慢(O(nlogn)，这是必须要避免的。</span></span><br><span class="line"><span class="comment">本题树节点结构：</span></span><br><span class="line"><span class="comment">struct CNode</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">int L,R;</span></span><br><span class="line"><span class="comment">CNode *pLeft,*pRight;</span></span><br><span class="line"><span class="comment">long long nSum;//原来的和</span></span><br><span class="line"><span class="comment">long long inc;//增量c的累加</span></span><br><span class="line"><span class="comment">};//本节点区间的和实际上是nSum+inc*(R-L+1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在增加时，如果要加的区间正好覆盖一个节点，则增加其节点的inc值，不再往下走，</span></span><br><span class="line"><span class="comment">否则要更新nSum(加上本次增量)，在将增量往下传。这样更新的复杂度就是O(logn)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在查询时，如果待查区间不是正好覆盖一个节点，就将节点的inc往下带，然后将inc代表的</span></span><br><span class="line"><span class="comment">所有增量累加到nSum上后将inc清0，接下来再往下查询。一边查询，一边inc往下带的过程也是区间分解的过程，</span></span><br><span class="line"><span class="comment">复杂度也是O(logn)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.10.06</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> Left, Right;</span><br><span class="line">	CNode *pLeft, *pRight;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> nSum;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> inc;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Mid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> (Left + Right) / <span class="number">2</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}CNode,*PCNode;</span><br><span class="line"><span class="comment">//CNode Tree[200010];</span></span><br><span class="line"><span class="keyword">int</span> nCount = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="function">Status <span class="title">BuildTree</span><span class="params">(PCNode &amp;pRoot, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	pRoot = <span class="keyword">new</span> CNode;</span><br><span class="line">	pRoot-&gt;Left = L;</span><br><span class="line">	pRoot-&gt;Right = R;</span><br><span class="line">	pRoot-&gt;nSum = <span class="number">0</span>;</span><br><span class="line">	pRoot-&gt;inc = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (L == R)<span class="comment">//叶子节点，更新至叶子节点结束</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/*nCount++;</span></span><br><span class="line"><span class="comment">	pRoot-&gt;pLeft = Tree + nCount;</span></span><br><span class="line"><span class="comment">	nCount++;</span></span><br><span class="line"><span class="comment">	pRoot-&gt;pRight = Tree + nCount;*/</span></span><br><span class="line">	BuildTree(pRoot-&gt;pLeft, L, (L + R) / <span class="number">2</span>);</span><br><span class="line">	BuildTree(pRoot-&gt;pRight, (L + R) / <span class="number">2</span> + <span class="number">1</span>, R);</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Insert</span><span class="params">(PCNode &amp;pRoot, <span class="keyword">int</span> i, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Left == pRoot-&gt;Right<span class="comment">/*pRoot-&gt;Left == i&amp;&amp;pRoot-&gt;Right == i*/</span>)<span class="comment">//叶子节点，更新至叶子节点结束</span></span><br><span class="line">	{</span><br><span class="line">		pRoot-&gt;nSum = v;</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	pRoot-&gt;nSum += v;</span><br><span class="line">	<span class="keyword">if</span> (i &lt;= pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Insert(pRoot-&gt;pLeft, i, v);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		Insert(pRoot-&gt;pRight, i, v);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Add</span><span class="params">(PCNode &amp;pRoot, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">long</span> <span class="keyword">long</span> c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Left == a&amp;&amp;pRoot-&gt;Right == b)<span class="comment">//不一次性更新到叶子节点，若区间恰好符合，则停住，保存增量，不下传</span></span><br><span class="line">	{</span><br><span class="line">		pRoot-&gt;inc += c;</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	pRoot-&gt;nSum += c*(b - a + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (b &lt;= pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Add(pRoot-&gt;pLeft, a, b, c);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (a &gt;= pRoot-&gt;Mid() + <span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		Add(pRoot-&gt;pRight, a, b, c);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		Add(pRoot-&gt;pLeft, a, pRoot-&gt;Mid(), c);</span><br><span class="line">		Add(pRoot-&gt;pRight, pRoot-&gt;Mid() + <span class="number">1</span>, b, c);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">QuerynSum</span><span class="params">(PCNode  &amp;pRoot, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Left == a&amp;&amp;pRoot-&gt;Right == b)<span class="comment">//不一次性查询到叶子节点</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> pRoot-&gt;nSum + (pRoot-&gt;Right - pRoot-&gt;Left + <span class="number">1</span>)*pRoot-&gt;inc;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//区间不符合，则往下传递inc</span></span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;inc != <span class="number">0</span>)<span class="comment">//条件控制</span></span><br><span class="line">	{</span><br><span class="line">		pRoot-&gt;nSum += (pRoot-&gt;Right - pRoot-&gt;Left + <span class="number">1</span>)*pRoot-&gt;inc;</span><br><span class="line">		Add(pRoot-&gt;pLeft, pRoot-&gt;Left, pRoot-&gt;Mid(), pRoot-&gt;inc);</span><br><span class="line">		Add(pRoot-&gt;pRight, pRoot-&gt;Mid() + <span class="number">1</span>, pRoot-&gt;Right, pRoot-&gt;inc);</span><br><span class="line">		pRoot-&gt;inc = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (b &lt;= pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> QuerynSum(pRoot-&gt;pLeft, a, b);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (a &gt;= pRoot-&gt;Mid() + <span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> QuerynSum(pRoot-&gt;pRight, a, b);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> QuerynSum(pRoot-&gt;pLeft, a, pRoot-&gt;Mid()) + QuerynSum(pRoot-&gt;pRight, pRoot-&gt;Mid() + <span class="number">1</span>, b);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> n, q, a, b, c;</span><br><span class="line">	<span class="keyword">char</span> cmd[<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">	nCount = <span class="number">0</span>;</span><br><span class="line">	PCNode Tree;</span><br><span class="line">	BuildTree(Tree, <span class="number">1</span>, n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">		Insert(Tree, i, a);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmd);</span><br><span class="line">		<span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'C'</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">			Add(Tree, a, b, c);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, QuerynSum(Tree, a, b));</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默写——还是有点小问题，不过对问题和代码过程有了更深的理解，嘻嘻。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stirng&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ERROR = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> Left;</span><br><span class="line">	<span class="keyword">int</span> Right;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> Sum;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> Inc;<span class="comment">//区间增量</span></span><br><span class="line">	CNode *pLeft, *pRight;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Mid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> (Left + Right) / <span class="number">2</span>;</span><br><span class="line">	}</span><br><span class="line">}Tree[MAXN];</span><br><span class="line"><span class="keyword">int</span> nNodeCount = <span class="number">0</span>;</span><br><span class="line"><span class="function">Status <span class="title">BuildTree</span><span class="params">(CNode *pRoot, <span class="keyword">int</span> Left, <span class="keyword">int</span> Right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	pRoot-&gt;Left = Left;</span><br><span class="line">	pRoot-&gt;Right = Right;</span><br><span class="line">	pRoot-&gt;Sum = <span class="number">0</span>;</span><br><span class="line">	pRoot-&gt;Inc = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (Left == Right)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	nNodeCount++;</span><br><span class="line">	pRoot-&gt;pLeft = Tree + nNodeCount;</span><br><span class="line">	nNodeCount++;</span><br><span class="line">	pRoot-&gt;pRight = Tree + nNodeCount;</span><br><span class="line">	BuildTree(pRoot-&gt;pLeft, Left, pRoot-&gt;Mid());</span><br><span class="line">	BuildTree(pRoot-&gt;pRight, pRoot-&gt;Mid() + <span class="number">1</span>, Right);</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Insert</span><span class="params">(CNode *pRoot, <span class="keyword">int</span> i, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	pRoot-&gt;Sum += x;</span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Left == pRoot-&gt;Right)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (i &lt;= pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Insert(pRoot-&gt;pLeft, i, x);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		Insert(pRoot-&gt;pRight, i, x);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Add</span><span class="params">(CNode *pRoot, <span class="keyword">int</span> Left, <span class="keyword">int</span> Right, <span class="keyword">int</span> Inc)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Left == Left&amp;&amp;pRoot-&gt;Right == Right)</span><br><span class="line">	{</span><br><span class="line">		pRoot-&gt;Inc += Inc;</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	pRoot-&gt;Sum += Inc*(Right - Left + <span class="number">1</span>);<span class="comment">//区间不匹配，增量下传,当前结点所示区间的局部区段求和</span></span><br><span class="line">	<span class="keyword">if</span> (Right &lt;= pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Add(pRoot-&gt;pLeft, Left, Right, Inc);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Left &gt; pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Add(pRoot-&gt;pRight, Left, Right, Inc);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		Add(pRoot-&gt;pLeft, Left, pRoot-&gt;Mid(), Inc);</span><br><span class="line">		Add(pRoot-&gt;pRight, pRoot-&gt;Mid() + <span class="number">1</span>, Right, Inc);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Query</span><span class="params">(CNode *pRoot, <span class="keyword">int</span> Left, <span class="keyword">int</span> Right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Left == Left&amp;&amp;pRoot-&gt;Right == Right)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//错误写法，查询，而没有往下迭代</span></span><br><span class="line">		<span class="comment">/*pRoot-&gt;Sum += pRoot-&gt;Inc*(pRoot-&gt;Right - pRoot-&gt;Left + 1);</span></span><br><span class="line"><span class="comment">		pRoot-&gt;Inc = 0;*/</span></span><br><span class="line">		<span class="keyword">return</span> pRoot-&gt;Sum + pRoot-&gt;Inc*(pRoot-&gt;Right - pRoot-&gt;Left + <span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Inc != <span class="number">0</span>)<span class="comment">//增量向下迭代</span></span><br><span class="line">	{</span><br><span class="line">		pRoot-&gt;Sum += pRoot-&gt;Inc*(pRoot-&gt;Right - pRoot-&gt;Left + <span class="number">1</span>);</span><br><span class="line">		Add(pRoot-&gt;pLeft,Left,pRoot-&gt;Mid(),pRoot-&gt;Inc);</span><br><span class="line">		Add(pRoot-&gt;pRight, pRoot-&gt;Mid() + <span class="number">1</span>, Right,pRoot-&gt;Inc);</span><br><span class="line">		pRoot-&gt;Inc = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (Right &lt;= pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> Query(pRoot-&gt;pLeft, Left, Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Left &gt; pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> Query(pRoot-&gt;pRight, Left, Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> Query(pRoot-&gt;pLeft, Left, pRoot-&gt;Mid()) + Query(pRoot-&gt;pRight, pRoot-&gt;Mid() + <span class="number">1</span>, Right);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> N, Q;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N&gt;&gt;Q;</span><br><span class="line">	nNodeCount = <span class="number">0</span>;</span><br><span class="line">	BuildTree(Tree, <span class="number">1</span>, N);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		Insert(Tree, i, x);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">char</span> ch;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">		<span class="keyword">if</span> (ch == <span class="string">'C'</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">int</span> a, b, c;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">			Add(Tree, a, b, c);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">int</span> a, b;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;Query(Tree, a, b)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ERROR=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> Left;</span><br><span class="line">	<span class="keyword">int</span> Right;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> nSum;<span class="comment">//区间和</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> Inc;<span class="comment">//增量</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Mid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> (Left+Right)/<span class="number">2</span>;</span><br><span class="line">	}</span><br><span class="line">	CNode *pRight,*pLeft;</span><br><span class="line">}Tree[<span class="number">2</span>*MAXN+<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> nNodeCount=<span class="number">0</span>;</span><br><span class="line"><span class="function">Status <span class="title">BuildTree</span><span class="params">(CNode *pRoot,<span class="keyword">int</span> Left,<span class="keyword">int</span> Right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	pRoot-&gt;Left=Left;</span><br><span class="line">	pRoot-&gt;Right=Right;</span><br><span class="line">	pRoot-&gt;nSum=<span class="number">0</span>;</span><br><span class="line">	pRoot-&gt;Inc=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(Left==Right)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	nNodeCount++;</span><br><span class="line">	pRoot-&gt;pLeft=Tree+nNodeCount;</span><br><span class="line">	nNodeCount++;</span><br><span class="line">	pRoot-&gt;pRight=Tree+nNodeCount;</span><br><span class="line">	BuildTree(pRoot-&gt;pLeft,Left,pRoot-&gt;Mid());</span><br><span class="line">	BuildTree(pRoot-&gt;pRight,pRoot-&gt;Mid()+<span class="number">1</span>,Right);</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"><span class="function">Status <span class="title">Insert</span><span class="params">(CNode *pRoot,<span class="keyword">int</span> i,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	pRoot-&gt;nSum+=val;</span><br><span class="line">	<span class="keyword">if</span>(pRoot-&gt;Left==pRoot-&gt;Right)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(i&lt;=pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Insert(pRoot-&gt;pLeft,i,val);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Insert(pRoot-&gt;pRight,i,val);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"><span class="function">Status <span class="title">Add</span><span class="params">(CNode *pRoot,<span class="keyword">int</span> Left,<span class="keyword">int</span> Right,<span class="keyword">long</span> <span class="keyword">long</span> Inc)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span>(pRoot-&gt;Left==Left&amp;&amp;pRoot-&gt;Right)</span><br><span class="line">	{</span><br><span class="line">		pRoot-&gt;Inc+=Inc;</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	pRoot-&gt;nSum+=Inc*(Right-Left+<span class="number">1</span>);<span class="comment">//注意是在[L,R]内加Inc，而不是当节点别是的整个区间</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(Right&lt;=pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Add(pRoot-&gt;pLeft,Left,Right,Inc);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(Left&gt;pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Add(pRoot-&gt;pRight,Left,Right,Inc);</span><br><span class="line">	 }</span><br><span class="line">	 <span class="keyword">else</span></span><br><span class="line">	 {</span><br><span class="line">	 	Add(pRoot-&gt;pLeft,Left,pRoot-&gt;Mid(),Inc);</span><br><span class="line">	 	Add(pRoot-&gt;pRight,pRoot-&gt;Mid()+<span class="number">1</span>,Right,Inc);</span><br><span class="line">	 }</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Query</span><span class="params">(CNode *pRoot,<span class="keyword">int</span> Left,<span class="keyword">int</span> Right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span>(pRoot-&gt;Left==Left&amp;&amp;pRoot-&gt;Right==Right)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> pRoot-&gt;Inc*(pRoot-&gt;Right-pRoot-&gt;Left+<span class="number">1</span>)+pRoot-&gt;nSum;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pRoot-&gt;Inc!=<span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span>(Right&lt;=pRoot-&gt;Mid())</span><br><span class="line">		{</span><br><span class="line">			Add(pRoot-&gt;pLeft,Left,Right,pRoot-&gt;Inc);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(Left&gt;pRoot-&gt;Mid())</span><br><span class="line">		{</span><br><span class="line">			Add(pRoot-&gt;pRight,Left,Right,pRoot-&gt;Inc);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			Add(pRoot-&gt;pLeft,Left,pRoot-&gt;Mid(),pRoot-&gt;Inc);</span><br><span class="line">			Add(pRoot-&gt;pRight,pRoot-&gt;Mid()+<span class="number">1</span>,Right,pRoot-&gt;Inc);</span><br><span class="line">		}</span><br><span class="line">		pRoot-&gt;nSum+=pRoot-&gt;Inc*(Right-Left+<span class="number">1</span>);</span><br><span class="line">		pRoot-&gt;Inc=<span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> result=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(Right&lt;=pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		result =Query(pRoot-&gt;pLeft,Left,Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(Left&gt;pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		result =Query(pRoot-&gt;pRight,Left,Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		result +=Query(pRoot-&gt;pLeft,Left,pRoot-&gt;Mid());</span><br><span class="line">		result +=Query(pRoot-&gt;pRight,pRoot-&gt;Mid()+<span class="number">1</span>,Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> N,M;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;N&gt;&gt;M;</span><br><span class="line">	BuildTree(Tree,<span class="number">1</span>,N);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">int</span> temp;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">		Insert(Tree,i,temp);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">char</span> ch;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">		<span class="keyword">int</span> a,b;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> c;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">'C'</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">			Add(Tree,a,b,c);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;Query(Tree,a,b)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><p>有时，区间的断点不是整数，或者区间太大导致建树内存开销过大MLE，那么就需要进行“离散化”后再建树。</p>
<h3 id="Mayor’s-Poster"><a href="#Mayor’s-Poster" class="headerlink" title="Mayor’s Poster"></a>Mayor’s Poster</h3><p><strong>Description</strong><br>The citizens of Bytetown, AB, could not stand that the candidates in the mayoral election campaign have been placing their electoral posters at all places at their whim. The city council has finally decided to build an electoral wall for placing the posters and introduce the following rules:<br>　　Every candidate can place exactly one poster on the wall.<br>　　All posters are of the same height equal to the height of the wall; the width of a poster can be any integer number of bytes (byte is the unit of length in Bytetown).<br>　　The wall is divided into segments and the width of each segment is one byte.<br>　　Each poster must completely cover a contiguous number of wall segments.<br>They have built a wall 10000000 bytes long (such that there is enough place for all candidates). When the electoral campaign was restarted, the candidates were placing their posters on the wall and their posters differed widely in width. Moreover, the candidates started placing their posters on wall segments already occupied by other posters. Everyone in Bytetown was curious whose posters will be visible (entirely or in part) on the last day before elections.<br>Your task is to find the number of visible posters when all the posters are placed given the information about posters’ size, their place and order of placement on the electoral wall.<br><strong>Input</strong><br>The first line of input contains a number c giving the number of cases that follow. The first line of data for a single case contains number 1 &lt;= n &lt;= 10000. The subsequent n lines describe the posters in the order in which they were placed. The i-th line among the n lines contains two integer numbers li and ri which are the number of the wall segment occupied by the left end and the right end of the i-th poster, respectively. We know that for each 1 &lt;= i &lt;= n, 1 &lt;= li &lt;= ri &lt;= 10000000. After the i-th poster is placed, it entirely covers all wall segments numbered li, li+1 ,… , ri.<br><strong>Output</strong><br>For each input data set print the number of visible posters after all the posters are placed.<br>The picture below illustrates the case of the sample input.<br><strong>Sample Input</strong><br>1<br>5<br>1 4<br>2 6<br>8 10<br>3 4<br>7 10<br><strong>Sample Output</strong><br>4<br><strong>Procedure</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：Mayor's Poster.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">给定一些海报，可能互相重叠，告诉你每个海报宽度（高度都一样）</span></span><br><span class="line"><span class="comment">和先后叠放次序，问没有被完全盖住的海报有多少张。</span></span><br><span class="line"><span class="comment">海报最多10000张，但是墙有10000000块瓷砖长。海报端点不会落在瓷砖中间。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">依次贴上一张张海报，每贴一张海报，就询问这张海报有没有被完全遮住</span></span><br><span class="line"><span class="comment">（假设贴海报的过程和现实可以不同，也可以先贴上面的，再贴下面的）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">贴的顺序如何选择？</span></span><br><span class="line"><span class="comment">关键：插入数据的书序——从上往下依次插入每张海报，这样后插入的海报不可能覆盖</span></span><br><span class="line"><span class="comment">先插入的海报，因此插入一张海报时，如果发现海报对应的瓷砖有一块露出来，就说明该海报部分可见。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">给瓷砖编号，一个海报就相当于一个整数区间。贴海报就是区间操作，查询</span></span><br><span class="line"><span class="comment">海报是否可见也是区间操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">因此可以用线段树来解决。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果每个叶子节点都代表一块瓷砖，那么线段树会导致MLE，即单位区间数目太多。而且建树</span></span><br><span class="line"><span class="comment">复杂度O(m)，查询复杂度为nlogm（n是海报数目，m是瓷砖数目）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">实际上，由于最多10000个海报，共计20000个端点，这些端点把墙最多分成</span></span><br><span class="line"><span class="comment">19999个单位区间（题意为整数个墙都会被覆盖）。每个单位区间的瓷砖数目可以不同。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">我们只要对这19999个区间编号，然后建树即可。这就是离散化。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> - 这些单位区间在线段树上是叶子节点</span></span><br><span class="line"><span class="comment"> - 每个单位区间要么全被覆盖，要么全部露出</span></span><br><span class="line"><span class="comment"> - 没有海报的端点会落在一个单位区间内部</span></span><br><span class="line"><span class="comment"> - 每个张海报一定完整覆盖若干个连续的单位区间</span></span><br><span class="line"><span class="comment"> - 要算出一共有多少个单位区间，并且算出每张海报覆盖的单位区间[a,b]</span></span><br><span class="line"><span class="comment"> （海报覆盖了从a号单位区间到b号单位区间）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 海报 1:1-4</span></span><br><span class="line"><span class="comment"> 海报 2:2-6</span></span><br><span class="line"><span class="comment"> 海报 3:8-10</span></span><br><span class="line"><span class="comment"> 海报 4:3-4</span></span><br><span class="line"><span class="comment"> 海报 5:7-10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 那么离散化结果：</span></span><br><span class="line"><span class="comment"> 1 0</span></span><br><span class="line"><span class="comment"> 2 1</span></span><br><span class="line"><span class="comment"> 3 3-4</span></span><br><span class="line"><span class="comment"> 4 5-6</span></span><br><span class="line"><span class="comment"> 5 7</span></span><br><span class="line"><span class="comment"> 6 8-10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 此离散化方法，求每张海报覆盖了哪些单位区间，写起来稍麻烦</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 更好的离散化方法，是将所有海报的端点瓷砖排序，把每个海报的端点瓷砖</span></span><br><span class="line"><span class="comment"> 都看做一个单位区间，两个相邻的端点瓷砖之间的部分是一个单位区间</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 离散化结果：</span></span><br><span class="line"><span class="comment"> 1 0</span></span><br><span class="line"><span class="comment"> 2 1</span></span><br><span class="line"><span class="comment"> 3 2</span></span><br><span class="line"><span class="comment"> 4 3</span></span><br><span class="line"><span class="comment"> 5 4</span></span><br><span class="line"><span class="comment"> 6 5</span></span><br><span class="line"><span class="comment"> 7 6</span></span><br><span class="line"><span class="comment"> 8 7</span></span><br><span class="line"><span class="comment"> 9 8</span></span><br><span class="line"><span class="comment"> 10 9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.10.09</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ERROR = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CPost</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> L, R;</span><br><span class="line">}posters[<span class="number">10100</span>];</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">20200</span>];<span class="comment">//存放所有海报的端点瓷砖编号</span></span><br><span class="line"><span class="keyword">int</span> Hash[<span class="number">10000010</span>]; <span class="comment">//hash[i]表示瓷砖i所处的离散化后的区间编号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> L, R;</span><br><span class="line">	<span class="keyword">bool</span> bCovered;<span class="comment">//区间[L,R]是否已经被完全覆盖</span></span><br><span class="line">	CNode *pLeft, *pRight;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Mid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> (L + R) / <span class="number">2</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line">CNode Tree[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">int</span> nNodeCount = <span class="number">0</span>;</span><br><span class="line"><span class="function">Status <span class="title">BuildTree</span><span class="params">(CNode *pRoot, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	pRoot-&gt;L = L;</span><br><span class="line">	pRoot-&gt;R = R;</span><br><span class="line">	pRoot-&gt;bCovered = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (L == R)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	nNodeCount++;</span><br><span class="line">	pRoot-&gt;pLeft = Tree + nNodeCount;</span><br><span class="line">	nNodeCount++;</span><br><span class="line">	pRoot-&gt;pRight = Tree + nNodeCount;</span><br><span class="line">	BuildTree(pRoot-&gt;pLeft, L, (L + R) / <span class="number">2</span>);</span><br><span class="line">	BuildTree(pRoot-&gt;pRight, (L + R) / <span class="number">2</span> + <span class="number">1</span>, R);</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Post</span><span class="params">(CNode *pRoot, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//插入一张正好覆盖区间[L,R]的海报，返回true则说明区间[L,R]是部分或全部可见的</span></span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;bCovered)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;L == L&amp;&amp;pRoot-&gt;R == R)</span><br><span class="line">	{</span><br><span class="line">		pRoot-&gt;bCovered = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">bool</span> bResult;</span><br><span class="line">	<span class="keyword">if</span> (R &lt;= pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		bResult = Post(pRoot-&gt;pLeft, L, R);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (L &gt;= pRoot-&gt;Mid() + <span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		bResult = Post(pRoot-&gt;pRight, L, R);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">bool</span> b1 = Post(pRoot-&gt;pLeft, L, pRoot-&gt;Mid());</span><br><span class="line">		<span class="keyword">bool</span> b2 = Post(pRoot-&gt;pRight, pRoot-&gt;Mid() + <span class="number">1</span>, R);</span><br><span class="line">		bResult = b1 || b2;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//要更新根节点的覆盖情况</span></span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;pLeft-&gt;bCovered&amp;&amp;pRoot-&gt;pRight-&gt;bCovered)</span><br><span class="line">	{</span><br><span class="line">		pRoot-&gt;bCovered = <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> bResult;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">int</span> nCaseNo = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	{</span><br><span class="line">		nCaseNo++;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">int</span> nCount = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; posters[i].L &gt;&gt; posters[i].R;</span><br><span class="line">			x[nCount++] = posters[i].L;</span><br><span class="line">			x[nCount++] = posters[i].R;</span><br><span class="line">		}</span><br><span class="line">		sort(x, x + nCount);</span><br><span class="line">		nCount = unique(x, x + nCount) - x;<span class="comment">//去掉重复元素</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//离散化</span></span><br><span class="line">		<span class="keyword">int</span> nIntervalNo = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nCount; i++)</span><br><span class="line">		{</span><br><span class="line">			Hash[x[i]] = nIntervalNo;</span><br><span class="line">			<span class="keyword">if</span> (i &lt; nCount - <span class="number">1</span>)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">if</span> (x[i + <span class="number">1</span>] - x[i] == <span class="number">1</span>)</span><br><span class="line">				{</span><br><span class="line">					nIntervalNo++;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				{</span><br><span class="line">					nIntervalNo += <span class="number">2</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		BuildTree(Tree, <span class="number">0</span>, nIntervalNo);</span><br><span class="line">		<span class="keyword">int</span> nSum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		{</span><br><span class="line">			<span class="comment">//从后往前看每个海报是否可见</span></span><br><span class="line">			<span class="keyword">if</span> (Post(Tree, Hash[posters[i].L], Hash[posters[i].R]))</span><br><span class="line">			{</span><br><span class="line">				nSum++;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; nSum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默写，恩，以后看完一个就默写一遍，我先把前两个的线段树也默写一遍吧！</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ERROR = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10001</span>;<span class="comment">//海报数目+1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXP = <span class="number">10000000</span>;<span class="comment">//瓷砖数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Post</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> Left;</span><br><span class="line">	<span class="keyword">int</span> Right;</span><br><span class="line">}poster[MAXN];</span><br><span class="line"><span class="keyword">int</span> Location[<span class="number">2</span>*MAXN];<span class="comment">//海报端点位置记录</span></span><br><span class="line"><span class="comment">//set&lt;int&gt;Location;</span></span><br><span class="line"><span class="keyword">int</span> Hash[MAXP];<span class="comment">//对单位区间编号的哈希表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> Left;</span><br><span class="line">	<span class="keyword">int</span> Right;</span><br><span class="line">	<span class="keyword">bool</span> Covered;</span><br><span class="line">	CNode *pLeft, *pRight;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Mid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> (Left + Right) / <span class="number">2</span>;</span><br><span class="line">	}</span><br><span class="line">}Tree[<span class="number">17</span>*MAXN];<span class="comment">//看不懂了，本想着8倍就行了非得17倍，什么鬼啊？？？</span></span><br><span class="line"><span class="keyword">int</span> nNodeCount = <span class="number">0</span>;</span><br><span class="line"><span class="function">Status <span class="title">BuildTree</span><span class="params">(CNode * pRoot, <span class="keyword">int</span> Left, <span class="keyword">int</span> Right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	pRoot-&gt;Left = Left;</span><br><span class="line">	pRoot-&gt;Right = Right;</span><br><span class="line">	pRoot-&gt;Covered = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (Left == Right)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	nNodeCount++;</span><br><span class="line">	pRoot-&gt;pLeft = Tree + nNodeCount;</span><br><span class="line">	nNodeCount++;</span><br><span class="line">	pRoot-&gt;pRight = Tree + nNodeCount;</span><br><span class="line">	BuildTree(pRoot-&gt;pLeft, Left, pRoot-&gt;Mid());</span><br><span class="line">	BuildTree(pRoot-&gt;pRight, pRoot-&gt;Mid() + <span class="number">1</span>, Right);</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Post</span><span class="params">(CNode *pRoot, <span class="keyword">int</span> Left, <span class="keyword">int</span> Right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//插入一张区间为[Left,Right]的海报，true为可见，反之不可见</span></span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Covered)<span class="comment">//已被覆盖</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Left == Left&amp;&amp;pRoot-&gt;Right == Right)<span class="comment">//未被覆盖，张贴后即被覆盖</span></span><br><span class="line">	{</span><br><span class="line">		pRoot-&gt;Covered = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">bool</span> bResult;</span><br><span class="line">	<span class="keyword">if</span> (Right &lt;= pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		bResult = Post(pRoot-&gt;pLeft, Left, Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Left &gt; pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		bResult = Post(pRoot-&gt;pRight, Left, Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">bool</span> b1 = Post(pRoot-&gt;pLeft, Left, pRoot-&gt;Mid());</span><br><span class="line">		<span class="keyword">bool</span> b2 = Post(pRoot-&gt;pRight, pRoot-&gt;Mid() + <span class="number">1</span>, Right);</span><br><span class="line">		bResult = b1 || b2;<span class="comment">//只要一方可见即可见</span></span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//最后更新当前结点的覆盖情况</span></span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;pLeft-&gt;Covered&amp;&amp;pRoot-&gt;pRight-&gt;Covered)</span><br><span class="line">	{</span><br><span class="line">		pRoot-&gt;Covered = <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> bResult;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> nPost;</span><br><span class="line">	<span class="keyword">int</span> nCase;</span><br><span class="line">	<span class="keyword">int</span> nCount;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; nCase;</span><br><span class="line">	<span class="keyword">while</span> (nCase--)</span><br><span class="line">	{</span><br><span class="line">		nCount = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; nPost;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nPost; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; poster[i].Left &gt;&gt; poster[i].Right;</span><br><span class="line">			Location[nCount++] = poster[i].Left;</span><br><span class="line">			Location[nCount++] = poster[i].Right;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//去重取新</span></span><br><span class="line">		sort(Location, Location + nCount);</span><br><span class="line">		nCount = unique(Location, Location + nCount) - Location;<span class="comment">//去重获取新的</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//离散化</span></span><br><span class="line">		<span class="keyword">int</span> nCodeList = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nCount; i++)</span><br><span class="line">		{</span><br><span class="line">			Hash[Location[i]] = nCodeList;</span><br><span class="line">			<span class="keyword">if</span> (i &lt; nCount - <span class="number">1</span>)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">if</span> (Location[i + <span class="number">1</span>] - Location[i] == <span class="number">1</span>)</span><br><span class="line">				{</span><br><span class="line">					nCodeList++;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				{</span><br><span class="line">					nCodeList += <span class="number">2</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//建树</span></span><br><span class="line">		BuildTree(Tree, <span class="number">0</span>, nCodeList);</span><br><span class="line">		<span class="comment">//张贴海报</span></span><br><span class="line">		<span class="keyword">int</span> Sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//张贴海报，注意这里从后往前张贴，因为后贴的在上面，如果从前往后张贴，后面张贴的在上的海报就被覆盖了</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = nPost<span class="number">-1</span>; i &gt;=<span class="number">0</span>; i--)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (Post(Tree, Hash[poster[i].Left], Hash[poster[i].Right]))</span><br><span class="line">			{</span><br><span class="line">				Sum++;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; Sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ERROR=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">10000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> Left;</span><br><span class="line">	<span class="keyword">int</span> Right;</span><br><span class="line">	<span class="keyword">bool</span> bCover;</span><br><span class="line">	CNode *pLeft,*pRight;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Mid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> (Left+Right)/<span class="number">2</span>;</span><br><span class="line">	}</span><br><span class="line">}Tree[<span class="number">8</span>*MAXN]; <span class="comment">//39999个结点，线段树节点2*39999-1</span></span><br><span class="line"><span class="keyword">int</span> nNodeCount=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CPost</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> Left;</span><br><span class="line">	<span class="keyword">int</span> Right;</span><br><span class="line">}Poster[MAXN+<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> Location[<span class="number">2</span>*MAXN+<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> Hash[<span class="number">1000</span>*MAXN+<span class="number">10</span>];</span><br><span class="line"><span class="function">Status <span class="title">BuildTree</span><span class="params">(CNode *pRoot,<span class="keyword">int</span> Left,<span class="keyword">int</span> Right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	pRoot-&gt;Left=Left;</span><br><span class="line">	pRoot-&gt;Right=Right;</span><br><span class="line">	pRoot-&gt;bCover=<span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(Left==Right)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	nNodeCount++;</span><br><span class="line">	pRoot-&gt;pLeft=Tree+nNodeCount;</span><br><span class="line">	nNodeCount++;</span><br><span class="line">	pRoot-&gt;pRight=Tree+nNodeCount;</span><br><span class="line">	BuildTree(pRoot-&gt;pLeft,Left,pRoot-&gt;Mid());</span><br><span class="line">	BuildTree(pRoot-&gt;pRight,pRoot-&gt;Mid()+<span class="number">1</span>,Right);</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Query</span><span class="params">(CNode *pRoot,<span class="keyword">int</span> Left, <span class="keyword">int</span> Right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//true则可见，否则不可见</span></span><br><span class="line">	<span class="keyword">if</span>(pRoot-&gt;bCover)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(pRoot-&gt;Left==Left&amp;&amp;pRoot-&gt;Right==Right)</span><br><span class="line">	{</span><br><span class="line">		pRoot-&gt;bCover=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">bool</span> bResult;</span><br><span class="line">	<span class="keyword">if</span>(Right&lt;=pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		bResult= Query(pRoot-&gt;pLeft,Left,Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(Left&gt;pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		bResult= Query(pRoot-&gt;pRight,Left,Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">bool</span> b1=Query(pRoot-&gt;pLeft,Left,pRoot-&gt;Mid());</span><br><span class="line">		<span class="keyword">bool</span> b2=Query(pRoot-&gt;pRight,pRoot-&gt;Mid()+<span class="number">1</span>,Right);</span><br><span class="line">		bResult = b2||b1;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果先覆盖根结点左半边，后覆盖右半边，则需要更新根结点，因为已经被覆盖</span></span><br><span class="line">	<span class="keyword">if</span>(pRoot-&gt;pLeft-&gt;bCover&amp;&amp;pRoot-&gt;pRight-&gt;bCover)</span><br><span class="line">	{</span><br><span class="line">		pRoot-&gt;bCover=<span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> bResult;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> nCase;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;nCase;</span><br><span class="line">	<span class="keyword">while</span>(nCase--)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">int</span> nPost=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;nPost;</span><br><span class="line">		<span class="keyword">int</span> nPointCount=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nPost;i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;Poster[i].Left&gt;&gt;Poster[i].Right;</span><br><span class="line">			Location[nPointCount++]=Poster[i].Left;</span><br><span class="line">			Location[nPointCount++]=Poster[i].Right;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//去重</span></span><br><span class="line">		sort(Location,Location+nPointCount);</span><br><span class="line">		nPointCount=unique(Location,Location+nPointCount)-Location;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//排序离散化</span></span><br><span class="line">		<span class="keyword">int</span> nList=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nPointCount<span class="number">-1</span>;i++)</span><br><span class="line">		{</span><br><span class="line">			Hash[Location[i]]=nList;</span><br><span class="line">			<span class="keyword">if</span>(Location[i+<span class="number">1</span>]-Location[i]==<span class="number">1</span>)</span><br><span class="line">			{</span><br><span class="line">				nList++;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			{</span><br><span class="line">				nList+=<span class="number">2</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		Hash[Location[i]]=nList;</span><br><span class="line"></span><br><span class="line">		BuildTree(Tree,<span class="number">0</span>,nList);</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=nPost<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span>(Query(Tree,Hash[Poster[j].Left],Hash[Poster[j].Right]))</span><br><span class="line">			{</span><br><span class="line">				sum++;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Atlantis"><a href="#Atlantis" class="headerlink" title="Atlantis"></a>Atlantis</h3><p><strong>Description</strong><br>There are several ancient Greek texts that contain descriptions of the fabled island Atlantis. Some of these texts even include maps of parts of the island. But unfortunately, these maps describe different regions of Atlantis. Your friend Bill has to know the total area for which maps exist. You (unwisely) volunteered to write a program that calculates this quantity.<br><strong>Input</strong><br>The input consists of several test cases. Each test case starts with a line containing a single integer n (1 &lt;= n &lt;= 100) of available maps. The n following lines describe one map each. Each of these lines contains four numbers x1;y1;x2;y2 (0 &lt;= x1 &lt; x2 &lt;= 100000;0 &lt;= y1 &lt; y2 &lt;= 100000), not necessarily integers. The values (x1; y1) and (x2;y2) are the coordinates of the top-left resp. bottom-right corner of the mapped area.<br>The input file is terminated by a line containing a single 0. Don’t process it.<br><strong>Output</strong><br>For each test case, your program should output one section. The first line of each section must be “Test case #k”, where k is the number of the test case (starting with 1). The second one must be “Total explored area: a”, where a is the total explored area (i.e. the area of the union of all rectangles in this test case), printed exact to two digits to the right of the decimal point.<br>Output a blank line after each test case.<br><strong>Sample Input</strong><br>2 10 10 20 20 15 15 25 25.5 0<br><strong>Sample Output</strong><br>Test case #1 Total explored area: 180.00<br><strong>Procedure</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：Atlantis.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">给定n个矩形(n&lt;=100)，其顶点坐标是浮点数，可能互相重叠，问这些矩形覆盖到的面积</span></span><br><span class="line"><span class="comment">是多大。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">用一条直线从左到右扫描，碰到一条矩形竖边的时候，就计算该直线有多长被矩形覆盖，</span></span><br><span class="line"><span class="comment">以及被覆盖部分是覆盖了几重。碰到矩形左边，要增加被覆盖的长度，碰到右边，要减少被</span></span><br><span class="line"><span class="comment">覆盖的长度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">随着扫描线的右移动，覆盖面积不断增加。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">每碰到一条矩形的纵边，覆盖面积就增加len*该纵边到下一条纵边的距离。</span></span><br><span class="line"><span class="comment">Len是此时扫描线被矩形覆盖的长度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在Y轴进行离散化，n个矩形的2n个横边纵坐标共构成最多2n-1个区间的边界，对这些区间编号，</span></span><br><span class="line"><span class="comment">建立起线段树。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">线段树的节点要保存哪些信息？如何将一个个矩形插入线段树？插入过程中这些信息如何更新？怎样查询？</span></span><br><span class="line"><span class="comment">struct CNode</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">  int L,R;</span></span><br><span class="line"><span class="comment">  CNode *pLeft,*pRight;</span></span><br><span class="line"><span class="comment">  double Len;//当前，本区间上有多长的部分是落在那些矩形中的</span></span><br><span class="line"><span class="comment">  int Couvers;//本区间当前被多少个矩形完全包含</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">一开始，所有区间Len=0,Covers=0</span></span><br><span class="line"><span class="comment">插入数据的顺序：</span></span><br><span class="line"><span class="comment">将矩形的纵边从左到右排序，然后依次将这些纵边插入线段树。要记住哪些纵边是一个矩形的左边（开始边），哪些</span></span><br><span class="line"><span class="comment">纵边是一个矩形的右边（结束边），以便插入时，对Len和Covers做不同的修改。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">插入一条边后，就根据根节点的Len值增加总覆盖面积的值。</span></span><br><span class="line"><span class="comment">增量是Len*本边到下一条边的距离</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.10.20</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ERROR = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> y[<span class="number">210</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> Left, Right;</span><br><span class="line">	CNode *pLeft, *pRight;</span><br><span class="line">	<span class="keyword">double</span> Len;<span class="comment">//当前，本区间上有多长的部分是落在那些矩形中的</span></span><br><span class="line">	<span class="keyword">int</span> Covers;<span class="comment">//本区间当前被多少个矩形完全包含</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Mid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> (Left + Right) / <span class="number">2</span>;</span><br><span class="line">	}</span><br><span class="line">}Tree[<span class="number">2000</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CLine</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">double</span> x, y1, y2;</span><br><span class="line">	<span class="keyword">bool</span> bLeft;<span class="comment">//是否是矩形的左边</span></span><br><span class="line">}Lines[<span class="number">210</span>];</span><br><span class="line"><span class="keyword">int</span> nNodeCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> CLine &amp;l1, <span class="keyword">const</span> CLine &amp;l2)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> l1.x &lt; l2.x;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">F</span> <span class="title">bin_search</span>(<span class="title">F</span> <span class="title">s</span>, <span class="title">F</span> <span class="title">e</span>, <span class="title">T</span> <span class="title">val</span>)</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="comment">//在区间[s,e)中查找val，找不到就返回e</span></span><br><span class="line">	F Left = s;</span><br><span class="line">	F Right = e - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (Left &lt;= Right)</span><br><span class="line">	{</span><br><span class="line">		F mid = Left + (Right - Left) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (!(*mid &lt; val || val &lt; *mid))</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (val &lt; *mid)</span><br><span class="line">		{</span><br><span class="line">			Right = mid - <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			Left = mid + <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> e;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">BuildTree</span><span class="params">(CNode *pRoot, <span class="keyword">int</span> Left, <span class="keyword">int</span> Right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	pRoot-&gt;Left = Left;</span><br><span class="line">	pRoot-&gt;Right = Right;</span><br><span class="line">	pRoot-&gt;Len = <span class="number">0</span>;</span><br><span class="line">	pRoot-&gt;Covers = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (Left == Right)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	nNodeCount++;</span><br><span class="line">	pRoot-&gt;pLeft = Tree + nNodeCount;</span><br><span class="line">	nNodeCount++;</span><br><span class="line">	pRoot-&gt;pRight = Tree + nNodeCount;</span><br><span class="line">	BuildTree(pRoot-&gt;pLeft, Left, pRoot-&gt;Mid());</span><br><span class="line">	BuildTree(pRoot-&gt;pRight, pRoot-&gt;Mid() + <span class="number">1</span>, Right);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Insert</span><span class="params">(CNode *pRoot, <span class="keyword">int</span> Left, <span class="keyword">int</span> Right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//在区间pRoot插入矩形左边的一部分或全部，该左边的一部分或全部覆盖了区间[L,R]</span></span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Left == Left&amp;&amp;pRoot-&gt;Right == Right)</span><br><span class="line">	{</span><br><span class="line">		pRoot-&gt;Len = y[Right + <span class="number">1</span>] - y[Left];</span><br><span class="line">		pRoot-&gt;Covers++;</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (Right &lt;= pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Insert(pRoot-&gt;pLeft, Left, Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Left &gt; pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Insert(pRoot-&gt;pRight, Left, Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		Insert(pRoot-&gt;pLeft, Left, pRoot-&gt;Mid());</span><br><span class="line">		Insert(pRoot-&gt;pRight, pRoot-&gt;Mid() + <span class="number">1</span>, Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Covers == <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//如果不为0，则说明本区间当前仍然被某个矩形完全包含，则不能更新Len</span></span><br><span class="line">		pRoot-&gt;Len = pRoot-&gt;pLeft-&gt;Len + pRoot-&gt;pRight-&gt;Len;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(CNode *pRoot, <span class="keyword">int</span> Left, <span class="keyword">int</span> Right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//在区间pRoot删除矩形右边的一部分或全部，该矩形右边的一部分或全部覆盖了区间[L,R]</span></span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Left == Left&amp;&amp;pRoot-&gt;Right == Right)</span><br><span class="line">	{</span><br><span class="line">		pRoot-&gt;Covers--;</span><br><span class="line">		<span class="keyword">if</span> (pRoot-&gt;Covers == <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (pRoot-&gt;Left == pRoot-&gt;Right)</span><br><span class="line">			{</span><br><span class="line">				pRoot-&gt;Len = <span class="number">0</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			{</span><br><span class="line">				pRoot-&gt;Len = pRoot-&gt;pLeft-&gt;Len + pRoot-&gt;pRight-&gt;Len;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Right &lt;= pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Delete(pRoot-&gt;pLeft, Left, Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Left &gt; pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Delete(pRoot-&gt;pRight,Left, Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		Delete(pRoot-&gt;pLeft, Left, pRoot-&gt;Mid());</span><br><span class="line">		Delete(pRoot-&gt;pRight, pRoot-&gt;Mid() + <span class="number">1</span>, Right);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Covers == <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//如果不为0，则说明本区间当前仍然被某个矩形完全包含，则不能更新Len</span></span><br><span class="line">		pRoot-&gt;Len = pRoot-&gt;pLeft-&gt;Len + pRoot-&gt;pRight-&gt;Len;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> nCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">double</span> x1, y1, x2, y2;</span><br><span class="line">	<span class="keyword">int</span> yc, lc;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		t++;</span><br><span class="line">		yc = lc = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="comment">//左上角和右下角顶点坐标</span></span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line"></span><br><span class="line">			y[yc++] = y1;</span><br><span class="line">			y[yc++] = y2;</span><br><span class="line">			<span class="comment">//左边</span></span><br><span class="line">			Lines[lc].x = x1;</span><br><span class="line">			Lines[lc].y1 = y1;</span><br><span class="line">			Lines[lc].y2 = y2;</span><br><span class="line">			Lines[lc].bLeft = <span class="literal">true</span>;</span><br><span class="line">			lc++;</span><br><span class="line">			<span class="comment">//右边</span></span><br><span class="line">			Lines[lc].x = x2;</span><br><span class="line">			Lines[lc].y1 = y1;</span><br><span class="line">			Lines[lc].y2 = y2;</span><br><span class="line">			Lines[lc].bLeft = <span class="literal">false</span>;</span><br><span class="line">			lc++;</span><br><span class="line">		}</span><br><span class="line">		sort(y, y + yc);</span><br><span class="line">		yc = unique(y, y + yc) - y;</span><br><span class="line">		<span class="comment">//yc是横线的条数，yc-1是纵向区间的个数，这些区间从0开始编号，那么最后一个区间编号就是yc-1-1;</span></span><br><span class="line">		BuildTree(Tree, <span class="number">0</span>, yc - <span class="number">1</span> - <span class="number">1</span>);</span><br><span class="line">		sort(Lines, Lines + lc);</span><br><span class="line">		<span class="keyword">double</span> Area = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lc - <span class="number">1</span>; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">int</span> Left = bin_search(y, y + yc, Lines[i].y1) - y;</span><br><span class="line">			<span class="keyword">int</span> Right = bin_search(y, y + yc, Lines[i].y2) - y;</span><br><span class="line">			<span class="keyword">if</span> (Lines[i].bLeft)</span><br><span class="line">			{</span><br><span class="line">				Insert(Tree, Left, Right - <span class="number">1</span>);</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			{</span><br><span class="line">				Delete(Tree, Left, Right - <span class="number">1</span>);</span><br><span class="line">			}</span><br><span class="line">			Area += Tree[<span class="number">0</span>].Len*(Lines[i + <span class="number">1</span>].x - Lines[i].x);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Test case #"</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">			&lt;&lt; <span class="string">"Total explored area: "</span> &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; Area &lt;&lt; <span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在理解的基础上，自己再默写一遍真的很有用，坚持下！Keep！</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ERROR = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">double</span> y[<span class="number">2</span> * MAXN + <span class="number">10</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> Left;</span><br><span class="line">	<span class="keyword">int</span> Right;</span><br><span class="line">	<span class="keyword">int</span> Covers;</span><br><span class="line">	<span class="keyword">double</span> Len;</span><br><span class="line">	CNode *pLeft, *pRight;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Mid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> (Left + Right) / <span class="number">2</span>;</span><br><span class="line">	}</span><br><span class="line">}Tree[<span class="number">20</span> * MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CLine</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">double</span> x;</span><br><span class="line">	<span class="keyword">double</span> y1, y2;<span class="comment">//用于计算长度</span></span><br><span class="line">	<span class="keyword">bool</span> bLeft;<span class="comment">//是否是左边</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> CLine &amp;s) <span class="keyword">const</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> x&lt;s.x;</span><br><span class="line">	}</span><br><span class="line">}Line[<span class="number">2</span> * MAXN + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> nNodeCount = <span class="number">0</span>;</span><br><span class="line"><span class="function">Status <span class="title">BuildTree</span><span class="params">(CNode *pRoot, <span class="keyword">int</span> Left, <span class="keyword">int</span> Right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	pRoot-&gt;Left = Left;</span><br><span class="line">	pRoot-&gt;Right = Right;</span><br><span class="line">	pRoot-&gt;Len = <span class="number">0</span>;</span><br><span class="line">	pRoot-&gt;Covers = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (Left == Right)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	nNodeCount++;</span><br><span class="line">	pRoot-&gt;pLeft = Tree + nNodeCount;</span><br><span class="line">	nNodeCount++;</span><br><span class="line">	pRoot-&gt;pRight = Tree + nNodeCount;</span><br><span class="line">	BuildTree(pRoot-&gt;pLeft, Left, pRoot-&gt;Mid());</span><br><span class="line">	BuildTree(pRoot-&gt;pRight, pRoot-&gt;Mid() + <span class="number">1</span>, Right);</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"><span class="function">Status <span class="title">Insert</span><span class="params">(CNode *pRoot, <span class="keyword">int</span> Left, <span class="keyword">int</span> Right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Left == Left&amp;&amp;pRoot-&gt;Right == Right)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//不直接递归到叶子节点</span></span><br><span class="line">		<span class="comment">//如果直接到叶子节点，时间复杂度不说</span></span><br><span class="line">		<span class="comment">//在删除线段的时候，还必须到叶子节点</span></span><br><span class="line">		<span class="comment">//太复杂，只要更新到相应区间就行了，操作还跟方便</span></span><br><span class="line">		<span class="comment">//时间复杂度也更低</span></span><br><span class="line">		pRoot-&gt;Covers++;</span><br><span class="line">		pRoot-&gt;Len = y[Right + <span class="number">1</span>] - y[Left];</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (Right &lt;= pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Insert(pRoot-&gt;pLeft, Left, Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Left&gt;pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Insert(pRoot-&gt;pRight, Left, Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		Insert(pRoot-&gt;pLeft, Left, pRoot-&gt;Mid());</span><br><span class="line">		Insert(pRoot-&gt;pRight, pRoot-&gt;Mid() + <span class="number">1</span>, Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//因为这里Len的值时映射值，所以必须检查子节点的Len值</span></span><br><span class="line">	<span class="comment">//如果区间没有完全覆盖，那么一个区间的Len值等于该区间内的子树的节点Len值之和</span></span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Covers == <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		pRoot-&gt;Len = pRoot-&gt;pLeft-&gt;Len + pRoot-&gt;pRight-&gt;Len;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(CNode *pRoot, <span class="keyword">int</span> Left, <span class="keyword">int</span> Right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Left == Left&amp;&amp;pRoot-&gt;Right == Right)</span><br><span class="line">	{<span class="comment">//同样不必删除到叶子节点</span></span><br><span class="line">		pRoot-&gt;Covers--;</span><br><span class="line">		<span class="comment">//注意叶子节点的左右孩子为NULL！！！</span></span><br><span class="line">		<span class="comment">//自然会想到Insert的时候为什么没有考虑，其实已经做了特殊处理，不再累述</span></span><br><span class="line">		<span class="keyword">if</span> (pRoot-&gt;Covers == <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (pRoot-&gt;Left == pRoot-&gt;Right)</span><br><span class="line">			{</span><br><span class="line">				pRoot-&gt;Len = <span class="number">0</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			{</span><br><span class="line">				pRoot-&gt;Len = pRoot-&gt;pLeft-&gt;Len + pRoot-&gt;pRight-&gt;Len;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (Right &lt;= pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Delete(pRoot-&gt;pLeft, Left, Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Left&gt;pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Delete(pRoot-&gt;pRight, Left, Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		Delete(pRoot-&gt;pLeft, Left, pRoot-&gt;Mid());</span><br><span class="line">		Delete(pRoot-&gt;pRight, pRoot-&gt;Mid() + <span class="number">1</span>, Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//如果区间不匹配，且Covers为0，同理该区间更新Len值</span></span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Covers == <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		pRoot-&gt;Len = pRoot-&gt;pLeft-&gt;Len + pRoot-&gt;pRight-&gt;Len;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">F</span> <span class="title">bin_search</span>(<span class="title">F</span> <span class="title">src</span>, <span class="title">F</span> <span class="title">dst</span>, <span class="title">T</span> <span class="title">val</span>)</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	F Left = src;</span><br><span class="line">	F Right = dst - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (Left &lt;= Right)</span><br><span class="line">	{</span><br><span class="line">		F mid = Left + (Right - Left) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (*mid == val)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (val&lt;*mid)</span><br><span class="line">		{</span><br><span class="line">			Right = mid - <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			Left = mid + <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> dst;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> nPointCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">double</span> x1, x2, y1, y2;</span><br><span class="line">	<span class="keyword">int</span> nLineCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n&amp;&amp;n != <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		t++;</span><br><span class="line">		nPointCount = nLineCount = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">			y[nPointCount++] = y1;</span><br><span class="line">			y[nPointCount++] = y2;</span><br><span class="line">			<span class="comment">//左边</span></span><br><span class="line">			Line[nLineCount].x = x1;</span><br><span class="line">			Line[nLineCount].y1 = y1;</span><br><span class="line">			Line[nLineCount].y2 = y2;</span><br><span class="line">			Line[nLineCount].bLeft = <span class="literal">true</span>;</span><br><span class="line">			nLineCount++;</span><br><span class="line">			Line[nLineCount].x = x2;</span><br><span class="line">			Line[nLineCount].y1 = y1;</span><br><span class="line">			Line[nLineCount].y2 = y2;</span><br><span class="line">			Line[nLineCount].bLeft = <span class="literal">false</span>;</span><br><span class="line">			nLineCount++;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//去重</span></span><br><span class="line">		sort(y, y + nPointCount);</span><br><span class="line">		nPointCount = unique(y, y + nPointCount) - y;</span><br><span class="line">		<span class="comment">//离散化</span></span><br><span class="line">		<span class="comment">//nPointCount个点，nPointCount-1个区间</span></span><br><span class="line">		BuildTree(Tree, <span class="number">0</span>, nPointCount - <span class="number">1</span> - <span class="number">1</span>);</span><br><span class="line">		sort(Line, Line + nLineCount);</span><br><span class="line">		<span class="comment">//扫描</span></span><br><span class="line">		<span class="keyword">double</span> Area = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nLineCount - <span class="number">1</span>; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">int</span> Left = bin_search(y, y + nPointCount, Line[i].y1) - y;</span><br><span class="line">			<span class="keyword">int</span> Right = bin_search(y, y + nPointCount, Line[i].y2) - y;</span><br><span class="line">			<span class="keyword">if</span> (Line[i].bLeft)</span><br><span class="line">			{</span><br><span class="line">				Insert(Tree, Left, Right - <span class="number">1</span>);<span class="comment">//注意区间，例如点0 1 2 区间对应1 2</span></span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			{</span><br><span class="line">				Delete(Tree, Left, Right - <span class="number">1</span>);</span><br><span class="line">			}</span><br><span class="line">			Area += Tree[<span class="number">0</span>].Len*(Line[i + <span class="number">1</span>].x - Line[i].x);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Test case #"</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">			&lt;&lt; <span class="string">"Total explored area: "</span> &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; Area &lt;&lt; <span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//恩，再来一遍换个方向扫描的，但你妈，出现了一个问题</span></span><br><span class="line"><span class="comment">//我的Insert里面的一个pRight打成了pLeft，打人！</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ERROR = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> Left;</span><br><span class="line">	<span class="keyword">int</span> Right;</span><br><span class="line">	<span class="keyword">int</span> Covers;</span><br><span class="line">	<span class="keyword">double</span> Len;<span class="comment">//映射长</span></span><br><span class="line">	CNode *pLeft, *pRight;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Mid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> (Left + Right) / <span class="number">2</span>;</span><br><span class="line">	}</span><br><span class="line">}Tree[<span class="number">20</span> * MAXN + <span class="number">1</span>];<span class="comment">//顶点共有2n个，那么最大结点数为2n-1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CLine</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">double</span> y;</span><br><span class="line">	<span class="keyword">double</span> x1;</span><br><span class="line">	<span class="keyword">double</span> x2;</span><br><span class="line">	<span class="keyword">bool</span> bHigh;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> CLine &amp;s)<span class="keyword">const</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> y &lt; s.y;</span><br><span class="line">	}</span><br><span class="line">}Line[<span class="number">2</span> * MAXN + <span class="number">1</span>];<span class="comment">//线段个数2n</span></span><br><span class="line"><span class="keyword">int</span> nNodeCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> x[<span class="number">2</span> * MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="function">Status <span class="title">BuildTree</span><span class="params">(CNode *pRoot, <span class="keyword">int</span> Left, <span class="keyword">int</span> Right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	pRoot-&gt;Left = Left;</span><br><span class="line">	pRoot-&gt;Right = Right;</span><br><span class="line">	pRoot-&gt;Covers = <span class="number">0</span>;</span><br><span class="line">	pRoot-&gt;Len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (Left == Right)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	nNodeCount++;</span><br><span class="line">	pRoot-&gt;pLeft = Tree + nNodeCount;</span><br><span class="line">	nNodeCount++;</span><br><span class="line">	pRoot-&gt;pRight = Tree + nNodeCount;</span><br><span class="line">	BuildTree(pRoot-&gt;pLeft, Left, pRoot-&gt;Mid());</span><br><span class="line">	BuildTree(pRoot-&gt;pRight, pRoot-&gt;Mid() + <span class="number">1</span>, Right);</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Insert</span><span class="params">(CNode *pRoot, <span class="keyword">int</span> Left, <span class="keyword">int</span> Right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Left == Left&amp;&amp;pRoot-&gt;Right == Right)</span><br><span class="line">	{</span><br><span class="line">		pRoot-&gt;Covers++;</span><br><span class="line">		pRoot-&gt;Len = x[Right + <span class="number">1</span>] - x[Left];</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (Right &lt;= pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Insert(pRoot-&gt;pLeft, Left, Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Left &gt; pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Insert(pRoot-&gt;pRight, Left, Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		Insert(pRoot-&gt;pLeft, Left, pRoot-&gt;Mid());</span><br><span class="line">		Insert(pRoot-&gt;pRight, pRoot-&gt;Mid() + <span class="number">1</span>, Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Covers == <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		pRoot-&gt;Len = pRoot-&gt;pLeft-&gt;Len + pRoot-&gt;pRight-&gt;Len;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(CNode *pRoot, <span class="keyword">int</span> Left, <span class="keyword">int</span> Right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Left == Left&amp;&amp;pRoot-&gt;Right == Right)</span><br><span class="line">	{</span><br><span class="line">		pRoot-&gt;Covers--;</span><br><span class="line">		<span class="keyword">if</span> (pRoot-&gt;Covers == <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (pRoot-&gt;Left == pRoot-&gt;Right)</span><br><span class="line">			{</span><br><span class="line">				pRoot-&gt;Len = <span class="number">0</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			{</span><br><span class="line">				pRoot-&gt;Len = pRoot-&gt;pLeft-&gt;Len + pRoot-&gt;pRight-&gt;Len;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (Right &lt;= pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Delete(pRoot-&gt;pLeft, Left, Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Left &gt; pRoot-&gt;Mid())</span><br><span class="line">	{</span><br><span class="line">		Delete(pRoot-&gt;pRight, Left, Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		Delete(pRoot-&gt;pLeft, Left, pRoot-&gt;Mid());</span><br><span class="line">		Delete(pRoot-&gt;pRight, pRoot-&gt;Mid() + <span class="number">1</span>, Right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;Covers == <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		pRoot-&gt;Len = pRoot-&gt;pLeft-&gt;Len + pRoot-&gt;pRight-&gt;Len;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">F</span> <span class="title">bin_search</span>(<span class="title">F</span> <span class="title">src</span>, <span class="title">F</span> <span class="title">dst</span>, <span class="title">T</span> <span class="title">val</span>)</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	F Left = src;</span><br><span class="line">	F Right = dst - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (Left &lt;= Right)</span><br><span class="line">	{</span><br><span class="line">		F mid = Left + (Right - Left) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (*mid == val)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (val &lt; *mid)</span><br><span class="line">		{</span><br><span class="line">			Right = mid - <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			Left = mid + <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> dst;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> nPointCount;</span><br><span class="line">	<span class="keyword">int</span> nLineCount;</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">double</span> x1, x2, y1, y2;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n&amp;&amp;n != <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		t++;</span><br><span class="line">		nPointCount = nLineCount = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">			x[nPointCount++] = x1;</span><br><span class="line">			x[nPointCount++] = x2;</span><br><span class="line"></span><br><span class="line">			Line[nLineCount].y = y1;</span><br><span class="line">			Line[nLineCount].x1 = x1;</span><br><span class="line">			Line[nLineCount].x2 = x2;</span><br><span class="line">			Line[nLineCount].bHigh = <span class="literal">false</span>;</span><br><span class="line">			nLineCount++;</span><br><span class="line"></span><br><span class="line">			Line[nLineCount].y = y2;</span><br><span class="line">			Line[nLineCount].x1 = x1;</span><br><span class="line">			Line[nLineCount].x2 = x2;</span><br><span class="line">			Line[nLineCount].bHigh = <span class="literal">true</span>;</span><br><span class="line">			nLineCount++;</span><br><span class="line">		}</span><br><span class="line">		sort(x, x + nPointCount);</span><br><span class="line">		nPointCount = unique(x, x + nPointCount) - x;</span><br><span class="line"></span><br><span class="line">		BuildTree(Tree, <span class="number">0</span>, nPointCount - <span class="number">1</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		sort(Line, Line + nLineCount);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">double</span> Area = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLineCount - <span class="number">1</span>; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">int</span> Left = bin_search(x, x + nPointCount, Line[i].x1) - x;</span><br><span class="line">			<span class="keyword">int</span> Right = bin_search(x, x + nPointCount, Line[i].x2) - x;</span><br><span class="line">			<span class="keyword">if</span> (Line[i].bHigh)</span><br><span class="line">			{</span><br><span class="line">				Delete(Tree, Left, Right - <span class="number">1</span>);</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			{</span><br><span class="line">				Insert(Tree, Left, Right - <span class="number">1</span>);</span><br><span class="line">			}</span><br><span class="line">			Area += Tree[<span class="number">0</span>].Len*(Line[i + <span class="number">1</span>].y - Line[i].y);</span><br><span class="line"></span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Test case #"</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">			&lt;&lt; <span class="string">"Total explored area: "</span> &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; Area &lt;&lt; <span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><a href="http://www.cnblogs.com/fenshen371/p/3214092.html" target="_blank" rel="noopener"><strong>参考</strong></a></p>
<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><ul>
<li><strong>对于序列a，我们设一个数组C</strong><br>– <strong>$C[i]=a[i-2^k+1]+…+a[i]$</strong><br>– <strong>k为i在二进制下末尾0的个数</strong><br>– <strong>$2^k$就是i保留最右边的1，其余位全变0</strong><br>– <strong>i从1开始算！</strong></li>
<li><strong>C即为a的树状数组</strong></li>
<li><strong>对于i，如何求$2^k$?</strong></li>
<li><strong>$2^k=i&amp;{(-1)}$</strong></li>
</ul>
<p><strong>关于$2^k=i&amp;(-i)$的说明：</strong><br>由于k是i末尾0的个数，那么$2^k$就是$0.010..0$(1后k个0)，那么也就是说保留i的最低位1，其余全变成0，做到这一点可以这么考虑：<br>i各位取反，可以知道$i&amp;!i=0$，那么为了只保留最低位的1——由于最低位1后面都为0，那么最低位1后面0各位取反都会得到1，那么i的各位取反+1后就可以得到构造出新的$i’=!i+1$，而$i’$的最低位1与i的最低位1位置相同，最低位1之前各位与$!i$相同，最低位1后都为0<br>那么$i&amp;i’=2^k$，而$i’$的表示在这里恰好就是负数的补码定义，而计算机中存储负数恰好就是采用补码，所以$2^k=i&amp;(-i)$</p>
<ul>
<li><p><strong>通常我们用$Lowbit(x)$表示对应的$2^k$</strong></p>
</li>
<li><p><strong>$Lowbit(x)=x&amp;(-x)$</strong></p>
</li>
<li><p><strong>$Lowbit(x)$实际上就是x的二进制表示形式留下最右边的1，其他位都变成0</strong></p>
</li>
<li><p><strong>$C[i]=a[i-Lowbit(i)+1]+…+a[i]$</strong></p>
</li>
<li><p><strong>C[i]表示的区间的最后一个元素一定是a[i]</strong><br><img src="/assets/img/algorithm/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.png" alt="树状数组"></p>
</li>
<li><p><strong>树状数组的好处在于能快速求任意区间的和$a[i]+a[i+1]+…+a[j]$</strong><br>设$sum(k)=a[1]+a[2]+a[3]+…+a[k]$<br>则$a[i]+a[i+1]+…+a[j]=sum(j)-sum(i-1)$<br>有了树状数组，$sum(k)$就能在$O(\log_2 N)$时间内求出，N是a数组元素</p>
</li>
</ul>
<p>有了树状数组，$sum(k)$就能在$O(\log_2 n)$时间内求出，N是a数组元素个数。而且更新一个a的元素所花的时间也是$O(\log_2 n)$的(因为a更新了C也得更新)。<br>根据C的构成规律，可以发现sum(k)可以表示为：<br>$sum(k)=C[n_1]+C[n_2]+…+C[n_m]$<br>其中$n_m=k$<br>$n_{i-1}=n_i-Lowbit(n_i)$而且$n_1-Lowbit(n_1)$必须等于0，$n_1$大于0</p>
<p>如：$sum(6)=C[4]+C[6]$<br>$Lowbit(x)$实际上就是x的二进制表示形式留下最右边的1，其他为都变成0<br>那么，$sum(k)$最多有几项？这个决定了求区间和的时间复杂度</p>
<p>$n_i-Lowbit(n_i)$就是$n_i$的二进制去掉最右边的1<br>k的二进制里最多有$ceil(\log_2 k)$个1<br>$sum(k)$最多$ceil(\log_2 k)$项，所以本次求和的复杂度就是$\log_2 k$<br>证明：$sum(k)=a[i]+…+a[k]=C[n_1]+…C[n_k]$<br>$C[n_m]=a[n_m-Lowbit(n_m)+1]+…+a[n_m]$<br>$C[n_m]=a[n_{m-1}-Lowbit(n_{m-1})+1]+…+a[n_{m-1}]$<br>$=a[n_{m-1}-Lowbit(n_{m-1})+1]+…+a[n_m-Lowbit(n_m)]$<br>$C[n_{m-2}]=a[n_{m-2}-Lowbit(n_{m-2})+1]+…+a[n_{m-2}]$<br>……<br>$C[n_1]=a[n_1-Lowbit(n_1)+1]+…+a[n_1]$<br>$=a[1]+..+a[n_1]$<br>(因$n_1-Lowbit(n_1)$必须等于0，否则就还需要$C[n_1-Lowbit(n_1)]$了)</p>
<ul>
<li><strong>更新一个a元素，C也要跟着更新，复杂度是多少呢？即C里有几项要更新呢？</strong><br>如果a[i]更新了，那么以下的几项都需要更新：<br>$C[n_1],C[n_2],…,C[n_m]$<br>其中，$n_1=i,n_{i+1}=n_i+Lowbit(n_i)$<br>$n_m+Lowbit(n_m)$必须大于a的元素个数N，$n_m$小于等于N，同理，总的来说更新一个元素的时间，也是$\log_2 N$</li>
</ul>
<p>原因如下：<br>$a[i]$更新-&gt;$C[i]$必须更新，因为$C[i]=a[i-Lowbit(i)+1]+…+a[i]$<br>$C[k]=a[k-Lowbit(k)+1]+…+a[k]$<br>$C[k+Lowbit(k)]=a[k+Lowbit(k)-Lowbit(k+Lowbit(k))+1]+…+a[k+Lowbit(k)]$<br>注意第一项，一个数加上自身最低位1，然后新的数减去自身最低位1，结果肯定比这个数小，即$k+Lowbit(k)-Lowbit(k+Lowbit(k))&lt;k$,故$k+Lowbit(k)-Lowbit(k+Lowbit(k))+1&lt;=k$，所以说$C[k+Lowbit(k)]$的起始项不晚于$C[k]$的起始项，所以，若$C[k]$包含$a[i]$，则$C[k+Lowbit(k)]$也包含$a[i]$，即$C[k]$需要更新-&gt;$C[k+Lowbit(k)]$也需要更新</p>
<ul>
<li><strong>初始状态下由a构建树状数组C的时间复杂度是多少？</strong><br>显然是$O(N)$的：<br>$∵C[k]=sum(k)-sum(k-Lowbit(k))$<br>$sum(k)=C[n_1]+C[n_2]+…+C[n_{m-1}]+C[n_m],\left(n_m=k\right)$<br>$n_{m-1}=k-Lowbit(k)$<br>$sum(k-Lowbit(k))=C[n_1]+C[n_2]+…+C[n_{m-1}]$</li>
</ul>
<p>所以，树状数组适合单个元素经常修改而且还反复要求部分的区间的和的情况。<br>上述问题虽然也可以用线段树解决，但是用树状数组来做，编程效率和程序运行效率都更高（时间复杂度相同，但是树状数组常数小）<br>如果每次要修改的不是单个元素，而是一个区间，那么就不能用树状数组了（效率过低）</p>
<ul>
<li><p><strong>树状数组时间复杂度总结：</strong><br>建数组：$O(N)$<br>更新：$O(\log_2 n)$<br>局部求和：$O(\log_2 n)$</p>
</li>
<li><p><strong>注意：图示的每个节点和这里表示的$sum(k)=a[i]+…+a[k]=C[n_1]+…C[n_k]$就会发现，树状数组其实也是二分的性质，同线段树类似。</strong><br><a href="http://www.cnblogs.com/ECJTUACM-873284962/p/6380245.html" target="_blank" rel="noopener"><strong>参考</strong></a></p>
</li>
</ul>
<h3 id="Apple-Tree"><a href="#Apple-Tree" class="headerlink" title="Apple Tree"></a>Apple Tree</h3><p><strong>Description</strong><br>There is an apple tree outside of kaka’s house. Every autumn, a lot of apples will grow in the tree. Kaka likes apple very much, so he has been carefully nurturing the big apple tree.<br>The tree has N forks which are connected by branches. Kaka numbers the forks by 1 to N and the root is always numbered by 1. Apples will grow on the forks and two apple won’t grow on the same fork. kaka wants to know how many apples are there in a sub-tree, for his study of the produce ability of the apple tree.<br>The trouble is that a new apple may grow on an empty fork some time and kaka may pick an apple from the tree for his dessert. Can you help kaka?<br><strong>Input</strong><br>The first line contains an integer N (N ≤ 100,000) , which is the number of the forks in the tree.<br>The following N - 1 lines each contain two integers u and v, which means fork u and fork v are connected by a branch.<br>The next line contains an integer M (M ≤ 100,000).<br>The following M lines each contain a message which is either<br>“C x” which means the existence of the apple on fork x has been changed. i.e. if there is an apple on the fork, then Kaka pick it; otherwise a new apple has grown on the empty fork.<br>or<br>“Q x” which means an inquiry for the number of apples in the sub-tree above the fork x, including the apple (if exists) on the fork x<br>Note the tree is full of apples at the beginning<br><strong>Output</strong><br>For every inquiry, output the correspond answer per line.<br><strong>Sample Input</strong><br>3<br>1 2<br>1 3<br>3<br>Q 1<br>C 2<br>Q 1<br><strong>Sample Output</strong><br>3<br>2<br><strong>Procedure</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：Apple_Tree.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">树状数组做：</span></span><br><span class="line"><span class="comment">一棵树上长了苹果，每一个树枝节点上有长苹果和不长苹果两种状态，两种操作，</span></span><br><span class="line"><span class="comment">一种操作能够改变树枝上苹果的状态，另一种操作询问某一树枝节点以下的所有</span></span><br><span class="line"><span class="comment">的苹果有多少。</span></span><br><span class="line"><span class="comment">具体做法是做一次dfs，记下每个节点的开始时间Start[i]和结束时间End[i]，</span></span><br><span class="line"><span class="comment">那么对于i节点的所有子孙的开始时间和结束时间都应位于Start[i]和End[i]之间</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">然后用树状数组C统计Start[i]到End[i]之间的附加苹果总数。</span></span><br><span class="line"><span class="comment">这里用树状数组统计图区间可以用Sum(End[i])-Sum(Start[i]-1)来计算</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.10.27</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MY_MAX = <span class="number">220000</span>;</span><br><span class="line"><span class="keyword">int</span> C[MY_MAX];</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;G(MY_MAX / <span class="number">2</span>); <span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">int</span> Lowbit[MY_MAX];</span><br><span class="line"><span class="keyword">bool</span> HasApple[MY_MAX / <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> Start[MY_MAX];<span class="comment">//左值</span></span><br><span class="line"><span class="keyword">int</span> End[MY_MAX];<span class="comment">//右值</span></span><br><span class="line"><span class="keyword">int</span> nCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ERROR = <span class="number">0</span>;</span><br><span class="line"><span class="function">Status <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span><span class="comment">//给每个节点分配左值和右值，以表示该节点表示的区间</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Start[v] = ++nCount;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++)</span><br><span class="line">	{</span><br><span class="line">		DFS(G[v][i]);</span><br><span class="line">	}</span><br><span class="line">	End[v] = ++nCount;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuerySum</span><span class="params">(<span class="keyword">int</span> p)</span><span class="comment">//求Sum(p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> nSum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p &gt; <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		nSum += C[p];</span><br><span class="line">		p -= Lowbit[p];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> nSum;</span><br><span class="line">}</span><br><span class="line"><span class="function">Status <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span> (p &lt;= nCount)</span><br><span class="line">	{</span><br><span class="line">		C[p] += val;</span><br><span class="line">		p += Lowbit[p];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//std::ios::sync_with_stdio(false);</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="comment">//cin &gt;&gt; n;</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="comment">//建图</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">int</span> a, b;</span><br><span class="line">		<span class="comment">//cin &gt;&gt; a &gt;&gt; b;</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">		G[a].push_back(b);<span class="comment">//a有边连到b</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//核心代码段</span></span><br><span class="line">	<span class="comment">//////////////////////////////</span></span><br><span class="line">	nCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	DFS(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//树状数组要处理的原始数组下标范围1-nCount</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= nCount; i++)</span><br><span class="line">	{</span><br><span class="line">		Lowbit[i] = i&amp;(-i);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	{</span><br><span class="line">		HasApple[i] = <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="comment">//求C数组，即树状数组的节点的值</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= nCount; i++)</span><br><span class="line">	{</span><br><span class="line">		C[i] = i - (i - Lowbit[i]);</span><br><span class="line">		<span class="comment">//C[i]=Sum[i]-Sum[i-Lowbit(i)]</span></span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//cin &gt;&gt; m;</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">char</span> cmd[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">int</span> a;</span><br><span class="line">		<span class="comment">//cin &gt;&gt; cmd &gt;&gt; a;</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, cmd, &amp;a);</span><br><span class="line">		<span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'C'</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (HasApple[a]==<span class="number">1</span>)</span><br><span class="line">			{</span><br><span class="line">				Modify(Start[a], <span class="number">-1</span>);</span><br><span class="line">				Modify(End[a], <span class="number">-1</span>);</span><br><span class="line">				HasApple[a] = <span class="number">0</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			{</span><br><span class="line">				Modify(Start[a], <span class="number">1</span>);</span><br><span class="line">				Modify(End[a], <span class="number">1</span>);</span><br><span class="line">				HasApple[a] = <span class="number">1</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">int</span> t1 = QuerySum(End[a]);</span><br><span class="line">			<span class="keyword">int</span> t2 = QuerySum(Start[a] - <span class="number">1</span>);</span><br><span class="line">			<span class="comment">//cout &lt;&lt; (t1 - t2) / 2 &lt;&lt; endl;</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (t1 - t2) / <span class="number">2</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="树状数组求逆序对"><a href="#树状数组求逆序对" class="headerlink" title="树状数组求逆序对"></a>树状数组求逆序对</h2><ul>
<li><p><strong>这个思路很巧妙啊！</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> val;<span class="comment">//数组值</span></span><br><span class="line">	<span class="keyword">int</span> order;<span class="comment">//数组顺序</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>首先引入例子：</strong><br>原始数组：<br>  i: 1 2 3 4 5<br>val: 9 0 1 5 4<br>order: 1 2 3 4 5</p>
</li>
<li><p><strong>对原始数组按照val值进行升序排列：</strong><br>  i: 1 2 3 4 5<br>val: 0 1 4 5 9<br>order: 2 3 5 4 1</p>
</li>
<li><p><strong>接下来，重定序，也就是说按照输入的顺序给出关于自然顺序定序：</strong><br>（找出原数组元素排列在1-n中的对应排列映射关系）<br>   i: 1 2 3 4 5<br> val: 0 1 4 5 9<br>order: 2 3 5 4 1<br> val: 9 0 1 5 4<br>record：5 1 2 4 3</p>
</li>
<li><p><strong>record和order的映射关系：</strong><br>record[order]=i</p>
</li>
<li><p><strong>而后求逆序对，按照i=1 2 3 4 5一次插入record进树状数组：</strong><br>这里的i的意义为当前树状数组中插入的元素的个数，先对C全部初始化为0<br>那么逆序对，就是插入一个数，对该元素的C进行更新，表示该元素插入，<br>而计算逆序对的时候，只需要返回i-GetSum(record)就是插入该元素后，获得的逆序对个数<br>例如：<br>①插入i=1,record=5，那么<br>1 2 3 4 5<br>0 0 0 0 1<br>计算区间总和为1，i-GetSum(record)=1-1=0，这里的意思就表示插入5后当前树状数组中没有比5更小的数，<br>因为当前插入个数为i=1，那么找出当前树状数组中更小的数的个数就是当前所得到的逆序对个数<br>换言之，i就是当前区间总和i=GetSum(5)=1,GetSum(record)=GetSum(5)=1<br>②插入i=2,record=1，那么<br>1 2 3 4 5<br>1 0 0 0 1<br>i-GetSum(record)=2-GetSum(1)=2-1=1;<br>即GetSum(5)-GetSum(record)=i-GetSum(1)=2-1=1;<br>……</p>
</li>
<li><p><strong>所以总的思路就是：</strong><br>找出插入当前区间时较小的数的个数，累加结果就是逆序对的个数，即：<br>求出区间总和与当前插入区间的总和之差，累加的结果就是逆序对的个数：<br>当前区间总和有两部分组成：当前插入区间（左半部分区间）总和和右半部分区间总和<br>而右半部分区间的总和就是数较大的部分<br>左半部分区间就是数较小的部分<br>①如果右半部分区间的总和为0，那么在当前插入区间（左半部分区间）就是区间总和，故此时逆序对个数为0<br>②如果右半部分区间的总和不为0，那么区间总和-左半部分区间总和就是当前插入时的逆序对个数<br>所以每次插入元素，就是找之前插入的数中比当前插入元素大的个数！！！！</p>
</li>
</ul>
<p><a href="http://blog.csdn.net/SeasonJoe/article/details/50193789?locationNum=15&amp;fps=1" target="_blank" rel="noopener"><strong>参考</strong></a></p>
<h3 id="Ultra-QuickSort"><a href="#Ultra-QuickSort" class="headerlink" title="Ultra-QuickSort"></a>Ultra-QuickSort</h3><p><strong>Description</strong><br>In this problem, you have to analyze a particular sorting algorithm. The algorithm processes a sequence of n distinct integers by swapping two adjacent sequence elements until the sequence is sorted in ascending order. For the input sequence<br>9 1 0 5 4 ,<br>Ultra-QuickSort produces the output<br>0 1 4 5 9 .<br>Your task is to determine how many swap operations Ultra-QuickSort needs to perform in order to sort a given input sequence.<br><strong>Input</strong><br>The input contains several test cases. Every test case begins with a line that contains a single integer n &lt; 500,000 – the length of the input sequence. Each of the the following n lines contains a single integer 0 ≤ a[i] ≤ 999,999,999, the i-th input sequence element. Input is terminated by a sequence of length n = 0. This sequence must not be processed.<br><strong>Output</strong><br>For every input sequence, your program prints a single line containing an integer number op, the minimum number of swap operations necessary to sort the given input sequence.<br><strong>Sample Input</strong><br>5<br>9<br>1<br>0<br>5<br>4<br>3<br>1<br>2<br>3<br>0<br><strong>Sample Output</strong><br>6<br>0<br><strong>Procedure</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：树状数组求逆序对.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">这个思路很巧妙啊！</span></span><br><span class="line"><span class="comment">struct Node</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">	int val;//数组值</span></span><br><span class="line"><span class="comment">	int order;//数组顺序</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">首先引入例子：</span></span><br><span class="line"><span class="comment">原始数组：</span></span><br><span class="line"><span class="comment">	i: 1 2 3 4 5</span></span><br><span class="line"><span class="comment">  val: 9 0 1 5 4</span></span><br><span class="line"><span class="comment">order: 1 2 3 4 5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对原始数组按照val值进行升序排列：</span></span><br><span class="line"><span class="comment">	i: 1 2 3 4 5</span></span><br><span class="line"><span class="comment">  val: 0 1 4 5 9</span></span><br><span class="line"><span class="comment">order: 2 3 5 4 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">接下来，重定序，也就是说按照输入的顺序给出关于自然顺序定序：</span></span><br><span class="line"><span class="comment">（找出原数组元素排列在1-n中的对应排列映射关系）</span></span><br><span class="line"><span class="comment">	 i: 1 2 3 4 5</span></span><br><span class="line"><span class="comment">   val: 0 1 4 5 9</span></span><br><span class="line"><span class="comment"> order: 2 3 5 4 1</span></span><br><span class="line"><span class="comment">   val: 9 0 1 5 4</span></span><br><span class="line"><span class="comment">record：5 1 2 4 3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">record和order的映射关系：</span></span><br><span class="line"><span class="comment">record[order]=i</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">而后求逆序对，按照i=1 2 3 4 5一次插入record进树状数组：</span></span><br><span class="line"><span class="comment">这里的i的意义为当前树状数组中插入的元素的个数，先对C全部初始化为0</span></span><br><span class="line"><span class="comment">那么逆序对，就是插入一个数，对该元素的C进行更新，表示该元素插入，</span></span><br><span class="line"><span class="comment">而计算逆序对的时候，只需要返回i-GetSum(record)就是插入该元素后，获得的逆序对个数</span></span><br><span class="line"><span class="comment">例如：</span></span><br><span class="line"><span class="comment">①插入i=1,record=5，那么</span></span><br><span class="line"><span class="comment">1 2 3 4 5</span></span><br><span class="line"><span class="comment">0 0 0 0 1</span></span><br><span class="line"><span class="comment">计算区间总和为1，i-GetSum(record)=1-1=0，这里的意思就表示插入5后当前树状数组中没有比5更小的数，</span></span><br><span class="line"><span class="comment">因为当前插入个数为i=1，那么找出当前树状数组中更小的数的个数就是当前所得到的逆序对个数</span></span><br><span class="line"><span class="comment">换言之，i就是当前区间总和i=GetSum(5)=1,GetSum(record)=GetSum(5)=1</span></span><br><span class="line"><span class="comment">②插入i=2,record=1，那么</span></span><br><span class="line"><span class="comment">1 2 3 4 5</span></span><br><span class="line"><span class="comment">1 0 0 0 1</span></span><br><span class="line"><span class="comment">i-GetSum(record)=2-GetSum(1)=2-1=1;</span></span><br><span class="line"><span class="comment">即GetSum(5)-GetSum(record)=i-GetSum(1)=2-1=1;</span></span><br><span class="line"><span class="comment">......</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">所以总的思路就是：</span></span><br><span class="line"><span class="comment">找出插入当前区间时较小的数的个数，累加结果就是逆序对的个数，即：</span></span><br><span class="line"><span class="comment">求出区间总和与当前插入区间的总和之差，累加的结果就是逆序对的个数：</span></span><br><span class="line"><span class="comment">当前区间总和有两部分组成：当前插入区间（左半部分区间）总和和右半部分区间总和</span></span><br><span class="line"><span class="comment">而右半部分区间的总和就是数较大的部分</span></span><br><span class="line"><span class="comment">左半部分区间就是数较小的部分</span></span><br><span class="line"><span class="comment">①如果右半部分区间的总和为0，那么在当前插入区间（左半部分区间）就是区间总和，故此时逆序对个数为0</span></span><br><span class="line"><span class="comment">②如果右半部分区间的总和不为0，那么区间总和-左半部分区间总和就是当前插入时的逆序对个数</span></span><br><span class="line"><span class="comment">所以每次插入元素，就是找之前插入的数中比当前插入元素大的个数！！！！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.10.28</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ERROR = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">int</span> order;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Node &amp;o) <span class="keyword">const</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> val &lt; o.val;</span><br><span class="line">	}</span><br><span class="line">}Data[MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> C[MAXN];</span><br><span class="line"><span class="keyword">int</span> Lowbit[MAXN];</span><br><span class="line"><span class="keyword">int</span> Record[MAXN];</span><br><span class="line"><span class="function">Status <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= n)</span><br><span class="line">	{</span><br><span class="line">		C[i] += val;</span><br><span class="line">		i += Lowbit[i];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSum</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> Sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		Sum += C[i];</span><br><span class="line">		i -= Lowbit[i];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> Sum;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="comment">/*cin &gt;&gt; n*/</span><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n != <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="comment">//cin &gt;&gt; Data[i].val;</span></span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Data[i].val);</span><br><span class="line">			Data[i].order = i;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">//树状数组初始化</span></span><br><span class="line">		fill(C, C + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		sort(Data + <span class="number">1</span>, Data + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		{</span><br><span class="line">			Lowbit[i] = i&amp;(-i);</span><br><span class="line">			Record[Data[i].order] = i;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> nSum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		{</span><br><span class="line">			Insert(Record[i], <span class="number">1</span>);</span><br><span class="line">			nSum += i - GetSum(Record[i]);</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//cout &lt;&lt; nSum &lt;&lt; endl;</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, nSum);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h2><p>对于一个数组A[ ]，其差分数组D[i]=A[i]-A[i-1] (i&gt;0)且D[0]=A[0]</p>
<p>令SumD[i]=D[0]+D[1]+D[2]+…+D[i] （SumD[ ]是差分数组D[ ]的前缀和）<br>则SumD[i]=A[0]+A[1]-A[0]+A[2]-A[1]+A[3]-A[2]+…+A[i]-A[i-1]=A[i]<br>所以A[i]=D[0]+D[1]+D[2]+…+D[i]<br>即A[i]的差分数组是D[i]， 而D[i]的前缀和是A[i]</p>
<ul>
<li>最好自己代入例子试一遍，加深理解</li>
<li>总的来说差分数组适用于离线的区间修改问题，如果是在线的话应该用线段树或其他数据结构。</li>
<li>差分数组其实就相当于通过改变区间前端和末端与其他部分的差值，在最后进行累加的时候实行对整个区间的值的改变。</li>
<li>但为什么要存差值呢？————因为数列中的数满A[i]=sum{D[1]…D[i]},便于用递推求得最后的值。</li>
<li>[L,R]的元素值加C：</li>
</ul>
<p><strong>D[L]+=C,D[R+1]-=Ｃ</strong><br>那么,<br>A[L]=D[0]+…+<strong>D[L]</strong>=A[L]+C<br>A[L+1]=D[0]+…+<strong>D[L]</strong>+D[L+1]=A[L]+C<br>…<br>A[R]=D[0]+…+<strong>D[L]</strong>+…+D[R]=A[R]+C<br>A[R+1]=D[0]+…+<strong>D[L]</strong>+…+<em>D[R+1]</em>=A[R]+C-C=A[R]<br>…</p>
<h3 id="Color-the-ball"><a href="#Color-the-ball" class="headerlink" title="Color the ball"></a>Color the ball</h3><p><strong>Problem Description</strong><br>N个气球排成一排，从左到右依次编号为1,2,3….N.每次给定2个整数a b(a &lt;= b),lele便为骑上他的“小飞鸽”牌电动车从气球a开始到气球b依次给每个气球涂一次颜色。但是N次以后lele已经忘记了第I个气球已经涂过几次颜色了，你能帮他算出每个气球被涂过几次颜色吗？<br><strong>Input</strong><br>每个测试实例第一行为一个整数N,(N &lt;= 100000).接下来的N行，每行包括2个整数a b(1 &lt;= a &lt;= b &lt;= N)。<br>当N = 0，输入结束。<br><strong>Output</strong><br>每个测试实例输出一行，包括N个整数，第I个数代表第I个气球总共被涂色的次数。<br><strong>Sample Input</strong><br>3<br>1 1<br>2 2<br>3 3<br>3<br>1 1<br>1 2<br>1 3<br>0<br><strong>Sample Output</strong><br>1 1 1<br>3 2 1<br><strong>Procedure</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment">文件名称：Cube Stacking.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">离线查询</span></span><br><span class="line"><span class="comment">差分数组</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.10.31</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n&amp;&amp;n != <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">int</span> *Ball = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">		<span class="keyword">int</span> *D = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">		fill(Ball, Ball + n, <span class="number">0</span>);</span><br><span class="line">		fill(D, D + n, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">			D[a - <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">			D[b] -= <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		Ball[<span class="number">0</span>] = D[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">		{</span><br><span class="line">			Ball[i] = D[i] + Ball[i - <span class="number">1</span>];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; Ball[i];</span><br><span class="line">			<span class="keyword">if</span> (i != n - <span class="number">1</span>)</span><br><span class="line">			{</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">delete</span>[] Ball;</span><br><span class="line">		<span class="keyword">delete</span>[] D;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="第九章-并查集"><a href="#第九章-并查集" class="headerlink" title="第九章 并查集"></a>第九章 并查集</h1></blockquote>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集（Union-find Sets）是一种非常精巧而实用的数据结构，它主要用于处理一些不相交集合的合并问题。一些常见的用途有求连通子图、求最小生成树的 Kruskal 算法和求最近公共祖先（Least Common Ancestors, LCA）等。</p>
<p>使用并查集时，首先会存在一组不相交的动态集合$S={S_1,S_2,⋯,S_k}$，一般都会使用一个整数表示集合中的一个元素。</p>
<p>每个集合可能包含一个或多个元素，并选出集合中的某个元素作为代表。每个集合中具体包含了哪些元素是不关心的，具体选择哪个元素作为代表一般也是不关心的。我们关心的是，对于给定的元素，可以很快的找到这个元素所在的集合（的代表），以及合并两个元素所在的集合，而且这些操作的时间复杂度都是常数级的。</p>
<p><strong>并查集的基本操作有三个：<br>①makeSet(s)：建立一个新的并查集，其中包含 s 个单元素集合。<br>②UnionSet(x, y)：把元素 x 和元素 y 所在的集合合并，要求 x 和 y 所在的集合不相交，如果相交则不合并。<br>③Find(x)：找到元素 x 所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将它们各自的代表比较一下就可以了。</strong></p>
<ul>
<li><strong>并查集的实现原理也比较简单，就是使用树来表示集合，树的每个节点就表示集合中的一个元素，树根对应的元素就是该集合的代表</strong><br><img src="/assets/img/algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%8601.png" alt="并查集图示01"><br>图中有两棵树，分别对应两个集合，其中第一个集合为 {a,b,c,d}，代表元素是 a；第二个集合为 {e,f,g}，代表元素是 e。</li>
</ul>
<p>树的节点表示集合中的元素，指针表示指向父节点的指针，根节点的指针指向自己，表示其没有父节点。沿着每个节点的父节点不断向上查找，最终就可以找到该树的根节点，即该集合的代表元素。</p>
<p>现在，应该可以很容易的写出 makeSet 和 find 的代码了，假设使用一个足够长的数组来存储树节点（很类似之前讲到的静态链表），那么 makeSet 要做的就是构造出如图的森林，其中每个元素都是一个单元素集合，即父节点是其自身：<br><img src="/assets/img/algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%8602.png" alt="并查集图示02"></p>
<p>相应的代码如下所示，时间复杂度是 O(n)：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">MakeSet</span><span class="params">(<span class="keyword">int</span> size)</span></span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">  {</span><br><span class="line">    Set_Parent[i]=i;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>接下来，就是 find 操作了，如果每次都沿着父节点向上查找，那时间复杂度就是树的高度，完全不可能达到常数级。这里需要应用一种非常简单而有效的策略——路径压缩。</strong></li>
</ul>
<p>路径压缩，就是在每次查找时，令查找路径上的每个节点都直接指向根节点。<br><img src="/assets/img/algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%8603.png" alt="并查集图示03"></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get_Set_Parent</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">if</span>(x!=Set_Parent[x])</span><br><span class="line">  {</span><br><span class="line">    Set_Parent[x]=Get_Set_Parent(Set_Parent[x]);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> Set_Parent[x];</span><br><span class="line">}<span class="comment">//时间复杂度&lt;=4</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get_Set_Parent</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="comment">//非路径压缩版</span></span><br><span class="line">  <span class="keyword">if</span>(x==Set_Parent[x])</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span>{</span><br><span class="line">    <span class="keyword">return</span> Get_Set_Parent(Set_Parent[x]);</span><br><span class="line">  }</span><br><span class="line">}<span class="comment">//时间时间复杂度可能最差至O(N)</span></span><br></pre></td></tr></tbody></table></figure>
<p>注意：这里的Get_Set_Parent的时间复杂度可以说是&lt;=4，具体分析以后再说，这里记住即可，反正就是效率高！没错的！没毛病！</p>
<ul>
<li><strong>最后是合并操作 unionSet，并查集的合并也非常简单，就是将一个集合的树根指向另一个集合的树根</strong><br><img src="/assets/img/algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%8604.png" alt="并查集图示04"></li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">MergeSet</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  Set_Parent[Get_Set_Parent(x)]=Get_Set_Parent(y);</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><a href="http://www.cnblogs.com/cyjb/p/UnionFindSets.html" target="_blank" rel="noopener"><strong>参考</strong></a></p>
<h2 id="The-Suspects"><a href="#The-Suspects" class="headerlink" title="The Suspects"></a>The Suspects</h2><p><strong>Description</strong><br>Severe acute respiratory syndrome (SARS), an atypical pneumonia of unknown aetiology, was recognized as a global threat in mid-March 2003. To minimize transmission to others, the best strategy is to separate the suspects from others.<br>In the Not-Spreading-Your-Sickness University (NSYSU), there are many student groups. Students in the same group intercommunicate with each other frequently, and a student may join several groups. To prevent the possible transmissions of SARS, the NSYSU collects the member lists of all student groups, and makes the following rule in their standard operation procedure (SOP).<br>Once a member in a group is a suspect, all members in the group are suspects.<br>However, they find that it is not easy to identify all the suspects when a student is recognized as a suspect. Your job is to write a program which finds all the suspects.<br><strong>Input</strong><br>The input file contains several cases. Each test case begins with two integers n and m in a line, where n is the number of students, and m is the number of groups. You may assume that 0 &lt; n &lt;= 30000 and 0 &lt;= m &lt;= 500. Every student is numbered by a unique integer between 0 and n−1, and initially student 0 is recognized as a suspect in all the cases. This line is followed by m member lists of the groups, one line per group. Each line begins with an integer k by itself representing the number of members in the group. Following the number of members, there are k integers representing the students in this group. All the integers in a line are separated by at least one space.<br>A case with n = 0 and m = 0 indicates the end of the input, and need not be processed.<br><strong>Output</strong><br>For each case, output the number of suspects in one line.<br><strong>Sample Input</strong><br>100 4<br>2 1 2<br>5 10 13 11 12 14<br>2 0 1<br>2 99 2<br>200 2<br>1 5<br>5 1 2 3 4 5<br>1 0<br>0 0<br><strong>Sample Output</strong><br>4<br>1<br>1<br><strong>Procedure</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment">文件名称：The_Suspect.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">n个学生分属m个团体，(0&lt;n&lt;=30000,0&lt;=m&lt;=500)一个学生可以属于多个团体。</span></span><br><span class="line"><span class="comment">一个学生疑似患病，则它所属的整个团体都疑似患病。</span></span><br><span class="line"><span class="comment">已知0号学生疑似患病，以及每个团体都由哪些学生构成，求一共多少个学生意思患病。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">最基础的并查集，把所有可以的都并一块。</span></span><br><span class="line"><span class="comment">也就是说，这里由于每个学生可以加入多个社团</span></span><br><span class="line"><span class="comment">那么也就可以把每个人加入的这些社团看成一个集合，因为只要一个社团里面有一个人疑似，</span></span><br><span class="line"><span class="comment">那么社团内每个人加入的所有社团必然也在疑似内，故看成一个集合。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.10.28</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ERROR = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">30010</span>;</span><br><span class="line"><span class="keyword">int</span> Set_Parent[MAXN];<span class="comment">//集合</span></span><br><span class="line"><span class="keyword">int</span> Total[MAXN];<span class="comment">//集合人数</span></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get_Set_Parent</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//获取集合主键同时压缩路径</span></span><br><span class="line">	<span class="keyword">if</span> (i != Set_Parent[i])</span><br><span class="line">	{</span><br><span class="line">		Set_Parent[i] = Get_Set_Parent(Set_Parent[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> Set_Parent[i];</span><br><span class="line">}</span><br><span class="line"><span class="function">Status <span class="title">Merge_Set</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> Parent1 = Get_Set_Parent(a);</span><br><span class="line">	<span class="keyword">int</span> Parent2 = Get_Set_Parent(b);</span><br><span class="line">	<span class="keyword">if</span> (Parent1 == Parent2)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//集合Parent2并入集合Parent1</span></span><br><span class="line">	Total[Parent1] += Total[Parent2];</span><br><span class="line">	Set_Parent[Parent2] = Parent1;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; (n != <span class="number">0</span> || m != <span class="number">0</span>))</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//集合及集合人数初始化</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="comment">//注意从0开始开始</span></span><br><span class="line">		{</span><br><span class="line">			Set_Parent[i] = i;</span><br><span class="line">			Total[i] = <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">int</span> a, b;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; k; j++)</span><br><span class="line">			{</span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; b;</span><br><span class="line">				Merge_Set(a, b);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; Total[Get_Set_Parent(<span class="number">0</span>)] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Cube-Stacking"><a href="#Cube-Stacking" class="headerlink" title="Cube Stacking"></a>Cube Stacking</h2><p><strong>Description</strong><br>Farmer John and Betsy are playing a game with N (1 &lt;= N &lt;= 30,000)identical cubes labeled 1 through N. They start with N stacks, each containing a single cube. Farmer John asks Betsy to perform P (1&lt;= P &lt;= 100,000) operation. There are two types of operations:<br>moves and counts.</p>
<ul>
<li>In a move operation, Farmer John asks Bessie to move the stack containing cube X on top of the stack containing cube Y.</li>
<li>In a count operation, Farmer John asks Bessie to count the number of cubes on the stack with cube X that are under the cube X and report that value.<br>Write a program that can verify the results of the game.</li>
</ul>
<p><strong>Input</strong></p>
<ul>
<li>Line 1: A single integer, P</li>
<li>Lines 2..P+1: Each of these lines describes a legal operation. Line 2 describes the first operation, etc. Each line begins with a ‘M’ for a move operation or a ‘C’ for a count operation. For move operations, the line also contains two integers: X and Y.For count operations, the line also contains a single integer: X.<br>Note that the value for N does not appear in the input file. No move operation will request a move a stack onto itself.</li>
</ul>
<p><strong>Output</strong><br>Print the output from each of the count operations in the same order as the input file.<br><strong>Sample Input</strong><br>6<br>M 1 6<br>C 1<br>M 2 4<br>M 2 6<br>C 3<br>C 4<br><strong>Sample Output</strong><br>1<br>0<br>2<br><strong>Procdure</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment">文件名称：Cube Stacking.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">除了维护一个集合主键外，还需要为每一个Cube分配一个变量表示当前在它下面的Cube的个数</span></span><br><span class="line"><span class="comment">同时还需要一个记录各集合元素个数的数组</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这里集合的主键采用Stack最底下的元素，那么Under[i]就是i到主键之间的距离，可以由Get_Set_Parent(i)得到，</span></span><br><span class="line"><span class="comment">所以在Get_Set_Parent(i)中必须更新Under[i]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">①合并两个集合的时候，x并到y，那么x的主键必须更新Under=Sum[y]</span></span><br><span class="line"><span class="comment">②而合并两个新的集合后，x并到y，那么x中的主键上层的所有元素必须更新Under+=Sum[y]，这一步显然不能在Merge中实现，</span></span><br><span class="line"><span class="comment">那么在Get_Set_Parent中实现，那么只要Under[i]+=Under[Set_Parent[i]]即可</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.10.29</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ERROR = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">30010</span>;</span><br><span class="line"><span class="keyword">int</span> Set_Parent[MAXN];</span><br><span class="line"><span class="keyword">int</span> UnderX[MAXN];<span class="comment">//记录Under以下的Cube个数</span></span><br><span class="line"><span class="keyword">int</span> Sum[MAXN];<span class="comment">//记录每个集合的元素个数值</span></span><br><span class="line"><span class="keyword">int</span> P;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get_Set_Parent</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">/*if (i != Set_Parent[i])</span></span><br><span class="line"><span class="comment">	{</span></span><br><span class="line"><span class="comment">		Set_Parent[i] = Get_Set_Parent(Set_Parent[i]);</span></span><br><span class="line"><span class="comment">		UnderX[i] += UnderX[Set_Parent[i]];</span></span><br><span class="line"><span class="comment">	}*/</span></span><br><span class="line">	<span class="comment">//这里首先要迭代获得Set_Parent[i]更新后的Under然后再进行UnderX[i] += UnderX[Set_Parent[i]];</span></span><br><span class="line">	<span class="comment">//否则将出现错误</span></span><br><span class="line">	<span class="keyword">if</span> (i != Set_Parent[i])</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">int</span> Parent = Get_Set_Parent(Set_Parent[i]);</span><br><span class="line">		UnderX[i] += UnderX[Set_Parent[i]];</span><br><span class="line">		Set_Parent[i] = Parent;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> Set_Parent[i];</span><br><span class="line">}</span><br><span class="line"><span class="function">Status <span class="title">Merge_Set</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//将x放到y中</span></span><br><span class="line">	<span class="keyword">int</span> Parent1 = Get_Set_Parent(x);</span><br><span class="line">	<span class="keyword">int</span> Parent2 = Get_Set_Parent(y);</span><br><span class="line">	<span class="keyword">if</span> (Parent1 == Parent2)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	}</span><br><span class="line">	Set_Parent[Parent1] = Parent2;</span><br><span class="line">	UnderX[Parent1] = Sum[Parent2];<span class="comment">//x的主键更新</span></span><br><span class="line">	Sum[Parent2] += Sum[Parent1];</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; P)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= MAXN; i++)</span><br><span class="line">		{</span><br><span class="line">			Set_Parent[i] = i;</span><br><span class="line">		}</span><br><span class="line">		fill(Sum, Sum + MAXN, <span class="number">1</span>);</span><br><span class="line">		fill(UnderX, UnderX + MAXN, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; P; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">char</span> ch;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">			<span class="keyword">if</span> (ch == <span class="string">'C'</span>)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">int</span> a;</span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">				<span class="comment">//注意合并后，只有主键节点的Under值更新了，</span></span><br><span class="line">        <span class="comment">//而其他节点的Under并没有跟新，而是合并的时候之前的合并更新了！！！</span></span><br><span class="line">        <span class="comment">//即当次合并时，各节点未及时更新，而是更新了之前的合并所产生的变化！</span></span><br><span class="line">				Get_Set_Parent(a);</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; UnderX[a] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">int</span> a, b;</span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">				Merge_Set(a, b);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<h1 id="第十章-最小生成树-MST-问题"><a href="#第十章-最小生成树-MST-问题" class="headerlink" title="第十章 最小生成树(MST)问题"></a>第十章 最小生成树(MST)问题</h1></blockquote>
<h2 id="图的生成树"><a href="#图的生成树" class="headerlink" title="图的生成树"></a>图的生成树</h2><ul>
<li><p>在一个连通图G中，如果取它的全部顶点和一部分边构成一个子图G’，即:$V(G’)=V(G),E(G’)∈E(G)$若边集E(G’)中的边既将图中的<strong>所有顶点连通又不形成回路</strong>，则称子图G’是原图G的一棵生成树。</p>
</li>
<li><p>一棵含有n个点的生成树，必含有n-1条边。<br>##最小生成树</p>
</li>
<li><p>对于一个连通网（连通带权图，假定每条边上的权均为大于零的实数）来说，每棵树的权（即树中所有边的权值总和）也可能不同</p>
</li>
<li><p>具有权最小的生成树称为最小生成树。</p>
<h3 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h3></li>
<li><p>无向连通图的边的集合</p>
</li>
<li><p>无回路</p>
</li>
<li><p>连接所有的点</p>
<h3 id="最小"><a href="#最小" class="headerlink" title="最小"></a>最小</h3></li>
<li><p>所有边的权值之和最小</p>
<h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2></li>
<li><p>假设G=(V,E)是一个具有n个顶点的连通网，T=(U,TE)是G的最小生成树，U,TE初值均为空集。</p>
</li>
<li><p>首先从V中任取一个顶点（假定取v1），将它并入U中，此时U={v1}，然后只要U是V的真子集（U∈V），就从那些一个端点已在T中，另一个端点仍在T外的所有边中，找一条最短边，设为$(v_i,v_j)$，其中$v_i∈U，v_j∈V-U$，并把改变$(v_i,v_j)$和顶点$v_j$分别并入T的边集TE和顶点集U，如此进行下去，每次往生成树并入一个顶点和一条边，知道n-1次后得到最小生成树。</p>
<h3 id="Prim算法实现"><a href="#Prim算法实现" class="headerlink" title="Prim算法实现"></a>Prim算法实现</h3></li>
<li><p>图节点数目为N，正在构造的生成树为T</p>
</li>
<li><p>维护Dist数组，Dist[i]表示v_i到T的“距离”（权值）</p>
</li>
<li><p>开始所有$Dist[i]=∞$，T为空集</p>
</li>
<li><p>①若|T|=N，最小生成树完成。否则取Dist[i]最小的不在T中的点$v_i$，将其加入T</p>
</li>
<li><p>②更新所有与$v_i$有边相连且不在T中的点$v_j$的Dist值：$Dist[i]=min(Dist[j],W(v_i,v_j))$</p>
</li>
<li><p>③转到①</p>
<h3 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h3></li>
<li><p>每次如何从连接T中和T外顶点的所有边中，找到一条最短的</p>
</li>
<li><p>①如果用邻接矩阵存放图，而且选取最短边的时候遍历所有点进行选取，则总时间复杂度为$O(V^2)$，V位顶点个数</p>
</li>
<li><p>②用邻接表存放图，并且使用堆来选取最短边，则总时间复杂度为$O(ElogV)$</p>
</li>
<li><p>不加堆优化的Prim算法适用于密集图，加堆优化的使用与稀疏图。<br><a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/07/30/2615542.html" target="_blank" rel="noopener"><strong>参考</strong></a></p>
<h3 id="Agri-Net"><a href="#Agri-Net" class="headerlink" title="Agri-Net"></a>Agri-Net</h3></li>
</ul>
<p><strong>Description</strong><br>Farmer John has been elected mayor of his town! One of his campaign promises was to bring internet connectivity to all farms in the area. He needs your help, of course.<br>Farmer John ordered a high speed connection for his farm and is going to share his connectivity with the other farmers. To minimize cost, he wants to lay the minimum amount of optical fiber to connect his farm to all the other farms.<br>Given a list of how much fiber it takes to connect each pair of farms, you must find the minimum amount of fiber needed to connect them all together. Each farm must connect to some other farm such that a packet can flow from any one farm to any other farm.<br>The distance between any two farms will not exceed 100,000.<br><strong>Input</strong><br>The input includes several cases. For each case, the first line contains the number of farms, N (3 &lt;= N &lt;= 100). The following lines contain the N x N conectivity matrix, where each element shows the distance from on farm to another. Logically, they are N lines of N space-separated integers. Physically, they are limited in length to 80 characters, so some lines continue onto others. Of course, the diagonal will be 0, since the distance from farm i to itself is not interesting for this problem.<br><strong>Output</strong><br>For each case, output a single integer length that is the sum of the minimum length of fiber required to connect the entire set of farms.<br><strong>Sample Input</strong><br>4<br>0 4 9 21<br>4 0 8 17<br>9 8 0 16<br>21 17 16 0<br><strong>Sample Output</strong><br>28<br><strong>Procedure</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment">文件名称：Agri-Net.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">Prim模板题</span></span><br><span class="line"><span class="comment">priority_queue实现Prim+堆</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.11.01</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INFINITE = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	Edge(<span class="keyword">int</span> v_ = <span class="number">0</span>, <span class="keyword">int</span> w_ = INFINITE) :v(v_), w(w_) {}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp; s)<span class="keyword">const</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> w &gt; s.w;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;Edge&gt; &gt;G(<span class="number">110</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HeapPrim</span><span class="params">(<span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;Edge&gt; &gt; &amp;G, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;vUsed(n, <span class="literal">false</span>);<span class="comment">//已加入的顶点</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vDist(n, INFINITE);<span class="comment">//各顶点到最小生成树的最小距离</span></span><br><span class="line">	priority_queue&lt;Edge&gt; pq;</span><br><span class="line">	<span class="function">Edge <span class="title">xDist</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;<span class="comment">//起点</span></span><br><span class="line">	<span class="keyword">int</span> nDoneCount = <span class="number">0</span>;</span><br><span class="line">	pq.push(xDist);</span><br><span class="line">	<span class="keyword">int</span> TotalW = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (nDoneCount &lt; n &amp;&amp; !pq.empty())</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">do</span> {<span class="comment">//找出当前未加入生成树的最小距离的节点</span></span><br><span class="line">			xDist = pq.top();</span><br><span class="line">			pq.pop();</span><br><span class="line">		} <span class="keyword">while</span> (vUsed[xDist.v] &amp;&amp; !pq.empty());</span><br><span class="line">		<span class="keyword">if</span> (!vUsed[xDist.v])</span><br><span class="line">		{</span><br><span class="line">			vUsed[xDist.v] = <span class="literal">true</span>;<span class="comment">//加入生成树</span></span><br><span class="line">			nDoneCount++;<span class="comment">//生成树顶点更新</span></span><br><span class="line">			TotalW += xDist.w;<span class="comment">//生成树权值更新</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[xDist.v].size(); i++)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">int</span> k = G[xDist.v][i].v;</span><br><span class="line">				<span class="keyword">if</span> (!vUsed[k])</span><br><span class="line">				{</span><br><span class="line">					<span class="keyword">int</span> w = G[xDist.v][i].w;</span><br><span class="line">					<span class="keyword">if</span> (vDist[k] &gt; w)</span><br><span class="line">					{</span><br><span class="line">						vDist[k] = w;</span><br><span class="line">						pq.push(Edge(k, w));</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (nDoneCount &lt; n)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> TotalW;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> N;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">		{</span><br><span class="line">			G[i].clear();</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">int</span> w;</span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">				<span class="keyword">if</span> (w != <span class="number">0</span>)</span><br><span class="line">				{</span><br><span class="line">					G[i].push_back(Edge(j, w));</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; HeapPrim(G, N) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment">文件名称：Agri-Net_Prim.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">Prim模板题</span></span><br><span class="line"><span class="comment">priority_queue实现Prim+堆</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.11.01</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ERROR = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INFINITE = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> End_vertex;<span class="comment">//终点，起点已知</span></span><br><span class="line">	<span class="keyword">int</span> Weight;</span><br><span class="line">	Edge(<span class="keyword">int</span> e_=<span class="number">0</span>, <span class="keyword">int</span> w_=INFINITE) :End_vertex(e_), Weight(w_) {}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;s)<span class="keyword">const</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> Weight &gt; s.Weight;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;Edge&gt; &gt; G(<span class="number">110</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HeapPrim</span><span class="params">(<span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;Edge&gt; &gt;&amp;G, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">Edge <span class="title">tmpVertex</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;<span class="comment">//起点</span></span><br><span class="line">	priority_queue&lt;Edge&gt; pq;</span><br><span class="line">	pq.push(tmpVertex);<span class="comment">//起点入队列</span></span><br><span class="line">	<span class="keyword">int</span> nDoneCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> TotalW = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; Visited(n, <span class="literal">false</span>);<span class="comment">//加入生成树的顶点</span></span><br><span class="line">	<span class="comment">//vector&lt;int&gt; Min_nDist(n, INFINITE);//各顶点到生成树的最短距离</span></span><br><span class="line">	<span class="keyword">while</span> (nDoneCount &lt; n &amp;&amp; !pq.empty())</span><br><span class="line">	{</span><br><span class="line">    tmpVertex = pq.top();</span><br><span class="line">    pq.pop();</span><br><span class="line">    <span class="keyword">if</span>(nDoneCount==n)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">		<span class="keyword">if</span> (!Visited[tmpVertex.End_vertex])</span><br><span class="line">		{</span><br><span class="line">			Visited[tmpVertex.End_vertex] = <span class="literal">true</span>;</span><br><span class="line">			nDoneCount++;</span><br><span class="line">			TotalW += tmpVertex.Weight;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[tmpVertex.End_vertex].size(); i++)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">int</span> vertex = G[tmpVertex.End_vertex][i].End_vertex;</span><br><span class="line">				<span class="keyword">if</span> (!Visited[vertex])</span><br><span class="line">				{</span><br><span class="line">					<span class="keyword">int</span> weight = G[tmpVertex.End_vertex][i].Weight;</span><br><span class="line">					<span class="keyword">if</span> (Min_nDist[vertex] &gt; weight)</span><br><span class="line">					{</span><br><span class="line">						Min_nDist[vertex] = weight;</span><br><span class="line">						pq.push(Edge(vertex, weight));</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (nDoneCount != n)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> TotalW;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> N;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">		{</span><br><span class="line">			G[i].clear();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">int</span> w;</span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">				<span class="keyword">if</span> (w &gt; <span class="number">0</span>)</span><br><span class="line">				{</span><br><span class="line">					G[i].push_back(Edge(j, w));</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; HeapPrim(G, N)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><ul>
<li>假设G=(V,E)是一个具有n个顶点的连通网，T=(U,TE)是G的最小生成树，U=V,TE初值为空。</li>
<li>将图G中的边按权值从小到大依次选取，若选取的边使生成树不形成回路，则把它并入TE中，若形成回路则将其舍弃，直到TE中包含N-1条边为止，此时T为最小生成树。</li>
</ul>
<h3 id="关键问题-1"><a href="#关键问题-1" class="headerlink" title="关键问题"></a>关键问题</h3><ul>
<li>如何判断欲加入的一条边是否与生成树中边构成回路。</li>
<li>将各顶点划分为所属集合的方法来解决，每个集合的表示一个无回路的子集。开始时边集为空，N个顶点分属N个集合，每个集合只有一个顶点，表示顶点之间互不联通。</li>
<li>当从边集中按顺序选取一条边时，若它的两个端点分属于不同的集合，则表明此边连通了两个的部分，因每个部分连通无回路，故连通后 仍不会产生回路，此边保留，同时把相应两个集合合并。<br><a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/07/30/2615542.html" target="_blank" rel="noopener"><strong>参考</strong></a><h3 id="Agri-Net-1"><a href="#Agri-Net-1" class="headerlink" title="Agri-Net"></a>Agri-Net</h3></li>
</ul>
<p><strong>Description</strong><br>Farmer John has been elected mayor of his town! One of his campaign promises was to bring internet connectivity to all farms in the area. He needs your help, of course.<br>Farmer John ordered a high speed connection for his farm and is going to share his connectivity with the other farmers. To minimize cost, he wants to lay the minimum amount of optical fiber to connect his farm to all the other farms.<br>Given a list of how much fiber it takes to connect each pair of farms, you must find the minimum amount of fiber needed to connect them all together. Each farm must connect to some other farm such that a packet can flow from any one farm to any other farm.<br>The distance between any two farms will not exceed 100,000.<br><strong>Input</strong><br>The input includes several cases. For each case, the first line contains the number of farms, N (3 &lt;= N &lt;= 100). The following lines contain the N x N conectivity matrix, where each element shows the distance from on farm to another. Logically, they are N lines of N space-separated integers. Physically, they are limited in length to 80 characters, so some lines continue onto others. Of course, the diagonal will be 0, since the distance from farm i to itself is not interesting for this problem.<br><strong>Output</strong><br>For each case, output a single integer length that is the sum of the minimum length of fiber required to connect the entire set of farms.<br><strong>Sample Input</strong><br>4<br>0 4 9 21<br>4 0 8 17<br>9 8 0 16<br>21 17 16 0<br><strong>Sample Output</strong><br>28<br><strong>Procedure</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment">文件名称：Agri-Net_Prim.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">Kruskal算法</span></span><br><span class="line"><span class="comment">并查集</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.11.04</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ERROR = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> Start_Vertex, End_Vertex, Weight;<span class="comment">//起点，终点，权值</span></span><br><span class="line">	Edge(<span class="keyword">int</span> s_, <span class="keyword">int</span> e_, <span class="keyword">int</span> w_) :Start_Vertex(s_), End_Vertex(e_), Weight(w_) {}</span><br><span class="line">	Edge() {}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Edge &amp;s)<span class="keyword">const</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> Weight &lt; s.Weight;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; Edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Set_Parent;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get_Set_Parent</span><span class="params">(<span class="keyword">int</span> vertex)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (Set_Parent[vertex] != vertex)</span><br><span class="line">	{</span><br><span class="line">		Set_Parent[vertex] = Get_Set_Parent(Set_Parent[vertex]);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> Set_Parent[vertex];</span><br><span class="line">}</span><br><span class="line"><span class="function">Status <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> vertex_a, <span class="keyword">int</span> vertex_b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> parent1 = Get_Set_Parent(vertex_a);</span><br><span class="line">	<span class="keyword">int</span> parent2 = Get_Set_Parent(vertex_b);</span><br><span class="line">	<span class="keyword">if</span> (parent1 == parent2)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	}</span><br><span class="line">	Set_Parent[parent2] = parent1;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> N;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N)</span><br><span class="line">	{</span><br><span class="line">		Edges.clear();</span><br><span class="line">		Set_Parent.clear();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">		{</span><br><span class="line">			Set_Parent.push_back(i);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">int</span> w;</span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">				<span class="keyword">if</span> (w &gt; <span class="number">0</span>&amp;&amp;j&gt;i)<span class="comment">//没有必要记录双向路径，单向路径即可！不过好像也没发现时间复杂度提高多少</span></span><br><span class="line">				{</span><br><span class="line">					Edges.push_back(Edge(i, j, w));</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		sort(Edges.begin(), Edges.end());</span><br><span class="line">		<span class="keyword">int</span> nDoneCount = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> TotalW = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Edges.size(); i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (Get_Set_Parent(Edges[i].Start_Vertex) != Get_Set_Parent(Edges[i].End_Vertex))</span><br><span class="line">			{</span><br><span class="line">				Merge(Edges[i].Start_Vertex, Edges[i].End_Vertex);</span><br><span class="line">				nDoneCount++;</span><br><span class="line">				TotalW += Edges[i].Weight;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (nDoneCount == N - <span class="number">1</span>)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; TotalW &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Kruskal和Prim比较"><a href="#Kruskal和Prim比较" class="headerlink" title="Kruskal和Prim比较"></a>Kruskal和Prim比较</h2><p><strong>Kruskal：将所有边从小到大加入，在此过程中判断是否构成回路</strong></p>
<ul>
<li>使用数据结构：并查集</li>
<li>时间复杂度：$O(ElogE)$</li>
<li>适用于稀疏图</li>
</ul>
<p><strong>Prim：从任一节点出发，不断扩展</strong></p>
<ul>
<li>使用数据结构：堆</li>
<li>时间复杂度：$O(ElogV)$或$O(VlogV+E)$(斐波那契堆)</li>
<li>适用于密集图</li>
<li>若不用堆则时间复杂度为$O(V^2)$</li>
</ul>
<blockquote>
<h1 id="第十一章-最短路径"><a href="#第十一章-最短路径" class="headerlink" title="第十一章 最短路径"></a>第十一章 最短路径</h1></blockquote>
<h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><ul>
<li><strong>解决无负权边的带权有向图或无向图的单源最短路问题</strong></li>
<li>贪心思想，若离源点s前k-1近的点已经被确定，构成点集P，那么从s到离s第k近的点t的最短路径，${s,p_1,p_2,…,p_i,t}$，满足$s,p_1,p_2,…,p_i∈P$</li>
<li>否则假设$p_i∉P$，则因为边权非负，$p_i$到t的路径≥0，则$d[p_i]≤d[t]$，$p_i$才是第k近。将$p_i$看作t，重复上面过程，最终一定会有找不到$p_i$的情况。</li>
<li>$d[i] = min(d[p_i] + cost(p_i,i)),i∉P,p_i∈P$<br>　$d[t] = min(d[i]),i∉P$</li>
<li>初始令$d[s]=0,d[i]=+∞，P=∅$</li>
<li>找到点$i∉P$，且$d[i]$最小</li>
<li>把i添入P，对于任意$j∉P$，若$d[i]+cost(i,j)&lt;d[j]$，则更新$d[j]=d[i]+cost(i,j)$。</li>
<li>用邻接表，不优化，时间复杂度$O(V^2+E)$</li>
<li>Dijkstra+堆的时间复杂度$O(ElogV)$</li>
<li>用斐波那契堆可以做到$O(VlogV+E)$</li>
<li>若要输出路径，则设置prev数组记录每个节点的前驱点，在$d[i]$更新时更新$prev[i]$。</li>
<li>Dijkstra算法也适用于无向图，但不适用于有负权边的图。<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3></li>
<li>已经求出到$v_0$点的最短路的点的集合为T</li>
<li>维护Dist数组，Dist[i]表示目前$v_i$到$v_0$的“距离”</li>
<li>开始Dist[0]=0，其他Dist[i]=∞，T为空集</li>
<li>①若|T|=N，算法完成，Dist数组就是解。否则取Dist[i]最小的不在T中的点$V_i$，将其加入T，Dist[i]就是$v_i$到$v_0$的最短路长度。</li>
<li>②更新所有与$v_i$有边相连且不在T中的点$v_j$的Dist值：<br>　$Dist[j]=min(Dist[j],Dist[i]+W(v_i,v_j))$</li>
<li>③转到①<br><img src="/assets/img/algorithm/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.gif" alt="最短路径"><h3 id="Candies"><a href="#Candies" class="headerlink" title="Candies"></a>Candies</h3></li>
</ul>
<p><strong>Description</strong><br>During the kindergarten days, flymouse was the monitor of his class. Occasionally the head-teacher brought the kids of flymouse’s class a large bag of candies and had flymouse distribute them. All the kids loved candies very much and often compared the numbers of candies they got with others. A kid A could had the idea that though it might be the case that another kid B was better than him in some aspect and therefore had a reason for deserving more candies than he did, he should never get a certain number of candies fewer than B did no matter how many candies he actually got, otherwise he would feel dissatisfied and go to the head-teacher to complain about flymouse’s biased distribution.<br>snoopy shared class with flymouse at that time. flymouse always compared the number of his candies with that of snoopy’s. He wanted to make the difference between the numbers as large as possible while keeping every kid satisfied. Now he had just got another bag of candies from the head-teacher, what was the largest difference he could make out of it?<br><strong>Input</strong><br>The input contains a single test cases. The test cases starts with a line with two integers N and M not exceeding 30 000 and 150 000 respectively. N is the number of kids in the class and the kids were numbered 1 through N. snoopy and flymouse were always numbered 1 and N. Then follow M lines each holding three integers A, B and c in order, meaning that kid A believed that kid B should never get over c candies more than he did.<br><strong>Output</strong><br>Output one line with only the largest difference desired. The difference is guaranteed to be finite.<br><strong>Sample Input</strong><br>2 2<br>1 2 5<br>2 1 4<br><strong>Sample Output</strong><br>5<br><strong>Procedure</strong><br><a href="http://blog.csdn.net/to_be_better/article/details/50539385" target="_blank" rel="noopener"><strong>参考</strong></a></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment">文件名称：Candies.cpp</span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">定位到这一句</span></span><br><span class="line"><span class="comment">snoopy shared class with flymouse at that time. flymouse always compared the number of his candies with that of snoopy’s. He wanted to make the difference between the numbers as large as possible while keeping every kid satisfied.snoopy and flymouse were always numbered 1 and N.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">snoopy始终是1，flymouse始终是N，monitor——flymouse自私，希望在满足其他同学的前提下，自己所得到的糖果尽可能比snoopy多！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">令x-y&lt;=z表示x最大比y大z。</span></span><br><span class="line"><span class="comment">若b-a&lt;=k1, c-b&lt;=k2, c-a&lt;=k3，那么c-a最大为多少呢？显然应该等于min(k1+k2, k3)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">那么N最终获得的糖果最大的情况就是从1到N，有向图，箭头上的权值表示后者比前者多的糖果数，</span></span><br><span class="line"><span class="comment">此题隐含肯定有从1到N的路径，否则无解！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.11.05</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> End_Vertex;<span class="comment">//有向边的终点</span></span><br><span class="line">	<span class="keyword">int</span> Weight;<span class="comment">//权值，或当前k到源点的距离</span></span><br><span class="line">	CNode() {}</span><br><span class="line">	CNode(<span class="keyword">int</span> e_, <span class="keyword">int</span> w_) :End_Vertex(e_), Weight(w_) {}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> CNode &amp;s)<span class="keyword">const</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> Weight &gt; s.Weight;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line">priority_queue&lt;CNode&gt; pq;</span><br><span class="line"><span class="keyword">bool</span> bUsed[<span class="number">30010</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;CNode&gt; &gt; G;<span class="comment">//邻接表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> N, M, a, b, c;</span><br><span class="line">	<span class="comment">//cin &gt;&gt; N &gt;&gt; M;</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M);</span><br><span class="line">	G.clear();</span><br><span class="line">	G.resize(N + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">memset</span>(bUsed, <span class="literal">false</span>, <span class="keyword">sizeof</span>(bUsed));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">		G[a].push_back(CNode(b, c));</span><br><span class="line">	}</span><br><span class="line">	pq.push(CNode(<span class="number">1</span>, <span class="number">0</span>));<span class="comment">//源点入队列</span></span><br><span class="line">	CNode temp;</span><br><span class="line">	<span class="keyword">while</span> (!pq.empty())</span><br><span class="line">	{</span><br><span class="line">	    temp = pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		<span class="keyword">if</span> (temp.End_Vertex == N)<span class="comment">//只需要求1~N的最短路，所以break</span></span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (!bUsed[temp.End_Vertex])</span><br><span class="line">		{</span><br><span class="line">			bUsed[temp.End_Vertex] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[temp.End_Vertex].size(); i++)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">int</span> vertex = G[temp.End_Vertex][i].End_Vertex;</span><br><span class="line">				<span class="keyword">if</span> (!bUsed[vertex])</span><br><span class="line">				{</span><br><span class="line">					<span class="function">CNode <span class="title">q</span><span class="params">(vertex, temp.Weight + G[temp.End_Vertex][i].Weight)</span></span>;</span><br><span class="line">					pq.push(q);</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//cout &lt;&lt; temp.Weight &lt;&lt; endl;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, temp.Weight);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ERROR = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INFINITE = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> End_Vertex;<span class="comment">//终点</span></span><br><span class="line">	<span class="keyword">int</span> Weight;<span class="comment">//权值，或者到源点的距离</span></span><br><span class="line">	Edge() {}</span><br><span class="line">	Edge(<span class="keyword">int</span> e, <span class="keyword">int</span> w) :End_Vertex(e), Weight(w) {}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;s) <span class="keyword">const</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> Weight &gt; s.Weight;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;Edge&gt; &gt;G;<span class="comment">//邻接表</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;bUsed;</span><br><span class="line">priority_queue&lt;Edge&gt; pq;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> N, M, a, b, c;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M);</span><br><span class="line">	G.clear();</span><br><span class="line">	G.resize(N + <span class="number">1</span>);</span><br><span class="line">	bUsed.clear();</span><br><span class="line">	<span class="keyword">while</span> (!pq.empty())</span><br><span class="line">	{</span><br><span class="line">		pq.pop();</span><br><span class="line">	}</span><br><span class="line">	bUsed = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(N + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">		G[a].push_back(Edge(b, c));</span><br><span class="line">	}</span><br><span class="line">	pq.push(Edge(<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">	Edge temp;</span><br><span class="line">	<span class="keyword">while</span> (!pq.empty())</span><br><span class="line">	{</span><br><span class="line">		temp = pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		<span class="keyword">if</span> (temp.End_Vertex == N)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (!bUsed[temp.End_Vertex])</span><br><span class="line">		{</span><br><span class="line">			bUsed[temp.End_Vertex] = <span class="literal">true</span>; <span class="comment">//pop出来的点表示已经完成了到源点的最短距离计算</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[temp.End_Vertex].size(); i++)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">int</span> vertex = G[temp.End_Vertex][i].End_Vertex;</span><br><span class="line">				<span class="keyword">if</span> (!bUsed[vertex])</span><br><span class="line">				{</span><br><span class="line">					<span class="keyword">int</span> weight = G[temp.End_Vertex][i].Weight;</span><br><span class="line">					pq.push(Edge(vertex, weight + temp.Weight));</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, temp.Weight);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//超时！对于稠密图，SPFA的效率果然降低了，我是不是得去考虑学SPFA的两个优化啊。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ERROR=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> endVertex;</span><br><span class="line">	<span class="keyword">int</span> nowWeight;</span><br><span class="line">	Edge(){}</span><br><span class="line">	Edge(<span class="keyword">int</span> e,<span class="keyword">int</span> w):endVertex(e),nowWeight(w){}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;Edge&gt; &gt; G;<span class="comment">//邻接表</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; updateTimes;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; bUsed;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Dist;</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="function">Status <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Dist[v]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">	que.push(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	bUsed[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(!que.empty())</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">int</span> s=que.front();</span><br><span class="line">		que.pop();</span><br><span class="line">		bUsed[s]=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[s].size();i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">int</span> e=G[s][i].endVertex;</span><br><span class="line">			<span class="keyword">if</span>(Dist[e]&gt;Dist[s]+G[s][i].nowWeight)</span><br><span class="line">			{</span><br><span class="line">				Dist[e]=Dist[s]+G[s][i].nowWeight;</span><br><span class="line">				<span class="keyword">if</span>(!bUsed[e])</span><br><span class="line">				{</span><br><span class="line">					bUsed[e]=<span class="literal">true</span>;</span><br><span class="line">					que.push(e);</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line"></span><br><span class="line">	G.clear();</span><br><span class="line">	Dist.clear();</span><br><span class="line">	bUsed.clear();</span><br><span class="line">	G.resize(N+<span class="number">1</span>);</span><br><span class="line">	Dist=<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N+<span class="number">1</span>,INF);</span><br><span class="line">	bUsed=<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(N+<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> s,e,w;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;s,&amp;e,&amp;w);</span><br><span class="line">		G[s].push_back(Edge(e,w));</span><br><span class="line">	}</span><br><span class="line">	SPFA(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Dist[N]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="Bellman-Ford 算法"></a>Bellman-Ford 算法</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><ul>
<li>解决含负权边的带权有向图的单源最短路径问题</li>
<li>不能处理带负权边的无向图（因可以来回走一条负权边）</li>
<li>限制条件：要求图中不能包含权值总和为负值回路（负权值回路），如图所示。<br><img src="https://dn-coding-net-production-file.codehub.cn/1a6b87b0-0863-11e9-bec5-e1ca741700a6.png?e=1545827553&amp;token=goE9CtaiT5YaIP6ZQ1nAafd_C1Z_H2gVP8AwuC-5:hASfxODm5Go0AhAtsqH_EPancZk=" alt="Bellman-Ford图示"></li>
<li>构造一个最短路径长度数组序列$dist^{1}[u],dist^{2}[u],…,dist^{n-1}[u]$(u=0,1,…,n-1,n为点数)<br>①$dist^{1}[u]$为从源点v到终点u的只经过一条边的最短路径长度，并有dist^{1}[u]=Edge[v][u];<br>②$dist^{2}[u]$为从源点v<strong>最多经过两条边</strong>到达终点u的最短路径长度；<br>③$dist^{3}[u]$位从源点v出发<strong>最多经过不构成负权值回路的三条边</strong>到达终点u的最短路径长度；<br>……<br>④$dist^{n-1}[u]$为从源点v出发<strong>最多经过不构成负权值回路的n-1条边</strong>到达终点u的最短路径长度。</li>
<li>算法最终的目的是计算出$dist^{n-1}[u]$，为源点v到顶点u的最短路径长度。<h3 id="dist-k-u-的计算"><a href="#dist-k-u-的计算" class="headerlink" title="$dist^{k}[u]$的计算"></a>$dist^{k}[u]$的计算</h3></li>
<li>设已经求出了$dist^{k-1}[u]，u=0,1,…,n-1,$即从源点v经过最多不构成负权值回路的k-1条边到达终点u的最短路径的长度</li>
<li>递推公式（求顶点u到源点v的最短路径）：<br>$dist^{1}[u]=Edge[v][u]$<br>$dist^{k}[u]=min${$dist^{k-1}[u]$}$,min${$dist^{k-1}[j]+Edge[j][u]$}$,j=0,1,…,n-1,j≠u$</li>
</ul>
<h3 id="Dijkstra算法与Bellman-Ford算法的区别"><a href="#Dijkstra算法与Bellman-Ford算法的区别" class="headerlink" title="Dijkstra算法与Bellman-Ford算法的区别"></a>Dijkstra算法与Bellman-Ford算法的区别</h3><ul>
<li>Dijkstra算法和Bellman算法思想有很大的区别：<br>①Dijkstra算法在求解过程中，源点到集合S内各顶点的最短路径一旦求出，则之后不变了，修改的仅仅是源点到S外各顶点的最短路径长度。<br>②Bellman-Ford算法在求解过程中，每次循环都要修改所有顶点的$dist[]$，也就是说源点到各顶点最短路径长度一直要到算法结束才确定下来。</li>
</ul>
<h3 id="负权回路的判断"><a href="#负权回路的判断" class="headerlink" title="负权回路的判断"></a>负权回路的判断</h3><ul>
<li>如果存在从源点可达的负权值回路，则最短路径不存在，因为可以重复走这个回路，使得路径长度无穷小。</li>
<li>思路：在求出$dist^{n-1}[]$之后，再对每条边$&lt;u,k&gt;$判断一下：加入这条边是否会使得顶点k的最短路径值再缩短，即判断：$dist[u]+w(u,k)&lt;dist[k]$是否成立，如果成立，则说明存在从源点可达的负权值回路。<br>证明：</li>
<li>如果成立，则说明找到了一条经过了n条边的从s到k的路径，且其比任何少于n条边的从s到k的路径都短。</li>
<li>一共n个顶点，路径却经过了n条边，则必有一个顶点m经过了至少两次。则m是一个回路的起点和终点。走这个回路比不走这个回路路径更短，只能说明这个回路是负权回路。<br><a href="https://www.cnblogs.com/tanky_woo/archive/2011/01/17/1937728.html" target="_blank" rel="noopener"><strong>参考</strong></a><h3 id="Wormholes"><a href="#Wormholes" class="headerlink" title="Wormholes"></a>Wormholes</h3></li>
</ul>
<p><strong>Description</strong><br>While exploring his many farms, Farmer John has discovered a number of amazing wormholes. A wormhole is very peculiar because it is a one-way path that delivers you to its destination at a time that is BEFORE you entered the wormhole! Each of FJ’s farms comprises N (1 ≤ N ≤ 500) fields conveniently numbered 1..N, M (1 ≤ M ≤ 2500) paths, and W (1 ≤ W ≤ 200) wormholes.<br>As FJ is an avid time-traveling fan, he wants to do the following: start at some field, travel through some paths and wormholes, and return to the starting field a time before his initial departure. Perhaps he will be able to meet himself :) .<br>To help FJ find out whether this is possible or not, he will supply you with complete maps to F (1 ≤ F ≤ 5) of his farms. No paths will take longer than 10,000 seconds to travel and no wormhole can bring FJ back in time by more than 10,000 seconds.<br><strong>Input</strong><br>Line 1: A single integer, F. F farm descriptions follow.<br>Line 1 of each farm: Three space-separated integers respectively: N, M, and W<br>Lines 2..M+1 of each farm: Three space-separated numbers (S, E, T) that describe, respectively: a bidirectional path between S and E that requires T seconds to traverse. Two fields might be connected by more than one path.<br>Lines M+2..M+W+1 of each farm: Three space-separated numbers (S, E, T) that describe, respectively: A one way path from S to E that also moves the traveler back T seconds.<br><strong>Output</strong><br>Lines 1..F: For each farm, output “YES” if FJ can achieve his goal, otherwise output “NO” (do not include the quotes).<br><strong>Sample Input</strong><br>2<br>3 3 1<br>1 2 2<br>1 3 4<br>2 3 1<br>3 1 3<br>3 2 1<br>1 2 3<br>2 3 4<br>3 1 8<br><strong>Sample Output</strong><br>NO<br>YES<br><strong>Procedure</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：Wormholes.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">厉害了，John在自己的农场发现了些虫洞，并且这些虫洞是单向的，</span></span><br><span class="line"><span class="comment">能够将自己传送到进入虫洞之前的某个时间节点时空的目的地。</span></span><br><span class="line"><span class="comment">题目给出F个测试样例，每个测试样例开头包括三个数N,M,W</span></span><br><span class="line"><span class="comment">分别代表顶点数，双向边数，单向边（虫洞）数，</span></span><br><span class="line"><span class="comment">顶点从1开始编号</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：Two fields might be connected by more than one path.</span></span><br><span class="line"><span class="comment">两个顶点间可能有多条路径</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">双向路径消逝时间</span></span><br><span class="line"><span class="comment">单向路径追回时间</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">求Johan能否回到他初次离开的顶点，并且时间比离开的时间早</span></span><br><span class="line"><span class="comment">As FJ is an avid time-traveling fan, he wants to do the following:</span></span><br><span class="line"><span class="comment">start at some field, travel through some paths and wormholes,</span></span><br><span class="line"><span class="comment">and return to the starting field a time before his initial departure.</span></span><br><span class="line"><span class="comment">Perhaps he will be able to meet himself :) .</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">判断是否有负权回路</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.11.10</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> F, N, M, W;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> startVertex;</span><br><span class="line">	<span class="keyword">int</span> endVertex;</span><br><span class="line">	<span class="keyword">int</span> nowWeight;</span><br><span class="line">	Edge() {}</span><br><span class="line">	Edge(<span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> w) :startVertex(s), endVertex(e), nowWeight(w) {}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;<span class="comment">//边集</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dist;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bellman_ford</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	dist[v] = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//经过不超过k条边，假设不含有负权回路的时候。</span></span><br><span class="line">	<span class="comment">//这里需要注意的是，N个顶点，从1到N最多经过不包含负权回路的N-1条边</span></span><br><span class="line">	<span class="comment">//故更新N-1次，结果肯定就是不包含负权回路后的最终结果！</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; N; k++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">bool</span> change=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">int</span> s = edges[i].startVertex;</span><br><span class="line">			<span class="keyword">int</span> e = edges[i].endVertex;</span><br><span class="line">			<span class="keyword">if</span> (dist[s] + edges[i].nowWeight &lt; dist[e])</span><br><span class="line">			{</span><br><span class="line">				dist[e] = dist[s] + edges[i].nowWeight;</span><br><span class="line">				change=<span class="literal">true</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(!change)<span class="comment">//如果N-1次内就更新松弛停止，说明肯定不包含负权回路</span></span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//上述得到的是N-1次后的最终结果，如果在进行一次更新，只要发现一个节点dist更新，即松弛</span></span><br><span class="line">	<span class="comment">//那么说明肯定含有负权回路！</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">int</span> s = edges[i].startVertex;</span><br><span class="line">		<span class="keyword">int</span> e = edges[i].endVertex;</span><br><span class="line">		<span class="keyword">if</span> (dist[s] + edges[i].nowWeight &lt; dist[e])</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; F;</span><br><span class="line">	<span class="keyword">while</span> (F--)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; W;</span><br><span class="line">		edges.clear();</span><br><span class="line">		dist = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>,INF);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">int</span> s, e, t;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; e &gt;&gt; t;</span><br><span class="line">			edges.push_back(Edge(s, e, t));<span class="comment">//双向边等于两条单向边</span></span><br><span class="line">			edges.push_back(Edge(e, s, t));</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; W; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">int</span> s, e, t;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; e &gt;&gt; t;</span><br><span class="line">			edges.push_back(Edge(s, e, -t));</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (Bellman_ford(<span class="number">1</span>))</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h3><ul>
<li>假设图的顶点个数为n，边的个数为e<br>①使用邻接表存储图，复杂度$O(N*E)$<br>②使用邻接矩阵存储图，复杂度为$O(N^3)$<h3 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h3></li>
<li>Bellman-Ford算法不一定要循环n-1次，n为顶点个数</li>
<li>只要在某次循环过程中，考虑每条边后，源点到所有顶点的最短路径长度都没有变，那么Bellman-Ford算法就可以提前结束了，同冒泡排序的方法相同</li>
</ul>
<h2 id="SPFA-Shortest-Path-Faster-Algorithm-算法"><a href="#SPFA-Shortest-Path-Faster-Algorithm-算法" class="headerlink" title="SPFA(Shortest Path Faster Algorithm)算法"></a>SPFA(Shortest Path Faster Algorithm)算法</h2><h3 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h3><ul>
<li>快速求解含负权边的带权有向图的单源最短路径问题</li>
<li>是Bellman-Ford算法的改进版，利用队列动态更新$Dist[]$</li>
<li>维护一个队列，里面存放所有需要进行迭代的点。初始时队列中只有一个源点S，用一个布尔数组记录每个点是否处在队列中。</li>
<li>每次迭代，取出队头的点v，依次枚举从v出发的边$v-&gt;u$，若$Dist[v]+len(v-&gt;u)&lt;Dist[u]$，则更新$Dist[u]$（可同时将u前驱记为v）。此时由于S到u的最短距离变小了，有可能u可以更新其他的点，所以若u不在队列中，就将它放入队尾。这样一直迭代下去直到队列变空，也就是S到所有节点的最短距离都确定下来，结束算法。若一个点最短路被改进的 次数达到n，则有负权环（原因同B-F算法）。可以用SPFA算法判断图有无负权环。</li>
<li>在平均情况下，SPFA算法的期望时间复杂度为$O(E)$。</li>
<li>类似BFS，但与之不同的是，同一个点可以反复加入和退出队列。</li>
<li>BFS版不太稳定，对于稠密图，效率降低。</li>
<li>这里需要说明的是，标记数组用来标记是否在队列中，如果已经在队列中，那么不用重复添加，因为这里队列记录的是点，而不是整个状态Edge，所以在对Dist[]更新的时候在队列中的点的Dist[]已经是当前最小值了！这里举个例子，1-&gt;2,2-&gt;3,2-&gt;5,3-&gt;5，… 从2扩展3,5，然后从3更新Dist[5],这里假设1-&gt;2-&gt;5的路径比1-&gt;2-&gt;3-&gt;5路径长，那么此时5在队列中，并且Dist[5]已经由前一个较长路径值更新至较短路径值，对于5的后继更新而言无影响，因为后继的更新时在5的当前最短路径基础上进行更新松弛的;同理Dist[5]更新且不在队列中，则必须加入队列。（从小打到扩展）<br><a href="https://www.cnblogs.com/scau20110726/archive/2012/11/18/2776124.html" target="_blank" rel="noopener"><strong>参考</strong></a><h3 id="Wormholes-1"><a href="#Wormholes-1" class="headerlink" title="Wormholes"></a>Wormholes</h3></li>
</ul>
<p><strong>Description</strong><br>While exploring his many farms, Farmer John has discovered a number of amazing wormholes. A wormhole is very peculiar because it is a one-way path that delivers you to its destination at a time that is BEFORE you entered the wormhole! Each of FJ’s farms comprises N (1 ≤ N ≤ 500) fields conveniently numbered 1..N, M (1 ≤ M ≤ 2500) paths, and W (1 ≤ W ≤ 200) wormholes.<br>As FJ is an avid time-traveling fan, he wants to do the following: start at some field, travel through some paths and wormholes, and return to the starting field a time before his initial departure. Perhaps he will be able to meet himself :) .<br>To help FJ find out whether this is possible or not, he will supply you with complete maps to F (1 ≤ F ≤ 5) of his farms. No paths will take longer than 10,000 seconds to travel and no wormhole can bring FJ back in time by more than 10,000 seconds.<br><strong>Input</strong><br>Line 1: A single integer, F. F farm descriptions follow.<br>Line 1 of each farm: Three space-separated integers respectively: N, M, and W<br>Lines 2..M+1 of each farm: Three space-separated numbers (S, E, T) that describe, respectively: a bidirectional path between S and E that requires T seconds to traverse. Two fields might be connected by more than one path.<br>Lines M+2..M+W+1 of each farm: Three space-separated numbers (S, E, T) that describe, respectively: A one way path from S to E that also moves the traveler back T seconds.<br><strong>Output</strong><br>Lines 1..F: For each farm, output “YES” if FJ can achieve his goal, otherwise output “NO” (do not include the quotes).<br><strong>Sample Input</strong><br>2<br>3 3 1<br>1 2 2<br>1 3 4<br>2 3 1<br>3 1 3<br>3 2 1<br>1 2 3<br>2 3 4<br>3 1 8<br><strong>Sample Output</strong><br>NO<br>YES<br><strong>Procedure</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright(c)2017, Louris</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件名称：Wormholes_SPFA.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">SPFA算法版</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前版本：1.0</span></span><br><span class="line"><span class="comment">作    者：Louris</span></span><br><span class="line"><span class="comment">完成日期：2017.11.11</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> endVertex;</span><br><span class="line">	<span class="keyword">int</span> nowWeight;</span><br><span class="line">	Edge(){}</span><br><span class="line">	Edge(<span class="keyword">int</span> e,<span class="keyword">int</span> w):endVertex(e),nowWeight(w){}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;Edge&gt; &gt; G;<span class="comment">//邻接表</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Dist;<span class="comment">//路径数组</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; updateTimes;<span class="comment">//最短路径更新次数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; bUsed;<span class="comment">//标记数组</span></span><br><span class="line"><span class="keyword">int</span> F,N,M,W;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Dist[v]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">	que.push(v);</span><br><span class="line">	bUsed[v]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(!que.empty())</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">int</span> s=que.front();</span><br><span class="line">		que.pop();</span><br><span class="line">		bUsed[s]=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[s].size();i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">int</span> e=G[s][i].endVertex;</span><br><span class="line">			<span class="keyword">if</span>(Dist[e]&gt;Dist[s]+G[s][i].nowWeight)</span><br><span class="line">			{</span><br><span class="line">				Dist[e]=Dist[s]+G[s][i].nowWeight;</span><br><span class="line">				updateTimes[e]++;</span><br><span class="line">				<span class="keyword">if</span>(updateTimes[e]&gt;=N)</span><br><span class="line">				{</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">if</span>(!bUsed[e])</span><br><span class="line">				{</span><br><span class="line">					bUsed[e]=<span class="literal">true</span>;</span><br><span class="line">					que.push(e);</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> s,e,t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;F;</span><br><span class="line">	<span class="keyword">while</span>(F--)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;N&gt;&gt;M&gt;&gt;W;</span><br><span class="line"></span><br><span class="line">		G.clear();</span><br><span class="line">		G.resize(N+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		Dist.clear();</span><br><span class="line">		Dist=<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N+<span class="number">1</span>,INF);</span><br><span class="line"></span><br><span class="line">		updateTimes.clear();</span><br><span class="line">		updateTimes=<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		bUsed.clear();</span><br><span class="line">		bUsed=<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(N+<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;e&gt;&gt;t;</span><br><span class="line">			G[s].push_back(Edge(e,t));</span><br><span class="line">			G[e].push_back(Edge(s,t));</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;W;i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;e&gt;&gt;t;</span><br><span class="line">			G[s].push_back(Edge(e,-t));</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(SPFA(<span class="number">1</span>))</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="SPFA算法有两个优化算法-SLF-和-LLL"><a href="#SPFA算法有两个优化算法-SLF-和-LLL" class="headerlink" title="SPFA算法有两个优化算法 SLF 和 LLL"></a>SPFA算法有两个优化算法 SLF 和 LLL</h3><p>SLF：Small Label First 策略，设要加入的节点是j，队首元素为i，若dist(j) &lt; dist(i)，则将j插入队首，否则插入队尾。<br>LLL：Large Label Last 策略，设队首元素为i，每次弹出时进行判断，队列中所有dist值的平均值为x，若dist(i)&gt;x则将i插入到队尾，查找下一元素，直到找到某一i使得dist(i)&lt;=x，则将i出对进行松弛操作。</p>
<blockquote>
<h1 id="第十二章-强连通分量"><a href="#第十二章-强连通分量" class="headerlink" title="第十二章 强连通分量"></a>第十二章 强连通分量</h1></blockquote>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>在有向图G中，如果任意两个不同的顶点相互可达，则称该有向图是强连通的。</li>
<li>有向图G的极大强连通子图称为G的强连通分支。<h3 id="有向图强连通分支的Tarjan算法"><a href="#有向图强连通分支的Tarjan算法" class="headerlink" title="有向图强连通分支的Tarjan算法"></a>有向图强连通分支的Tarjan算法</h3></li>
<li>做一遍DFS，用dfn[i]表示编号为i的节点在DFS过程中的访问序号（也可以做开始时间）。</li>
<li>在DFS过程中会形成一搜索树。</li>
<li>在搜索树上越先遍历到的节点，显然dfn的值就越小。</li>
<li>dfc值越小的节点，就称为越“早”。</li>
<li>用low[i]表示从i节点出发DFS过程中i下方节点（开始时间大于dfn[i]。且由i可达的节点）所能到达的最早的节点的开始时间。初始时low[i]=dfn[i]</li>
<li>DFS过程中，碰到哪个节点，就将哪个节点入栈。栈中节点只有在其所属的强连通分量已经全部求出时，才会出栈。</li>
<li>如果发现某节点u有边连到栈里的节点v，则更新u的low值为min(low[u],dfn[v])，若low[u]被更新未dfn[v]，则表明目前发现u可达的最早的节点是v.</li>
<li>对于u的子节点v，从v出发进行的DFS结束回到u时，使得low[u]=min(low[u],low[v])。因为u可达v，所以v可达的最早的节点，也是u可达的。</li>
<li>如果一个节点u，从其出发进行的DFS已经全部完成并回到u，而且此时其low值等于dfn值，则说明u可达的所有节点，都不能到达任何比u早的节点——那么该节点u就是一个强连通分量在DFS搜索树中的根。</li>
<li>此时，显然栈中u上方的节点，都是不能到达比u早的节点的。将栈中节点弹出，一直弹到u(包括u)，弹出的节点就构成一个强连通分量。</li>
</ul>

      

      
        <div class="page-reward">
          <a href="javascript:;" class="page-reward-btn tooltip-top">
            <div class="tooltip tooltip-east">
            <span class="tooltip-item">
              赏
            </span>
            <span class="tooltip-content">
              <span class="tooltip-text">
                <span class="tooltip-inner">
                  <p class="reward-p"><i class="icon icon-quo-left"></i>Thank you for inviting me to have candy.<i class="icon icon-quo-right"></i></p>
                  <div class="reward-box">
                    
                    <div class="reward-box-item">
                      <img class="reward-img" src="/assets/img/blog/zhifubao.png">
                      <span class="reward-type">支付宝</span>
                    </div>
                    
                    
                    <div class="reward-box-item">
                      <img class="reward-img" src="/assets/img/blog/weixin.jpg">
                      <span class="reward-type">微信</span>
                    </div>
                    
                  </div>
                </span>
              </span>
            </span>
          </div>
          </a>
        </div>
      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">Algorithm</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">C++</a>
        		</li>
      		
		</ul>
	</div>

      

      

      
        
<div class="share-btn share-icons tooltip-left">
  <div class="tooltip tooltip-east">
    <span class="tooltip-item">
      <a href="javascript:;" class="share-sns share-outer">
        <i class="icon icon-share"></i>
      </a>
    </span>
    <span class="tooltip-content">
      <div class="share-wrap">
        <div class="share-icons">
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="icon icon-weibo"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="icon icon-weixin"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="icon icon-qq"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="icon icon-douban"></i>
          </a>
          <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a>
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="icon icon-facebook"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="icon icon-twitter"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="icon icon-google"></i>
          </a>
        </div>
      </div>
    </span>
  </div>
</div>

<div class="page-modal wx-share js-wx-box">
    <a class="close js-modal-close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="http://s.jiathis.com/qrcode.php?url=https://lourisxu.github.io/2017/09/12/advanced-algorithm.html/" alt="微信分享二维码">
    </div>
</div>

<div class="mask js-mask"></div>
      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
    <a href="/2017/09/17/index-table-password-0424.html/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          索引表（密码：0424）
        
      </div>
    </a>
  
  
    <a href="/2017/08/24/blog-memo.html/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">博客备忘录</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>


<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
        <div class="toc-container tooltip-left">
            <i class="icon-font icon-category"></i>
            <div class="tooltip tooltip-east">
                <span class="tooltip-item">
                </span>
                <span class="tooltip-content">
                  <div class="toc-article">
                  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第一章-二分查找"><span class="toc-number">1.</span> <span class="toc-text">第一章 二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#二分查找函数"><span class="toc-number">1.1.</span> <span class="toc-text">二分查找函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二分法求方程的根"><span class="toc-number">1.2.</span> <span class="toc-text">二分法求方程的根</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#整数和"><span class="toc-number">1.3.</span> <span class="toc-text">整数和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Aggressive-cows"><span class="toc-number">1.4.</span> <span class="toc-text">Aggressive cows</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第二章-动态规划之背包专题"><span class="toc-number">2.</span> <span class="toc-text">第二章 动态规划之背包专题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">2.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1背包问题"><span class="toc-number">2.1.1.</span> <span class="toc-text">0-1背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#完全背包问题"><span class="toc-number">2.1.2.</span> <span class="toc-text">完全背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多重背包"><span class="toc-number">2.1.3.</span> <span class="toc-text">多重背包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#神奇的口袋"><span class="toc-number">2.2.</span> <span class="toc-text">神奇的口袋</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Charm-Bracelet"><span class="toc-number">2.3.</span> <span class="toc-text">Charm Bracelet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HDOJ-1114-Piggy-Bank"><span class="toc-number">2.4.</span> <span class="toc-text">HDOJ 1114 Piggy-Bank</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HDOJ-1203-I-NEED-A-OFFER"><span class="toc-number">2.5.</span> <span class="toc-text">HDOJ 1203 I NEED A OFFER!</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HDOJ-1171-Big-Event-in-HDU"><span class="toc-number">2.6.</span> <span class="toc-text">HDOJ 1171 Big Event in HDU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HDOJ-1059-Dividing"><span class="toc-number">2.7.</span> <span class="toc-text">HDOJ 1059 Dividing</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第三章-子集生成算法"><span class="toc-number">3.</span> <span class="toc-text">第三章 子集生成算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#增量构造法"><span class="toc-number">3.1.</span> <span class="toc-text">增量构造法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#位向量法"><span class="toc-number">3.2.</span> <span class="toc-text">位向量法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二进制法"><span class="toc-number">3.3.</span> <span class="toc-text">二进制法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第四章-双向广度优先搜索-DBFS"><span class="toc-number">4.</span> <span class="toc-text">第四章 双向广度优先搜索(DBFS)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述-1"><span class="toc-number">4.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DBFS算法是对BFS算法的一种扩展"><span class="toc-number">4.1.1.</span> <span class="toc-text">DBFS算法是对BFS算法的一种扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#比较"><span class="toc-number">4.1.2.</span> <span class="toc-text">比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DBFS框架"><span class="toc-number">4.1.3.</span> <span class="toc-text">DBFS框架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Eight"><span class="toc-number">4.2.</span> <span class="toc-text">Eight</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#迷宫问题（DBFS版）"><span class="toc-number">4.3.</span> <span class="toc-text">迷宫问题（DBFS版）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jack-and-Jill"><span class="toc-number">4.4.</span> <span class="toc-text">Jack and Jill</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第五章-素数筛选法"><span class="toc-number">5.</span> <span class="toc-text">第五章 素数筛选法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#素数筛选函数"><span class="toc-number">5.1.</span> <span class="toc-text">素数筛选函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#素数判断函数"><span class="toc-number">5.2.</span> <span class="toc-text">素数判断函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Calling-Extraterrestrial-Intelligence-Again"><span class="toc-number">5.3.</span> <span class="toc-text">Calling Extraterrestrial Intelligence Again</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第六章-博弈论及其算法实现"><span class="toc-number">6.</span> <span class="toc-text">第六章 博弈论及其算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#何为博弈论"><span class="toc-number">6.1.</span> <span class="toc-text">何为博弈论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#理论铺垫"><span class="toc-number">6.2.</span> <span class="toc-text">理论铺垫</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#公平组合博弈（ICG）"><span class="toc-number">6.3.</span> <span class="toc-text">公平组合博弈（ICG）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#巴什博奕-Bash-Game"><span class="toc-number">6.4.</span> <span class="toc-text">巴什博奕(Bash Game)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#尼姆博弈-Nimm-Game"><span class="toc-number">6.5.</span> <span class="toc-text">尼姆博弈(Nimm Game)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ICG，NIM博弈及-SG函数综合"><span class="toc-number">6.6.</span> <span class="toc-text">ICG，NIM博弈及 SG函数综合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#威佐夫博弈（Wythoff-Game"><span class="toc-number">6.7.</span> <span class="toc-text">威佐夫博弈（Wythoff Game)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#斐波那契博弈（Fibonacci-Game）"><span class="toc-number">6.8.</span> <span class="toc-text">斐波那契博弈（Fibonacci Game）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Good-Luck-in-CET-4-Everybody"><span class="toc-number">6.9.</span> <span class="toc-text">Good Luck in CET-4 Everybody!</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stone"><span class="toc-number">6.10.</span> <span class="toc-text">Stone</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#取石子游戏"><span class="toc-number">6.11.</span> <span class="toc-text">取石子游戏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Being-a-Good-Boy-in-Spring-Festival"><span class="toc-number">6.12.</span> <span class="toc-text">Being a Good Boy in Spring Festival</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2012-蓝桥杯-取球博弈"><span class="toc-number">6.13.</span> <span class="toc-text">2012 蓝桥杯 取球博弈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第七章-高级搜索算法"><span class="toc-number">7.</span> <span class="toc-text">第七章 高级搜索算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#A算法"><span class="toc-number">7.1.</span> <span class="toc-text">A算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-算法"><span class="toc-number">7.2.</span> <span class="toc-text">A*算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Knight-Moves"><span class="toc-number">7.3.</span> <span class="toc-text">Knight Moves</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#D-Olya-and-Energy-Drinks"><span class="toc-number">7.4.</span> <span class="toc-text">D. Olya and Energy Drinks</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第八章-线段树和树状数组"><span class="toc-number">8.</span> <span class="toc-text">第八章 线段树和树状数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#线段树-Interval-Tree"><span class="toc-number">8.1.</span> <span class="toc-text">线段树(Interval Tree)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线段树的特征"><span class="toc-number">8.1.1.</span> <span class="toc-text">线段树的特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线段树的构建"><span class="toc-number">8.1.2.</span> <span class="toc-text">线段树的构建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线段树的基本用途"><span class="toc-number">8.1.3.</span> <span class="toc-text">线段树的基本用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线段树应用举例"><span class="toc-number">8.1.4.</span> <span class="toc-text">线段树应用举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态建树与静态建树"><span class="toc-number">8.1.5.</span> <span class="toc-text">动态建树与静态建树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Balanced-Lineup"><span class="toc-number">8.1.6.</span> <span class="toc-text">Balanced Lineup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-Simple-Problem-with-Integers"><span class="toc-number">8.1.7.</span> <span class="toc-text">A Simple Problem with Integers</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#离散化"><span class="toc-number">8.2.</span> <span class="toc-text">离散化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mayor’s-Poster"><span class="toc-number">8.2.1.</span> <span class="toc-text">Mayor’s Poster</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Atlantis"><span class="toc-number">8.2.2.</span> <span class="toc-text">Atlantis</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树状数组"><span class="toc-number">8.3.</span> <span class="toc-text">树状数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Apple-Tree"><span class="toc-number">8.3.1.</span> <span class="toc-text">Apple Tree</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树状数组求逆序对"><span class="toc-number">8.4.</span> <span class="toc-text">树状数组求逆序对</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Ultra-QuickSort"><span class="toc-number">8.4.1.</span> <span class="toc-text">Ultra-QuickSort</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#差分数组"><span class="toc-number">8.5.</span> <span class="toc-text">差分数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Color-the-ball"><span class="toc-number">8.5.1.</span> <span class="toc-text">Color the ball</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第九章-并查集"><span class="toc-number">9.</span> <span class="toc-text">第九章 并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#并查集"><span class="toc-number">9.1.</span> <span class="toc-text">并查集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Suspects"><span class="toc-number">9.2.</span> <span class="toc-text">The Suspects</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cube-Stacking"><span class="toc-number">9.3.</span> <span class="toc-text">Cube Stacking</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十章-最小生成树-MST-问题"><span class="toc-number">10.</span> <span class="toc-text">第十章 最小生成树(MST)问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#图的生成树"><span class="toc-number">10.1.</span> <span class="toc-text">图的生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#生成树"><span class="toc-number">10.1.1.</span> <span class="toc-text">生成树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最小"><span class="toc-number">10.1.2.</span> <span class="toc-text">最小</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Prim算法"><span class="toc-number">10.2.</span> <span class="toc-text">Prim算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Prim算法实现"><span class="toc-number">10.2.1.</span> <span class="toc-text">Prim算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关键问题"><span class="toc-number">10.2.2.</span> <span class="toc-text">关键问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Agri-Net"><span class="toc-number">10.2.3.</span> <span class="toc-text">Agri-Net</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kruskal算法"><span class="toc-number">10.3.</span> <span class="toc-text">Kruskal算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关键问题-1"><span class="toc-number">10.3.1.</span> <span class="toc-text">关键问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Agri-Net-1"><span class="toc-number">10.3.2.</span> <span class="toc-text">Agri-Net</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kruskal和Prim比较"><span class="toc-number">10.4.</span> <span class="toc-text">Kruskal和Prim比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十一章-最短路径"><span class="toc-number">11.</span> <span class="toc-text">第十一章 最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Dijkstra算法"><span class="toc-number">11.1.</span> <span class="toc-text">Dijkstra算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本思想"><span class="toc-number">11.1.1.</span> <span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法实现"><span class="toc-number">11.1.2.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Candies"><span class="toc-number">11.1.3.</span> <span class="toc-text">Candies</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bellman-Ford-算法"><span class="toc-number">11.2.</span> <span class="toc-text">Bellman-Ford 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本思想-1"><span class="toc-number">11.2.1.</span> <span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dist-k-u-的计算"><span class="toc-number">11.2.2.</span> <span class="toc-text">$dist^{k}[u]$的计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dijkstra算法与Bellman-Ford算法的区别"><span class="toc-number">11.2.3.</span> <span class="toc-text">Dijkstra算法与Bellman-Ford算法的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#负权回路的判断"><span class="toc-number">11.2.4.</span> <span class="toc-text">负权回路的判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Wormholes"><span class="toc-number">11.2.5.</span> <span class="toc-text">Wormholes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法复杂度分析"><span class="toc-number">11.2.6.</span> <span class="toc-text">算法复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法改进"><span class="toc-number">11.2.7.</span> <span class="toc-text">算法改进</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPFA-Shortest-Path-Faster-Algorithm-算法"><span class="toc-number">11.3.</span> <span class="toc-text">SPFA(Shortest Path Faster Algorithm)算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本思想-2"><span class="toc-number">11.3.1.</span> <span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Wormholes-1"><span class="toc-number">11.3.2.</span> <span class="toc-text">Wormholes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPFA算法有两个优化算法-SLF-和-LLL"><span class="toc-number">11.3.3.</span> <span class="toc-text">SPFA算法有两个优化算法 SLF 和 LLL</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十二章-强连通分量"><span class="toc-number">12.</span> <span class="toc-text">第十二章 强连通分量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义"><span class="toc-number">12.0.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有向图强连通分支的Tarjan算法"><span class="toc-number">12.0.2.</span> <span class="toc-text">有向图强连通分支的Tarjan算法</span></a></li></ol></li></ol></li></ol>
                  </div>
                </span>

            </div>
        </div>
        

    </div>
</aside>




  

  

  

  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2024 Louris
        <span style="font-size: smaller">
          Hosted by
          <a href="https://coding.net/" target="_blank" rel="noopener" style="font-weight: bold">Coding Pages</a>/
          <a href="https://gitee.com/" target="_blank" rel="noopener" style="font-weight: bold">Gitee Pages</a>/
          <a href="https://github.com/" target="_blank" rel="noopener" style="font-weight: bold">Github Pages</a>
        </span>
        <!-- <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
        <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人次</span> -->
    	</div>

      <!-- <div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
           <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
           <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人次</span>
      </div> -->

      <div class="footer-right">
      	<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      </div>
    </div>
  </div>
</footer>

    </div>
    <script>
	var yiliaConfig = {
		mathjax: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: false,
		root: "/",
		innerArchive: true,
		showTags: false
	}
</script>

<script>!function(t){function n(e){if(r[e])return r[e].exports;var i=r[e]={exports:{},id:e,loaded:!1};return t[e].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var r={};n.m=t,n.c=r,n.p="./",n(0)}([function(t,n,r){r(203),t.exports=r(199)},function(t,n,r){var e=r(3),i=r(49),o=r(26),u=r(27),c=r(46),f="prototype",a=function(t,n,r){var s,l,h,v,p=t&a.F,d=t&a.G,y=t&a.S,g=t&a.P,m=t&a.B,b=d?e:y?e[n]||(e[n]={}):(e[n]||{})[f],x=d?i:i[n]||(i[n]={}),S=x[f]||(x[f]={});d&&(r=n);for(s in r)l=!p&&b&&void 0!==b[s],h=(l?b:r)[s],v=m&&l?c(h,e):g&&"function"==typeof h?c(Function.call,h):h,b&&u(b,s,h,t&a.U),x[s]!=h&&o(x,s,v),g&&S[s]!=h&&(S[s]=h)};e.core=i,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,n,r){var e=r(5);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n,r){var e=r(128)("wks"),i=r(78),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(170),o=r(53),u=Object.defineProperty;n.f=r(9)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(52),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){t.exports=!r(18)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(22);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(20),i=r(59),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(95),i=r(33);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(40)("wks"),i=r(23),o=r(6).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(50);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(21);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n){var r=t.exports={version:"2.5.1"};"number"==typeof __e&&(__e=r)},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(10),i=r(74);t.exports=r(9)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(3),i=r(26),o=r(25),u=r(78)("src"),c="toString",f=Function[c],a=(""+f).split(c);r(49).inspectSource=function(t){return f.call(t)},(t.exports=function(t,n,r,c){var f="function"==typeof r;f&&(o(r,"name")||i(r,"name",n)),t[n]!==r&&(f&&(o(r,u)||i(r,u,t[n]?""+t[n]:a.join(String(n)))),t===e?t[n]=r:c?t[n]?t[n]=r:i(t,n,r):(delete t[n],i(t,n,r)))})(Function.prototype,c,function(){return"function"==typeof this&&this[u]||f.call(this)})},function(t,n,r){var e=r(1),i=r(4),o=r(50),u=/"/g,c=function(t,n,r,e){var i=String(o(t)),c="<"+n;return""!==r&&(c+=" "+r+'="'+String(e).replace(u,"&quot;")+'"'),c+">"+i+"</"+n+">"};t.exports=function(t,n){var r={};r[t]=n(c),e(e.P+e.F*i(function(){var n=""[t]('"');return n!==n.toLowerCase()||n.split('"').length>3}),"String",r)}},function(t,n,r){var e=r(64),i=r(34);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(116),i=r(74),o=r(32),u=r(53),c=r(25),f=r(170),a=Object.getOwnPropertyDescriptor;n.f=r(9)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(25),i=r(17),o=r(149)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(115),i=r(50);t.exports=function(t){return e(i(t))}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(8),o=r(16)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(23);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(6),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n,r){var e=r(21);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(6),i=r(24),o=r(36),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(16)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(19);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){"use strict";var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n,r){var e=r(46),i=r(115),o=r(17),u=r(11),c=r(134);t.exports=function(t,n){var r=1==t,f=2==t,a=3==t,s=4==t,l=6==t,h=5==t||l,v=n||c;return function(n,c,p){for(var d,y,g=o(n),m=i(g),b=e(c,p,3),x=u(m.length),S=0,w=r?v(n,x):f?v(n,0):void 0;x>S;S++)if((h||S in m)&&(d=m[S],y=b(d,S,g),t))if(r)w[S]=y;else if(y)switch(t){case 3:return!0;case 5:return d;case 6:return S;case 2:w.push(d)}else if(s)return!1;return l?-1:a||s?s:w}}},function(t,n){var r=t.exports={version:"2.5.1"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var e=r(1),i=r(49),o=r(4);t.exports=function(t,n){var r=(i.Object||{})[t]||Object[t],u={};u[t]=n(r),e(e.S+e.F*o(function(){r(1)}),"Object",u)}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n,r){var e=r(5);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(6),i=r(24),o=r(92),u=r(13),c="prototype",f=function(t,n,r){var a,s,l,h=t&f.F,v=t&f.G,p=t&f.S,d=t&f.P,y=t&f.B,g=t&f.W,m=v?i:i[n]||(i[n]={}),b=m[c],x=v?e:p?e[n]:(e[n]||{})[c];v&&(r=n);for(a in r)(s=!h&&x&&void 0!==x[a])&&a in m||(l=s?x[a]:r[a],m[a]=v&&"function"!=typeof x[a]?r[a]:y&&s?o(l,e):g&&x[a]==l?function(t){var n=function(n,r,e){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,r)}return new t(n,r,e)}return t.apply(this,arguments)};return n[c]=t[c],n}(l):d&&"function"==typeof l?o(Function.call,l):l,d&&((m.virtual||(m.virtual={}))[a]=l,t&f.R&&b&&!b[a]&&u(b,a,l)))};f.F=1,f.G=2,f.S=4,f.P=8,f.B=16,f.W=32,f.U=64,f.R=128,t.exports=f},function(t,n,r){var e=r(191),i=r(1),o=r(128)("metadata"),u=o.store||(o.store=new(r(194))),c=function(t,n,r){var i=u.get(t);if(!i){if(!r)return;u.set(t,i=new e)}var o=i.get(n);if(!o){if(!r)return;i.set(n,o=new e)}return o};t.exports={store:u,map:c,has:function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},get:function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},set:function(t,n,r,e){c(r,e,!0).set(t,n)},keys:function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},key:function(t){return void 0===t||"symbol"==typeof t?t:String(t)},exp:function(t){i(i.S,"Reflect",t)}}},function(t,n,r){"use strict";if(r(9)){var e=r(70),i=r(3),o=r(4),u=r(1),c=r(130),f=r(155),a=r(46),s=r(68),l=r(74),h=r(26),v=r(75),p=r(52),d=r(11),y=r(189),g=r(77),m=r(53),b=r(25),x=r(114),S=r(5),w=r(17),_=r(141),O=r(71),E=r(31),M=r(72).f,P=r(157),j=r(78),F=r(7),A=r(48),L=r(117),N=r(129),T=r(158),I=r(80),k=r(123),R=r(76),C=r(133),D=r(162),G=r(10),W=r(30),U=G.f,V=W.f,B=i.RangeError,q=i.TypeError,z=i.Uint8Array,H="ArrayBuffer",K="Shared"+H,J="BYTES_PER_ELEMENT",Y="prototype",$=Array[Y],X=f.ArrayBuffer,Q=f.DataView,Z=A(0),tt=A(2),nt=A(3),rt=A(4),et=A(5),it=A(6),ot=L(!0),ut=L(!1),ct=T.values,ft=T.keys,at=T.entries,st=$.lastIndexOf,lt=$.reduce,ht=$.reduceRight,vt=$.join,pt=$.sort,dt=$.slice,yt=$.toString,gt=$.toLocaleString,mt=F("iterator"),bt=F("toStringTag"),xt=j("typed_constructor"),St=j("def_constructor"),wt=c.CONSTR,_t=c.TYPED,Ot=c.VIEW,Et="Wrong length!",Mt=A(1,function(t,n){return Lt(N(t,t[St]),n)}),Pt=o(function(){return 1===new z(new Uint16Array([1]).buffer)[0]}),jt=!!z&&!!z[Y].set&&o(function(){new z(1).set({})}),Ft=function(t,n){var r=p(t);if(r<0||r%n)throw B("Wrong offset!");return r},At=function(t){if(S(t)&&_t in t)return t;throw q(t+" is not a typed array!")},Lt=function(t,n){if(!(S(t)&&xt in t))throw q("It is not a typed array constructor!");return new t(n)},Nt=function(t,n){return Tt(N(t,t[St]),n)},Tt=function(t,n){for(var r=0,e=n.length,i=Lt(t,e);e>r;)i[r]=n[r++];return i},It=function(t,n,r){U(t,n,{get:function(){return this._d[r]}})},kt=function(t){var n,r,e,i,o,u,c=w(t),f=arguments.length,s=f>1?arguments[1]:void 0,l=void 0!==s,h=P(c);if(void 0!=h&&!_(h)){for(u=h.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(l&&f>2&&(s=a(s,arguments[2],2)),n=0,r=d(c.length),i=Lt(this,r);r>n;n++)i[n]=l?s(c[n],n):c[n];return i},Rt=function(){for(var t=0,n=arguments.length,r=Lt(this,n);n>t;)r[t]=arguments[t++];return r},Ct=!!z&&o(function(){gt.call(new z(1))}),Dt=function(){return gt.apply(Ct?dt.call(At(this)):At(this),arguments)},Gt={copyWithin:function(t,n){return D.call(At(this),t,n,arguments.length>2?arguments[2]:void 0)},every:function(t){return rt(At(this),t,arguments.length>1?arguments[1]:void 0)},fill:function(t){return C.apply(At(this),arguments)},filter:function(t){return Nt(this,tt(At(this),t,arguments.length>1?arguments[1]:void 0))},find:function(t){return et(At(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function(t){return it(At(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function(t){Z(At(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function(t){return ut(At(this),t,arguments.length>1?arguments[1]:void 0)},includes:function(t){return ot(At(this),t,arguments.length>1?arguments[1]:void 0)},join:function(t){return vt.apply(At(this),arguments)},lastIndexOf:function(t){return st.apply(At(this),arguments)},map:function(t){return Mt(At(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function(t){return lt.apply(At(this),arguments)},reduceRight:function(t){return ht.apply(At(this),arguments)},reverse:function(){for(var t,n=this,r=At(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(At(this),t,arguments.length>1?arguments[1]:void 0)},sort:function(t){return pt.call(At(this),t)},subarray:function(t,n){var r=At(this),e=r.length,i=g(t,e);return new(N(r,r[St]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,d((void 0===n?e:g(n,e))-i))}},Wt=function(t,n){return Nt(this,dt.call(At(this),t,n))},Ut=function(t){At(this);var n=Ft(arguments[1],1),r=this.length,e=w(t),i=d(e.length),o=0;if(i+n>r)throw B(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(At(this))},keys:function(){return ft.call(At(this))},values:function(){return ct.call(At(this))}},Bt=function(t,n){return S(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return Bt(t,n=m(n,!0))?l(2,t[n]):V(t,n)},zt=function(t,n,r){return!(Bt(t,n=m(n,!0))&&S(r)&&b(r,"value"))||b(r,"get")||b(r,"set")||r.configurable||b(r,"writable")&&!r.writable||b(r,"enumerable")&&!r.enumerable?U(t,n,r):(t[n]=r.value,t)};wt||(W.f=qt,G.f=zt),u(u.S+u.F*!wt,"Object",{getOwnPropertyDescriptor:qt,defineProperty:zt}),o(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Ht=v({},Gt);v(Ht,Vt),h(Ht,mt,Vt.values),v(Ht,{slice:Wt,set:Ut,constructor:function(){},toString:yt,toLocaleString:Dt}),It(Ht,"buffer","b"),It(Ht,"byteOffset","o"),It(Ht,"byteLength","l"),It(Ht,"length","e"),U(Ht,bt,{get:function(){return this[_t]}}),t.exports=function(t,n,r,f){var a=t+((f=!!f)?"Clamped":"")+"Array",l="get"+t,v="set"+t,p=i[a],g=p||{},m=p&&E(p),b=!p||!c.ABV,w={},_=p&&p[Y],P=function(t,r){var e=t._d;return e.v[l](r*n+e.o,Pt)},j=function(t,r,e){var i=t._d;f&&(e=(e=Math.round(e))<0?0:e>255?255:255&e),i.v[v](r*n+i.o,e,Pt)},F=function(t,n){U(t,n,{get:function(){return P(this,n)},set:function(t){return j(this,n,t)},enumerable:!0})};b?(p=r(function(t,r,e,i){s(t,p,a,"_d");var o,u,c,f,l=0,v=0;if(S(r)){if(!(r instanceof X||(f=x(r))==H||f==K))return _t in r?Tt(p,r):kt.call(p,r);o=r,v=Ft(e,n);var g=r.byteLength;if(void 0===i){if(g%n)throw B(Et);if((u=g-v)<0)throw B(Et)}else if((u=d(i)*n)+v>g)throw B(Et);c=u/n}else c=y(r),u=c*n,o=new X(u);for(h(t,"_d",{b:o,o:v,l:u,e:c,v:new Q(o)});l<c;)F(t,l++)}),_=p[Y]=O(Ht),h(_,"constructor",p)):o(function(){p(1)})&&o(function(){new p(-1)})&&k(function(t){new p,new p(null),new p(1.5),new p(t)},!0)||(p=r(function(t,r,e,i){s(t,p,a);var o;return S(r)?r instanceof X||(o=x(r))==H||o==K?void 0!==i?new g(r,Ft(e,n),i):void 0!==e?new g(r,Ft(e,n)):new g(r):_t in r?Tt(p,r):kt.call(p,r):new g(y(r))}),Z(m!==Function.prototype?M(g).concat(M(m)):M(g),function(t){t in p||h(p,t,g[t])}),p[Y]=_,e||(_.constructor=p));var A=_[mt],L=!!A&&("values"==A.name||void 0==A.name),N=Vt.values;h(p,xt,!0),h(_,_t,a),h(_,Ot,!0),h(_,St,p),(f?new p(1)[bt]==a:bt in _)||U(_,bt,{get:function(){return a}}),w[a]=p,u(u.G+u.W+u.F*(p!=g),w),u(u.S,a,{BYTES_PER_ELEMENT:n}),u(u.S+u.F*o(function(){g.of.call(p,1)}),a,{from:kt,of:Rt}),J in _||h(_,J,n),u(u.P,a,Gt),R(a),u(u.P+u.F*jt,a,{set:Ut}),u(u.P+u.F*!L,a,Vt),e||_.toString==yt||(_.toString=yt),u(u.P+u.F*o(function(){new p(1).slice()}),a,{slice:Wt}),u(u.P+u.F*(o(function(){return[1,2].toLocaleString()!=new p([1,2]).toLocaleString()})||!o(function(){_.toLocaleString.call([1,2])})),a,{toLocaleString:Dt}),I[a]=L?A:N,e||L||h(_,mt,N)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(21),i=r(6).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(18)(function(){return 7!=Object.defineProperty(r(58)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var e=r(36),i=r(54),o=r(65),u=r(13),c=r(8),f=r(35),a=r(97),s=r(38),l=r(103),h=r(16)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,m,b,x){a(r,n,g);var S,w,_,O=function(t){if(!v&&t in j)return j[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",M=m==d,P=!1,j=t.prototype,F=j[h]||j["@@iterator"]||m&&j[m],A=F||O(m),L=m?M?O("entries"):A:void 0,N="Array"==n?j.entries||F:F;if(N&&(_=l(N.call(new t)))!==Object.prototype&&_.next&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),M&&F&&F.name!==d&&(P=!0,A=function(){return F.call(this)}),e&&!x||!v&&!P&&j[h]||u(j,h,A),f[n]=A,f[E]=y,m)if(S={values:M?A:O(d),keys:b?A:O(p),entries:L},x)for(w in S)w in j||o(j,w,S[w]);else i(i.P+i.F*(v||P),n,S);return S}},function(t,n,r){var e=r(20),i=r(100),o=r(34),u=r(39)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(58)("iframe"),e=o.length;for(n.style.display="none",r(94).appendChild(n),n.src="javascript:",(t=n.contentWindow.document).open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(64),i=r(34).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(8),i=r(15),o=r(91)(!1),u=r(39)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;void 0==i[e]&&r(26)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n,r){var e=r(78)("meta"),i=r(5),o=r(25),u=r(10).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=t.exports={KEY:e,NEED:!1,fastKey:function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},getWeak:function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},onFreeze:function(t){return a&&l.NEED&&f(t)&&!o(t,e)&&s(t),t}}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n,r){var e=r(46),i=r(173),o=r(141),u=r(2),c=r(11),f=r(157),a={},s={};(n=t.exports=function(t,n,r,l,h){var v,p,d,y,g=h?function(){return t}:f(t),m=e(r,l,n?2:1),b=0;if("function"!=typeof g)throw TypeError(t+" is not iterable!");if(o(g)){for(v=c(t.length);v>b;b++)if((y=n?m(u(p=t[b])[0],p[1]):m(t[b]))===a||y===s)return y}else for(d=g.call(t);!(p=d.next()).done;)if((y=i(d,m,p.value,n))===a||y===s)return y}).BREAK=a,n.RETURN=s},function(t,n){t.exports=!1},function(t,n,r){var e=r(2),i=r(179),o=r(137),u=r(149)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(136)("iframe"),e=o.length;for(n.style.display="none",r(139).appendChild(n),n.src="javascript:",(t=n.contentWindow.document).open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(181),i=r(137).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(181),i=r(137);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n,r){var e=r(27);t.exports=function(t,n,r){for(var i in n)e(t,i,n[i],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(10),o=r(9),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(52),i=Math.max,o=Math.min;t.exports=function(t,n){return(t=e(t))<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(33);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports={}},function(t,n,r){var e=r(10).f,i=r(25),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(1),i=r(50),o=r(4),u=r(153),c="["+u+"]",f=RegExp("^"+c+c+"*"),a=RegExp(c+c+"*$"),s=function(t,n,r){var i={},c=o(function(){return!!u[t]()||"​"!="​"[t]()}),f=i[t]=c?n(l):u[t];r&&(i[r]=f),e(e.P+e.F*c,"String",i)},l=s.trim=function(t,n){return t=String(i(t)),1&n&&(t=t.replace(f,"")),2&n&&(t=t.replace(a,"")),t};t.exports=s},function(t,n,r){var e=r(5);t.exports=function(t,n){if(!e(t)||t._t!==n)throw TypeError("Incompatible receiver, "+n+" required!");return t}},function(t,n,r){t.exports={default:r(87),__esModule:!0}},function(t,n,r){t.exports={default:r(88),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=e(r(85)),o=e(r(84)),u="function"==typeof o.default&&"symbol"==typeof i.default?function(t){return typeof t}:function(t){return t&&"function"==typeof o.default&&t.constructor===o.default&&t!==o.default.prototype?"symbol":typeof t};n.default="function"==typeof o.default&&"symbol"===u(i.default)?function(t){return void 0===t?"undefined":u(t)}:function(t){return t&&"function"==typeof o.default&&t.constructor===o.default&&t!==o.default.prototype?"symbol":void 0===t?"undefined":u(t)}},function(t,n,r){r(110),r(108),r(111),r(112),t.exports=r(24).Symbol},function(t,n,r){r(109),r(113),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var e=r(15),i=r(106),o=r(105);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){var e=r(89);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(29),i=r(63),o=r(37);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){var e=r(6).document;t.exports=e&&e.documentElement},function(t,n,r){var e=r(57);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(57);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(61),i=r(22),o=r(38),u={};r(13)(u,r(16)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(23)("meta"),i=r(21),o=r(8),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(18)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=t.exports={KEY:e,NEED:!1,fastKey:function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},getWeak:function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},onFreeze:function(t){return a&&l.NEED&&f(t)&&!o(t,e)&&s(t),t}}},function(t,n,r){var e=r(14),i=r(20),o=r(29);t.exports=r(12)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(22),o=r(15),u=r(42),c=r(8),f=r(59),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(15),i=r(62).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(8),i=r(79),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(41),i=r(33);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f))<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return(t=e(t))<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(90),i=r(98),o=r(35),u=r(15);t.exports=r(60)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(104)(!0);r(60)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(6),i=r(8),o=r(12),u=r(54),c=r(65),f=r(99).KEY,a=r(18),s=r(40),l=r(38),h=r(23),v=r(16),p=r(44),d=r(43),y=r(93),g=r(96),m=r(20),b=r(15),x=r(42),S=r(22),w=r(61),_=r(102),O=r(101),E=r(14),M=r(29),P=O.f,j=E.f,F=_.f,A=e.Symbol,L=e.JSON,N=L&&L.stringify,T="prototype",I=v("_hidden"),k=v("toPrimitive"),R={}.propertyIsEnumerable,C=s("symbol-registry"),D=s("symbols"),G=s("op-symbols"),W=Object[T],U="function"==typeof A,V=e.QObject,B=!V||!V[T]||!V[T].findChild,q=o&&a(function(){return 7!=w(j({},"a",{get:function(){return j(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=P(W,n);e&&delete W[n],j(t,n,r),e&&t!==W&&j(W,n,e)}:j,z=function(t){var n=D[t]=w(A[T]);return n._k=t,n},H=U&&"symbol"==typeof A.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof A},K=function(t,n,r){return t===W&&K(G,n,r),m(t),n=x(n,!0),m(r),i(D,n)?(r.enumerable?(i(t,I)&&t[I][n]&&(t[I][n]=!1),r=w(r,{enumerable:S(0,!1)})):(i(t,I)||j(t,I,S(1,{})),t[I][n]=!0),q(t,n,r)):j(t,n,r)},J=function(t,n){m(t);for(var r,e=y(n=b(n)),i=0,o=e.length;o>i;)K(t,r=e[i++],n[r]);return t},Y=function(t){var n=R.call(this,t=x(t,!0));return!(this===W&&i(D,t)&&!i(G,t))&&(!(n||!i(this,t)||!i(D,t)||i(this,I)&&this[I][t])||n)},$=function(t,n){if(t=b(t),n=x(n,!0),t!==W||!i(D,n)||i(G,n)){var r=P(t,n);return!r||!i(D,n)||i(t,I)&&t[I][n]||(r.enumerable=!0),r}},X=function(t){for(var n,r=F(b(t)),e=[],o=0;r.length>o;)i(D,n=r[o++])||n==I||n==f||e.push(n);return e},Q=function(t){for(var n,r=t===W,e=F(r?G:b(t)),o=[],u=0;e.length>u;)!i(D,n=e[u++])||r&&!i(W,n)||o.push(D[n]);return o};U||(A=function(){if(this instanceof A)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===W&&n.call(G,r),i(this,I)&&i(this[I],t)&&(this[I][t]=!1),q(this,t,S(1,r))};return o&&B&&q(W,t,{configurable:!0,set:n}),z(t)},c(A[T],"toString",function(){return this._k}),O.f=$,E.f=K,r(62).f=_.f=X,r(37).f=Y,r(63).f=Q,o&&!r(36)&&c(W,"propertyIsEnumerable",Y,!0),p.f=function(t){return z(v(t))}),u(u.G+u.W+u.F*!U,{Symbol:A});for(var Z="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),tt=0;Z.length>tt;)v(Z[tt++]);for(var nt=M(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!U,"Symbol",{for:function(t){return i(C,t+="")?C[t]:C[t]=A(t)},keyFor:function(t){if(!H(t))throw TypeError(t+" is not a symbol!");for(var n in C)if(C[n]===t)return n},useSetter:function(){B=!0},useSimple:function(){B=!1}}),u(u.S+u.F*!U,"Object",{create:function(t,n){return void 0===n?w(t):J(w(t),n)},defineProperty:K,defineProperties:J,getOwnPropertyDescriptor:$,getOwnPropertyNames:X,getOwnPropertySymbols:Q}),L&&u(u.S+u.F*(!U||a(function(){var t=A();return"[null]"!=N([t])||"{}"!=N({a:t})||"{}"!=N(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!H(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return"function"==typeof(n=e[1])&&(r=n),!r&&g(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!H(n))return n}),e[1]=n,N.apply(L,e)}}}),A[T][k]||r(13)(A[T],k,A[T].valueOf),l(A,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(107);for(var e=r(6),i=r(13),o=r(35),u=r(16)("toStringTag"),c="CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","),f=0;f<c.length;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){var e=r(45),i=r(7)("toStringTag"),o="Arguments"==e(function(){return arguments}()),u=function(t,n){try{return t[n]}catch(t){}};t.exports=function(t){var n,r,c;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=u(n=Object(t),i))?r:o?e(n):"Object"==(c=e(n))&&"function"==typeof n.callee?"Arguments":c}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(32),i=r(11),o=r(77);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){"use strict";var e=r(3),i=r(1),o=r(27),u=r(75),c=r(67),f=r(69),a=r(68),s=r(5),l=r(4),h=r(123),v=r(81),p=r(140);t.exports=function(t,n,r,d,y,g){var m=e[t],b=m,x=y?"set":"add",S=b&&b.prototype,w={},_=function(t){var n=S[t];o(S,t,"delete"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"has"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"get"==t?function(t){return g&&!s(t)?void 0:n.call(this,0===t?0:t)}:"add"==t?function(t){return n.call(this,0===t?0:t),this}:function(t,r){return n.call(this,0===t?0:t,r),this})};if("function"==typeof b&&(g||S.forEach&&!l(function(){(new b).entries().next()}))){var O=new b,E=O[x](g?{}:-0,1)!=O,M=l(function(){O.has(1)}),P=h(function(t){new b(t)}),j=!g&&l(function(){for(var t=new b,n=5;n--;)t[x](n,n);return!t.has(-0)});P||(b=n(function(n,r){a(n,b,t);var e=p(new m,n,b);return void 0!=r&&f(r,y,e[x],e),e}),b.prototype=S,S.constructor=b),(M||j)&&(_("delete"),_("has"),y&&_("get")),(j||E)&&_(x),g&&S.clear&&delete S.clear}else b=d.getConstructor(n,t,y,x),u(b.prototype,r),c.NEED=!0;return v(b,t),w[t]=b,i(i.G+i.W+i.F*(b!=m),w),g||d.setStrong(b,t,y),b}},function(t,n,r){"use strict";var e=r(26),i=r(27),o=r(4),u=r(50),c=r(7);t.exports=function(t,n,r){var f=c(t),a=r(u,f,""[t]),s=a[0],l=a[1];o(function(){var n={};return n[f]=function(){return 7},7!=""[t](n)})&&(i(String.prototype,t,s),e(RegExp.prototype,f,2==n?function(t,n){return l.call(t,this,n)}:function(t){return l.call(t,this)}))}},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){var e=r(5),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var e=r(7)("iterator"),i=!1;try{var o=[7][e]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!i)return!1;var r=!1;try{var o=[7],u=o[e]();u.next=function(){return{done:r=!0}},o[e]=function(){return u},t(o)}catch(t){}return r}},function(t,n,r){"use strict";t.exports=r(70)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){"use strict";var e=r(1),i=r(19),o=r(46),u=r(69);t.exports=function(t){e(e.S,t,{from:function(t){var n,r,e,c,f=arguments[1];return i(this),(n=void 0!==f)&&i(f),void 0==t?new this:(r=[],n?(e=0,c=o(f,arguments[2],2),u(t,!1,function(t){r.push(c(t,e++))})):u(t,!1,r.push,r),new this(r))}})}},function(t,n,r){"use strict";var e=r(1);t.exports=function(t){e(e.S,t,{of:function(){for(var t=arguments.length,n=Array(t);t--;)n[t]=arguments[t];return new this(n)}})}},function(t,n,r){var e=r(3),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n,r){var e=r(2),i=r(19),o=r(7)("species");t.exports=function(t,n){var r,u=e(t).constructor;return void 0===u||void 0==(r=e(u)[o])?n:i(r)}},function(t,n,r){for(var e,i=r(3),o=r(26),u=r(78),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n){"use strict";var r={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&-1==t.indexOf("KHTML"),mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:-1==t.indexOf("Safari"),weixin:-1==t.indexOf("MicroMessenger")}}()};t.exports=r},function(t,n,r){"use strict";var e=function(t){return t&&t.__esModule?t:{default:t}}(r(86)),i=function(){function t(t,n,r){return n||r?String.fromCharCode(n||r):u[t]||t}function n(t){return l[t]}var r=/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,o=/['<> "&]/g,u={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},c=/\u00a0/g,f=/<br\s*\/?>/gi,a=/\r?\n/g,s=/\s/g,l={};for(var h in u)l[u[h]]=h;return u["&apos;"]="'",l["'"]="&#39;",{encode:function(t){return t?(""+t).replace(o,n).replace(a,"<br/>").replace(s,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(f,"\n").replace(r,t).replace(c," "):""},encodeBase16:function(t){if(!t)return t;for(var n=[],r=0,e=(t+="").length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;for(var n=[],r=0,e=(t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")})).length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;for(var n=[],r=0,e=(t+="").length;e>r;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;r>n;n++)t[n]=i.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,e.default)(t)))for(var o in t)t[o]=i.encodeObject(t[o]);else if("string"==typeof t)return i.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=i},function(t,n,r){"use strict";var e=r(17),i=r(77),o=r(11);t.exports=function(t){for(var n=e(this),r=o(n.length),u=arguments.length,c=i(u>1?arguments[1]:void 0,r),f=u>2?arguments[2]:void 0,a=void 0===f?r:i(f,r);a>c;)n[c++]=t;return n}},function(t,n,r){var e=r(211);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(10),i=r(74);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(5),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(t){var n=/./;try{"/./"[t](n)}catch(r){try{return n[e]=!1,!"/./"[t](n)}catch(t){}}return!0}},function(t,n,r){var e=r(3).document;t.exports=e&&e.documentElement},function(t,n,r){var e=r(5),i=r(148).set;t.exports=function(t,n,r){var o,u=n.constructor;return u!==r&&"function"==typeof u&&(o=u.prototype)!==r.prototype&&e(o)&&i&&i(t,o),t}},function(t,n,r){var e=r(80),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){"use strict";var e=r(71),i=r(74),o=r(81),u={};r(26)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var e=r(70),i=r(1),o=r(27),u=r(26),c=r(25),f=r(80),a=r(142),s=r(81),l=r(31),h=r(7)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,m,b,x){a(r,n,g);var S,w,_,O=function(t){if(!v&&t in j)return j[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",M=m==d,P=!1,j=t.prototype,F=j[h]||j["@@iterator"]||m&&j[m],A=F||O(m),L=m?M?O("entries"):A:void 0,N="Array"==n?j.entries||F:F;if(N&&(_=l(N.call(new t)))!==Object.prototype&&_.next&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),M&&F&&F.name!==d&&(P=!0,A=function(){return F.call(this)}),e&&!x||!v&&!P&&j[h]||u(j,h,A),f[n]=A,f[E]=y,m)if(S={values:M?A:O(d),keys:b?A:O(p),entries:L},x)for(w in S)w in j||o(j,w,S[w]);else i(i.P+i.F*(v||P),n,S);return S}},function(t,n){var r=Math.expm1;t.exports=!r||r(10)>22025.465794806718||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:t>-1e-6&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var e=r(3),i=r(154).set,o=e.MutationObserver||e.WebKitMutationObserver,u=e.process,c=e.Promise,f="process"==r(45)(u);t.exports=function(){var t,n,r,a=function(){var e,i;for(f&&(e=u.domain)&&e.exit();t;){i=t.fn,t=t.next;try{i()}catch(e){throw t?r():n=void 0,e}}n=void 0,e&&e.enter()};if(f)r=function(){u.nextTick(a)};else if(o){var s=!0,l=document.createTextNode("");new o(a).observe(l,{characterData:!0}),r=function(){l.data=s=!s}}else if(c&&c.resolve){var h=c.resolve();r=function(){h.then(a)}}else r=function(){i.call(e,a)};return function(e){var i={fn:e,next:void 0};n&&(n.next=i),t||(t=i,r()),n=i}}},function(t,n,r){"use strict";function e(t){var n,r;this.promise=new t(function(t,e){if(void 0!==n||void 0!==r)throw TypeError("Bad Promise constructor");n=t,r=e}),this.resolve=i(n),this.reject=i(r)}var i=r(19);t.exports.f=function(t){return new e(t)}},function(t,n,r){var e=r(5),i=r(2),o=function(t,n){if(i(t),!e(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,n,e){try{(e=r(46)(Function.call,r(30).f(Object.prototype,"__proto__").set,2))(t,[]),n=!(t instanceof Array)}catch(t){n=!0}return function(t,r){return o(t,r),n?t.__proto__=r:e(t,r),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(128)("keys"),i=r(78);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(52),i=r(50);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f))<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536}}},function(t,n,r){var e=r(122),i=r(50);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var e=r(52),i=r(50);t.exports=function(t){var n=String(i(this)),r="",o=e(t);if(o<0||o==1/0)throw RangeError("Count can't be negative");for(;o>0;(o>>>=1)&&(n+=n))1&o&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(46),c=r(171),f=r(139),a=r(136),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=s.Dispatch,y=0,g={},m="onreadystatechange",b=function(){var t=+this;if(g.hasOwnProperty(t)){var n=g[t];delete g[t],n()}},x=function(t){b.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return g[++y]=function(){c("function"==typeof t?t:Function(t),n)},e(y),y},v=function(t){delete g[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(b,t,1))}:d&&d.now?e=function(t){d.now(u(b,t,1))}:p?(i=new p,o=i.port2,i.port1.onmessage=x,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",x,!1)):e=m in a("script")?function(t){f.appendChild(a("script"))[m]=function(){f.removeChild(this),b.call(t)}}:function(t){setTimeout(u(b,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";function e(t,n,r){var e,i,o,u=Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?W(2,-24)-W(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for((t=G(t))!=t||t===C?(i=t!=t?1:0,e=f):(e=U(V(t)/B),t*(o=W(2,-e))<1&&(e--,o*=2),(t+=e+a>=1?s/o:s*W(2,1-a))*o>=2&&(e++,o/=2),e+a>=f?(i=0,e=f):e+a>=1?(i=(t*o-1)*W(2,n),e+=a):(i=t*W(2,a-1)*W(2,n),e=0));n>=8;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;c>0;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u}function i(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;c>0;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;c>0;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-C:C;e+=W(2,n),s-=u}return(a?-1:1)*e*W(2,s-n)}function o(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]}function u(t){return[255&t]}function c(t){return[255&t,t>>8&255]}function f(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]}function a(t){return e(t,52,8)}function s(t){return e(t,23,4)}function l(t,n,r){M(t[L],n,{get:function(){return this[r]}})}function h(t,n,r,e){var i=O(+r);if(i+n>t[J])throw R(N);var o=t[K]._b,u=i+t[Y],c=o.slice(u,u+n);return e?c:c.reverse()}function v(t,n,r,e,i,o){var u=O(+r);if(u+n>t[J])throw R(N);for(var c=t[K]._b,f=u+t[Y],a=e(+i),s=0;s<n;s++)c[f+s]=a[o?s:n-s-1]}var p=r(3),d=r(9),y=r(70),g=r(130),m=r(26),b=r(75),x=r(4),S=r(68),w=r(52),_=r(11),O=r(189),E=r(72).f,M=r(10).f,P=r(133),j=r(81),F="ArrayBuffer",A="DataView",L="prototype",N="Wrong index!",T=p[F],I=p[A],k=p.Math,R=p.RangeError,C=p.Infinity,D=T,G=k.abs,W=k.pow,U=k.floor,V=k.log,B=k.LN2,q="buffer",z="byteLength",H="byteOffset",K=d?"_b":q,J=d?"_l":z,Y=d?"_o":H;if(g.ABV){if(!x(function(){T(1)})||!x(function(){new T(-1)})||x(function(){return new T,new T(1.5),new T(NaN),T.name!=F})){for(var $,X=(T=function(t){return S(this,T),new D(O(t))})[L]=D[L],Q=E(D),Z=0;Q.length>Z;)($=Q[Z++])in T||m(T,$,D[$]);y||(X.constructor=T)}var tt=new I(new T(2)),nt=I[L].setInt8;tt.setInt8(0,2147483648),tt.setInt8(1,2147483649),!tt.getInt8(0)&&tt.getInt8(1)||b(I[L],{setInt8:function(t,n){nt.call(this,t,n<<24>>24)},setUint8:function(t,n){nt.call(this,t,n<<24>>24)}},!0)}else T=function(t){S(this,T,F);var n=O(t);this._b=P.call(Array(n),0),this[J]=n},I=function(t,n,r){S(this,I,A),S(t,T,A);var e=t[J],i=w(n);if(i<0||i>e)throw R("Wrong offset!");if(r=void 0===r?e-i:_(r),i+r>e)throw R("Wrong length!");this[K]=t,this[Y]=i,this[J]=r},d&&(l(T,z,"_l"),l(I,q,"_b"),l(I,z,"_l"),l(I,H,"_o")),b(I[L],{getInt8:function(t){return h(this,1,t)[0]<<24>>24},getUint8:function(t){return h(this,1,t)[0]},getInt16:function(t){var n=h(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=h(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return o(h(this,4,t,arguments[1]))},getUint32:function(t){return o(h(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return i(h(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return i(h(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){v(this,1,t,u,n)},setUint8:function(t,n){v(this,1,t,u,n)},setInt16:function(t,n){v(this,2,t,c,n,arguments[2])},setUint16:function(t,n){v(this,2,t,c,n,arguments[2])},setInt32:function(t,n){v(this,4,t,f,n,arguments[2])},setUint32:function(t,n){v(this,4,t,f,n,arguments[2])},setFloat32:function(t,n){v(this,4,t,s,n,arguments[2])},setFloat64:function(t,n){v(this,8,t,a,n,arguments[2])}});j(T,F),j(I,A),m(I[L],g.VIEW,!0),n[F]=T,n[A]=I},function(t,n,r){var e=r(3),i=r(49),o=r(70),u=r(190),c=r(10).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(114),i=r(7)("iterator"),o=r(80);t.exports=r(49).getIteratorMethod=function(t){if(void 0!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(66),i=r(174),o=r(80),u=r(32);t.exports=r(143)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){t.exports=function(t,n){t.classList?t.classList.add(n):t.className+=" "+n}},function(t,n){t.exports=function(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var e=r(17),i=r(77),o=r(11);t.exports=[].copyWithin||function(t,n){var r=e(this),u=o(r.length),c=i(t,u),f=i(n,u),a=arguments.length>2?arguments[2]:void 0,s=Math.min((void 0===a?u:i(a,u))-f,u-c),l=1;for(f<c&&c<f+s&&(l=-1,f+=s-1,c+=s-1);s-- >0;)f in r?r[c]=r[f]:delete r[c],c+=l,f+=l;return r}},function(t,n,r){var e=r(69);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var e=r(19),i=r(17),o=r(115),u=r(11);t.exports=function(t,n,r,c,f){e(n);var a=i(t),s=o(a),l=u(a.length),h=f?l-1:0,v=f?-1:1;if(r<2)for(;;){if(h in s){c=s[h],h+=v;break}if(h+=v,f?h<0:l<=h)throw TypeError("Reduce of empty array with no initial value")}for(;f?h>=0:l>h;h+=v)h in s&&(c=n(c,s[h],h,a));return c}},function(t,n,r){"use strict";var e=r(19),i=r(5),o=r(171),u=[].slice,c={},f=function(t,n,r){if(!(n in c)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";c[n]=Function("F,a","return new F("+e.join(",")+")")}return c[n](t,r)};t.exports=Function.bind||function(t){var n=e(this),r=u.call(arguments,1),c=function(){var e=r.concat(u.call(arguments));return this instanceof c?f(n,e.length,e):o(n,e,t)};return i(n.prototype)&&(c.prototype=n.prototype),c}},function(t,n,r){"use strict";var e=r(10).f,i=r(71),o=r(75),u=r(46),c=r(68),f=r(69),a=r(143),s=r(174),l=r(76),h=r(9),v=r(67).fastKey,p=r(83),d=h?"_s":"size",y=function(t,n){var r,e=v(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,n,r,a){var s=t(function(t,e){c(t,s,n,"_i"),t._t=n,t._i=i(null),t._f=void 0,t._l=void 0,t[d]=0,void 0!=e&&f(e,r,t[a],t)});return o(s.prototype,{clear:function(){for(var t=p(this,n),r=t._i,e=t._f;e;e=e.n)e.r=!0,e.p&&(e.p=e.p.n=void 0),delete r[e.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var r=p(this,n),e=y(r,t);if(e){var i=e.n,o=e.p;delete r._i[e.i],e.r=!0,o&&(o.n=i),i&&(i.p=o),r._f==e&&(r._f=i),r._l==e&&(r._l=o),r[d]--}return!!e},forEach:function(t){p(this,n);for(var r,e=u(t,arguments.length>1?arguments[1]:void 0,3);r=r?r.n:this._f;)for(e(r.v,r.k,this);r&&r.r;)r=r.p},has:function(t){return!!y(p(this,n),t)}}),h&&e(s.prototype,"size",{get:function(){return p(this,n)[d]}}),s},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=v(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,n,r){a(t,n,function(t,r){this._t=p(t,n),this._k=r,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?"keys"==n?s(0,r.k):"values"==n?s(0,r.v):s(0,[r.k,r.v]):(t._t=void 0,s(1))},r?"entries":"values",!r,!0),l(n)}}},function(t,n,r){var e=r(114),i=r(163);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var e=r(75),i=r(67).getWeak,o=r(2),u=r(5),c=r(68),f=r(69),a=r(48),s=r(25),l=r(83),h=a(5),v=a(6),p=0,d=function(t){return t._l||(t._l=new y)},y=function(){this.a=[]},g=function(t,n){return h(t.a,function(t){return t[0]===n})};y.prototype={get:function(t){var n=g(this,t);if(n)return n[1]},has:function(t){return!!g(this,t)},set:function(t,n){var r=g(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(t){var n=v(this.a,function(n){return n[0]===t});return~n&&this.a.splice(n,1),!!~n}},t.exports={getConstructor:function(t,n,r,o){var a=t(function(t,e){c(t,a,n,"_i"),t._t=n,t._i=p++,t._l=void 0,void 0!=e&&f(e,r,t[o],t)});return e(a.prototype,{delete:function(t){if(!u(t))return!1;var r=i(t);return!0===r?d(l(this,n)).delete(t):r&&s(r,this._i)&&delete r[this._i]},has:function(t){if(!u(t))return!1;var r=i(t);return!0===r?d(l(this,n)).has(t):r&&s(r,this._i)}}),a},def:function(t,n,r){var e=i(o(n),!0);return!0===e?d(t).set(n,r):e[t._i]=r,t},ufstore:d}},function(t,n,r){"use strict";function e(t,n,r,a,s,l,h,v){for(var p,d,y=s,g=0,m=!!h&&c(h,v,3);g<a;){if(g in r){if(p=m?m(r[g],g,n):r[g],d=!1,o(p)&&(d=p[f],d=void 0!==d?!!d:i(p)),d&&l>0)y=e(t,n,p,u(p.length),y,l-1)-1;else{if(y>=9007199254740991)throw TypeError();t[y]=p}y++}g++}return y}var i=r(121),o=r(5),u=r(11),c=r(46),f=r(7)("isConcatSpreadable");t.exports=e},function(t,n,r){t.exports=!r(9)&&!r(4)(function(){return 7!=Object.defineProperty(r(136)("div"),"a",{get:function(){return 7}}).a})},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(5),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var e=r(2);t.exports=function(t,n,r,i){try{return i?n(e(r)[0],r[1]):n(r)}catch(n){var o=t.return;throw void 0!==o&&e(o.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(145),i=Math.pow,o=i(2,-52),u=i(2,-23),c=i(2,127)*(2-u),f=i(2,-126),a=function(t){return t+1/o-1/o};t.exports=Math.fround||function(t){var n,r,i=Math.abs(t),s=e(t);return i<f?s*a(i/f/u)*f*u:(n=(1+u/o)*i,(r=n-(n-i))>c||r!=r?s*(1/0):s*r)}},function(t,n){t.exports=Math.log1p||function(t){return(t=+t)>-1e-8&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n){t.exports=Math.scale||function(t,n,r,e,i){return 0===arguments.length||t!=t||n!=n||r!=r||e!=e||i!=i?NaN:t===1/0||t===-1/0?t:(t-n)*(i-e)/(r-n)+e}},function(t,n,r){"use strict";var e=r(73),i=r(125),o=r(116),u=r(17),c=r(115),f=Object.assign;t.exports=!f||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=f({},t)[r]||Object.keys(f({},n)).join("")!=e})?function(t,n){for(var r=u(t),f=arguments.length,a=1,s=i.f,l=o.f;f>a;)for(var h,v=c(arguments[a++]),p=s?e(v).concat(s(v)):e(v),d=p.length,y=0;d>y;)l.call(v,h=p[y++])&&(r[h]=v[h]);return r}:f},function(t,n,r){var e=r(10),i=r(2),o=r(73);t.exports=r(9)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(32),i=r(72).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(25),i=r(32),o=r(117)(!1),u=r(149)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){var e=r(73),i=r(32),o=r(116).f;t.exports=function(t){return function(n){for(var r,u=i(n),c=e(u),f=c.length,a=0,s=[];f>a;)o.call(u,r=c[a++])&&s.push(t?[r,u[r]]:u[r]);return s}}},function(t,n,r){var e=r(72),i=r(125),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(82).trim;t.exports=1/e(r(153)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(82).trim,o=r(153),u=/^[-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=function(t){try{return{e:!1,v:t()}}catch(t){return{e:!0,v:t}}}},function(t,n,r){var e=r(2),i=r(5),o=r(147);t.exports=function(t,n){if(e(t),i(n)&&n.constructor===t)return n;var r=o.f(t);return(0,r.resolve)(n),r.promise}},function(t,n,r){var e=r(11),i=r(152),o=r(50);t.exports=function(t,n,r,u){var c=String(o(t)),f=c.length,a=void 0===r?" ":String(r),s=e(n);if(s<=f||""==a)return c;var l=s-f,h=i.call(a,Math.ceil(l/a.length));return h.length>l&&(h=h.slice(0,l)),u?h+c:c+h}},function(t,n,r){var e=r(52),i=r(11);t.exports=function(t){if(void 0===t)return 0;var n=e(t),r=i(n);if(n!==r)throw RangeError("Wrong length!");return r}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(166),i=r(83),o="Map";t.exports=r(118)(o,function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(i(this,o),t);return n&&n.v},set:function(t,n){return e.def(i(this,o),0===t?0:t,n)}},e,!0)},function(t,n,r){r(9)&&"g"!=/./g.flags&&r(10).f(RegExp.prototype,"flags",{configurable:!0,get:r(120)})},function(t,n,r){"use strict";var e=r(166),i=r(83);t.exports=r(118)("Set",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(i(this,"Set"),t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var e,i=r(48)(0),o=r(27),u=r(67),c=r(178),f=r(168),a=r(5),s=r(4),l=r(83),h="WeakMap",v=u.getWeak,p=Object.isExtensible,d=f.ufstore,y={},g=function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},m={get:function(t){if(a(t)){var n=v(t);return!0===n?d(l(this,h)).get(t):n?n[this._i]:void 0}},set:function(t,n){return f.def(l(this,h),t,n)}},b=t.exports=r(118)(h,g,m,f,!0,!0);s(function(){return 7!=(new b).set((Object.freeze||Object)(y),7).get(y)})&&(e=f.getConstructor(g,h),c(e.prototype,m),u.NEED=!0,i(["delete","has","get","set"],function(t){var n=b.prototype,r=n[t];o(n,t,function(n,i){if(a(n)&&!p(n)){this._f||(this._f=new e);var o=this._f[t](n,i);return"set"==t?this:o}return r.call(this,n,i)})}))},,,,function(t,n){"use strict";t.exports={init:function(){var t=document.querySelector("#page-nav");t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&lt; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &gt;</a>'),yiliaConfig&&yiliaConfig.open_in_new&&document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")}),yiliaConfig&&yiliaConfig.toc_hide_index&&document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"});var n=document.querySelector("#js-aboutme");n&&0!==n.length&&(n.innerHTML=n.innerText)}}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n){var r=/\/|index.html/g;return t.replace(r,"")===n.replace(r,"")}function o(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var o=t[r];i(n,o.getAttribute("href"))&&(0,l.default)(o,"active")}}function u(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}function c(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}function f(t,n,r,e,i){var o=u(t),f=c(t)-n;if(f-r<=i){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,h.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(r||f)+"px",a.style.left=o+"px",a.style.zIndex=e||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");f(t,document.body.scrollTop,-63,2,0),f(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}var l=e(r(159)),h=e((e(r(160)),r(410))),v=e(r(131)),p=e(r(198)),d=r(132);v.default.versions.mobile&&window.screen.width<800&&(o(),s()),(0,d.addLoadEvent)(function(){p.default.init()}),t.exports={}},,,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object[e](t,n,{writable:!0,configurable:!0,value:r})}if(r(409),r(204),r(207),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;var e="defineProperty";n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},function(t,n){(function(n){!function(n){"use strict";function r(t,n,r,e){var o=n&&n.prototype instanceof i?n:i,u=Object.create(o.prototype),c=new v(e||[]);return u._invoke=a(t,r,c),u}function e(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function i(){}function o(){}function u(){}function c(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function f(t){function r(n,i,o,u){var c=e(t[n],t,i);if("throw"!==c.type){var f=c.arg,a=f.value;return a&&"object"==typeof a&&m.call(a,"__await")?Promise.resolve(a.__await).then(function(t){r("next",t,o,u)},function(t){r("throw",t,o,u)}):Promise.resolve(a).then(function(t){f.value=t,o(f)},u)}u(c.arg)}"object"==typeof n.process&&n.process.domain&&(r=n.process.domain.bind(r));var i;this._invoke=function(t,n){function e(){return new Promise(function(e,i){r(t,n,e,i)})}return i=i?i.then(e,e):e()}}function a(t,n,r){var i=E;return function(o,u){if(i===P)throw new Error("Generator is already running");if(i===j){if("throw"===o)throw u;return d()}for(r.method=o,r.arg=u;;){var c=r.delegate;if(c){var f=s(c,r);if(f){if(f===F)continue;return f}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(i===E)throw i=j,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);i=P;var a=e(t,n,r);if("normal"===a.type){if(i=r.done?j:M,a.arg===F)continue;return{value:a.arg,done:r.done}}"throw"===a.type&&(i=j,r.method="throw",r.arg=a.arg)}}}function s(t,n){var r=t.iterator[n.method];if(r===y){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=y,s(t,n),"throw"===n.method))return F;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return F}var i=e(r,t.iterator,n.arg);if("throw"===i.type)return n.method="throw",n.arg=i.arg,n.delegate=null,F;var o=i.arg;return o?o.done?(n[t.resultName]=o.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=y),n.delegate=null,F):o:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,F)}function l(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function h(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function v(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(l,this),this.reset(!0)}function p(t){if(t){var n=t[x];if(n)return n.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,e=function n(){for(;++r<t.length;)if(m.call(t,r))return n.value=t[r],n.done=!1,n;return n.value=y,n.done=!0,n};return e.next=e}}return{next:d}}function d(){return{value:y,done:!0}}var y,g=Object.prototype,m=g.hasOwnProperty,b="function"==typeof Symbol?Symbol:{},x=b.iterator||"@@iterator",S=b.asyncIterator||"@@asyncIterator",w=b.toStringTag||"@@toStringTag",_="object"==typeof t,O=n.regeneratorRuntime;if(O)_&&(t.exports=O);else{(O=n.regeneratorRuntime=_?t.exports:{}).wrap=r;var E="suspendedStart",M="suspendedYield",P="executing",j="completed",F={},A={};A[x]=function(){return this};var L=Object.getPrototypeOf,N=L&&L(L(p([])));N&&N!==g&&m.call(N,x)&&(A=N);var T=u.prototype=i.prototype=Object.create(A);o.prototype=T.constructor=u,u.constructor=o,u[w]=o.displayName="GeneratorFunction",O.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===o||"GeneratorFunction"===(n.displayName||n.name))},O.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,u):(t.__proto__=u,w in t||(t[w]="GeneratorFunction")),t.prototype=Object.create(T),t},O.awrap=function(t){return{__await:t}},c(f.prototype),f.prototype[S]=function(){return this},O.AsyncIterator=f,O.async=function(t,n,e,i){var o=new f(r(t,n,e,i));return O.isGeneratorFunction(n)?o:o.next().then(function(t){return t.done?t.value:o.next()})},c(T),T[w]="Generator",T[x]=function(){return this},T.toString=function(){return"[object Generator]"},O.keys=function(t){var n=[];for(var r in t)n.push(r);return n.reverse(),function r(){for(;n.length;){var e=n.pop();if(e in t)return r.value=e,r.done=!1,r}return r.done=!0,r}},O.values=p,v.prototype={constructor:v,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=y,this.done=!1,this.delegate=null,this.method="next",this.arg=y,this.tryEntries.forEach(h),!t)for(var n in this)"t"===n.charAt(0)&&m.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=y)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){function n(n,e){return o.type="throw",o.arg=t,r.next=n,e&&(r.method="next",r.arg=y),!!e}if(this.done)throw t;for(var r=this,e=this.tryEntries.length-1;e>=0;--e){var i=this.tryEntries[e],o=i.completion;if("root"===i.tryLoc)return n("end");if(i.tryLoc<=this.prev){var u=m.call(i,"catchLoc"),c=m.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return n(i.catchLoc,!0);if(this.prev<i.finallyLoc)return n(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return n(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return n(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&m.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,F):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),F},finish:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),h(r),F}},catch:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;h(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:p(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=y),F}}}}("object"==typeof n?n:"object"==typeof window?window:"object"==typeof self?self:this)}).call(n,function(){return this}())},,,function(t,n,r){r(217),t.exports=r(49).RegExp.escape},,,,function(t,n,r){var e=r(5),i=r(121),o=r(7)("species");t.exports=function(t){var n;return i(t)&&("function"!=typeof(n=t.constructor)||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&null===(n=n[o])&&(n=void 0)),void 0===n?Array:n}},function(t,n,r){"use strict";var e=r(4),i=Date.prototype.getTime,o=Date.prototype.toISOString,u=function(t){return t>9?t:"0"+t};t.exports=e(function(){return"0385-07-25T07:06:39.999Z"!=o.call(new Date(-5e13-1))})||!e(function(){o.call(new Date(NaN))})?function(){if(!isFinite(i.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":n>9999?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(r>99?r:"0"+u(r))+"Z"}:o},function(t,n,r){"use strict";var e=r(2),i=r(53),o="number";t.exports=function(t){if("string"!==t&&t!==o&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),t!=o)}},function(t,n,r){var e=r(73),i=r(125),o=r(116);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n){t.exports=function(t,n){var r=n===Object(n)?function(t){return n[t]}:n;return function(n){return String(n).replace(t,r)}}},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var e=r(1),i=r(215)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(162)}),r(66)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(48)(4);e(e.P+e.F*!r(47)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(133)}),r(66)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(48)(2);e(e.P+e.F*!r(47)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(66)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(66)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(0),o=r(47)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(46),i=r(1),o=r(17),u=r(173),c=r(141),f=r(11),a=r(135),s=r(157);i(i.S+i.F*!r(123)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,i,l,h=o(t),v="function"==typeof this?this:Array,p=arguments.length,d=p>1?arguments[1]:void 0,y=void 0!==d,g=0,m=s(h);if(y&&(d=e(d,p>2?arguments[2]:void 0,2)),void 0==m||v==Array&&c(m))for(n=f(h.length),r=new v(n);n>g;g++)a(r,g,y?d(h[g],g):h[g]);else for(l=m.call(h),r=new v;!(i=l.next()).done;g++)a(r,g,y?u(l,d,[i.value,g],!0):i.value);return r.length=g,r}})},function(t,n,r){"use strict";var e=r(1),i=r(117)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(47)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(121)})},function(t,n,r){"use strict";var e=r(1),i=r(32),o=[].join;e(e.P+e.F*(r(115)!=Object||!r(47)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(32),o=r(52),u=r(11),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(47)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(arguments.length>1&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);e>=0;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(1);e(e.P+e.F*!r(47)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(135);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);n>t;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(164);e(e.P+e.F*!r(47)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(164);e(e.P+e.F*!r(47)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(139),o=r(45),u=r(77),c=r(11),f=[].slice;e(e.P+e.F*r(4)(function(){i&&f.call(i)}),"Array",{slice:function(t,n){var r=c(this.length),e=o(this);if(n=void 0===n?r:n,"Array"==e)return f.call(this,t,n);for(var i=u(t,r),a=u(n,r),s=c(a-i),l=Array(s),h=0;h<s;h++)l[h]="String"==e?this.charAt(i+h):this[i+h];return l}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(3);e(e.P+e.F*!r(47)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(19),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(47)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(76)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){var e=r(1),i=r(212);e(e.P+e.F*(Date.prototype.toISOString!==i),"Date",{toISOString:i})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(53);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(26)(i,e,r(213))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(27)(e,o,function(){var t=c.call(this);return t===t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(165)})},function(t,n,r){"use strict";var e=r(5),i=r(31),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(10).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(10).f,i=Function.prototype,o=/^\s*function ([^ (]*)/,u="name";u in i||r(9)&&e(i,u,{configurable:!0,get:function(){try{return(""+this).match(o)[1]}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(176),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:t>94906265.62425156?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){function e(t){return isFinite(t=+t)&&0!=t?t<0?-e(-t):Math.log(t+Math.sqrt(t*t+1)):t}var i=r(1),o=Math.asinh;i(i.S+i.F*!(o&&1/o(0)>0),"Math",{asinh:e})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(145);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(144);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1);e(e.S,"Math",{fround:r(175)})},function(t,n,r){var e=r(1),i=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,o=0,u=0,c=arguments.length,f=0;u<c;)r=i(arguments[u++]),f<r?(e=f/r,o=o*e*e+1,f=r):r>0?(e=r/f,o+=e*e):o+=r;return f===1/0?1/0:f*Math.sqrt(o)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)*Math.LOG10E}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(176)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(145)})},function(t,n,r){var e=r(1),i=r(144),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(144),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(t>0?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(25),o=r(45),u=r(140),c=r(53),f=r(4),a=r(72).f,s=r(30).f,l=r(10).f,h=r(82).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(71)(y))==v,m="trim"in String.prototype,b=function(t){var n=c(t,!1);if("string"==typeof n&&n.length>2){var r,e,i,o=(n=m?n.trim():h(n,3)).charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,f=n.slice(2),a=0,s=f.length;a<s;a++)if((u=f.charCodeAt(a))<48||u>i)return NaN;return parseInt(f,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?f(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(b(n)),r,p):b(n)};for(var x,S=r(9)?a(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),w=0;S.length>w;w++)i(d,x=S[w])&&!i(p,x)&&l(p,x,s(d,x));p.prototype=y,y.constructor=p,r(27)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(172)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(172),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(184);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(185);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),i=r(52),o=r(161),u=r(152),c=1..toFixed,f=Math.floor,a=[0,0,0,0,0,0],s="Number.toFixed: incorrect invocation!",l="0",h=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*a[r],a[r]=e%1e7,e=f(e/1e7)},v=function(t){for(var n=6,r=0;--n>=0;)r+=a[n],a[n]=f(r/t),r=r%t*1e7},p=function(){for(var t=6,n="";--t>=0;)if(""!==n||0===t||0!==a[t]){var r=String(a[t]);n=""===n?r:n+u.call(l,7-r.length)+r}return n},d=function(t,n,r){return 0===n?r:n%2==1?d(t,n-1,r*t):d(t*t,n/2,r)},y=function(t){for(var n=0,r=t;r>=4096;)n+=12,r/=4096;for(;r>=2;)n+=1,r/=2;return n};e(e.P+e.F*(!!c&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){c.call({})})),"Number",{toFixed:function(t){var n,r,e,c,f=o(this,s),a=i(t),g="",m=l;if(a<0||a>20)throw RangeError(s);if(f!=f)return"NaN";if(f<=-1e21||f>=1e21)return String(f);if(f<0&&(g="-",f=-f),f>1e-21)if(n=y(f*d(2,69,1))-69,r=n<0?f*d(2,-n,1):f/d(2,n,1),r*=4503599627370496,(n=52-n)>0){for(h(0,r),e=a;e>=7;)h(1e7,0),e-=7;for(h(d(10,e,1),0),e=n-1;e>=23;)v(1<<23),e-=23;v(1<<e),h(1,1),v(2),m=p()}else h(0,r),h(1<<-n,0),m=p()+u.call(l,a);return a>0?(c=m.length,m=g+(c<=a?"0."+u.call(l,a-c)+m:m.slice(0,c-a)+"."+m.slice(c-a))):m=g+m,m}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(161),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(178)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(71)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(9),"Object",{defineProperties:r(179)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(9),"Object",{defineProperty:r(10).f})},function(t,n,r){var e=r(5),i=r(67).onFreeze;r(51)("freeze",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(32),i=r(30).f;r(51)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(51)("getOwnPropertyNames",function(){return r(180).f})},function(t,n,r){var e=r(17),i=r(31);r(51)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(5);r(51)("isExtensible",function(t){return function(n){return!!e(n)&&(!t||t(n))}})},function(t,n,r){var e=r(5);r(51)("isFrozen",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(5);r(51)("isSealed",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(216)})},function(t,n,r){var e=r(17),i=r(73);r(51)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(5),i=r(67).onFreeze;r(51)("preventExtensions",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(5),i=r(67).onFreeze;r(51)("seal",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(148).set})},function(t,n,r){"use strict";var e=r(114),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(27)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(184);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(185);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u,c=r(70),f=r(3),a=r(46),s=r(114),l=r(1),h=r(5),v=r(19),p=r(68),d=r(69),y=r(129),g=r(154).set,m=r(146)(),b=r(147),x=r(186),S=r(187),w="Promise",_=f.TypeError,O=f.process,E=f[w],M="process"==s(O),P=function(){},j=i=b.f,F=!!function(){try{var t=E.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(P,P)};return(M||"function"==typeof PromiseRejectionEvent)&&t.then(P)instanceof n}catch(t){}}(),A=function(t){var n;return!(!h(t)||"function"!=typeof(n=t.then))&&n},L=function(t,n){if(!t._n){t._n=!0;var r=t._c;m(function(){for(var e=t._v,i=1==t._s,o=0;r.length>o;)!function(n){var r,o,u=i?n.ok:n.fail,c=n.resolve,f=n.reject,a=n.domain;try{u?(i||(2==t._h&&I(t),t._h=1),!0===u?r=e:(a&&a.enter(),r=u(e),a&&a.exit()),r===n.promise?f(_("Promise-chain cycle")):(o=A(r))?o.call(r,c,f):c(r)):f(e)}catch(t){f(t)}}(r[o++]);t._c=[],t._n=!1,n&&!t._h&&N(t)})}},N=function(t){g.call(f,function(){var n,r,e,i=t._v,o=T(t);if(o&&(n=x(function(){M?O.emit("unhandledRejection",i,t):(r=f.onunhandledrejection)?r({promise:t,reason:i}):(e=f.console)&&e.error&&e.error("Unhandled promise rejection",i)}),t._h=M||T(t)?2:1),t._a=void 0,o&&n.e)throw n.v})},T=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if((n=r[e++]).fail||!T(n.promise))return!1;return!0},I=function(t){g.call(f,function(){var n;M?O.emit("rejectionHandled",t):(n=f.onrejectionhandled)&&n({promise:t,reason:t._v})})},k=function(t){var n=this;n._d||(n._d=!0,n=n._w||n,n._v=t,n._s=2,n._a||(n._a=n._c.slice()),L(n,!0))},R=function(t){var n,r=this;if(!r._d){r._d=!0,r=r._w||r;try{if(r===t)throw _("Promise can't be resolved itself");(n=A(t))?m(function(){var e={_w:r,_d:!1};try{n.call(t,a(R,e,1),a(k,e,1))}catch(t){k.call(e,t)}}):(r._v=t,r._s=1,L(r,!1))}catch(t){k.call({_w:r,_d:!1},t)}}};F||(E=function(t){p(this,E,w,"_h"),v(t),e.call(this);try{t(a(R,this,1),a(k,this,1))}catch(t){k.call(this,t)}},e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},e.prototype=r(75)(E.prototype,{then:function(t,n){var r=j(y(this,E));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=M?O.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&L(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),o=function(){var t=new e;this.promise=t,this.resolve=a(R,t,1),this.reject=a(k,t,1)},b.f=j=function(t){return t===E||t===u?new o(t):i(t)}),l(l.G+l.W+l.F*!F,{Promise:E}),r(81)(E,w),r(76)(w),u=r(49)[w],l(l.S+l.F*!F,w,{reject:function(t){var n=j(this);return(0,n.reject)(t),n.promise}}),l(l.S+l.F*(c||!F),w,{resolve:function(t){return S(c&&this===u?E:this,t)}}),l(l.S+l.F*!(F&&r(123)(function(t){E.all(t).catch(P)})),w,{all:function(t){var n=this,r=j(n),e=r.resolve,i=r.reject,o=x(function(){var r=[],o=0,u=1;d(t,!1,function(t){var c=o++,f=!1;r.push(void 0),u++,n.resolve(t).then(function(t){f||(f=!0,r[c]=t,--u||e(r))},i)}),--u||e(r)});return o.e&&i(o.v),r.promise},race:function(t){var n=this,r=j(n),e=r.reject,i=x(function(){d(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i.e&&e(i.v),r.promise}})},function(t,n,r){var e=r(1),i=r(19),o=r(2),u=(r(3).Reflect||{}).apply,c=Function.apply;e(e.S+e.F*!r(4)(function(){u(function(){})}),"Reflect",{apply:function(t,n,r){var e=i(t),f=o(r);return u?u(e,n,f):c.call(e,n,f)}})},function(t,n,r){var e=r(1),i=r(71),o=r(19),u=r(2),c=r(5),f=r(4),a=r(165),s=(r(3).Reflect||{}).construct,l=f(function(){function t(){}return!(s(function(){},[],t)instanceof t)}),h=!f(function(){s(function(){})});e(e.S+e.F*(l||h),"Reflect",{construct:function(t,n){o(t),u(n);var r=arguments.length<3?t:o(arguments[2]);if(h&&!l)return s(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(a.apply(t,e))}var f=r.prototype,v=i(c(f)?f:Object.prototype),p=Function.apply.call(t,v,n);return c(p)?p:v}})},function(t,n,r){var e=r(10),i=r(1),o=r(2),u=r(53);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(30).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(142)(o,"Object",function(){var t,n=this,r=n._k;do{if(n._i>=r.length)return{value:void 0,done:!0}}while(!((t=r[n._i++])in n._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(30),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(31),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){function e(t,n){var r,c,s=arguments.length<3?t:arguments[2];return a(t)===s?t[n]:(r=i.f(t,n))?u(r,"value")?r.value:void 0!==r.get?r.get.call(s):void 0:f(c=o(t))?e(c,n,s):void 0}var i=r(30),o=r(31),u=r(25),c=r(1),f=r(5),a=r(2);c(c.S,"Reflect",{get:e})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(183)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(148);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){function e(t,n,r){var f,h,v=arguments.length<4?t:arguments[3],p=o.f(s(t),n);if(!p){if(l(h=u(t)))return e(h,n,r,v);p=a(0)}return c(p,"value")?!(!1===p.writable||!l(v)||(f=o.f(v,n)||a(0),f.value=r,i.f(v,n,f),0)):void 0!==p.set&&(p.set.call(v,r),!0)}var i=r(10),o=r(30),u=r(31),c=r(25),f=r(1),a=r(74),s=r(2),l=r(5);f(f.S,"Reflect",{set:e})},function(t,n,r){var e=r(3),i=r(140),o=r(10).f,u=r(72).f,c=r(122),f=r(120),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(9)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),o=void 0===n;return!r&&e&&t.constructor===a&&o?t:i(p?new s(e&&!o?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&o?f.call(t):n),r?this:l,a)};for(var d=u(s),y=0;d.length>y;)!function(t){t in a||o(a,t,{configurable:!0,get:function(){return s[t]},set:function(n){s[t]=n}})}(d[y++]);l.constructor=a,a.prototype=l,r(27)(e,"RegExp",a)}r(76)("RegExp")},function(t,n,r){r(119)("match",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("replace",2,function(t,n,r){return[function(e,i){"use strict";var o=t(this),u=void 0==e?void 0:e[n];return void 0!==u?u.call(e,o,i):r.call(String(o),e,i)},r]})},function(t,n,r){r(119)("search",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("split",2,function(t,n,e){"use strict";var i=r(122),o=e,u=[].push,c="split",f="length",a="lastIndex";if("c"=="abbc"[c](/(b)*/)[1]||4!="test"[c](/(?:)/,-1)[f]||2!="ab"[c](/(?:ab)*/)[f]||4!="."[c](/(.?)(.?)/)[f]||"."[c](/()()/)[f]>1||""[c](/.?/)[f]){var s=void 0===/()??/.exec("")[1];e=function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!i(t))return o.call(r,t,n);var e,c,l,h,v,p=[],d=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),y=0,g=void 0===n?4294967295:n>>>0,m=new RegExp(t.source,d+"g");for(s||(e=new RegExp("^"+m.source+"$(?!\\s)",d));(c=m.exec(r))&&!((l=c.index+c[0][f])>y&&(p.push(r.slice(y,c.index)),!s&&c[f]>1&&c[0].replace(e,function(){for(v=1;v<arguments[f]-2;v++)void 0===arguments[v]&&(c[v]=void 0)}),c[f]>1&&c.index<r[f]&&u.apply(p,c.slice(1)),h=c[0][f],y=l,p[f]>=g));)m[a]===c.index&&m[a]++;return y===r[f]?!h&&m.test("")||p.push(""):p.push(r.slice(y)),p[f]>g?p.slice(0,g):p}}else"0"[c](void 0,0)[f]&&(e=function(t,n){return void 0===t&&0===n?[]:o.call(this,t,n)});return[function(r,i){var o=t(this),u=void 0==r?void 0:r[n];return void 0!==u?u.call(r,o,i):e.call(String(o),r,i)},e]})},function(t,n,r){"use strict";r(192);var e=r(2),i=r(120),o=r(9),u="toString",c=/./[u],f=function(t){r(27)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(28)("anchor",function(t){return function(n){return t(this,"a","name",n)}})},function(t,n,r){"use strict";r(28)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(28)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(28)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(150)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(11),o=r(151),u="endsWith",c=""[u];e(e.P+e.F*r(138)(u),"String",{endsWith:function(t){var n=o(this,t,u),r=arguments.length>1?arguments[1]:void 0,e=i(n.length),f=void 0===r?e:Math.min(i(r),e),a=String(t);return c?c.call(n,a,f):n.slice(f-a.length,f)===a}})},function(t,n,r){"use strict";r(28)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(28)("fontcolor",function(t){return function(n){return t(this,"font","color",n)}})},function(t,n,r){"use strict";r(28)("fontsize",function(t){return function(n){return t(this,"font","size",n)}})},function(t,n,r){var e=r(1),i=r(77),o=String.fromCharCode,u=String.fromCodePoint;e(e.S+e.F*(!!u&&1!=u.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,u=0;e>u;){if(n=+arguments[u++],i(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?o(n):o(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(151),o="includes";e(e.P+e.F*r(138)(o),"String",{includes:function(t){return!!~i(this,t,o).indexOf(t,arguments.length>1?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(28)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(150)(!0);r(143)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(28)("link",function(t){return function(n){return t(this,"a","href",n)}})},function(t,n,r){var e=r(1),i=r(32),o=r(11);e(e.S,"String",{raw:function(t){for(var n=i(t.raw),r=o(n.length),e=arguments.length,u=[],c=0;r>c;)u.push(String(n[c++])),c<e&&u.push(String(arguments[c]));return u.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(152)})},function(t,n,r){"use strict";r(28)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(11),o=r(151),u="startsWith",c=""[u];e(e.P+e.F*r(138)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(arguments.length>1?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(28)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(28)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(28)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(82)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),i=r(25),o=r(9),u=r(1),c=r(27),f=r(67).KEY,a=r(4),s=r(128),l=r(81),h=r(78),v=r(7),p=r(190),d=r(156),y=r(214),g=r(121),m=r(2),b=r(32),x=r(53),S=r(74),w=r(71),_=r(180),O=r(30),E=r(10),M=r(73),P=O.f,j=E.f,F=_.f,A=e.Symbol,L=e.JSON,N=L&&L.stringify,T="prototype",I=v("_hidden"),k=v("toPrimitive"),R={}.propertyIsEnumerable,C=s("symbol-registry"),D=s("symbols"),G=s("op-symbols"),W=Object[T],U="function"==typeof A,V=e.QObject,B=!V||!V[T]||!V[T].findChild,q=o&&a(function(){return 7!=w(j({},"a",{get:function(){return j(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=P(W,n);e&&delete W[n],j(t,n,r),e&&t!==W&&j(W,n,e)}:j,z=function(t){var n=D[t]=w(A[T]);return n._k=t,n},H=U&&"symbol"==typeof A.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof A},K=function(t,n,r){return t===W&&K(G,n,r),m(t),n=x(n,!0),m(r),i(D,n)?(r.enumerable?(i(t,I)&&t[I][n]&&(t[I][n]=!1),r=w(r,{enumerable:S(0,!1)})):(i(t,I)||j(t,I,S(1,{})),t[I][n]=!0),q(t,n,r)):j(t,n,r)},J=function(t,n){m(t);for(var r,e=y(n=b(n)),i=0,o=e.length;o>i;)K(t,r=e[i++],n[r]);return t},Y=function(t){var n=R.call(this,t=x(t,!0));return!(this===W&&i(D,t)&&!i(G,t))&&(!(n||!i(this,t)||!i(D,t)||i(this,I)&&this[I][t])||n)},$=function(t,n){if(t=b(t),n=x(n,!0),t!==W||!i(D,n)||i(G,n)){var r=P(t,n);return!r||!i(D,n)||i(t,I)&&t[I][n]||(r.enumerable=!0),r}},X=function(t){for(var n,r=F(b(t)),e=[],o=0;r.length>o;)i(D,n=r[o++])||n==I||n==f||e.push(n);return e},Q=function(t){for(var n,r=t===W,e=F(r?G:b(t)),o=[],u=0;e.length>u;)!i(D,n=e[u++])||r&&!i(W,n)||o.push(D[n]);return o};U||(A=function(){if(this instanceof A)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===W&&n.call(G,r),i(this,I)&&i(this[I],t)&&(this[I][t]=!1),q(this,t,S(1,r))};return o&&B&&q(W,t,{configurable:!0,set:n}),z(t)},c(A[T],"toString",function(){return this._k}),O.f=$,E.f=K,r(72).f=_.f=X,r(116).f=Y,r(125).f=Q,o&&!r(70)&&c(W,"propertyIsEnumerable",Y,!0),p.f=function(t){return z(v(t))}),u(u.G+u.W+u.F*!U,{Symbol:A});for(var Z="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),tt=0;Z.length>tt;)v(Z[tt++]);for(var nt=M(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!U,"Symbol",{for:function(t){return i(C,t+="")?C[t]:C[t]=A(t)},keyFor:function(t){if(!H(t))throw TypeError(t+" is not a symbol!");for(var n in C)if(C[n]===t)return n},useSetter:function(){B=!0},useSimple:function(){B=!1}}),u(u.S+u.F*!U,"Object",{create:function(t,n){return void 0===n?w(t):J(w(t),n)},defineProperty:K,defineProperties:J,getOwnPropertyDescriptor:$,getOwnPropertyNames:X,getOwnPropertySymbols:Q}),L&&u(u.S+u.F*(!U||a(function(){var t=A();return"[null]"!=N([t])||"{}"!=N({a:t})||"{}"!=N(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!H(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return"function"==typeof(n=e[1])&&(r=n),!r&&g(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!H(n))return n}),e[1]=n,N.apply(L,e)}}}),A[T][k]||r(26)(A[T],k,A[T].valueOf),l(A,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(130),o=r(155),u=r(2),c=r(77),f=r(11),a=r(5),s=r(3).ArrayBuffer,l=r(129),h=o.ArrayBuffer,v=o.DataView,p=i.ABV&&s.isView,d=h.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(s!==h),{ArrayBuffer:h}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return p&&p(t)||a(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new h(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(u(this),t);for(var r=u(this).byteLength,e=c(t,r),i=c(void 0===n?r:n,r),o=new(l(this,h))(f(i-e)),a=new v(this),s=new v(o),p=0;e<i;)s.setUint8(p++,a.getUint8(e++));return o}}),r(76)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(130).ABV,{DataView:r(155).DataView})},function(t,n,r){r(56)("Float32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(56)("Float64",8,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(56)("Int16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(56)("Int32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(56)("Int8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(56)("Uint16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(56)("Uint32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(56)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(56)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}},!0)},function(t,n,r){"use strict";var e=r(168),i=r(83),o="WeakSet";r(118)(o,function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(i(this,o),t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(169),o=r(17),u=r(11),c=r(19),f=r(134);e(e.P,"Array",{flatMap:function(t){var n,r,e=o(this);return c(t),n=u(e.length),r=f(e,0),i(r,e,e,n,0,1,t,arguments[1]),r}}),r(66)("flatMap")},function(t,n,r){"use strict";var e=r(1),i=r(169),o=r(17),u=r(11),c=r(52),f=r(134);e(e.P,"Array",{flatten:function(){var t=arguments[0],n=o(this),r=u(n.length),e=f(n,0);return i(e,n,n,r,0,void 0===t?1:c(t)),e}}),r(66)("flatten")},function(t,n,r){"use strict";var e=r(1),i=r(117)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(66)("includes")},function(t,n,r){var e=r(1),i=r(146)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.G,{global:r(3)})},function(t,n,r){r(126)("Map")},function(t,n,r){r(127)("Map")},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(167)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{clamp:function(t,n,r){return Math.min(r,Math.max(n,t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{DEG_PER_RAD:Math.PI/180})},function(t,n,r){var e=r(1),i=180/Math.PI;e(e.S,"Math",{degrees:function(t){return t*i}})},function(t,n,r){var e=r(1),i=r(177),o=r(175);e(e.S,"Math",{fscale:function(t,n,r,e,u){return o(i(t,n,r,e,u))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=r>>>0;return(n>>>0)+(e>>>0)+((i&o|(i|o)&~(i+o>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>16,f=i>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>16)+((o*f>>>0)+(a&r)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=r>>>0;return(n>>>0)-(e>>>0)-((~i&o|~(i^o)&i-o>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{RAD_PER_DEG:180/Math.PI})},function(t,n,r){var e=r(1),i=Math.PI/180;e(e.S,"Math",{radians:function(t){return t*i}})},function(t,n,r){var e=r(1);e(e.S,"Math",{scale:r(177)})},function(t,n,r){var e=r(1);e(e.S,"Math",{signbit:function(t){return(t=+t)!=t?t:0==t?1/t==1/0:t>0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>>16,f=i>>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>>16)+((o*f>>>0)+(a&r)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(19),u=r(10);r(9)&&e(e.P+r(124),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(19),u=r(10);r(9)&&e(e.P+r(124),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(182)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),i=r(183),o=r(32),u=r(30),c=r(135);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r,e=o(t),f=u.f,a=i(e),s={},l=0;a.length>l;)void 0!==(r=f(e,n=a[l++]))&&c(s,n,r);return s}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(53),u=r(31),c=r(30).f;r(9)&&e(e.P+r(124),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(53),u=r(31),c=r(30).f;r(9)&&e(e.P+r(124),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(182)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),i=r(3),o=r(49),u=r(146)(),c=r(7)("observable"),f=r(19),a=r(2),s=r(68),l=r(75),h=r(26),v=r(69),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},m=function(t){g(t)||(t._o=void 0,y(t))},b=function(t,n){a(t),this._c=void 0,this._o=t,t=new x(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};b.prototype=l({},{unsubscribe:function(){m(this)}});var x=function(t){this._s=t};x.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{m(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var S=function(t){s(this,S,"Observable","_f")._f=f(t)};l(S.prototype,{subscribe:function(t){return new b(t,this._f)},forEach:function(t){var n=this;return new(o.Promise||i.Promise)(function(r,e){f(t);var i=n.subscribe({next:function(n){try{return t(n)}catch(t){e(t),i.unsubscribe()}},error:e,complete:r})})}}),l(S,{from:function(t){var n="function"==typeof this?this:S,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return u(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,r=Array(n);t<n;)r[t]=arguments[t++];return new("function"==typeof this?this:S)(function(t){var n=!1;return u(function(){if(!n){for(var e=0;e<r.length;++e)if(t.next(r[e]),n)return;t.complete()}}),function(){n=!0}})}}),h(S.prototype,c,function(){return this}),e(e.G,{Observable:S}),r(76)("Observable")},function(t,n,r){"use strict";var e=r(1),i=r(49),o=r(3),u=r(129),c=r(187);e(e.P+e.R,"Promise",{finally:function(t){var n=u(this,i.Promise||o.Promise),r="function"==typeof t;return this.then(r?function(r){return c(n,t()).then(function(){return r})}:t,r?function(r){return c(n,t()).then(function(){throw r})}:t)}})},function(t,n,r){"use strict";var e=r(1),i=r(147),o=r(186);e(e.S,"Promise",{try:function(t){var n=i.f(this),r=o(t);return(r.e?n.reject:n.resolve)(r.v),n.promise}})},function(t,n,r){var e=r(55),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(55),i=r(2),o=e.key,u=e.map,c=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:o(arguments[2]),e=u(i(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var f=c.get(n);return f.delete(r),!!f.size||c.delete(n)}})},function(t,n,r){var e=r(193),i=r(163),o=r(55),u=r(2),c=r(31),f=o.keys,a=o.key,s=function(t,n){var r=f(t,n),o=c(t);if(null===o)return r;var u=s(o,n);return u.length?r.length?i(new e(r.concat(u))):u:r};o.exp({getMetadataKeys:function(t){return s(u(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(55),i=r(2),o=r(31),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(55),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(55),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(55),i=r(2),o=r(31),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(55),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(55),i=r(2),o=r(19),u=e.key,c=e.set;e.exp({metadata:function(t,n){return function(r,e){c(t,n,(void 0!==e?i:o)(r),u(e))}}})},function(t,n,r){r(126)("Set")},function(t,n,r){r(127)("Set")},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(167)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(150)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(50),o=r(11),u=r(122),c=r(120),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(142)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(188);e(e.P,"String",{padEnd:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(188);e(e.P,"String",{padStart:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(82)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(82)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(156)("asyncIterator")},function(t,n,r){r(156)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){r(126)("WeakMap")},function(t,n,r){r(127)("WeakMap")},function(t,n,r){r(126)("WeakSet")},function(t,n,r){r(127)("WeakSet")},function(t,n,r){for(var e=r(158),i=r(73),o=r(27),u=r(3),c=r(26),f=r(80),a=r(7),s=a("iterator"),l=a("toStringTag"),h=f.Array,v={CSSRuleList:!0,CSSStyleDeclaration:!1,CSSValueList:!1,ClientRectList:!1,DOMRectList:!1,DOMStringList:!1,DOMTokenList:!0,DataTransferItemList:!1,FileList:!1,HTMLAllCollection:!1,HTMLCollection:!1,HTMLFormElement:!1,HTMLSelectElement:!1,MediaList:!0,MimeTypeArray:!1,NamedNodeMap:!1,NodeList:!0,PaintRequestList:!1,Plugin:!1,PluginArray:!1,SVGLengthList:!1,SVGNumberList:!1,SVGPathSegList:!1,SVGPointList:!1,SVGStringList:!1,SVGTransformList:!1,SourceBufferList:!1,StyleSheetList:!0,TextTrackCueList:!1,TextTrackList:!1,TouchList:!1},p=i(v),d=0;d<p.length;d++){var y,g=p[d],m=v[g],b=u[g],x=b&&b.prototype;if(x&&(x[s]||c(x,s,h),x[l]||c(x,l,g),f[g]=h,m))for(y in e)x[y]||o(x,y,e[y],!0)}},function(t,n,r){var e=r(1),i=r(154);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=e.navigator,u=[].slice,c=!!o&&/MSIE .\./.test(o.userAgent),f=function(t){return function(n,r){var e=arguments.length>2,i=!!e&&u.call(arguments,2);return t(e?function(){("function"==typeof n?n:Function(n)).apply(this,i)}:n,r)}};i(i.G+i.B+i.F*c,{setTimeout:f(e.setTimeout),setInterval:f(e.setInterval)})},function(t,n,r){r(337),r(276),r(278),r(277),r(280),r(282),r(287),r(281),r(279),r(289),r(288),r(284),r(285),r(283),r(275),r(286),r(290),r(291),r(243),r(245),r(244),r(293),r(292),r(263),r(273),r(274),r(264),r(265),r(266),r(267),r(268),r(269),r(270),r(271),r(272),r(246),r(247),r(248),r(249),r(250),r(251),r(252),r(253),r(254),r(255),r(256),r(257),r(258),r(259),r(260),r(261),r(262),r(324),r(329),r(336),r(327),r(319),r(320),r(325),r(330),r(332),r(315),r(316),r(317),r(318),r(321),r(322),r(323),r(326),r(328),r(331),r(333),r(334),r(335),r(238),r(240),r(239),r(242),r(241),r(227),r(225),r(231),r(228),r(234),r(236),r(224),r(230),r(221),r(235),r(219),r(233),r(232),r(226),r(229),r(218),r(220),r(223),r(222),r(237),r(158),r(309),r(314),r(192),r(310),r(311),r(312),r(313),r(294),r(191),r(193),r(194),r(349),r(338),r(339),r(344),r(347),r(348),r(342),r(345),r(343),r(346),r(340),r(341),r(295),r(296),r(297),r(298),r(299),r(302),r(300),r(301),r(303),r(304),r(305),r(306),r(308),r(307),r(352),r(350),r(351),r(393),r(396),r(395),r(397),r(398),r(394),r(399),r(400),r(374),r(377),r(373),r(371),r(372),r(375),r(376),r(358),r(392),r(357),r(391),r(403),r(405),r(356),r(390),r(402),r(404),r(355),r(401),r(354),r(359),r(360),r(361),r(362),r(363),r(365),r(364),r(366),r(367),r(368),r(370),r(369),r(379),r(380),r(381),r(382),r(384),r(383),r(386),r(385),r(387),r(388),r(389),r(353),r(378),r(408),r(407),r(406),t.exports=r(49)},function(t,n){t.exports=function(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}}])</script><script src="/./main.e8862b.js"></script><script>!function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}("/slider.5b7e29.js")</script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">All articles</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">Friends</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">About me</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Algorithm</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">C++</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">DS</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">Android</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Tech</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">ML</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">DL</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">English</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Essay</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">git</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">hexo</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">golang</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">HTML</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Javascript</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">CSS</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">js</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">html</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Java</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Redis</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">MYSQL</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">Spring</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">linux</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">papers</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">RL</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">k8s</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="https://leetcode-cn.com/u/louris/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>我的力扣</a>
            </li>
          
            <li class="search-li">
              <a href="https://www.six1110.top/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>饭勺</a>
            </li>
          
            <li class="search-li">
              <a href="https://www.zjcheng.site/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>中建</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">做一个安静细微的人，&lt;br&gt; 于角落里自在开放，&lt;br&gt; 默默悦人，&lt;br&gt; 却始终不引起过分热闹的关注，&lt;br&gt; 保有独立而随意的品格，&lt;br&gt; 这就很好。&lt;br&gt;&lt;br&gt; Stick to what you insist on,&lt;br&gt; believe what you believe!&lt;br&gt; Life hastily for decades,&lt;br&gt; do what I can!</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":1},"log":false});</script></body>
</html>